{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/LICENSE","path":"lib/pace/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/README.md","path":"lib/pace/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flat-top.min.css","path":"lib/pace/pace-theme-flat-top.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-material.min.css","path":"lib/pace/pace-theme-material.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/theme-next-canvas-ribbon-master/LICENSE","path":"lib/canvas-ribbon/theme-next-canvas-ribbon-master/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/theme-next-canvas-ribbon-master/README.md","path":"lib/canvas-ribbon/theme-next-canvas-ribbon-master/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/theme-next-canvas-ribbon-master/canvas-ribbon.js","path":"lib/canvas-ribbon/theme-next-canvas-ribbon-master/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/images/avatar.jpg","hash":"eedc3cb767ecbcdbadd5e7e1b4a2c574eeb930c3","modified":1759053230518},{"_id":"source/categories/index.md","hash":"af5140ff20c645870dfaa9d26534a3e9bb700ba4","modified":1759111973953},{"_id":"source/_posts/buildroot/stage_install.md","hash":"6004c7b8f2e0e2b30dfdfd5f96a92f7c8d1dad0a","modified":1759052478567},{"_id":"source/tags/index.md","hash":"ef05055df2050c154617702d8e5bad2ac03bba88","modified":1759111973955},{"_id":"source/about/index.md","hash":"f5591229459156000fa5b889359ef835acb9275f","modified":1759111973953},{"_id":"source/_posts/muduo/AsyncLogging.md","hash":"e31d329de368c4215e2dc8e5ef97391416628956","modified":1759075603125},{"_id":"source/_posts/muduo/EventLoopThreadPool.md","hash":"de468956fd7776b61b4f8ec12683a817f7502075","modified":1759075603125},{"_id":"source/_posts/muduo/EvevntLoopAndThread.md","hash":"58aa33f122cc4e8a0003083064c5030cf21fc1a6","modified":1759075603125},{"_id":"source/_posts/muduo/ChannelAndPoller.md","hash":"da2f641387269dbfab5b949ad6a78af6626c218e","modified":1759075603125},{"_id":"source/_posts/muduo/SynLogging.md","hash":"c3939f8b7d9c0aa3d0da611a3f3ab285b7b4d4c3","modified":1759075603130},{"_id":"source/_posts/muduo/TcpServer.md","hash":"30079f59f27690b216dd6ed68db1d30bc9a0ae88","modified":1759075603130},{"_id":"source/_posts/muduo/TcpClient.md","hash":"0eb8dc9e28d9978759912a7700c15acbedfd508a","modified":1759075603130},{"_id":"source/_posts/muduo/TcpConnection.md","hash":"d07ebc49d86f6f2e2c14246580279f4765347359","modified":1759075603130},{"_id":"source/_posts/muduo/Start.md","hash":"b958561c56063d82a0a56a75f4af834fd6c9f5e2","modified":1759075603130},{"_id":"source/_posts/workflow/TCPServer_2.md","hash":"2cfab0c1affca173bce830f55e90fd9c9d121d64","modified":1759070287199},{"_id":"source/_posts/workflow/TCPServer_3.md","hash":"79ff27a9387906229ca82c279592732fc86fb34a","modified":1759070073264},{"_id":"source/_posts/workflow/TCPServer_1.md","hash":"7d073c987730f266b3eea5690679c340fd6858b3","modified":1759070007743},{"_id":"source/_posts/workflow/go_task.md","hash":"54ad7218b87400ce3e4b46972f5f891ce62fc60a","modified":1759069937118},{"_id":"source/_posts/xv6/Boot.md","hash":"876f271de6a63a0188d98304621e035c462d3170","modified":1759052445876},{"_id":"source/_posts/xv6/FileSystem.md","hash":"276ebb30037b686b701f908753c914ace89a9aa7","modified":1759071679926},{"_id":"source/_posts/xv6/MemoryManager.md","hash":"af75bed854526a65f513c7298f140b3ca0885acf","modified":1759052458181},{"_id":"source/_posts/xv6/Scheduler.md","hash":"46a6516bfb16c321dc5821df54abb1dea34cd7d4","modified":1759052468734},{"_id":"source/_posts/muduo/ThreadSafeAndSync.md","hash":"cc1415f8143286d454a7a4bf011b522bfbde5d29","modified":1759075603135},{"_id":"source/_posts/muduo/ThreadAndThreadPool/photo/ThreadPool.drawio.png","hash":"fd81e3dc3084ae1ba009f2b0c5b808025921ae42","modified":1706771375173},{"_id":"source/_posts/muduo/EvevntLoopAndThread/photo/EventLoop.drawio.png","hash":"1b042f052b1c603a63b3423dbd16c661e8e03d28","modified":1705390642525},{"_id":"source/_posts/muduo/ThreadAndThreadPool.md","hash":"75f90634ff882cc964a34016434bd3bd03f658dc","modified":1759075603135},{"_id":"source/_posts/xv6/Boot/photo/Logo.jpg","hash":"808892bb96be6a1e7e82534873c36e7ae2cb9544","modified":1759021665518},{"_id":"source/_posts/xv6/Boot/photo/scheduler/8259a.drawio.png","hash":"83d2785b610a50aed51bbd2721a4d8dc91d09e6d","modified":1717813054252},{"_id":"source/_posts/xv6/Boot/photo/scheduler/IDT_Entry.png","hash":"4cd80376efd49a1cfa9213496d7b61f3320eb64c","modified":1717591506752},{"_id":"source/_posts/xv6/Boot/photo/scheduler/IDTR.png","hash":"49db6c278ef03ebf2a718819995c81a7e0e852b5","modified":1717595225355},{"_id":"source/_posts/xv6/Boot/photo/scheduler/MP_floating_pointer_structure.png","hash":"a3458fe0c961df5a72a7cf12b409dd9dcc05afe5","modified":1717646250634},{"_id":"source/_posts/xv6/Boot/photo/scheduler/imcrp.png","hash":"8c9864113c89b148bd721ea5f4b93b6e6da5efa9","modified":1717651724294},{"_id":"source/_posts/xv6/Boot/photo/scheduler/ioapic_entry.png","hash":"7b551a258d0b1dc29c5851d1c8355fa037841796","modified":1717646386248},{"_id":"source/_posts/xv6/Boot/photo/scheduler/task_stack.drawio.png","hash":"ba199d6a2e2d9f403408bbeabc5b94a4d598f4e0","modified":1717725546886},{"_id":"source/_posts/xv6/Boot/photo/scheduler/trap_frame.png","hash":"6a191f20fab43fadd95da12ef456ee6c149cba87","modified":1717665607888},{"_id":"source/_posts/xv6/Boot/photo/start/GDT.png","hash":"c7865b8c24a0bb195567b318fdb2c332c642e954","modified":1716790321552},{"_id":"source/_posts/xv6/Boot/photo/start/GDTR.png","hash":"c1de122b466da828be0ae56e3d195416f5c29af4","modified":1716791186516},{"_id":"source/_posts/xv6/Boot/photo/start/SegmentDescriptor.png","hash":"0b2178b404782f2aedef546f3e4841cd4b0f5328","modified":1716790249997},{"_id":"source/_posts/xv6/Boot/photo/start/SegmentSelector.png","hash":"4cb9e6e79a1e9e29cb4bfc975e050855d58a0d9c","modified":1716790287039},{"_id":"source/_posts/xv6/Boot/photo/start/boot.drawio.png","hash":"4d4eeec0332589443e39742c5007784058433312","modified":1717728321411},{"_id":"source/_posts/xv6/Boot/photo/start/entry.drawio.png","hash":"60d49b69b0f343b4bb71c830294c95c7565bb5ff","modified":1717504193205},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/8259a.drawio.png","hash":"83d2785b610a50aed51bbd2721a4d8dc91d09e6d","modified":1717813054252},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/IDTR.png","hash":"49db6c278ef03ebf2a718819995c81a7e0e852b5","modified":1717595225355},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/IDT_Entry.png","hash":"4cd80376efd49a1cfa9213496d7b61f3320eb64c","modified":1717591506752},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/MP_floating_pointer_structure.png","hash":"a3458fe0c961df5a72a7cf12b409dd9dcc05afe5","modified":1717646250634},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/imcrp.png","hash":"8c9864113c89b148bd721ea5f4b93b6e6da5efa9","modified":1717651724294},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/ioapic_entry.png","hash":"7b551a258d0b1dc29c5851d1c8355fa037841796","modified":1717646386248},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/task_stack.drawio.png","hash":"ba199d6a2e2d9f403408bbeabc5b94a4d598f4e0","modified":1717725546886},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/trap_frame.png","hash":"6a191f20fab43fadd95da12ef456ee6c149cba87","modified":1717665607888},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio","hash":"bc34b6aad6a41e1dadad7aac08c053de83ec9b62","modified":1759111973918},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache.drawio","hash":"7474147536b4ac4c3c00ea16b07671f780e13d97","modified":1759111973920},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache2.drawio","hash":"f34adef92989402356e6d139def58c7e190c55b7","modified":1759111973921},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache3.drawio","hash":"31c156b1c05b206c65cff8160e891390acc88823","modified":1759111973921},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_dentry.drawio","hash":"65a8be4674b07c5b29bdde8b2902729cb5f9d15d","modified":1759111973922},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio","hash":"8ce9d32364920623b9dd517df178e8bbcc68cb6b","modified":1759111973923},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio","hash":"08195759ab6c5ac2616e128760855b57a992e852","modified":1759111973924},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio.png","hash":"09710d67477b554aaa7323a2c375ee9d0d341687","modified":1758267860416},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio.png","hash":"3337f4f391a9d971abdf4951b0a2987486775eb8","modified":1758790058275},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_ide.drawio","hash":"1a8f29964aee9423db4757763cf65a47daa4d211","modified":1759111973925},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio","hash":"a64e4db9d0e53d2981f516a2e7135e52a2f177d0","modified":1759111973926},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio","hash":"4319249aa4713a3944272ca2c77b95fd4415e428","modified":1759111973932},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_ide.drawio","hash":"7b59e34715988f6a95cb9851e0ebe6502b473c4d","modified":1759111973932},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_fsstructureondisk.png","hash":"3347f61be1d43d87912ac2106a09c6a34576669e","modified":1758765034940},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio","hash":"ed57340c1d5249c677289edf08db313e3be0a089","modified":1759111973932},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio.png","hash":"c97b586ce404c596a4cc0577d3691ae36ef1beb0","modified":1758768616730},{"_id":"source/_posts/muduo/TimerQueue.md","hash":"fbcdc41f05586832657cd3707bb9c87931979879","modified":1759075603135},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/entry.png","hash":"3d63c684eb7a4300424f1cc83b64407f8346b3ae","modified":1717478000642},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/kalloc.drawio.png","hash":"7051117fab81b005bd89c6b5ecf5306dd0621885","modified":1717484416877},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/memory_paging_02.drawio.png","hash":"28391dd60a873b1a9c780022ad1bbbe92309bfad","modified":1717512366970},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/vaddr.png","hash":"5428246143a54c039ddf86504d7d77c104b4a4dc","modified":1717477075443},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/main_page_table.drawio.png","hash":"c892bc156ba2d25cdb8372353b4f5c262f2e4c99","modified":1717503991074},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/onix_memory_map.drawio.png","hash":"21b0eb31b9d8524d394b6345a1b78add0ce073ee","modified":1717511797850},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1759111973955},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1759111973956},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1759111973956},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1759111973959},{"_id":"themes/next/.gitignore","hash":"d9021ac0041b511356fc7044cb02c6e0e567d706","modified":1759111973959},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1759111973959},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1759111973959},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1759111973960},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1759111973960},{"_id":"themes/next/_config.yml","hash":"a0e2a22021d828d88ce47a7f1e2a938b9756d772","modified":1759111973960},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1759111973956},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1759111973982},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1759111973962},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1759111973956},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1759111973957},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1759111973957},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1759111973958},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1759111973958},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1759111973958},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1759111973958},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1759111973958},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1759111973959},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1759111973959},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1759111973961},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1759111973961},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1759111973961},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1759111973961},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1759111973962},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1759111973962},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1759111973962},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1759111973962},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1759111973967},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1759111973982},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1759111973982},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1759111973982},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1759111973982},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1759111973982},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1759111973982},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1759111973967},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1759111973962},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1759111973967},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1759111973967},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1759111973967},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1759049299332},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1759111973967},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1759111973967},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1759111973967},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1759111973967},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1759111973967},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1759111973967},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1759111973967},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1759111973967},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1759111973967},{"_id":"themes/next/languages/tr.yml","hash":"46e09f2119cbfbcf93fb8dbd267dccabeb8b0cda","modified":1759111973967},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1759111973967},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1759111973967},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1759111973967},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1759111973967},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1759111973967},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1759111973967},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1759111973967},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1759111973987},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1759111973957},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1759111973957},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1759111973957},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1759111973962},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1759111973962},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1759111973962},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"c459531bba73a11ce84435d2c91f105ecd0e310a","modified":1759111973967},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1759111973957},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1759111973962},{"_id":"themes/next/layout/_macro/post.swig","hash":"60d4ab526812d93ad17e44e51ddaf5d7d4e06475","modified":1759111973967},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1759111973972},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1759111973972},{"_id":"themes/next/layout/_partials/footer.swig","hash":"a76355d230792e924ea3beb3094bad4b51567419","modified":1759111973972},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1759111973972},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1759111973972},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1759111973972},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1759111973962},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1759111973977},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1759111973977},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1759111973977},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1759111973977},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1759111973977},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"bd9ba0bf60cc3008ee14339fa395ee6af188e879","modified":1759111973977},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1759111973977},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1759111973982},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1759111973982},{"_id":"themes/next/source/css/_mixins.styl","hash":"cf81a6731aa436e7bb8d9a743b01f62107e27dd3","modified":1759111974008},{"_id":"themes/next/source/css/_colors.styl","hash":"9d65353ca8c634eb96142dcee1b36b6f1004522a","modified":1759111973992},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1759111974011},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1759111974011},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1759049303805},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1759049303820},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1759111974011},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1759111974011},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1759111974011},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1759111974011},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1759111974011},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1759111974011},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1759111974016},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1759049304086},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1759111974016},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1759049304096},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1759111974016},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1759111974019},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1759111974016},{"_id":"themes/next/source/js/algolia-search.js","hash":"f0cee802b4d48d5e78ba88d77d4257cb8a88dd6e","modified":1759111974016},{"_id":"themes/next/source/js/bookmark.js","hash":"2268bfcab8cf9019e590e2d356b08a3d4a0cf791","modified":1759111974016},{"_id":"themes/next/source/js/local-search.js","hash":"8f046860139f8dc7d1b445290a19e391800ff322","modified":1759111974018},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1759111974018},{"_id":"themes/next/source/js/next-boot.js","hash":"509c5b02446d4989a6ef3081cafeb9497cdde4e5","modified":1759111974018},{"_id":"themes/next/source/js/utils.js","hash":"db826a40e5830371f5fd4d648c2855a74c223cc1","modified":1759111974019},{"_id":"themes/next/scripts/events/index.js","hash":"7baf362743b3d30626066614d877891fc140c502","modified":1759111973987},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1759111973987},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1759111973987},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1759111973987},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1759111973987},{"_id":"themes/next/scripts/filters/post.js","hash":"cf5b0db0a9271687f7a21bc581ae87addd8f0767","modified":1759111973987},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1759111973987},{"_id":"themes/next/scripts/helpers/engine.js","hash":"6abda91b431c9b6f6cd2adfa665e694cfdb171be","modified":1759111973987},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1759111973987},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1759111973987},{"_id":"themes/next/scripts/tags/button.js","hash":"178d3efb8d2c1aca606181894c352fc65c40c32a","modified":1759111973987},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1759111973992},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e11a738ee77c4304add79c964bdec3715c45653a","modified":1759111973992},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1759111973992},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1759111973992},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1759111973992},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1759111973992},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1759111973992},{"_id":"themes/next/scripts/tags/tabs.js","hash":"72a5adbd8f300bee1d0c289367598ca06b2bed17","modified":1759111973992},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1759111973972},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"6a3901962ad7e698640a288be627947de90de1f6","modified":1759111973972},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1759111973972},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1759111973992},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"11acd6b585eeb823358e642c7dde7d637fda706f","modified":1759111973972},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1759111973972},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1759111973972},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1759111973972},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1759111973972},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"ca1b16202403515550f57b51dccb19afcb10ccf1","modified":1759111973972},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"5fd5ba53962aefccb43b1d2b306a534add2373e1","modified":1759111973972},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"deffa919e72da6c2cdc2f32d403c809916bd36d1","modified":1759111973972},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1759111973972},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1759111973972},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1759111973972},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"d1b9a43bdfaf2b151cce1a74d23e65c2e488e41b","modified":1759111973972},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1759111973972},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1759111973972},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1759111973972},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1759111973977},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1759111973977},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1759111973977},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1759111973977},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1759111973977},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1759111973977},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1759111973977},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1759111973977},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1759111973977},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1759111973977},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1759111973977},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1759111973977},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1759111973977},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1759111973977},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1759111973977},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1759111973977},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1759111973977},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1759111973977},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1759111973982},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1759111973982},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1759111973982},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1759111973982},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1759111973982},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1759111973982},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1759111973982},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"5b5618c2f6ad1d7971e6db257222fce89aa56565","modified":1759111973982},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1759111973982},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1759111973982},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1759111973982},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1759111973982},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1759111974011},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1759111974011},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1759111974011},{"_id":"themes/next/source/css/_variables/base.styl","hash":"fa086b75ff09268e22adf6cb36b2b6720306d824","modified":1759111974011},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"93625aa12a40482fe911e350758f9b4abe4546ff","modified":1759111974011},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1759111974020},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1759111974020},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1759111974021},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1759111974020},{"_id":"themes/next/source/lib/pace/README.md","hash":"168f57bb63563b9671d0c4f10c0940e7eec261f0","modified":1759057797094},{"_id":"themes/next/source/lib/pace/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1759057797064},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1759057797120},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1759111974020},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1759057797166},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1759057797142},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1759057797206},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1759057797231},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1759057797267},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1759057797181},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1759057797221},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1759057797247},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1759057797282},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1759057797333},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1759057797358},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1759057797398},{"_id":"themes/next/source/lib/pace/pace-theme-material.min.css","hash":"f1ff83985c090f3a3236554c5ef69542dcceb049","modified":1759057797378},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1759057797433},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1759111974025},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1759111974025},{"_id":"themes/next/source/js/schemes/muse.js","hash":"78c77614b9fe0d7d97aa08468c6cffbcbda96b75","modified":1759111974019},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"1a9741145938e2c754a808381350723cbebf43c5","modified":1759111974019},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1759111973987},{"_id":"themes/next/source/lib/pace/pace-theme-flat-top.min.css","hash":"5e1c97e232b46e48592a8e4983ae5a89e0a7da6a","modified":1759057797308},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1759111973987},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"31a6c8fbdfa16112b0b099727437b9df7641d421","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"d002c9eea7e7dd31b64a4172012d4294489974d5","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"14917c0f9ac76b50296e64437316cba0966c61d1","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"7ff11f64f4315d06ba585928fc9a8bc3761894a5","modified":1759111973987},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1759111973997},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"6471369bd120986f4afad25ad1216f9c4e8405d5","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"7ed4733240206d1aa729c835e69a85f8f3c73cd6","modified":1759111974002},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1759111974008},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1759111974007},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"83b7104a319cfbf6af3548f354240eb07dd73d38","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1759111974011},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"315eea625a90a19421b6d6413322ae40bb5ad4c6","modified":1759111974011},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"919068c7db32bfee26238e3a783efe14b3060d63","modified":1759111974011},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"c9df5ee78b46f4a2926e6e88fbe1ba1a9a75aecc","modified":1759111974011},{"_id":"themes/next/source/lib/canvas-ribbon/theme-next-canvas-ribbon-master/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1759058217329},{"_id":"themes/next/source/lib/canvas-ribbon/theme-next-canvas-ribbon-master/README.md","hash":"3a18d68b0673c0e79faecc8503268ac7bec7d30e","modified":1759058217355},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1759111974011},{"_id":"themes/next/source/lib/canvas-ribbon/theme-next-canvas-ribbon-master/canvas-ribbon.js","hash":"65b1a8f12d04b15d7ed6eeb9d11dec760a799c5f","modified":1759058217370},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1759111974021},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1759111974021},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1759111974022},{"_id":"themes/next/source/lib/pace/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1759057797458},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"f7977cfacaca9db6fab4d154486ad57ec4b0fde9","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"73c578914052e11392cd4364af9075b66832b793","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"0812ae7ecd1d8c60ec4290f506ec10881ed0fca8","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1759111974002},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1759111973994},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1759111974002},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"66001b7624ca044f9c06e75036f0e6e4b091b094","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"5912a1676a973b6d9291b43aec6aeeef6871d1ed","modified":1759111973994},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"a22c639cdf1073c9d060af62233125991ddf4dd5","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"44749e3f07a328d81a959708316494d3d737ab57","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"81b2bbd6fb590101a089bc390ed4934f5c462215","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"82a275ca74086a46b8e82d5ebf78c7a807cd9c8b","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1759111973997},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"8c318a485c56dbdcdb22fd00781484ecc151bf8a","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"9d1f42d01f6e346b61f83cdd4f5fbd3bf8e44968","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1759111974007},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1759111974007},{"_id":"themes/next/source/lib/canvas-ribbon/theme-next-canvas-ribbon-master/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1759058217386},{"_id":"source/images/wechatpay.jpg","hash":"4f7b73da01747011fb11fe937256210b1440343b","modified":1759056317889},{"_id":"source/_posts/buildroot/stage_install/photo/stage_install1.png","hash":"d0c23fc7da37176cf88979bee31141ad1fda271f","modified":1751378133020},{"_id":"source/_posts/buildroot/stage_install/photo/stage_install0.png","hash":"510b5c98d7fa60e398c4e0e15a0bd24c4f768c20","modified":1751378186677},{"_id":"source/_posts/buildroot/stage_install/photo/stage_install2.png","hash":"e9516f2e56c1ec5ab24ef261d6cbd1f4b0f1ff9f","modified":1751378069381},{"_id":"source/_posts/muduo/EventLoopThreadPool/photo/EventLoopThreadPool.drawio.png","hash":"efc8d5f6931112927291f92b16f10b1c60678d1d","modified":1705460743374},{"_id":"source/_posts/xv6/Boot/photo/scheduler/APICStructure.png","hash":"90aa790259201a55aa54328695c98bb8d63948ef","modified":1717571871485},{"_id":"source/_posts/xv6/Boot/photo/scheduler/MP_Configuration_Data_Structures.png","hash":"2916cdda4078a3dbb84f424a81a42fba9200abaa","modified":1717650679511},{"_id":"source/_posts/xv6/Boot/photo/scheduler/entry_types.png","hash":"f4ecccc51783db7a021e60befb4b5ec3040f5e0b","modified":1717649747224},{"_id":"source/_posts/xv6/Boot/photo/scheduler/processor_entry.png","hash":"e922fd5bab1c28c3e869803e1f1dbddbe0b9363e","modified":1717646358453},{"_id":"source/_posts/xv6/Boot/photo/scheduler/scheduler.drawio.png","hash":"d8fd08a7e1c6ac088c2c55da51d3f2b4082d2038","modified":1717687042770},{"_id":"source/_posts/xv6/Boot/photo/scheduler/scheduler_pluse.drawio.png","hash":"2c5e81074ed0f84056964fdf070ed45e97196f89","modified":1717935466105},{"_id":"source/_posts/xv6/Boot/photo/scheduler/universal_algorithm.png","hash":"a2dd1ec0eb390d534e4570d8eac0a8427727a1d0","modified":1717666452516},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/APICStructure.png","hash":"90aa790259201a55aa54328695c98bb8d63948ef","modified":1717571871485},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png","hash":"2916cdda4078a3dbb84f424a81a42fba9200abaa","modified":1717650679511},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/entry_types.png","hash":"f4ecccc51783db7a021e60befb4b5ec3040f5e0b","modified":1717649747224},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/processor_entry.png","hash":"e922fd5bab1c28c3e869803e1f1dbddbe0b9363e","modified":1717646358453},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/scheduler.drawio.png","hash":"d8fd08a7e1c6ac088c2c55da51d3f2b4082d2038","modified":1717687042770},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/scheduler_pluse.drawio.png","hash":"2c5e81074ed0f84056964fdf070ed45e97196f89","modified":1717935466105},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/universal_algorithm.png","hash":"a2dd1ec0eb390d534e4570d8eac0a8427727a1d0","modified":1717666452516},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio.png","hash":"0510767317a632fdf8e8077007492b81d4f9dc4a","modified":1758457929179},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache.drawio.png","hash":"e69f782d81971897de45ba427d9cdca7757b7b24","modified":1758455633428},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache2.drawio.png","hash":"ced58c1012c04b6e486fb2eec12a618126422a83","modified":1758458318241},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache3.drawio.png","hash":"8f1b794aa02d3125a379b0636d648b4326c7294d","modified":1758459074551},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_dentry.drawio.png","hash":"8d3f51c1b536e41e6d64e4b26c45c8a1daabd000","modified":1758989274858},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_ide.drawio.png","hash":"73e5cf76ca64efd8d99c2f71e04967f1f1b8fcd8","modified":1758274994042},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_mount.drawio","hash":"5e94d7ab3a3f38419022b57dfda1a430d8b4dcb4","modified":1759111973927},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio","hash":"8d25e43234e275ffd482a771bff5318f69b58ddf","modified":1759111973927},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio.png","hash":"95e79ebed1e00dffdc1827adafe184f246163bf2","modified":1758197598316},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_ide.drawio.png","hash":"ba8ea2c0090da682608a91cd37c9fa107f8e1b91","modified":1758264793550},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/vaddr2paddr.png","hash":"6ffa614b9a3a80240fc42d53e2faecf7d516d141","modified":1717476210791},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1759049304944},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1759049304916},{"_id":"source/_posts/muduo/AsyncLogging/photo/AsynLogging.drawio.png","hash":"d9a524d478c3ea9f3a47a744bb2ccf962ccb3fec","modified":1706771088386},{"_id":"source/_posts/workflow/TCPServer_1/photo/EventLoopThreadPool.drawio.png","hash":"6378bde2125ca7e8a1e85b123866b983d8574fb2","modified":1730363968900},{"_id":"source/_posts/xv6/Boot/photo/scheduler/MP_configuration_table_header.png","hash":"77f8f397c241da0e86e870ccfaa281a0d5efb536","modified":1717646308549},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/MP_configuration_table_header.png","hash":"77f8f397c241da0e86e870ccfaa281a0d5efb536","modified":1717646308549},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio.png","hash":"30030b6c629dbb70e3d0f84043d07be91ff74361","modified":1758888464591},{"_id":"source/_posts/muduo/TcpServer/photo/TcpServer.drawio.png","hash":"aa9f13db074318701d634b6a57abd727b1730f5f","modified":1705651048478},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1759049304887},{"_id":"source/_posts/workflow/TCPServer_1/photo/EventLoopFlowChart.drawio.png","hash":"bdbda89e07f8248ccb9689325a5cd2c0ecd0c2f9","modified":1730363057282},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio.png","hash":"cbc2de25bbddf38fb4da4787b179b992908f771d","modified":1758975153948},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_mount.drawio.png","hash":"9937ffdc3bded10f1ae61991a4f116455026b3e9","modified":1758971773093},{"_id":"source/_posts/xv6/Boot/photo/scheduler/trap__structure.png","hash":"2c96a0e25efeda0c90515b6cd996c28409fe1dfb","modified":1717661661090},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/trap__structure.png","hash":"2c96a0e25efeda0c90515b6cd996c28409fe1dfb","modified":1717661661090},{"_id":"source/_posts/xv6/Boot/photo/scheduler/yield_scheduler.png","hash":"ca89de4ab6f0f1f47b33cd4983fd390bc23f3811","modified":1717685346373},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/yield_scheduler.png","hash":"ca89de4ab6f0f1f47b33cd4983fd390bc23f3811","modified":1717685346373},{"_id":"source/_posts/workflow/TCPServer_2/photo/StateTranslateThreadPool.drawio.png","hash":"68eeedeae08a12c9839189bf5a90e8830575e895","modified":1730618095140},{"_id":"source/_posts/workflow/TCPServer_2/photo/ReadStatusTranslate.drawio.png","hash":"7bd7f8ebef714823af6113fa5dc06fb67c5ebd9f","modified":1730638585817},{"_id":"public/about/index.html","hash":"4e7d045c600c521ddece36d98e67ec2cef8e37ef","modified":1759122105257},{"_id":"public/categories/index.html","hash":"ac5d1d86c8b73fac100ec8d90f195d943db788f1","modified":1759122105257},{"_id":"public/tags/index.html","hash":"eec83d1442d4cde75c77554e77c22a08b329dfd2","modified":1759122105257},{"_id":"public/archives/page/3/index.html","hash":"6d05d00d4ada7d36ea60b1d5dd1fa94d943cb0a4","modified":1759122105257},{"_id":"public/archives/2024/06/index.html","hash":"01f04798033b74399b7428a8d01ff61d01851360","modified":1759122105257},{"_id":"public/archives/2024/10/index.html","hash":"da53c90507e5d9a51fe63e34af13016d3740ee94","modified":1759122105257},{"_id":"public/archives/2024/11/page/2/index.html","hash":"827fc29833ceec698de2e75b5b43ddce402203c8","modified":1759122105257},{"_id":"public/archives/2025/index.html","hash":"69fdfe055306b54a6db23f5179765eb99d91272c","modified":1759122105257},{"_id":"public/archives/2025/09/index.html","hash":"e919969afe4e5bb1f28a6afe0d161302d8b47080","modified":1759122105257},{"_id":"public/page/3/index.html","hash":"a858ba6a181b801a182216a808556c3d5d055825","modified":1759122105257},{"_id":"public/tags/Linux应用技术笔记/index.html","hash":"1320e33403aba2225fa36d4fc19f23db430da6b2","modified":1759122105257},{"_id":"public/tags/高性能服务器框架/page/2/index.html","hash":"5040dbcd1e563e1af1d27650f0b76197cf3b76c0","modified":1759122105257},{"_id":"public/tags/类Unix源码剖析/index.html","hash":"e9dda06e22a3ea550b431ec74ba6255d5e14703e","modified":1759122105257},{"_id":"public/2025/09/28/buildroot/stage_install/index.html","hash":"11499183fd18b97bb4a3492df7a7abafe3f8984a","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/index.html","hash":"dc7ea0b0ed3ca2c4ee66d6d72d08972c1788270a","modified":1759122105257},{"_id":"public/2024/11/07/workflow/TCPServer_3/index.html","hash":"4f54d8ef9c83ec2fe630ae4ab15f1378ae874fff","modified":1759122105257},{"_id":"public/2024/11/04/workflow/TCPServer_2/index.html","hash":"c8ed1ea24c121e2ff6fbadb19cb0d02fd6899fbe","modified":1759122105257},{"_id":"public/2024/11/02/muduo/AsyncLogging/index.html","hash":"2e1c9b8f3033bdc51e4263e64bfa097a9276e2e5","modified":1759122105257},{"_id":"public/2024/11/02/muduo/ChannelAndPoller/index.html","hash":"495601eae67308dbbbcf622b8394666a550f0906","modified":1759122105257},{"_id":"public/2024/11/02/muduo/Start/index.html","hash":"0f7eee216abbc6c579431834dd03099efc6b5513","modified":1759122105257},{"_id":"public/2024/11/02/muduo/EventLoopThreadPool/index.html","hash":"5f12c8c3c82dc7a3453cffc0aa775836bf5abf02","modified":1759122105257},{"_id":"public/2024/11/02/muduo/EvevntLoopAndThread/index.html","hash":"bc6f7074e136b7995234699288765b2cd4c98acd","modified":1759122105257},{"_id":"public/2024/11/02/muduo/SynLogging/index.html","hash":"ecf8de9c8782ae0a0a9e08185edaba05b265b1b8","modified":1759122105257},{"_id":"public/2024/11/02/muduo/TcpClient/index.html","hash":"f5092026d7a7c908e7447f07941fb3ed475da917","modified":1759122105257},{"_id":"public/2024/11/02/muduo/TcpConnection/index.html","hash":"7b4635acad1bb9993091da4db0a0f703237caaeb","modified":1759122105257},{"_id":"public/2024/11/02/muduo/TcpServer/index.html","hash":"5dad0f4e7f8e861aa973b5273535d99eddc73a25","modified":1759122105257},{"_id":"public/2024/11/02/muduo/ThreadAndThreadPool/index.html","hash":"ca567df348581cfa1eb70e03cecf5f2ac44fe2ca","modified":1759122105257},{"_id":"public/2024/11/02/muduo/ThreadSafeAndSync/index.html","hash":"3661a29f97501adf3793da86c9aec7d94417628a","modified":1759122105257},{"_id":"public/2024/11/02/muduo/TimerQueue/index.html","hash":"79f2530ad7cb24315b18433e06bbf6dcd10725a2","modified":1759122105257},{"_id":"public/2024/11/02/workflow/TCPServer_1/index.html","hash":"1416b9b4267c60a8942048c6ef1f0d9d35015394","modified":1759122105257},{"_id":"public/2024/10/13/workflow/go_task/index.html","hash":"d5160874e61dcaa37127293867b52e9d498f1ba9","modified":1759122105257},{"_id":"public/2024/06/08/xv6/Scheduler/index.html","hash":"815b8f4569ec549b1378d7a0b2ce33d70417f9bf","modified":1759122105257},{"_id":"public/2024/06/07/xv6/MemoryManager/index.html","hash":"0e1cf722c970b89b19b068958a2ce3ac16a7581c","modified":1759122105257},{"_id":"public/2024/06/07/xv6/Boot/index.html","hash":"0311d784b7f57b78760be25f89473a87d2dfd641","modified":1759122105257},{"_id":"public/archives/index.html","hash":"3a467ed228e509a0df44966fff97c3006b7d230f","modified":1759122105257},{"_id":"public/archives/page/2/index.html","hash":"dcba0cd0495fd9dc5b088f63ed5a487274a163ed","modified":1759122105257},{"_id":"public/archives/2024/index.html","hash":"c71889dc61febfd610835c2fde8c2ed42e5ee333","modified":1759122105257},{"_id":"public/archives/2024/page/2/index.html","hash":"4d6ddf61bd59ee2f24389d6ad390e2836d0a7964","modified":1759122105257},{"_id":"public/archives/2024/11/index.html","hash":"3f5e0e42e8561d0f34f8f8b1b7e9c0a1c0c959b9","modified":1759122105257},{"_id":"public/index.html","hash":"cbe204d9e0815682b4f0e74b70b3e05a25cd50ad","modified":1759122105257},{"_id":"public/page/2/index.html","hash":"c3c663d953df7792a9a5d45a624cb705c6179db3","modified":1759122105257},{"_id":"public/tags/高性能服务器框架/index.html","hash":"0afb785e02ae1dd594f0a4941c97842a44739709","modified":1759122105257},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1759110968437},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1759110968437},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1759122105257},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1759122105257},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1759122105257},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1759122105257},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1759122105257},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1759122105257},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1759122105257},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1759110968437},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1759122105257},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1759110968437},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1759122105257},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1759122105257},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1759122105257},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1759122105257},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1759122105257},{"_id":"public/images/avatar.jpg","hash":"eedc3cb767ecbcdbadd5e7e1b4a2c574eeb930c3","modified":1759110968437},{"_id":"public/2024/11/02/muduo/ThreadAndThreadPool/photo/ThreadPool.drawio.png","hash":"fd81e3dc3084ae1ba009f2b0c5b808025921ae42","modified":1759110968437},{"_id":"public/2024/11/02/muduo/EvevntLoopAndThread/photo/EventLoop.drawio.png","hash":"1b042f052b1c603a63b3423dbd16c661e8e03d28","modified":1759110968437},{"_id":"public/2024/06/07/xv6/MemoryManager/photo/memmanager/entry.png","hash":"3d63c684eb7a4300424f1cc83b64407f8346b3ae","modified":1759110968437},{"_id":"public/2024/06/07/xv6/MemoryManager/photo/memmanager/kalloc.drawio.png","hash":"7051117fab81b005bd89c6b5ecf5306dd0621885","modified":1759110968437},{"_id":"public/2024/06/07/xv6/MemoryManager/photo/memmanager/main_page_table.drawio.png","hash":"c892bc156ba2d25cdb8372353b4f5c262f2e4c99","modified":1759110968437},{"_id":"public/2024/06/07/xv6/MemoryManager/photo/memmanager/memory_paging_02.drawio.png","hash":"28391dd60a873b1a9c780022ad1bbbe92309bfad","modified":1759110968437},{"_id":"public/lib/canvas-ribbon/theme-next-canvas-ribbon-master/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1759110968437},{"_id":"public/lib/pace/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1759110968437},{"_id":"public/2024/06/07/xv6/MemoryManager/photo/memmanager/onix_memory_map.drawio.png","hash":"21b0eb31b9d8524d394b6345a1b78add0ce073ee","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/8259a.drawio.png","hash":"83d2785b610a50aed51bbd2721a4d8dc91d09e6d","modified":1759110968437},{"_id":"public/2024/06/07/xv6/MemoryManager/photo/memmanager/vaddr.png","hash":"5428246143a54c039ddf86504d7d77c104b4a4dc","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/IDTR.png","hash":"49db6c278ef03ebf2a718819995c81a7e0e852b5","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/ioapic_entry.png","hash":"7b551a258d0b1dc29c5851d1c8355fa037841796","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/imcrp.png","hash":"8c9864113c89b148bd721ea5f4b93b6e6da5efa9","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/IDT_Entry.png","hash":"4cd80376efd49a1cfa9213496d7b61f3320eb64c","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/MP_floating_pointer_structure.png","hash":"a3458fe0c961df5a72a7cf12b409dd9dcc05afe5","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/task_stack.drawio.png","hash":"ba199d6a2e2d9f403408bbeabc5b94a4d598f4e0","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/trap_frame.png","hash":"6a191f20fab43fadd95da12ef456ee6c149cba87","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio","hash":"bc34b6aad6a41e1dadad7aac08c053de83ec9b62","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache.drawio","hash":"7474147536b4ac4c3c00ea16b07671f780e13d97","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache2.drawio","hash":"f34adef92989402356e6d139def58c7e190c55b7","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache3.drawio","hash":"31c156b1c05b206c65cff8160e891390acc88823","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_dentry.drawio","hash":"65a8be4674b07c5b29bdde8b2902729cb5f9d15d","modified":1759122105257},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1759110968437},{"_id":"public/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1759110968437},{"_id":"public/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1759110968437},{"_id":"public/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1759110968437},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1759110968437},{"_id":"public/js/local-search.js","hash":"b42bd1c883ce91db8632d96e0f0e062cb6b73adc","modified":1759110968437},{"_id":"public/js/utils.js","hash":"d26efec3ecda8ec1ac32a4304e8c309c07aec56b","modified":1759110968437},{"_id":"public/css/main.css","hash":"77cc8f08bee3d9433f0b8a19dea65a95d382868c","modified":1759122105257},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio","hash":"08195759ab6c5ac2616e128760855b57a992e852","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio.png","hash":"3337f4f391a9d971abdf4951b0a2987486775eb8","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio","hash":"8ce9d32364920623b9dd517df178e8bbcc68cb6b","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_ide.drawio","hash":"1a8f29964aee9423db4757763cf65a47daa4d211","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio.png","hash":"09710d67477b554aaa7323a2c375ee9d0d341687","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio","hash":"a64e4db9d0e53d2981f516a2e7135e52a2f177d0","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_fsstructureondisk.png","hash":"3347f61be1d43d87912ac2106a09c6a34576669e","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio","hash":"4319249aa4713a3944272ca2c77b95fd4415e428","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio","hash":"ed57340c1d5249c677289edf08db313e3be0a089","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_ide.drawio","hash":"7b59e34715988f6a95cb9851e0ebe6502b473c4d","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio.png","hash":"c97b586ce404c596a4cc0577d3691ae36ef1beb0","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/Logo.jpg","hash":"808892bb96be6a1e7e82534873c36e7ae2cb9544","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/8259a.drawio.png","hash":"83d2785b610a50aed51bbd2721a4d8dc91d09e6d","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/IDTR.png","hash":"49db6c278ef03ebf2a718819995c81a7e0e852b5","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/IDT_Entry.png","hash":"4cd80376efd49a1cfa9213496d7b61f3320eb64c","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/imcrp.png","hash":"8c9864113c89b148bd721ea5f4b93b6e6da5efa9","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/ioapic_entry.png","hash":"7b551a258d0b1dc29c5851d1c8355fa037841796","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/MP_floating_pointer_structure.png","hash":"a3458fe0c961df5a72a7cf12b409dd9dcc05afe5","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/task_stack.drawio.png","hash":"ba199d6a2e2d9f403408bbeabc5b94a4d598f4e0","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/trap_frame.png","hash":"6a191f20fab43fadd95da12ef456ee6c149cba87","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/start/boot.drawio.png","hash":"4d4eeec0332589443e39742c5007784058433312","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/start/entry.drawio.png","hash":"60d49b69b0f343b4bb71c830294c95c7565bb5ff","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/start/GDT.png","hash":"c7865b8c24a0bb195567b318fdb2c332c642e954","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/start/GDTR.png","hash":"c1de122b466da828be0ae56e3d195416f5c29af4","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/start/SegmentDescriptor.png","hash":"0b2178b404782f2aedef546f3e4841cd4b0f5328","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/start/SegmentSelector.png","hash":"4cb9e6e79a1e9e29cb4bfc975e050855d58a0d9c","modified":1759110968437},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1759110968437},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1759110968437},{"_id":"public/images/wechatpay.jpg","hash":"4f7b73da01747011fb11fe937256210b1440343b","modified":1759110968437},{"_id":"public/2024/11/02/muduo/AsyncLogging/photo/AsynLogging.drawio.png","hash":"d9a524d478c3ea9f3a47a744bb2ccf962ccb3fec","modified":1759110968437},{"_id":"public/2025/09/28/buildroot/stage_install/photo/stage_install0.png","hash":"510b5c98d7fa60e398c4e0e15a0bd24c4f768c20","modified":1759110968437},{"_id":"public/2024/11/02/muduo/EventLoopThreadPool/photo/EventLoopThreadPool.drawio.png","hash":"efc8d5f6931112927291f92b16f10b1c60678d1d","modified":1759110968437},{"_id":"public/2025/09/28/buildroot/stage_install/photo/stage_install1.png","hash":"d0c23fc7da37176cf88979bee31141ad1fda271f","modified":1759110968437},{"_id":"public/2025/09/28/buildroot/stage_install/photo/stage_install2.png","hash":"e9516f2e56c1ec5ab24ef261d6cbd1f4b0f1ff9f","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/APICStructure.png","hash":"90aa790259201a55aa54328695c98bb8d63948ef","modified":1759110968437},{"_id":"public/2024/06/07/xv6/MemoryManager/photo/memmanager/vaddr2paddr.png","hash":"6ffa614b9a3a80240fc42d53e2faecf7d516d141","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/entry_types.png","hash":"f4ecccc51783db7a021e60befb4b5ec3040f5e0b","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png","hash":"2916cdda4078a3dbb84f424a81a42fba9200abaa","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler.drawio.png","hash":"d8fd08a7e1c6ac088c2c55da51d3f2b4082d2038","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler_pluse.drawio.png","hash":"2c5e81074ed0f84056964fdf070ed45e97196f89","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/universal_algorithm.png","hash":"a2dd1ec0eb390d534e4570d8eac0a8427727a1d0","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio.png","hash":"0510767317a632fdf8e8077007492b81d4f9dc4a","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache2.drawio.png","hash":"ced58c1012c04b6e486fb2eec12a618126422a83","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache.drawio.png","hash":"e69f782d81971897de45ba427d9cdca7757b7b24","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache3.drawio.png","hash":"8f1b794aa02d3125a379b0636d648b4326c7294d","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_dentry.drawio.png","hash":"8d3f51c1b536e41e6d64e4b26c45c8a1daabd000","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1759110968437},{"_id":"public/lib/pace/README.html","hash":"b1db0e6c71c25fbdc5a161e1bd70382846ce99ab","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-flat-top.min.css","hash":"5e1c97e232b46e48592a8e4983ae5a89e0a7da6a","modified":1759110968437},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1759110968437},{"_id":"public/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1759110968437},{"_id":"public/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1759110968437},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1759110968437},{"_id":"public/lib/canvas-ribbon/theme-next-canvas-ribbon-master/README.html","hash":"1b6d10c79836d002d90f4bcf35f498f1bf38c7ee","modified":1759110968437},{"_id":"public/lib/canvas-ribbon/theme-next-canvas-ribbon-master/canvas-ribbon.js","hash":"65b1a8f12d04b15d7ed6eeb9d11dec760a799c5f","modified":1759110968437},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-material.min.css","hash":"f1ff83985c090f3a3236554c5ef69542dcceb049","modified":1759110968437},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1759110968437},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/processor_entry.png","hash":"e922fd5bab1c28c3e869803e1f1dbddbe0b9363e","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_ide.drawio.png","hash":"73e5cf76ca64efd8d99c2f71e04967f1f1b8fcd8","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_mount.drawio","hash":"5e94d7ab3a3f38419022b57dfda1a430d8b4dcb4","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio","hash":"8d25e43234e275ffd482a771bff5318f69b58ddf","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio.png","hash":"95e79ebed1e00dffdc1827adafe184f246163bf2","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_ide.drawio.png","hash":"ba8ea2c0090da682608a91cd37c9fa107f8e1b91","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/entry_types.png","hash":"f4ecccc51783db7a021e60befb4b5ec3040f5e0b","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/APICStructure.png","hash":"90aa790259201a55aa54328695c98bb8d63948ef","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/MP_Configuration_Data_Structures.png","hash":"2916cdda4078a3dbb84f424a81a42fba9200abaa","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/scheduler_pluse.drawio.png","hash":"2c5e81074ed0f84056964fdf070ed45e97196f89","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/scheduler.drawio.png","hash":"d8fd08a7e1c6ac088c2c55da51d3f2b4082d2038","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/processor_entry.png","hash":"e922fd5bab1c28c3e869803e1f1dbddbe0b9363e","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/universal_algorithm.png","hash":"a2dd1ec0eb390d534e4570d8eac0a8427727a1d0","modified":1759110968437},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1759110968437},{"_id":"public/2024/11/02/workflow/TCPServer_1/photo/EventLoopThreadPool.drawio.png","hash":"6378bde2125ca7e8a1e85b123866b983d8574fb2","modified":1759110968437},{"_id":"public/2024/11/02/muduo/TcpServer/photo/TcpServer.drawio.png","hash":"aa9f13db074318701d634b6a57abd727b1730f5f","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/MP_configuration_table_header.png","hash":"77f8f397c241da0e86e870ccfaa281a0d5efb536","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio.png","hash":"30030b6c629dbb70e3d0f84043d07be91ff74361","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/MP_configuration_table_header.png","hash":"77f8f397c241da0e86e870ccfaa281a0d5efb536","modified":1759110968437},{"_id":"public/2024/11/02/workflow/TCPServer_1/photo/EventLoopFlowChart.drawio.png","hash":"bdbda89e07f8248ccb9689325a5cd2c0ecd0c2f9","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio.png","hash":"cbc2de25bbddf38fb4da4787b179b992908f771d","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_mount.drawio.png","hash":"9937ffdc3bded10f1ae61991a4f116455026b3e9","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/trap__structure.png","hash":"2c96a0e25efeda0c90515b6cd996c28409fe1dfb","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/trap__structure.png","hash":"2c96a0e25efeda0c90515b6cd996c28409fe1dfb","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/yield_scheduler.png","hash":"ca89de4ab6f0f1f47b33cd4983fd390bc23f3811","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/yield_scheduler.png","hash":"ca89de4ab6f0f1f47b33cd4983fd390bc23f3811","modified":1759110968437},{"_id":"public/2024/11/04/workflow/TCPServer_2/photo/StateTranslateThreadPool.drawio.png","hash":"68eeedeae08a12c9839189bf5a90e8830575e895","modified":1759110968437},{"_id":"public/2024/11/04/workflow/TCPServer_2/photo/ReadStatusTranslate.drawio.png","hash":"7bd7f8ebef714823af6113fa5dc06fb67c5ebd9f","modified":1759110968437}],"Category":[],"Data":[],"Page":[{"title":"关于","date":"2025-09-28T09:44:49.000Z","tags":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2025-09-28 17:44:49\ntags: about\n---\n","updated":"2025-09-29T02:12:53.953Z","path":"about/index.html","_id":"cmg3w8w9g0000q8wsdo6dfyst","comments":1,"layout":"page","content":"","excerpt":"","more":""},{"title":"分类","date":"2025-09-28T09:48:31.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2025-09-28 17:48:31\ntype: categories\n---\n","updated":"2025-09-29T02:12:53.953Z","path":"categories/index.html","_id":"cmg3w8w9k0002q8ws44n48f9b","comments":1,"layout":"page","content":"","excerpt":"","more":""},{"title":"文章标签","date":"2025-09-28T08:57:26.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 文章标签\ndate: 2025-09-28 16:57:26\ntype: tags\n---\n","updated":"2025-09-29T02:12:53.955Z","path":"tags/index.html","_id":"cmg3w8w9m0005q8ws2qlggkme","comments":1,"layout":"page","content":"","excerpt":"","more":""}],"Post":[{"title":"Buildroot实现stage/target安装阶段，在执行原项目当中cmake的instll代码外再执行自定义的安装代码","date":"2025-09-28T04:00:00.000Z","_content":"\n## 正文\n\n实现方式其实是参考 buildroot/package/pkg-cmake.mk 的代码，你必需知道，我们再向buildroot添加一个包时，会编写mk文件，里面会有很多预定义的宏，最常见的：XX_INSTALL_STAGING_CMDS 和 XX_INSTALL_TARGET_CMDS，两者区别是：XX_INSTALL_STAGING_CMDS是往构建根目录安装一些文件、XX_INSTALL_TARGET_CMDS是往目标（下位机根文件系统）目录安装一些文件。一旦我们的mk文件定义了这两命令，这两命令的默认值就会被覆盖。\n\nXX_INSTALL_STAGING_CMDS 和 XX_INSTALL_TARGET_CMDS这两命令的默认行为就是使用原项目当中的cmake install代码。我们只需要参考 buildroot/package/pkg-cmake.mk 文件默认安装命令的实现，然后再此基础上自定义我们的内容就能实现“双install”的效果。\n\n废话不多说，直接上代码：\n\n<!-- more -->\n\nConfig.in文件实现如下：\n\n```\nconfig BR2_PACKAGE_MYPROJECT\n    bool \"my project\"\n    help\n        this configuration is used to enable or disable myproject.\n```\n\n- 首先我们不定义XX_INSTALL_STAGING_CMDS命令，查看其默认安装行为：mk文件如下：\n\n    ```makefile\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    # ONVIF_SRVD_VERSION =\n    MYPROJECT_SITE = $(TOPDIR)/../external/myproject\n    MYPROJECT_SITE_METHOD = local\n    MYPROJECT_DEPENDENCIES = rockchip-mpp\n    MYPROJECT_INSTALL_STAGING = YES\n    endif\n\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    $(eval $(cmake-package))\n    endif\n    ```\n\n    编译效果如下：\n\n    ![](./stage_install/photo/stage_install0.png)\n\n    可以看到，默认的编译效果会使用cmake文件当中的安装代码。\n\n- 然后我们尝试定义XX_INSTALL_STAGING_CMDS命令，查看默认行为是否会被覆盖：\n\n    ```makefile\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    # ONVIF_SRVD_VERSION =\n    MYPROJECT_SITE = $(TOPDIR)/../external/myproject\n    MYPROJECT_SITE_METHOD = local\n    MYPROJECT_DEPENDENCIES = rockchip-mpp\n    MYPROJECT_INSTALL_STAGING = YES\n    endif\n\n    define MYPROJECT_INSTALL_STAGING_CMDS\n        echo \"ok\"\n    endef\n\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    $(eval $(cmake-package))\n    endif\n    ```\n\n    效果如下\n\n    ![](./stage_install/photo/stage_install1.png)\n\n    很明显，默认的安装行为已经被覆盖，只执行了我们后来自定义的安装代码，也就是只打印了ok。\n\n- 最后我们在定义XX_INSTALL_STAGING_CMDS命令最前面，参考buildroot/package/pkg-cmake.mk加上默认安装行为，mk文件如下：\n\n    ```makefile\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    # ONVIF_SRVD_VERSION =\n    MYPROJECT_SITE = $(TOPDIR)/../external/myproject\n    MYPROJECT_SITE_METHOD = local\n    MYPROJECT_DEPENDENCIES = rockchip-mpp\n    MYPROJECT_INSTALL_STAGING = YES\n    endif\n\n    define MYPROJECT_INSTALL_STAGING_CMDS\n        $(TARGET_MAKE_ENV) $(MYPROJECT_MAKE_ENV) $(MYPROJECT_MAKE) $(MYPROJECT_MAKE_OPTS) $(MYPROJECT_INSTALL_STAGING_OPTS) -C $(MYPROJECT_BUILDDIR)\n        echo \"ok\"\n    endef\n\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    $(eval $(cmake-package))\n    endif\n    ```\n\n    结果如下：\n\n    ![](./stage_install/photo/stage_install2.png)\n\n    结果正是我们想要的，不仅执行了cmake当中的安装行为，也执行了我们后来追加的安装行为。\n\n---\n\n**本章完结**","source":"_posts/buildroot/stage_install.md","raw":"---\ntitle: Buildroot实现stage/target安装阶段，在执行原项目当中cmake的instll代码外再执行自定义的安装代码\ndate: 2025-09-28 12:00:00\ntags:\n  - Linux应用技术笔记\n---\n\n## 正文\n\n实现方式其实是参考 buildroot/package/pkg-cmake.mk 的代码，你必需知道，我们再向buildroot添加一个包时，会编写mk文件，里面会有很多预定义的宏，最常见的：XX_INSTALL_STAGING_CMDS 和 XX_INSTALL_TARGET_CMDS，两者区别是：XX_INSTALL_STAGING_CMDS是往构建根目录安装一些文件、XX_INSTALL_TARGET_CMDS是往目标（下位机根文件系统）目录安装一些文件。一旦我们的mk文件定义了这两命令，这两命令的默认值就会被覆盖。\n\nXX_INSTALL_STAGING_CMDS 和 XX_INSTALL_TARGET_CMDS这两命令的默认行为就是使用原项目当中的cmake install代码。我们只需要参考 buildroot/package/pkg-cmake.mk 文件默认安装命令的实现，然后再此基础上自定义我们的内容就能实现“双install”的效果。\n\n废话不多说，直接上代码：\n\n<!-- more -->\n\nConfig.in文件实现如下：\n\n```\nconfig BR2_PACKAGE_MYPROJECT\n    bool \"my project\"\n    help\n        this configuration is used to enable or disable myproject.\n```\n\n- 首先我们不定义XX_INSTALL_STAGING_CMDS命令，查看其默认安装行为：mk文件如下：\n\n    ```makefile\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    # ONVIF_SRVD_VERSION =\n    MYPROJECT_SITE = $(TOPDIR)/../external/myproject\n    MYPROJECT_SITE_METHOD = local\n    MYPROJECT_DEPENDENCIES = rockchip-mpp\n    MYPROJECT_INSTALL_STAGING = YES\n    endif\n\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    $(eval $(cmake-package))\n    endif\n    ```\n\n    编译效果如下：\n\n    ![](./stage_install/photo/stage_install0.png)\n\n    可以看到，默认的编译效果会使用cmake文件当中的安装代码。\n\n- 然后我们尝试定义XX_INSTALL_STAGING_CMDS命令，查看默认行为是否会被覆盖：\n\n    ```makefile\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    # ONVIF_SRVD_VERSION =\n    MYPROJECT_SITE = $(TOPDIR)/../external/myproject\n    MYPROJECT_SITE_METHOD = local\n    MYPROJECT_DEPENDENCIES = rockchip-mpp\n    MYPROJECT_INSTALL_STAGING = YES\n    endif\n\n    define MYPROJECT_INSTALL_STAGING_CMDS\n        echo \"ok\"\n    endef\n\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    $(eval $(cmake-package))\n    endif\n    ```\n\n    效果如下\n\n    ![](./stage_install/photo/stage_install1.png)\n\n    很明显，默认的安装行为已经被覆盖，只执行了我们后来自定义的安装代码，也就是只打印了ok。\n\n- 最后我们在定义XX_INSTALL_STAGING_CMDS命令最前面，参考buildroot/package/pkg-cmake.mk加上默认安装行为，mk文件如下：\n\n    ```makefile\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    # ONVIF_SRVD_VERSION =\n    MYPROJECT_SITE = $(TOPDIR)/../external/myproject\n    MYPROJECT_SITE_METHOD = local\n    MYPROJECT_DEPENDENCIES = rockchip-mpp\n    MYPROJECT_INSTALL_STAGING = YES\n    endif\n\n    define MYPROJECT_INSTALL_STAGING_CMDS\n        $(TARGET_MAKE_ENV) $(MYPROJECT_MAKE_ENV) $(MYPROJECT_MAKE) $(MYPROJECT_MAKE_OPTS) $(MYPROJECT_INSTALL_STAGING_OPTS) -C $(MYPROJECT_BUILDDIR)\n        echo \"ok\"\n    endef\n\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    $(eval $(cmake-package))\n    endif\n    ```\n\n    结果如下：\n\n    ![](./stage_install/photo/stage_install2.png)\n\n    结果正是我们想要的，不仅执行了cmake当中的安装行为，也执行了我们后来追加的安装行为。\n\n---\n\n**本章完结**","slug":"buildroot/stage_install","published":1,"updated":"2025-09-28T09:41:18.567Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9i0001q8ws0sso6gl1","content":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>实现方式其实是参考 buildroot&#x2F;package&#x2F;pkg-cmake.mk 的代码，你必需知道，我们再向buildroot添加一个包时，会编写mk文件，里面会有很多预定义的宏，最常见的：XX_INSTALL_STAGING_CMDS 和 XX_INSTALL_TARGET_CMDS，两者区别是：XX_INSTALL_STAGING_CMDS是往构建根目录安装一些文件、XX_INSTALL_TARGET_CMDS是往目标（下位机根文件系统）目录安装一些文件。一旦我们的mk文件定义了这两命令，这两命令的默认值就会被覆盖。</p>\n<p>XX_INSTALL_STAGING_CMDS 和 XX_INSTALL_TARGET_CMDS这两命令的默认行为就是使用原项目当中的cmake install代码。我们只需要参考 buildroot&#x2F;package&#x2F;pkg-cmake.mk 文件默认安装命令的实现，然后再此基础上自定义我们的内容就能实现“双install”的效果。</p>\n<p>废话不多说，直接上代码：</p>\n<span id=\"more\"></span>\n\n<p>Config.in文件实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config BR2_PACKAGE_MYPROJECT</span><br><span class=\"line\">    bool &quot;my project&quot;</span><br><span class=\"line\">    help</span><br><span class=\"line\">        this configuration is used to enable or disable myproject.</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>首先我们不定义XX_INSTALL_STAGING_CMDS命令，查看其默认安装行为：mk文件如下：</p>\n  <figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"comment\"># ONVIF_SRVD_VERSION =</span></span><br><span class=\"line\">MYPROJECT_SITE = <span class=\"variable\">$(TOPDIR)</span>/../external/myproject</span><br><span class=\"line\">MYPROJECT_SITE_METHOD = local</span><br><span class=\"line\">MYPROJECT_DEPENDENCIES = rockchip-mpp</span><br><span class=\"line\">MYPROJECT_INSTALL_STAGING = YES</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">eval</span> $(cmake-package)</span>)</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<p>  编译效果如下：</p>\n<p>  <img src=\"/2025/09/28/buildroot/stage_install/photo/stage_install0.png\"></p>\n<p>  可以看到，默认的编译效果会使用cmake文件当中的安装代码。</p>\n</li>\n<li><p>然后我们尝试定义XX_INSTALL_STAGING_CMDS命令，查看默认行为是否会被覆盖：</p>\n  <figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"comment\"># ONVIF_SRVD_VERSION =</span></span><br><span class=\"line\">MYPROJECT_SITE = <span class=\"variable\">$(TOPDIR)</span>/../external/myproject</span><br><span class=\"line\">MYPROJECT_SITE_METHOD = local</span><br><span class=\"line\">MYPROJECT_DEPENDENCIES = rockchip-mpp</span><br><span class=\"line\">MYPROJECT_INSTALL_STAGING = YES</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">define</span> MYPROJECT_INSTALL_STAGING_CMDS</span><br><span class=\"line\">    echo <span class=\"string\">&quot;ok&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">endef</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">eval</span> $(cmake-package)</span>)</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<p>  效果如下</p>\n<p>  <img src=\"/2025/09/28/buildroot/stage_install/photo/stage_install1.png\"></p>\n<p>  很明显，默认的安装行为已经被覆盖，只执行了我们后来自定义的安装代码，也就是只打印了ok。</p>\n</li>\n<li><p>最后我们在定义XX_INSTALL_STAGING_CMDS命令最前面，参考buildroot&#x2F;package&#x2F;pkg-cmake.mk加上默认安装行为，mk文件如下：</p>\n  <figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"comment\"># ONVIF_SRVD_VERSION =</span></span><br><span class=\"line\">MYPROJECT_SITE = <span class=\"variable\">$(TOPDIR)</span>/../external/myproject</span><br><span class=\"line\">MYPROJECT_SITE_METHOD = local</span><br><span class=\"line\">MYPROJECT_DEPENDENCIES = rockchip-mpp</span><br><span class=\"line\">MYPROJECT_INSTALL_STAGING = YES</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">define</span> MYPROJECT_INSTALL_STAGING_CMDS</span><br><span class=\"line\">    <span class=\"variable\">$(TARGET_MAKE_ENV)</span> <span class=\"variable\">$(MYPROJECT_MAKE_ENV)</span> <span class=\"variable\">$(MYPROJECT_MAKE)</span> <span class=\"variable\">$(MYPROJECT_MAKE_OPTS)</span> <span class=\"variable\">$(MYPROJECT_INSTALL_STAGING_OPTS)</span> -C <span class=\"variable\">$(MYPROJECT_BUILDDIR)</span></span><br><span class=\"line\">    echo <span class=\"string\">&quot;ok&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">endef</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">eval</span> $(cmake-package)</span>)</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<p>  结果如下：</p>\n<p>  <img src=\"/2025/09/28/buildroot/stage_install/photo/stage_install2.png\"></p>\n<p>  结果正是我们想要的，不仅执行了cmake当中的安装行为，也执行了我们后来追加的安装行为。</p>\n</li>\n</ul>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>实现方式其实是参考 buildroot&#x2F;package&#x2F;pkg-cmake.mk 的代码，你必需知道，我们再向buildroot添加一个包时，会编写mk文件，里面会有很多预定义的宏，最常见的：XX_INSTALL_STAGING_CMDS 和 XX_INSTALL_TARGET_CMDS，两者区别是：XX_INSTALL_STAGING_CMDS是往构建根目录安装一些文件、XX_INSTALL_TARGET_CMDS是往目标（下位机根文件系统）目录安装一些文件。一旦我们的mk文件定义了这两命令，这两命令的默认值就会被覆盖。</p>\n<p>XX_INSTALL_STAGING_CMDS 和 XX_INSTALL_TARGET_CMDS这两命令的默认行为就是使用原项目当中的cmake install代码。我们只需要参考 buildroot&#x2F;package&#x2F;pkg-cmake.mk 文件默认安装命令的实现，然后再此基础上自定义我们的内容就能实现“双install”的效果。</p>\n<p>废话不多说，直接上代码：</p>","more":"<p>Config.in文件实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config BR2_PACKAGE_MYPROJECT</span><br><span class=\"line\">    bool &quot;my project&quot;</span><br><span class=\"line\">    help</span><br><span class=\"line\">        this configuration is used to enable or disable myproject.</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>首先我们不定义XX_INSTALL_STAGING_CMDS命令，查看其默认安装行为：mk文件如下：</p>\n  <figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"comment\"># ONVIF_SRVD_VERSION =</span></span><br><span class=\"line\">MYPROJECT_SITE = <span class=\"variable\">$(TOPDIR)</span>/../external/myproject</span><br><span class=\"line\">MYPROJECT_SITE_METHOD = local</span><br><span class=\"line\">MYPROJECT_DEPENDENCIES = rockchip-mpp</span><br><span class=\"line\">MYPROJECT_INSTALL_STAGING = YES</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">eval</span> $(cmake-package)</span>)</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<p>  编译效果如下：</p>\n<p>  <img src=\"/2025/09/28/buildroot/stage_install/photo/stage_install0.png\"></p>\n<p>  可以看到，默认的编译效果会使用cmake文件当中的安装代码。</p>\n</li>\n<li><p>然后我们尝试定义XX_INSTALL_STAGING_CMDS命令，查看默认行为是否会被覆盖：</p>\n  <figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"comment\"># ONVIF_SRVD_VERSION =</span></span><br><span class=\"line\">MYPROJECT_SITE = <span class=\"variable\">$(TOPDIR)</span>/../external/myproject</span><br><span class=\"line\">MYPROJECT_SITE_METHOD = local</span><br><span class=\"line\">MYPROJECT_DEPENDENCIES = rockchip-mpp</span><br><span class=\"line\">MYPROJECT_INSTALL_STAGING = YES</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">define</span> MYPROJECT_INSTALL_STAGING_CMDS</span><br><span class=\"line\">    echo <span class=\"string\">&quot;ok&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">endef</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">eval</span> $(cmake-package)</span>)</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<p>  效果如下</p>\n<p>  <img src=\"/2025/09/28/buildroot/stage_install/photo/stage_install1.png\"></p>\n<p>  很明显，默认的安装行为已经被覆盖，只执行了我们后来自定义的安装代码，也就是只打印了ok。</p>\n</li>\n<li><p>最后我们在定义XX_INSTALL_STAGING_CMDS命令最前面，参考buildroot&#x2F;package&#x2F;pkg-cmake.mk加上默认安装行为，mk文件如下：</p>\n  <figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"comment\"># ONVIF_SRVD_VERSION =</span></span><br><span class=\"line\">MYPROJECT_SITE = <span class=\"variable\">$(TOPDIR)</span>/../external/myproject</span><br><span class=\"line\">MYPROJECT_SITE_METHOD = local</span><br><span class=\"line\">MYPROJECT_DEPENDENCIES = rockchip-mpp</span><br><span class=\"line\">MYPROJECT_INSTALL_STAGING = YES</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">define</span> MYPROJECT_INSTALL_STAGING_CMDS</span><br><span class=\"line\">    <span class=\"variable\">$(TARGET_MAKE_ENV)</span> <span class=\"variable\">$(MYPROJECT_MAKE_ENV)</span> <span class=\"variable\">$(MYPROJECT_MAKE)</span> <span class=\"variable\">$(MYPROJECT_MAKE_OPTS)</span> <span class=\"variable\">$(MYPROJECT_INSTALL_STAGING_OPTS)</span> -C <span class=\"variable\">$(MYPROJECT_BUILDDIR)</span></span><br><span class=\"line\">    echo <span class=\"string\">&quot;ok&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">endef</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">eval</span> $(cmake-package)</span>)</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<p>  结果如下：</p>\n<p>  <img src=\"/2025/09/28/buildroot/stage_install/photo/stage_install2.png\"></p>\n<p>  结果正是我们想要的，不仅执行了cmake当中的安装行为，也执行了我们后来追加的安装行为。</p>\n</li>\n</ul>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"muduo源码阅读笔记（4、异步日志）","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\nMuduo的异步日志支持：异步日志输出，日志回滚。本文重点在异步日志输出，主要集中在AsyncLogging.cc文件的实现，至于日志回滚，属于文件IO管理范畴，不会细讲，这部分的代码主要集中在LogFile.cc、FileUtil.cc文件，代码量也不大，感兴趣的读者可以自行深入阅读。\n\n## 正文\n\nMuduo异步日志的实现是典型的多对一的，多生产者，单消费者模型。简单来说就是程序中的多个线程（前台线程）产生日志，然后由一个日志同步线程（后台线程）消化日志，将日志同步给磁盘。\n\n**术语纠正**\n\n阅读过Muduo源码的朋友都应该知道，Muduo实现的异步日志是**双缓冲**的，但是我阅读过很多Muduo有关异步日志的博客，有的人说Muduo里面**双缓冲**指的是currentBuffer_和nextBuffer_两块缓存，也有人说，Muduo的双缓冲是指前台的缓存和后台线程的缓存。\n\n**查阅资料得知：**\n\n**定义：** 双缓冲技术是一种通过使用两个缓冲区（buffers）来实现某种功能的技术。**通常，这两个缓冲区会交替使用，一个用于写入数据，另一个用于读取数据，或者在某种操作完成后进行交换。**\n\n在不同的领域中，双缓冲技术有不同的应用，以下是一些常见的应用场景：\n\n1. 图形学： 在图形学中，双缓冲技术通常用于解决图像闪烁的问题。一个缓冲区用于显示当前图像，而另一个缓冲区则用于在**后台**绘制下一帧图像。当绘制完成后，两个缓冲区进行交换，确保只显示完整的图像，从而避免了闪烁。\n<!-- more -->\n\n2. 计算机图形渲染： 在图形渲染中，双缓冲技术可以用于提高性能。例如，使用一个缓冲区进行渲染，同时在另一个缓冲区进行**后台**计算或处理，然后交换缓冲区。这样可以实现更平滑的图形渲染效果。\n\n3. 日志系统： 在日志系统中，双缓冲技术可以用于异步日志的实现。一个缓冲区用于应用程序写入日志，而另一个缓冲区用于异步写入磁盘。当一个缓冲区满了之后，可以交换缓冲区，实现高效的异步日志记录。\n\n4. 网络传输： 在网络传输中，双缓冲技术可以用于提高数据传输的效率。一个缓冲区用于发送数据，而另一个缓冲区用于填充新的数据。这样，在一个缓冲区发送的同时，可以在另一个缓冲区准备下一批数据。\n\n**综上，Muduo异步日志的双缓冲就是指的前台的缓存和后台线程的缓存。**\n\n## 实现\n\n**提供的接口：**\n\n```cpp\nclass AsyncLogging : noncopyable{\npublic:\n\n    AsyncLogging(const string& basename,\n                off_t rollSize,\n                int flushInterval = 3);\n\n    ~AsyncLogging(){\n        if (running_){\n            stop();\n        }\n    }\n\n    void append(const char* logline, int len);\n\n    void start(){\n        running_ = true;\n        thread_.start();    // 启动线程\n        latch_.wait();  // 等待启动\n    }\n\n    void stop() NO_THREAD_SAFETY_ANALYSIS{\n        running_ = false;\n        cond_.notify();\n        thread_.join();\n    }\n\nprivate:\n\n    void threadFunc();\n\n    typedef muduo::detail::FixedBuffer<muduo::detail::kLargeBuffer> Buffer;   // 4M的缓存\n    typedef std::vector<std::unique_ptr<Buffer>> BufferVector;  // 使用独占智能指针管理\n    typedef BufferVector::value_type BufferPtr;\n\n    const int flushInterval_; // 将日志同步到磁盘上的间隔\n    std::atomic<bool> running_; // 后台同步线程正在运行？\n    const string basename_; // 文件前缀名\n    const off_t rollSize_;  // 日志文件回滚大小\n    muduo::Thread thread_;  // 后台日志同步线程\n    muduo::CountDownLatch latch_; // 确保同步回调函数跑起来了\n    muduo::MutexLock mutex_;\n    muduo::Condition cond_ GUARDED_BY(mutex_);  // 等待有至少一个Buffer满了\n    BufferPtr currentBuffer_ GUARDED_BY(mutex_);  // 接收日志的buff\n    BufferPtr nextBuffer_ GUARDED_BY(mutex_); // 替补的buff，为减少分配内存的开销\n    BufferVector buffers_ GUARDED_BY(mutex_); // 满载日志的buff队列\n};\n```\n\n**异步日志架构图：**\n\n简单画了一下Muduo异步日志的架构图，忽略了currentBuffer_、nextBuffer_等细节。如图所示。\n\n![异步日志架构图](./AsyncLogging/photo/AsynLogging.drawio.png)\n\n**实现的伪代码：**\n\n```cpp\n/*\n* 构造函数就省略了，主要做的事：\n* 1. 将AsyncLogging::threadFunc作为后台线程的回调。\n* 2. 构造currentBuffer_和nextBuffer_。\n*/\n\n// ...\n\nvoid AsyncLogging::append(const char* logline, int len){\n    muduo::MutexLockGuard lock(mutex_); // 持锁\n    if (currentBuffer_->avail() > len){  //当前缓存没满\n        currentBuffer_->append(logline, len); // 先写到前台缓存\n    }else{ //满了\n        buffers_.push_back(std::move(currentBuffer_));  // 放到缓存队列\n\n        if (nextBuffer_){  // 优先考虑替补缓存，没有分配内存的开销，性能更高。\n            currentBuffer_ = std::move(nextBuffer_);\n        }else { // 最坏的情况，替补缓存也用光了，只能去申请内存。\n            currentBuffer_.reset(new Buffer); // Rarely happens\n        }\n        currentBuffer_->append(logline, len);\n        cond_.notify(); // 提醒一下后台线程，前台缓存队列非空。\n    }\n}\n\nvoid AsyncLogging::threadFunc(){\n    assert(running_ == true);\n    latch_.countDown();\n    LogFile output(basename_, rollSize_, false);  // 日志文件管理类，实现了日志回滚。\n    BufferPtr newBuffer1(new Buffer); // 提前缓存两块buff减少内存开销\n    BufferPtr newBuffer2(new Buffer);\n    newBuffer1->bzero();\n    newBuffer2->bzero();\n    BufferVector buffersToWrite;\n    buffersToWrite.reserve(16);\n    while (running_){\n        // 后台线程的buff在向前台buff置换日志前，保证后台线程的buff是被清空的。\n        assert(newBuffer1 && newBuffer1->length() == 0);\n        assert(newBuffer2 && newBuffer2->length() == 0);\n        assert(buffersToWrite.empty());\n\n        {\n            muduo::MutexLockGuard lock(mutex_);\n            if (buffers_.empty()){  // unusual usage!\n                /*\n                * 1. 因前台日志队列非空而被唤醒。（AsyncLogging::append）\n                * 2. 超时。\n                */\n                cond_.waitForSeconds(flushInterval_);\n            }\n            // 不管currentBuffer_中是否有日志，都归入前台的日志队列。可以保证所有日志都归入到了前台的日志队列。\n            buffers_.push_back(std::move(currentBuffer_)); \n            currentBuffer_ = std::move(newBuffer1); // 补充currentBuffer_\n            buffersToWrite.swap(buffers_);  // 将前台的日志队列，置换到后台的日志队列，置换后前台的日志队列被清空\n            if (!nextBuffer_){ // 前台的nextBuffer_也被用了。\n                // nextBuffer_也需要补充\n                nextBuffer_ = std::move(newBuffer2);\n            }\n        }\n\n        assert(!buffersToWrite.empty());  // 至少为1\n\n        if (buffersToWrite.size() > 25){ // 避免日志洪流\n            char buf[256];\n            snprintf(buf, sizeof buf, \"Dropped log messages at %s, %zd larger buffers\\n\",\n                    Timestamp::now().toFormattedString().c_str(),\n                    buffersToWrite.size()-2);\n            fputs(buf, stderr);\n            output.append(buf, static_cast<int>(strlen(buf)));\n            buffersToWrite.erase(buffersToWrite.begin()+2, buffersToWrite.end());\n        }\n\n        for (const auto& buffer : buffersToWrite){ // 日志落盘\n            // FIXME: use unbuffered stdio FILE ? or use ::writev ?\n            output.append(buffer->data(), buffer->length());\n        }\n\n        if (buffersToWrite.size() > 2){ // 保留两块buff，填充newBuffer1、newBuffer2\n            // drop non-bzero-ed buffers, avoid trashing\n            buffersToWrite.resize(2);\n        }\n\n        if (!newBuffer1){\n            assert(!buffersToWrite.empty());\n            newBuffer1 = std::move(buffersToWrite.back());\n            buffersToWrite.pop_back();\n            newBuffer1->reset();\n        }\n\n        if (!newBuffer2){\n            assert(!buffersToWrite.empty());\n            newBuffer2 = std::move(buffersToWrite.back());\n            buffersToWrite.pop_back();\n            newBuffer2->reset();\n        }\n\n        buffersToWrite.clear(); // 清空后台日志队列。\n        output.flush(); // 文件同步。\n    }\n    output.flush();\n}\n\n```\n\n**套路总结**\n\n这里是一份经典的降低锁的粒度的套路模板，也是Muduo异步日志高效的核心：\n\n```cpp\n// 临界区外面处理临界区的数据\n\n// 定义临界区的数据结构\nstruct CriticalData {\n    // 数据成员...\n};\n\nvoid processCriticalData(const CriticalData& data) {\n    // 在临界区外面处理数据\n    // 可以进行计算、拷贝、异步处理等操作\n}\n\n// 在临界区内使用局部变量进行处理\nvoid criticalSection(const CriticalData& sharedData) {\n    CriticalData localCopy\n    // 进入临界区\n    // ...\n\n    // 拷贝数据到局部变量\n    localCopy.swap(sharedData);\n\n    // 离开临界区\n    // ...\n\n    // 在临界区外面处理局部变量\n    processCriticalData(localCopy);\n}\n```\n\n## 细节明细：\n\n**疑问：**\n\nMuduo的异步日志为什么日志过多就删除一些日志？\n\n**解答：**\n\n在Muduo库的异步日志系统中，删除一些日志的策略可能是为了防止日志积累过多导致系统资源消耗过大，以及为了保持日志的存储大小在可控范围内。具体的删除策略可能会根据应用程序的需求和性能考虑而定，通常包括以下一些原因：\n\n1. 资源限制： 大量的日志可能会占用大量磁盘空间，特别是在长时间运行的系统中。删除一些日志可以确保系统的磁盘空间不被过多消耗，避免磁盘空间不足的问题。\n\n2. 性能考虑： 当日志量非常大时，写入和处理大量日志会对系统性能产生影响。删除一些日志可以降低写入和处理的负担，确保系统的性能得到维持。\n\n3. 避免日志洪流： 在某些情况下，产生大量的日志可能并不是问题的根本原因，而是问题的表征。删除一些日志可以帮助集中关注真正的问题，而不被大量的无关日志所干扰。\n\n**疑问：**\n\nMuduo异步日志中nextBuffer_是不是冗余了？currentBuffer_满了的话，不是可以再new一个Buffer吗？为什么要额外提供一个nextBuffer_？\n\n**解答：**\n\n 预先分配并循环使用多个缓冲区（包括 nextBuffer_）可以减少内存分配的频率。如果只使用一个 currentBuffer_，每次都需要在 currentBuffer_ 满了之后重新分配一个新的缓冲区，这可能导致频繁的内存分配和释放操作，影响性能。\n\n 综上提供nextBuffer_主要是为了减少内存分配次数\n\n---\n\n**本章完结**","source":"_posts/muduo/AsyncLogging.md","raw":"---\ntitle: muduo源码阅读笔记（4、异步日志）\ndate: 2024-11-02 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\nMuduo的异步日志支持：异步日志输出，日志回滚。本文重点在异步日志输出，主要集中在AsyncLogging.cc文件的实现，至于日志回滚，属于文件IO管理范畴，不会细讲，这部分的代码主要集中在LogFile.cc、FileUtil.cc文件，代码量也不大，感兴趣的读者可以自行深入阅读。\n\n## 正文\n\nMuduo异步日志的实现是典型的多对一的，多生产者，单消费者模型。简单来说就是程序中的多个线程（前台线程）产生日志，然后由一个日志同步线程（后台线程）消化日志，将日志同步给磁盘。\n\n**术语纠正**\n\n阅读过Muduo源码的朋友都应该知道，Muduo实现的异步日志是**双缓冲**的，但是我阅读过很多Muduo有关异步日志的博客，有的人说Muduo里面**双缓冲**指的是currentBuffer_和nextBuffer_两块缓存，也有人说，Muduo的双缓冲是指前台的缓存和后台线程的缓存。\n\n**查阅资料得知：**\n\n**定义：** 双缓冲技术是一种通过使用两个缓冲区（buffers）来实现某种功能的技术。**通常，这两个缓冲区会交替使用，一个用于写入数据，另一个用于读取数据，或者在某种操作完成后进行交换。**\n\n在不同的领域中，双缓冲技术有不同的应用，以下是一些常见的应用场景：\n\n1. 图形学： 在图形学中，双缓冲技术通常用于解决图像闪烁的问题。一个缓冲区用于显示当前图像，而另一个缓冲区则用于在**后台**绘制下一帧图像。当绘制完成后，两个缓冲区进行交换，确保只显示完整的图像，从而避免了闪烁。\n<!-- more -->\n\n2. 计算机图形渲染： 在图形渲染中，双缓冲技术可以用于提高性能。例如，使用一个缓冲区进行渲染，同时在另一个缓冲区进行**后台**计算或处理，然后交换缓冲区。这样可以实现更平滑的图形渲染效果。\n\n3. 日志系统： 在日志系统中，双缓冲技术可以用于异步日志的实现。一个缓冲区用于应用程序写入日志，而另一个缓冲区用于异步写入磁盘。当一个缓冲区满了之后，可以交换缓冲区，实现高效的异步日志记录。\n\n4. 网络传输： 在网络传输中，双缓冲技术可以用于提高数据传输的效率。一个缓冲区用于发送数据，而另一个缓冲区用于填充新的数据。这样，在一个缓冲区发送的同时，可以在另一个缓冲区准备下一批数据。\n\n**综上，Muduo异步日志的双缓冲就是指的前台的缓存和后台线程的缓存。**\n\n## 实现\n\n**提供的接口：**\n\n```cpp\nclass AsyncLogging : noncopyable{\npublic:\n\n    AsyncLogging(const string& basename,\n                off_t rollSize,\n                int flushInterval = 3);\n\n    ~AsyncLogging(){\n        if (running_){\n            stop();\n        }\n    }\n\n    void append(const char* logline, int len);\n\n    void start(){\n        running_ = true;\n        thread_.start();    // 启动线程\n        latch_.wait();  // 等待启动\n    }\n\n    void stop() NO_THREAD_SAFETY_ANALYSIS{\n        running_ = false;\n        cond_.notify();\n        thread_.join();\n    }\n\nprivate:\n\n    void threadFunc();\n\n    typedef muduo::detail::FixedBuffer<muduo::detail::kLargeBuffer> Buffer;   // 4M的缓存\n    typedef std::vector<std::unique_ptr<Buffer>> BufferVector;  // 使用独占智能指针管理\n    typedef BufferVector::value_type BufferPtr;\n\n    const int flushInterval_; // 将日志同步到磁盘上的间隔\n    std::atomic<bool> running_; // 后台同步线程正在运行？\n    const string basename_; // 文件前缀名\n    const off_t rollSize_;  // 日志文件回滚大小\n    muduo::Thread thread_;  // 后台日志同步线程\n    muduo::CountDownLatch latch_; // 确保同步回调函数跑起来了\n    muduo::MutexLock mutex_;\n    muduo::Condition cond_ GUARDED_BY(mutex_);  // 等待有至少一个Buffer满了\n    BufferPtr currentBuffer_ GUARDED_BY(mutex_);  // 接收日志的buff\n    BufferPtr nextBuffer_ GUARDED_BY(mutex_); // 替补的buff，为减少分配内存的开销\n    BufferVector buffers_ GUARDED_BY(mutex_); // 满载日志的buff队列\n};\n```\n\n**异步日志架构图：**\n\n简单画了一下Muduo异步日志的架构图，忽略了currentBuffer_、nextBuffer_等细节。如图所示。\n\n![异步日志架构图](./AsyncLogging/photo/AsynLogging.drawio.png)\n\n**实现的伪代码：**\n\n```cpp\n/*\n* 构造函数就省略了，主要做的事：\n* 1. 将AsyncLogging::threadFunc作为后台线程的回调。\n* 2. 构造currentBuffer_和nextBuffer_。\n*/\n\n// ...\n\nvoid AsyncLogging::append(const char* logline, int len){\n    muduo::MutexLockGuard lock(mutex_); // 持锁\n    if (currentBuffer_->avail() > len){  //当前缓存没满\n        currentBuffer_->append(logline, len); // 先写到前台缓存\n    }else{ //满了\n        buffers_.push_back(std::move(currentBuffer_));  // 放到缓存队列\n\n        if (nextBuffer_){  // 优先考虑替补缓存，没有分配内存的开销，性能更高。\n            currentBuffer_ = std::move(nextBuffer_);\n        }else { // 最坏的情况，替补缓存也用光了，只能去申请内存。\n            currentBuffer_.reset(new Buffer); // Rarely happens\n        }\n        currentBuffer_->append(logline, len);\n        cond_.notify(); // 提醒一下后台线程，前台缓存队列非空。\n    }\n}\n\nvoid AsyncLogging::threadFunc(){\n    assert(running_ == true);\n    latch_.countDown();\n    LogFile output(basename_, rollSize_, false);  // 日志文件管理类，实现了日志回滚。\n    BufferPtr newBuffer1(new Buffer); // 提前缓存两块buff减少内存开销\n    BufferPtr newBuffer2(new Buffer);\n    newBuffer1->bzero();\n    newBuffer2->bzero();\n    BufferVector buffersToWrite;\n    buffersToWrite.reserve(16);\n    while (running_){\n        // 后台线程的buff在向前台buff置换日志前，保证后台线程的buff是被清空的。\n        assert(newBuffer1 && newBuffer1->length() == 0);\n        assert(newBuffer2 && newBuffer2->length() == 0);\n        assert(buffersToWrite.empty());\n\n        {\n            muduo::MutexLockGuard lock(mutex_);\n            if (buffers_.empty()){  // unusual usage!\n                /*\n                * 1. 因前台日志队列非空而被唤醒。（AsyncLogging::append）\n                * 2. 超时。\n                */\n                cond_.waitForSeconds(flushInterval_);\n            }\n            // 不管currentBuffer_中是否有日志，都归入前台的日志队列。可以保证所有日志都归入到了前台的日志队列。\n            buffers_.push_back(std::move(currentBuffer_)); \n            currentBuffer_ = std::move(newBuffer1); // 补充currentBuffer_\n            buffersToWrite.swap(buffers_);  // 将前台的日志队列，置换到后台的日志队列，置换后前台的日志队列被清空\n            if (!nextBuffer_){ // 前台的nextBuffer_也被用了。\n                // nextBuffer_也需要补充\n                nextBuffer_ = std::move(newBuffer2);\n            }\n        }\n\n        assert(!buffersToWrite.empty());  // 至少为1\n\n        if (buffersToWrite.size() > 25){ // 避免日志洪流\n            char buf[256];\n            snprintf(buf, sizeof buf, \"Dropped log messages at %s, %zd larger buffers\\n\",\n                    Timestamp::now().toFormattedString().c_str(),\n                    buffersToWrite.size()-2);\n            fputs(buf, stderr);\n            output.append(buf, static_cast<int>(strlen(buf)));\n            buffersToWrite.erase(buffersToWrite.begin()+2, buffersToWrite.end());\n        }\n\n        for (const auto& buffer : buffersToWrite){ // 日志落盘\n            // FIXME: use unbuffered stdio FILE ? or use ::writev ?\n            output.append(buffer->data(), buffer->length());\n        }\n\n        if (buffersToWrite.size() > 2){ // 保留两块buff，填充newBuffer1、newBuffer2\n            // drop non-bzero-ed buffers, avoid trashing\n            buffersToWrite.resize(2);\n        }\n\n        if (!newBuffer1){\n            assert(!buffersToWrite.empty());\n            newBuffer1 = std::move(buffersToWrite.back());\n            buffersToWrite.pop_back();\n            newBuffer1->reset();\n        }\n\n        if (!newBuffer2){\n            assert(!buffersToWrite.empty());\n            newBuffer2 = std::move(buffersToWrite.back());\n            buffersToWrite.pop_back();\n            newBuffer2->reset();\n        }\n\n        buffersToWrite.clear(); // 清空后台日志队列。\n        output.flush(); // 文件同步。\n    }\n    output.flush();\n}\n\n```\n\n**套路总结**\n\n这里是一份经典的降低锁的粒度的套路模板，也是Muduo异步日志高效的核心：\n\n```cpp\n// 临界区外面处理临界区的数据\n\n// 定义临界区的数据结构\nstruct CriticalData {\n    // 数据成员...\n};\n\nvoid processCriticalData(const CriticalData& data) {\n    // 在临界区外面处理数据\n    // 可以进行计算、拷贝、异步处理等操作\n}\n\n// 在临界区内使用局部变量进行处理\nvoid criticalSection(const CriticalData& sharedData) {\n    CriticalData localCopy\n    // 进入临界区\n    // ...\n\n    // 拷贝数据到局部变量\n    localCopy.swap(sharedData);\n\n    // 离开临界区\n    // ...\n\n    // 在临界区外面处理局部变量\n    processCriticalData(localCopy);\n}\n```\n\n## 细节明细：\n\n**疑问：**\n\nMuduo的异步日志为什么日志过多就删除一些日志？\n\n**解答：**\n\n在Muduo库的异步日志系统中，删除一些日志的策略可能是为了防止日志积累过多导致系统资源消耗过大，以及为了保持日志的存储大小在可控范围内。具体的删除策略可能会根据应用程序的需求和性能考虑而定，通常包括以下一些原因：\n\n1. 资源限制： 大量的日志可能会占用大量磁盘空间，特别是在长时间运行的系统中。删除一些日志可以确保系统的磁盘空间不被过多消耗，避免磁盘空间不足的问题。\n\n2. 性能考虑： 当日志量非常大时，写入和处理大量日志会对系统性能产生影响。删除一些日志可以降低写入和处理的负担，确保系统的性能得到维持。\n\n3. 避免日志洪流： 在某些情况下，产生大量的日志可能并不是问题的根本原因，而是问题的表征。删除一些日志可以帮助集中关注真正的问题，而不被大量的无关日志所干扰。\n\n**疑问：**\n\nMuduo异步日志中nextBuffer_是不是冗余了？currentBuffer_满了的话，不是可以再new一个Buffer吗？为什么要额外提供一个nextBuffer_？\n\n**解答：**\n\n 预先分配并循环使用多个缓冲区（包括 nextBuffer_）可以减少内存分配的频率。如果只使用一个 currentBuffer_，每次都需要在 currentBuffer_ 满了之后重新分配一个新的缓冲区，这可能导致频繁的内存分配和释放操作，影响性能。\n\n 综上提供nextBuffer_主要是为了减少内存分配次数\n\n---\n\n**本章完结**","slug":"muduo/AsyncLogging","published":1,"updated":"2025-09-28T16:06:43.125Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9k0003q8wsb3i18lsz","content":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>Muduo的异步日志支持：异步日志输出，日志回滚。本文重点在异步日志输出，主要集中在AsyncLogging.cc文件的实现，至于日志回滚，属于文件IO管理范畴，不会细讲，这部分的代码主要集中在LogFile.cc、FileUtil.cc文件，代码量也不大，感兴趣的读者可以自行深入阅读。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>Muduo异步日志的实现是典型的多对一的，多生产者，单消费者模型。简单来说就是程序中的多个线程（前台线程）产生日志，然后由一个日志同步线程（后台线程）消化日志，将日志同步给磁盘。</p>\n<p><strong>术语纠正</strong></p>\n<p>阅读过Muduo源码的朋友都应该知道，Muduo实现的异步日志是<strong>双缓冲</strong>的，但是我阅读过很多Muduo有关异步日志的博客，有的人说Muduo里面<strong>双缓冲</strong>指的是currentBuffer_和nextBuffer_两块缓存，也有人说，Muduo的双缓冲是指前台的缓存和后台线程的缓存。</p>\n<p><strong>查阅资料得知：</strong></p>\n<p><strong>定义：</strong> 双缓冲技术是一种通过使用两个缓冲区（buffers）来实现某种功能的技术。<strong>通常，这两个缓冲区会交替使用，一个用于写入数据，另一个用于读取数据，或者在某种操作完成后进行交换。</strong></p>\n<p>在不同的领域中，双缓冲技术有不同的应用，以下是一些常见的应用场景：</p>\n<ol>\n<li><p>图形学： 在图形学中，双缓冲技术通常用于解决图像闪烁的问题。一个缓冲区用于显示当前图像，而另一个缓冲区则用于在<strong>后台</strong>绘制下一帧图像。当绘制完成后，两个缓冲区进行交换，确保只显示完整的图像，从而避免了闪烁。</p>\n<span id=\"more\"></span>\n</li>\n<li><p>计算机图形渲染： 在图形渲染中，双缓冲技术可以用于提高性能。例如，使用一个缓冲区进行渲染，同时在另一个缓冲区进行<strong>后台</strong>计算或处理，然后交换缓冲区。这样可以实现更平滑的图形渲染效果。</p>\n</li>\n<li><p>日志系统： 在日志系统中，双缓冲技术可以用于异步日志的实现。一个缓冲区用于应用程序写入日志，而另一个缓冲区用于异步写入磁盘。当一个缓冲区满了之后，可以交换缓冲区，实现高效的异步日志记录。</p>\n</li>\n<li><p>网络传输： 在网络传输中，双缓冲技术可以用于提高数据传输的效率。一个缓冲区用于发送数据，而另一个缓冲区用于填充新的数据。这样，在一个缓冲区发送的同时，可以在另一个缓冲区准备下一批数据。</p>\n</li>\n</ol>\n<p><strong>综上，Muduo异步日志的双缓冲就是指的前台的缓存和后台线程的缓存。</strong></p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p><strong>提供的接口：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AsyncLogging</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">AsyncLogging</span>(<span class=\"type\">const</span> string&amp; basename,</span><br><span class=\"line\">                <span class=\"type\">off_t</span> rollSize,</span><br><span class=\"line\">                <span class=\"type\">int</span> flushInterval = <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">AsyncLogging</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (running_)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">stop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* logline, <span class=\"type\">int</span> len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        running_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        thread_.<span class=\"built_in\">start</span>();    <span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">        latch_.<span class=\"built_in\">wait</span>();  <span class=\"comment\">// 等待启动</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> NO_THREAD_SAFETY_ANALYSIS</span>&#123;</span><br><span class=\"line\">        running_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        cond_.<span class=\"built_in\">notify</span>();</span><br><span class=\"line\">        thread_.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">threadFunc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> muduo::detail::FixedBuffer&lt;muduo::detail::kLargeBuffer&gt; Buffer;   <span class=\"comment\">// 4M的缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;std::unique_ptr&lt;Buffer&gt;&gt; BufferVector;  <span class=\"comment\">// 使用独占智能指针管理</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> BufferVector::value_type BufferPtr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> flushInterval_; <span class=\"comment\">// 将日志同步到磁盘上的间隔</span></span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">bool</span>&gt; running_; <span class=\"comment\">// 后台同步线程正在运行？</span></span><br><span class=\"line\">    <span class=\"type\">const</span> string basename_; <span class=\"comment\">// 文件前缀名</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">off_t</span> rollSize_;  <span class=\"comment\">// 日志文件回滚大小</span></span><br><span class=\"line\">    muduo::Thread thread_;  <span class=\"comment\">// 后台日志同步线程</span></span><br><span class=\"line\">    muduo::CountDownLatch latch_; <span class=\"comment\">// 确保同步回调函数跑起来了</span></span><br><span class=\"line\">    muduo::MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">muduo::Condition cond_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// 等待有至少一个Buffer满了</span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr currentBuffer_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// 接收日志的buff</span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr nextBuffer_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// 替补的buff，为减少分配内存的开销</span></span><br><span class=\"line\">    <span class=\"function\">BufferVector buffers_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// 满载日志的buff队列</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>异步日志架构图：</strong></p>\n<p>简单画了一下Muduo异步日志的架构图，忽略了currentBuffer_、nextBuffer_等细节。如图所示。</p>\n<p><img src=\"/2024/11/02/muduo/AsyncLogging/photo/AsynLogging.drawio.png\" alt=\"异步日志架构图\"></p>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 构造函数就省略了，主要做的事：</span></span><br><span class=\"line\"><span class=\"comment\">* 1. 将AsyncLogging::threadFunc作为后台线程的回调。</span></span><br><span class=\"line\"><span class=\"comment\">* 2. 构造currentBuffer_和nextBuffer_。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AsyncLogging::append</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* logline, <span class=\"type\">int</span> len)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">muduo::MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// 持锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentBuffer_-&gt;<span class=\"built_in\">avail</span>() &gt; len)&#123;  <span class=\"comment\">//当前缓存没满</span></span><br><span class=\"line\">        currentBuffer_-&gt;<span class=\"built_in\">append</span>(logline, len); <span class=\"comment\">// 先写到前台缓存</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">//满了</span></span><br><span class=\"line\">        buffers_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(currentBuffer_));  <span class=\"comment\">// 放到缓存队列</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextBuffer_)&#123;  <span class=\"comment\">// 优先考虑替补缓存，没有分配内存的开销，性能更高。</span></span><br><span class=\"line\">            currentBuffer_ = std::<span class=\"built_in\">move</span>(nextBuffer_);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 最坏的情况，替补缓存也用光了，只能去申请内存。</span></span><br><span class=\"line\">            currentBuffer_.<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> Buffer); <span class=\"comment\">// Rarely happens</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentBuffer_-&gt;<span class=\"built_in\">append</span>(logline, len);</span><br><span class=\"line\">        cond_.<span class=\"built_in\">notify</span>(); <span class=\"comment\">// 提醒一下后台线程，前台缓存队列非空。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AsyncLogging::threadFunc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(running_ == <span class=\"literal\">true</span>);</span><br><span class=\"line\">    latch_.<span class=\"built_in\">countDown</span>();</span><br><span class=\"line\">    <span class=\"function\">LogFile <span class=\"title\">output</span><span class=\"params\">(basename_, rollSize_, <span class=\"literal\">false</span>)</span></span>;  <span class=\"comment\">// 日志文件管理类，实现了日志回滚。</span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr <span class=\"title\">newBuffer1</span><span class=\"params\">(<span class=\"keyword\">new</span> Buffer)</span></span>; <span class=\"comment\">// 提前缓存两块buff减少内存开销</span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr <span class=\"title\">newBuffer2</span><span class=\"params\">(<span class=\"keyword\">new</span> Buffer)</span></span>;</span><br><span class=\"line\">    newBuffer1-&gt;<span class=\"built_in\">bzero</span>();</span><br><span class=\"line\">    newBuffer2-&gt;<span class=\"built_in\">bzero</span>();</span><br><span class=\"line\">    BufferVector buffersToWrite;</span><br><span class=\"line\">    buffersToWrite.<span class=\"built_in\">reserve</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (running_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 后台线程的buff在向前台buff置换日志前，保证后台线程的buff是被清空的。</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(newBuffer1 &amp;&amp; newBuffer1-&gt;<span class=\"built_in\">length</span>() == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(newBuffer2 &amp;&amp; newBuffer2-&gt;<span class=\"built_in\">length</span>() == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(buffersToWrite.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"function\">muduo::MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (buffers_.<span class=\"built_in\">empty</span>())&#123;  <span class=\"comment\">// unusual usage!</span></span><br><span class=\"line\">                <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                * 1. 因前台日志队列非空而被唤醒。（AsyncLogging::append）</span></span><br><span class=\"line\"><span class=\"comment\">                * 2. 超时。</span></span><br><span class=\"line\"><span class=\"comment\">                */</span></span><br><span class=\"line\">                cond_.<span class=\"built_in\">waitForSeconds</span>(flushInterval_);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 不管currentBuffer_中是否有日志，都归入前台的日志队列。可以保证所有日志都归入到了前台的日志队列。</span></span><br><span class=\"line\">            buffers_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(currentBuffer_)); </span><br><span class=\"line\">            currentBuffer_ = std::<span class=\"built_in\">move</span>(newBuffer1); <span class=\"comment\">// 补充currentBuffer_</span></span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">swap</span>(buffers_);  <span class=\"comment\">// 将前台的日志队列，置换到后台的日志队列，置换后前台的日志队列被清空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!nextBuffer_)&#123; <span class=\"comment\">// 前台的nextBuffer_也被用了。</span></span><br><span class=\"line\">                <span class=\"comment\">// nextBuffer_也需要补充</span></span><br><span class=\"line\">                nextBuffer_ = std::<span class=\"built_in\">move</span>(newBuffer2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(!buffersToWrite.<span class=\"built_in\">empty</span>());  <span class=\"comment\">// 至少为1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buffersToWrite.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">25</span>)&#123; <span class=\"comment\">// 避免日志洪流</span></span><br><span class=\"line\">            <span class=\"type\">char</span> buf[<span class=\"number\">256</span>];</span><br><span class=\"line\">            <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;Dropped log messages at %s, %zd larger buffers\\n&quot;</span>,</span><br><span class=\"line\">                    Timestamp::<span class=\"built_in\">now</span>().<span class=\"built_in\">toFormattedString</span>().<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">                    buffersToWrite.<span class=\"built_in\">size</span>()<span class=\"number\">-2</span>);</span><br><span class=\"line\">            <span class=\"built_in\">fputs</span>(buf, stderr);</span><br><span class=\"line\">            output.<span class=\"built_in\">append</span>(buf, <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"built_in\">strlen</span>(buf)));</span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">erase</span>(buffersToWrite.<span class=\"built_in\">begin</span>()<span class=\"number\">+2</span>, buffersToWrite.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; buffer : buffersToWrite)&#123; <span class=\"comment\">// 日志落盘</span></span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use unbuffered stdio FILE ? or use ::writev ?</span></span><br><span class=\"line\">            output.<span class=\"built_in\">append</span>(buffer-&gt;<span class=\"built_in\">data</span>(), buffer-&gt;<span class=\"built_in\">length</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buffersToWrite.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">2</span>)&#123; <span class=\"comment\">// 保留两块buff，填充newBuffer1、newBuffer2</span></span><br><span class=\"line\">            <span class=\"comment\">// drop non-bzero-ed buffers, avoid trashing</span></span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">resize</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!newBuffer1)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(!buffersToWrite.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\">            newBuffer1 = std::<span class=\"built_in\">move</span>(buffersToWrite.<span class=\"built_in\">back</span>());</span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            newBuffer1-&gt;<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!newBuffer2)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(!buffersToWrite.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\">            newBuffer2 = std::<span class=\"built_in\">move</span>(buffersToWrite.<span class=\"built_in\">back</span>());</span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            newBuffer2-&gt;<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        buffersToWrite.<span class=\"built_in\">clear</span>(); <span class=\"comment\">// 清空后台日志队列。</span></span><br><span class=\"line\">        output.<span class=\"built_in\">flush</span>(); <span class=\"comment\">// 文件同步。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    output.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>套路总结</strong></p>\n<p>这里是一份经典的降低锁的粒度的套路模板，也是Muduo异步日志高效的核心：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 临界区外面处理临界区的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义临界区的数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CriticalData</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 数据成员...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processCriticalData</span><span class=\"params\">(<span class=\"type\">const</span> CriticalData&amp; data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在临界区外面处理数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 可以进行计算、拷贝、异步处理等操作</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在临界区内使用局部变量进行处理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">criticalSection</span><span class=\"params\">(<span class=\"type\">const</span> CriticalData&amp; sharedData)</span> </span>&#123;</span><br><span class=\"line\">    CriticalData localCopy</span><br><span class=\"line\">    <span class=\"comment\">// 进入临界区</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拷贝数据到局部变量</span></span><br><span class=\"line\">    localCopy.<span class=\"built_in\">swap</span>(sharedData);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 离开临界区</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在临界区外面处理局部变量</span></span><br><span class=\"line\">    <span class=\"built_in\">processCriticalData</span>(localCopy);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"细节明细：\"><a href=\"#细节明细：\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h2><p><strong>疑问：</strong></p>\n<p>Muduo的异步日志为什么日志过多就删除一些日志？</p>\n<p><strong>解答：</strong></p>\n<p>在Muduo库的异步日志系统中，删除一些日志的策略可能是为了防止日志积累过多导致系统资源消耗过大，以及为了保持日志的存储大小在可控范围内。具体的删除策略可能会根据应用程序的需求和性能考虑而定，通常包括以下一些原因：</p>\n<ol>\n<li><p>资源限制： 大量的日志可能会占用大量磁盘空间，特别是在长时间运行的系统中。删除一些日志可以确保系统的磁盘空间不被过多消耗，避免磁盘空间不足的问题。</p>\n</li>\n<li><p>性能考虑： 当日志量非常大时，写入和处理大量日志会对系统性能产生影响。删除一些日志可以降低写入和处理的负担，确保系统的性能得到维持。</p>\n</li>\n<li><p>避免日志洪流： 在某些情况下，产生大量的日志可能并不是问题的根本原因，而是问题的表征。删除一些日志可以帮助集中关注真正的问题，而不被大量的无关日志所干扰。</p>\n</li>\n</ol>\n<p><strong>疑问：</strong></p>\n<p>Muduo异步日志中nextBuffer_是不是冗余了？currentBuffer_满了的话，不是可以再new一个Buffer吗？为什么要额外提供一个nextBuffer_？</p>\n<p><strong>解答：</strong></p>\n<p> 预先分配并循环使用多个缓冲区（包括 nextBuffer_）可以减少内存分配的频率。如果只使用一个 currentBuffer_，每次都需要在 currentBuffer_ 满了之后重新分配一个新的缓冲区，这可能导致频繁的内存分配和释放操作，影响性能。</p>\n<p> 综上提供nextBuffer_主要是为了减少内存分配次数</p>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>Muduo的异步日志支持：异步日志输出，日志回滚。本文重点在异步日志输出，主要集中在AsyncLogging.cc文件的实现，至于日志回滚，属于文件IO管理范畴，不会细讲，这部分的代码主要集中在LogFile.cc、FileUtil.cc文件，代码量也不大，感兴趣的读者可以自行深入阅读。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>Muduo异步日志的实现是典型的多对一的，多生产者，单消费者模型。简单来说就是程序中的多个线程（前台线程）产生日志，然后由一个日志同步线程（后台线程）消化日志，将日志同步给磁盘。</p>\n<p><strong>术语纠正</strong></p>\n<p>阅读过Muduo源码的朋友都应该知道，Muduo实现的异步日志是<strong>双缓冲</strong>的，但是我阅读过很多Muduo有关异步日志的博客，有的人说Muduo里面<strong>双缓冲</strong>指的是currentBuffer_和nextBuffer_两块缓存，也有人说，Muduo的双缓冲是指前台的缓存和后台线程的缓存。</p>\n<p><strong>查阅资料得知：</strong></p>\n<p><strong>定义：</strong> 双缓冲技术是一种通过使用两个缓冲区（buffers）来实现某种功能的技术。<strong>通常，这两个缓冲区会交替使用，一个用于写入数据，另一个用于读取数据，或者在某种操作完成后进行交换。</strong></p>\n<p>在不同的领域中，双缓冲技术有不同的应用，以下是一些常见的应用场景：</p>\n<ol>\n<li><p>图形学： 在图形学中，双缓冲技术通常用于解决图像闪烁的问题。一个缓冲区用于显示当前图像，而另一个缓冲区则用于在<strong>后台</strong>绘制下一帧图像。当绘制完成后，两个缓冲区进行交换，确保只显示完整的图像，从而避免了闪烁。</p></li></ol>","more":"\n<li><p>计算机图形渲染： 在图形渲染中，双缓冲技术可以用于提高性能。例如，使用一个缓冲区进行渲染，同时在另一个缓冲区进行<strong>后台</strong>计算或处理，然后交换缓冲区。这样可以实现更平滑的图形渲染效果。</p>\n</li>\n<li><p>日志系统： 在日志系统中，双缓冲技术可以用于异步日志的实现。一个缓冲区用于应用程序写入日志，而另一个缓冲区用于异步写入磁盘。当一个缓冲区满了之后，可以交换缓冲区，实现高效的异步日志记录。</p>\n</li>\n<li><p>网络传输： 在网络传输中，双缓冲技术可以用于提高数据传输的效率。一个缓冲区用于发送数据，而另一个缓冲区用于填充新的数据。这样，在一个缓冲区发送的同时，可以在另一个缓冲区准备下一批数据。</p>\n</li>\n\n<p><strong>综上，Muduo异步日志的双缓冲就是指的前台的缓存和后台线程的缓存。</strong></p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p><strong>提供的接口：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AsyncLogging</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">AsyncLogging</span>(<span class=\"type\">const</span> string&amp; basename,</span><br><span class=\"line\">                <span class=\"type\">off_t</span> rollSize,</span><br><span class=\"line\">                <span class=\"type\">int</span> flushInterval = <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">AsyncLogging</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (running_)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">stop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* logline, <span class=\"type\">int</span> len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        running_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        thread_.<span class=\"built_in\">start</span>();    <span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">        latch_.<span class=\"built_in\">wait</span>();  <span class=\"comment\">// 等待启动</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> NO_THREAD_SAFETY_ANALYSIS</span>&#123;</span><br><span class=\"line\">        running_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        cond_.<span class=\"built_in\">notify</span>();</span><br><span class=\"line\">        thread_.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">threadFunc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> muduo::detail::FixedBuffer&lt;muduo::detail::kLargeBuffer&gt; Buffer;   <span class=\"comment\">// 4M的缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;std::unique_ptr&lt;Buffer&gt;&gt; BufferVector;  <span class=\"comment\">// 使用独占智能指针管理</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> BufferVector::value_type BufferPtr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> flushInterval_; <span class=\"comment\">// 将日志同步到磁盘上的间隔</span></span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">bool</span>&gt; running_; <span class=\"comment\">// 后台同步线程正在运行？</span></span><br><span class=\"line\">    <span class=\"type\">const</span> string basename_; <span class=\"comment\">// 文件前缀名</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">off_t</span> rollSize_;  <span class=\"comment\">// 日志文件回滚大小</span></span><br><span class=\"line\">    muduo::Thread thread_;  <span class=\"comment\">// 后台日志同步线程</span></span><br><span class=\"line\">    muduo::CountDownLatch latch_; <span class=\"comment\">// 确保同步回调函数跑起来了</span></span><br><span class=\"line\">    muduo::MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">muduo::Condition cond_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// 等待有至少一个Buffer满了</span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr currentBuffer_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// 接收日志的buff</span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr nextBuffer_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// 替补的buff，为减少分配内存的开销</span></span><br><span class=\"line\">    <span class=\"function\">BufferVector buffers_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// 满载日志的buff队列</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>异步日志架构图：</strong></p>\n<p>简单画了一下Muduo异步日志的架构图，忽略了currentBuffer_、nextBuffer_等细节。如图所示。</p>\n<p><img src=\"/2024/11/02/muduo/AsyncLogging/photo/AsynLogging.drawio.png\" alt=\"异步日志架构图\"></p>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 构造函数就省略了，主要做的事：</span></span><br><span class=\"line\"><span class=\"comment\">* 1. 将AsyncLogging::threadFunc作为后台线程的回调。</span></span><br><span class=\"line\"><span class=\"comment\">* 2. 构造currentBuffer_和nextBuffer_。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AsyncLogging::append</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* logline, <span class=\"type\">int</span> len)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">muduo::MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// 持锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentBuffer_-&gt;<span class=\"built_in\">avail</span>() &gt; len)&#123;  <span class=\"comment\">//当前缓存没满</span></span><br><span class=\"line\">        currentBuffer_-&gt;<span class=\"built_in\">append</span>(logline, len); <span class=\"comment\">// 先写到前台缓存</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">//满了</span></span><br><span class=\"line\">        buffers_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(currentBuffer_));  <span class=\"comment\">// 放到缓存队列</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextBuffer_)&#123;  <span class=\"comment\">// 优先考虑替补缓存，没有分配内存的开销，性能更高。</span></span><br><span class=\"line\">            currentBuffer_ = std::<span class=\"built_in\">move</span>(nextBuffer_);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 最坏的情况，替补缓存也用光了，只能去申请内存。</span></span><br><span class=\"line\">            currentBuffer_.<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> Buffer); <span class=\"comment\">// Rarely happens</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentBuffer_-&gt;<span class=\"built_in\">append</span>(logline, len);</span><br><span class=\"line\">        cond_.<span class=\"built_in\">notify</span>(); <span class=\"comment\">// 提醒一下后台线程，前台缓存队列非空。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AsyncLogging::threadFunc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(running_ == <span class=\"literal\">true</span>);</span><br><span class=\"line\">    latch_.<span class=\"built_in\">countDown</span>();</span><br><span class=\"line\">    <span class=\"function\">LogFile <span class=\"title\">output</span><span class=\"params\">(basename_, rollSize_, <span class=\"literal\">false</span>)</span></span>;  <span class=\"comment\">// 日志文件管理类，实现了日志回滚。</span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr <span class=\"title\">newBuffer1</span><span class=\"params\">(<span class=\"keyword\">new</span> Buffer)</span></span>; <span class=\"comment\">// 提前缓存两块buff减少内存开销</span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr <span class=\"title\">newBuffer2</span><span class=\"params\">(<span class=\"keyword\">new</span> Buffer)</span></span>;</span><br><span class=\"line\">    newBuffer1-&gt;<span class=\"built_in\">bzero</span>();</span><br><span class=\"line\">    newBuffer2-&gt;<span class=\"built_in\">bzero</span>();</span><br><span class=\"line\">    BufferVector buffersToWrite;</span><br><span class=\"line\">    buffersToWrite.<span class=\"built_in\">reserve</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (running_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 后台线程的buff在向前台buff置换日志前，保证后台线程的buff是被清空的。</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(newBuffer1 &amp;&amp; newBuffer1-&gt;<span class=\"built_in\">length</span>() == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(newBuffer2 &amp;&amp; newBuffer2-&gt;<span class=\"built_in\">length</span>() == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(buffersToWrite.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"function\">muduo::MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (buffers_.<span class=\"built_in\">empty</span>())&#123;  <span class=\"comment\">// unusual usage!</span></span><br><span class=\"line\">                <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                * 1. 因前台日志队列非空而被唤醒。（AsyncLogging::append）</span></span><br><span class=\"line\"><span class=\"comment\">                * 2. 超时。</span></span><br><span class=\"line\"><span class=\"comment\">                */</span></span><br><span class=\"line\">                cond_.<span class=\"built_in\">waitForSeconds</span>(flushInterval_);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 不管currentBuffer_中是否有日志，都归入前台的日志队列。可以保证所有日志都归入到了前台的日志队列。</span></span><br><span class=\"line\">            buffers_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(currentBuffer_)); </span><br><span class=\"line\">            currentBuffer_ = std::<span class=\"built_in\">move</span>(newBuffer1); <span class=\"comment\">// 补充currentBuffer_</span></span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">swap</span>(buffers_);  <span class=\"comment\">// 将前台的日志队列，置换到后台的日志队列，置换后前台的日志队列被清空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!nextBuffer_)&#123; <span class=\"comment\">// 前台的nextBuffer_也被用了。</span></span><br><span class=\"line\">                <span class=\"comment\">// nextBuffer_也需要补充</span></span><br><span class=\"line\">                nextBuffer_ = std::<span class=\"built_in\">move</span>(newBuffer2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(!buffersToWrite.<span class=\"built_in\">empty</span>());  <span class=\"comment\">// 至少为1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buffersToWrite.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">25</span>)&#123; <span class=\"comment\">// 避免日志洪流</span></span><br><span class=\"line\">            <span class=\"type\">char</span> buf[<span class=\"number\">256</span>];</span><br><span class=\"line\">            <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;Dropped log messages at %s, %zd larger buffers\\n&quot;</span>,</span><br><span class=\"line\">                    Timestamp::<span class=\"built_in\">now</span>().<span class=\"built_in\">toFormattedString</span>().<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">                    buffersToWrite.<span class=\"built_in\">size</span>()<span class=\"number\">-2</span>);</span><br><span class=\"line\">            <span class=\"built_in\">fputs</span>(buf, stderr);</span><br><span class=\"line\">            output.<span class=\"built_in\">append</span>(buf, <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"built_in\">strlen</span>(buf)));</span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">erase</span>(buffersToWrite.<span class=\"built_in\">begin</span>()<span class=\"number\">+2</span>, buffersToWrite.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; buffer : buffersToWrite)&#123; <span class=\"comment\">// 日志落盘</span></span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use unbuffered stdio FILE ? or use ::writev ?</span></span><br><span class=\"line\">            output.<span class=\"built_in\">append</span>(buffer-&gt;<span class=\"built_in\">data</span>(), buffer-&gt;<span class=\"built_in\">length</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buffersToWrite.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">2</span>)&#123; <span class=\"comment\">// 保留两块buff，填充newBuffer1、newBuffer2</span></span><br><span class=\"line\">            <span class=\"comment\">// drop non-bzero-ed buffers, avoid trashing</span></span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">resize</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!newBuffer1)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(!buffersToWrite.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\">            newBuffer1 = std::<span class=\"built_in\">move</span>(buffersToWrite.<span class=\"built_in\">back</span>());</span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            newBuffer1-&gt;<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!newBuffer2)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(!buffersToWrite.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\">            newBuffer2 = std::<span class=\"built_in\">move</span>(buffersToWrite.<span class=\"built_in\">back</span>());</span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            newBuffer2-&gt;<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        buffersToWrite.<span class=\"built_in\">clear</span>(); <span class=\"comment\">// 清空后台日志队列。</span></span><br><span class=\"line\">        output.<span class=\"built_in\">flush</span>(); <span class=\"comment\">// 文件同步。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    output.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>套路总结</strong></p>\n<p>这里是一份经典的降低锁的粒度的套路模板，也是Muduo异步日志高效的核心：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 临界区外面处理临界区的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义临界区的数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CriticalData</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 数据成员...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processCriticalData</span><span class=\"params\">(<span class=\"type\">const</span> CriticalData&amp; data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在临界区外面处理数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 可以进行计算、拷贝、异步处理等操作</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在临界区内使用局部变量进行处理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">criticalSection</span><span class=\"params\">(<span class=\"type\">const</span> CriticalData&amp; sharedData)</span> </span>&#123;</span><br><span class=\"line\">    CriticalData localCopy</span><br><span class=\"line\">    <span class=\"comment\">// 进入临界区</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拷贝数据到局部变量</span></span><br><span class=\"line\">    localCopy.<span class=\"built_in\">swap</span>(sharedData);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 离开临界区</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在临界区外面处理局部变量</span></span><br><span class=\"line\">    <span class=\"built_in\">processCriticalData</span>(localCopy);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"细节明细：\"><a href=\"#细节明细：\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h2><p><strong>疑问：</strong></p>\n<p>Muduo的异步日志为什么日志过多就删除一些日志？</p>\n<p><strong>解答：</strong></p>\n<p>在Muduo库的异步日志系统中，删除一些日志的策略可能是为了防止日志积累过多导致系统资源消耗过大，以及为了保持日志的存储大小在可控范围内。具体的删除策略可能会根据应用程序的需求和性能考虑而定，通常包括以下一些原因：</p>\n<ol>\n<li><p>资源限制： 大量的日志可能会占用大量磁盘空间，特别是在长时间运行的系统中。删除一些日志可以确保系统的磁盘空间不被过多消耗，避免磁盘空间不足的问题。</p>\n</li>\n<li><p>性能考虑： 当日志量非常大时，写入和处理大量日志会对系统性能产生影响。删除一些日志可以降低写入和处理的负担，确保系统的性能得到维持。</p>\n</li>\n<li><p>避免日志洪流： 在某些情况下，产生大量的日志可能并不是问题的根本原因，而是问题的表征。删除一些日志可以帮助集中关注真正的问题，而不被大量的无关日志所干扰。</p>\n</li>\n</ol>\n<p><strong>疑问：</strong></p>\n<p>Muduo异步日志中nextBuffer_是不是冗余了？currentBuffer_满了的话，不是可以再new一个Buffer吗？为什么要额外提供一个nextBuffer_？</p>\n<p><strong>解答：</strong></p>\n<p> 预先分配并循环使用多个缓冲区（包括 nextBuffer_）可以减少内存分配的频率。如果只使用一个 currentBuffer_，每次都需要在 currentBuffer_ 满了之后重新分配一个新的缓冲区，这可能导致频繁的内存分配和释放操作，影响性能。</p>\n<p> 综上提供nextBuffer_主要是为了减少内存分配次数</p>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"muduo源码阅读笔记（5、Channel和Poller）","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\n简单讲，Channel就是对文件描述符（fd）的封装，进行事件管理，将fd和对其操作的回调封装在一起，方便，在fd上有IO事件到来时，利用相应的回调来处理IO事件；Poller就是对Linux下各种IO多路复用进行抽象，提供一个统一的接口，该类是一个虚基类。路径./net/poller中的源码，就是对Poller的实现，包括：EPollPoller、PollPoller。\n\n这部分源代码很朴实易懂，代码量也不大，建议读者，亲自看看源码。\n\n## Channel的实现\n\n**提供的接口：**\n\n<!-- more -->\n```cpp\nclass Channel : noncopyable{\npublic:\n    typedef std::function<void()> EventCallback;\n    typedef std::function<void(Timestamp)> ReadEventCallback;\n\n    Channel(EventLoop* loop, int fd);\n    ~Channel();\n\n    void handleEvent(Timestamp receiveTime);\n    void setReadCallback(ReadEventCallback cb)\n    { readCallback_ = std::move(cb); }\n    void setWriteCallback(EventCallback cb)\n    { writeCallback_ = std::move(cb); }\n    void setCloseCallback(EventCallback cb)\n    { closeCallback_ = std::move(cb); }\n    void setErrorCallback(EventCallback cb)\n    { errorCallback_ = std::move(cb); }\n\n    /// Tie this channel to the owner object managed by shared_ptr,\n    /// prevent the owner object being destroyed in handleEvent.\n    void tie(const std::shared_ptr<void>&);\n\n    int fd() const { return fd_; }\n    int events() const { return events_; }\n    void set_revents(int revt) { revents_ = revt; } // used by pollers\n    // int revents() const { return revents_; }\n    bool isNoneEvent() const { return events_ == kNoneEvent; }\n\n    void enableReading() { events_ |= kReadEvent; update(); }\n    void disableReading() { events_ &= ~kReadEvent; update(); }\n    void enableWriting() { events_ |= kWriteEvent; update(); }\n    void disableWriting() { events_ &= ~kWriteEvent; update(); }\n    void disableAll() { events_ = kNoneEvent; update(); }\n    bool isWriting() const { return events_ & kWriteEvent; }\n    bool isReading() const { return events_ & kReadEvent; }\n\n    // for Poller\n    int index() { return index_; }\n    void set_index(int idx) { index_ = idx; }\n\n    // for debug\n    string reventsToString() const;\n    string eventsToString() const;\n\n    void doNotLogHup() { logHup_ = false; }\n\n    EventLoop* ownerLoop() { return loop_; }\n    void remove();\n\nprivate:\n    static string eventsToString(int fd, int ev);\n\n    void update();\n    void handleEventWithGuard(Timestamp receiveTime);\n\n    static const int kNoneEvent;  // 0\n    static const int kReadEvent;  // POLLIN | POLLPRI\n    static const int kWriteEvent; // POLLOUT\n\n    EventLoop* loop_; // channel被那个EventLoop监听\n    const int  fd_; // fd\n    int        events_;\n    int        revents_; // it's the received event types of epoll or poll // 触发的事件\n    int        index_; // used by Poller.\n    bool       logHup_;\n\n    std::weak_ptr<void> tie_;   // 主要解决循环引用的问题\n    bool tied_;\n    bool eventHandling_;  // 正在handleEventWithGuard中处理事件\n    bool addedToLoop_;  // 被添加到EventLoop了没？\n    ReadEventCallback readCallback_;  // 读回调\n    EventCallback writeCallback_; // 写回调\n    EventCallback closeCallback_; // 连接断开回调\n    EventCallback errorCallback_; // 错误处理回调\n};\n```\n\n**实现的伪代码：**\n\n```cpp\nChannel::Channel(EventLoop* loop, int fd__)\n  : loop_(loop),\n    fd_(fd__),\n    events_(0),\n    revents_(0),\n    index_(-1),\n    logHup_(true),\n    tied_(false),\n    eventHandling_(false),\n    addedToLoop_(false)\n{\n}\n\nChannel::~Channel(){\n    assert(!eventHandling_);\n    assert(!addedToLoop_);\n    if (loop_->isInLoopThread()){\n        // 该channel即将销毁，不能被EventLoop监听\n        assert(!loop_->hasChannel(this));\n    }\n}\n\nvoid Channel::tie(const std::shared_ptr<void>& obj){\n    tie_ = obj;   // 循环依赖，做生命周期的绑定\n    tied_ = true;\n}\n\nvoid Channel::update(){\n    // 在EventLoop中进行fd的事件更新\n    addedToLoop_ = true;\n    loop_->updateChannel(this);\n}\n\nvoid Channel::remove(){\n    // 取消EventLoop对channel的监听\n    assert(isNoneEvent());\n    addedToLoop_ = false;\n    loop_->removeChannel(this);\n}\n\nvoid Channel::handleEvent(Timestamp receiveTime){\n    std::shared_ptr<void> guard;\n    if (tied_){\n        guard = tie_.lock();\n        if (guard){ // 保证依赖对象没有被释放\n            handleEventWithGuard(receiveTime);\n        }\n    }else{\n        handleEventWithGuard(receiveTime);\n    }\n}\n\nvoid Channel::handleEventWithGuard(Timestamp receiveTime){\n    eventHandling_ = true;\n    if ((revents_ & POLLHUP) && !(revents_ & POLLIN)){\n        // 连接断开，并且fd上没有可读数据（默认水平触发）\n        // 调用关闭回调\n        if (closeCallback_) closeCallback_();\n    }\n\n    if (revents_ & (POLLERR | POLLNVAL)){\n        // 错误处理\n        if (errorCallback_) errorCallback_();\n    }\n    if (revents_ & (POLLIN | POLLPRI | POLLRDHUP)){\n        // 可读\n        if (readCallback_) readCallback_(receiveTime);\n    }\n    if (revents_ & POLLOUT){\n        // 可写\n        if (writeCallback_) writeCallback_();\n    }\n    eventHandling_ = false;\n}\n\n```\n\n**注意**\n\n**智能指针不是万能的，并不能解决cpp所有内存泄露的问题！！！**\n\n这里多提一句，关于循环引用这种头疼的问题，几个类可能很容易看出来，但是如果项目太大，涉及的类太多，就很容出现循环引用导致内存泄漏的问题！而且难以察觉。所以，在类的设计上，要特别注意这个坑。\n\n自引用：\n\n```cpp\nclass Node;\n\nclass Node {\npublic:\n    std::shared_ptr<Node> next;\n\n    Node() {\n        std::cout << \"Node constructed\" << std::endl;\n    }\n\n    ~Node() {\n        std::cout << \"Node destructed\" << std::endl;\n    }\n};\n\nint main() {\n    std::shared_ptr<Node> node1 = std::make_shared<Node>();\n\n    node1->next = node1;\n    return 0;\n}\n\n```\n\n结果如下：\n\n```\n[root@localhost muduo]# g++ -Wall -std=c++11 -o test.bin test.cc \n[root@localhost muduo]# \n[root@localhost muduo]# \n[root@localhost muduo]# ./test.bin \nNode constructed\n[root@localhost muduo]#\n```\n\n**多个类间的循环引用是同理的，一般是靠weak_ptr解决，单个类的自引用的化话，目前无解。**\n\n### 细节明细：\n\n**疑问：**\n\nMuduo中Channel的成员变量`std::weak_ptr<void> tie_`有什么意义？\n\n**解答：**\n\n使用std::weak_ptr的目的是为了避免循环引用（circular reference），因为TcpConnection对象通常也会持有一个指向Channel的指针。通过使用std::weak_ptr，可以避免引发循环引用导致对象无法正确释放的问题。\n\n**疑问：**\n\nfd上何时返回POLLHUP又何时返回POLLRDHUP？（POLLIN/POLLOUT呢？）\n\n**解答：**\n\n有写过一个deamo（有时间再写这方面的博客）专门测试这些事件触发条件，实验表明，POLLHUP事件一般是系统默认添加的事件，在连接关闭时会触发，而POLLIN/POLLOUT/POLLRDHUP等，需要用户手动添加才会触发。\n\n|   事件        |   水平触发                                                            |   边沿触发                    |\n|   :---:         |   :---:                                                             |   :---:                       |\n|   POLLIN      |   接收缓存有数据就一直触发                                                |   接收缓存有新数据来就触发    |\n|   POLLOUT     |   发送缓存未满就一致触发                                                  |   发送数据就触发              |\n|   POLLRDHUP   |   对端写关闭，本端就触发，同时触发POLLIN                                  |   同水平                      |\n|   POLLHUP     |   连接关闭，同时触发POLLIN/POLLOUT事件（用户添加过什么事件就触发什么事件）    |   同水平                      |\n\n## Poller的实现\n\n简单提一下，在Muduo中，Poller是对原生的linux下，C语言的IO多路复用接口进行了封装，毕竟面向对象用起来更舒服。Poller会在EventLoop中使用。具体，怎么使用，在下一章节，讲到EventLoop时，才会有所领悟，这里可以所见即所得，知道Poller就是封装IO多路复用的即可。\n\n**Poller提供的接口：**\n\n```cpp\nclass Poller : noncopyable{\npublic:\n    typedef std::vector<Channel*> ChannelList;\n\n    Poller(EventLoop* loop);\n    virtual ~Poller();\n\n    /// Polls the I/O events.\n    /// Must be called in the loop thread.\n    virtual Timestamp poll(int timeoutMs, ChannelList* activeChannels) = 0;\n\n    /// Changes the interested I/O events.\n    /// Must be called in the loop thread.\n    virtual void updateChannel(Channel* channel) = 0;\n\n    /// Remove the channel, when it destructs.\n    /// Must be called in the loop thread.\n    virtual void removeChannel(Channel* channel) = 0;\n\n    virtual bool hasChannel(Channel* channel) const;\n\n    static Poller* newDefaultPoller(EventLoop* loop);\n\n    void assertInLoopThread() const{\n        ownerLoop_->assertInLoopThread();\n    }\n\nprotected:\n    typedef std::map<int, Channel*> ChannelMap; \n    ChannelMap channels_;// fd到channel的映射\n\n    private:\n    EventLoop* ownerLoop_;  // 所属的EventLoop\n};\n```\n\n**Poller实现的伪代码：**\n\n```cpp\nPoller::Poller(EventLoop* loop)\n  : ownerLoop_(loop){\n}\n\nPoller::~Poller() = default;\n\nbool Poller::hasChannel(Channel* channel) const{\n    assertInLoopThread();\n    ChannelMap::const_iterator it = channels_.find(channel->fd());\n    return it != channels_.end() && it->second == channel;\n}\n\n```\n\n因为Muduo继承Poller实现了EPollPoller、PollPoller，考虑到篇幅有限，这里讲一下PollPoller的实现吧。\n\n### PollPoller的实现\n\n在muduo网络库中，PollPoller 是对 poll() 系统调用的封装，用于实现事件循环（EventLoop）中的事件分发。PollPoller 负责将 Channel管理的文件描述符注册到 poll() 中，监听各个文件描述符的事件。\n\n以下是对 PollPoller 的简要介绍：\n\n1. 文件位置： PollPoller 类的实现通常位于 PollPoller.cc 文件中。\n\n2. 继承关系： PollPoller 类继承自 Poller 类，而 Poller 类是对事件轮询机制的抽象。\n\n3. 主要方法： 重要的方法包括 poll 和 fillActiveChannels。\n\n    - poll 方法负责调用 poll() 系统调用，等待事件发生。\n    - fillActiveChannels 方法用于将 poll() 返回的就绪事件填充到 activeChannels 中。\n\n4. 事件分发： PollPoller 通过 EventLoop 实现了事件的分发。当有事件发生时，PollPoller 会通知 EventLoop，而后 EventLoop 会调用相应的 Channel 的handleEvent进行事件处理。\n\n**提供的接口**\n\n```cpp\nclass PollPoller : public Poller{\npublic:\n\n    PollPoller(EventLoop* loop);\n    ~PollPoller() override;\n\n    Timestamp poll(int timeoutMs, ChannelList* activeChannels) override;\n    void updateChannel(Channel* channel) override;\n    void removeChannel(Channel* channel) override;\n\nprivate:\n    void fillActiveChannels(int numEvents,\n                            ChannelList* activeChannels) const;\n\n    /*\n    * struct pollfd定义如下：\n    *    struct pollfd {\n    *        int   fd;     // 监听的文件描述符    \n    *       short events;   // 要监听的事件\n    *        short revents; // 监听到得到事件\n    *    };\n    */\n\n    typedef std::vector<struct pollfd> PollFdList;\n    PollFdList pollfds_;\n};\n\n```\n\n**实现的伪代码**\n\n```cpp\nPollPoller::PollPoller(EventLoop* loop)\n  : Poller(loop){\n}\n\nPollPoller::~PollPoller() = default;\n\n// 提供给EventLoop的接口，也是EventLoop 等待事件的程序点。\nTimestamp PollPoller::poll(int timeoutMs, ChannelList* activeChannels){\n    // 等待事件到来，或者超时\n    // XXX pollfds_ shouldn't change\n    int numEvents = ::poll(&*pollfds_.begin(), pollfds_.size(), timeoutMs);\n    int savedErrno = errno;\n    Timestamp now(Timestamp::now());\n    if (numEvents > 0){\n        fillActiveChannels(numEvents, activeChannels);\n    }else if (numEvents == 0){\n        LOG_TRACE << \" nothing happened\";\n    }else{\n        if (savedErrno != EINTR){   // 中断\n            errno = savedErrno;\n            LOG_SYSERR << \"PollPoller::poll()\";\n        }\n    }\n    return now;\n}\n\nvoid PollPoller::fillActiveChannels(int numEvents,\n                                    ChannelList* activeChannels) const{\n    // 将所有发生事件的fd对应的channel，收集到activeChannels，供EventLoop处理\n    for (PollFdList::const_iterator pfd = pollfds_.begin();\n        pfd != pollfds_.end() && numEvents > 0; ++pfd){\n        if (pfd->revents > 0){\n            --numEvents;\n            ChannelMap::const_iterator ch = channels_.find(pfd->fd);\n            assert(ch != channels_.end());   //一定要存在\n            Channel* channel = ch->second;\n            channel->set_revents(pfd->revents);\n            // pfd->revents = 0;    // poll会自动清零\n            activeChannels->push_back(channel);\n        }\n    }\n}\n\nvoid PollPoller::updateChannel(Channel* channel){\n    Poller::assertInLoopThread();\n    if (channel->index() < 0){\n        // 新的channel\n        // a new one, add to pollfds_\n        assert(channels_.find(channel->fd()) == channels_.end());\n        struct pollfd pfd;\n        pfd.fd = channel->fd();\n        pfd.events = static_cast<short>(channel->events());\n        pfd.revents = 0;\n        pollfds_.push_back(pfd);\n        int idx = static_cast<int>(pollfds_.size())-1;\n        channel->set_index(idx);\n        channels_[pfd.fd] = channel;\n    }else{\n        // update existing one\n        assert(channels_.find(channel->fd()) != channels_.end());\n        int idx = channel->index();\n        // idx 有效\n        assert(0 <= idx && idx < static_cast<int>(pollfds_.size()));\n        struct pollfd& pfd = pollfds_[idx];\n        // fd对的上，或者，因为之前不需要监听，被置为-(fd + 1)保证为负，这样，poll不会监听fd为负的channel。\n        assert(pfd.fd == channel->fd() || pfd.fd == -channel->fd()-1);\n        pfd.fd = channel->fd();\n        pfd.events = static_cast<short>(channel->events());\n        pfd.revents = 0;\n        if (channel->isNoneEvent()){\n            // 事件为空，置为负。\n            // ignore this pollfd\n            pfd.fd = -channel->fd()-1;\n        }\n    }\n}\n\nvoid PollPoller::removeChannel(Channel* channel){\n    Poller::assertInLoopThread();\n    assert(channels_.find(channel->fd()) != channels_.end());\n    assert(channels_[channel->fd()] == channel);\n    assert(channel->isNoneEvent());\n    int idx = channel->index();\n    assert(0 <= idx && idx < static_cast<int>(pollfds_.size()));\n    const struct pollfd& pfd = pollfds_[idx]; (void)pfd;\n    assert(pfd.fd == -channel->fd()-1 && pfd.events == channel->events());\n    size_t n = channels_.erase(channel->fd());\n    assert(n == 1); (void)n;\n\n    /*\n    * 因为poll是基于数组做轮询，考虑到数组的删除代价很大，所以Muduo在这里\n    * 做了一个优化：如果删除的fd正好是数组尾部，直接pop_back即可，否则，\n    * 把要删除的fd和数组最后一个元素做交换，并通过父类的channels_设置原来\n    * 最后一个fd对应的cahnnel的index。最后，删除数组最后一个需要删除的fd即\n    * 可。\n    */\n    if (implicit_cast<size_t>(idx) == pollfds_.size()-1){\n        pollfds_.pop_back();\n    }else{\n        int channelAtEnd = pollfds_.back().fd;\n        iter_swap(pollfds_.begin()+idx, pollfds_.end()-1);\n        if (channelAtEnd < 0){\n            channelAtEnd = -channelAtEnd-1;\n        }\n        channels_[channelAtEnd]->set_index(idx);\n        pollfds_.pop_back();\n    }\n}\n```\n\n## 细节明细\n\n**疑问**\n\nMuduo为什么要额外为fd的事件封装一个Channel?\n\n**解答**\n\nChannel和Poller的封装其实有考量Muduo的跨平台，为fd的事件多抽象一层channel，在使用不同平台的IO多路复用接口时，只需编写不同平台的Poller代码，然后触发事件后，统一将事件交由channel由上层统一处理，达到了解耦合的效果。Redis网络部分也做了类似的处理。\n\n---\n\n**本章完结**","source":"_posts/muduo/ChannelAndPoller.md","raw":"---\ntitle: muduo源码阅读笔记（5、Channel和Poller）\ndate: 2024-11-02 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\n简单讲，Channel就是对文件描述符（fd）的封装，进行事件管理，将fd和对其操作的回调封装在一起，方便，在fd上有IO事件到来时，利用相应的回调来处理IO事件；Poller就是对Linux下各种IO多路复用进行抽象，提供一个统一的接口，该类是一个虚基类。路径./net/poller中的源码，就是对Poller的实现，包括：EPollPoller、PollPoller。\n\n这部分源代码很朴实易懂，代码量也不大，建议读者，亲自看看源码。\n\n## Channel的实现\n\n**提供的接口：**\n\n<!-- more -->\n```cpp\nclass Channel : noncopyable{\npublic:\n    typedef std::function<void()> EventCallback;\n    typedef std::function<void(Timestamp)> ReadEventCallback;\n\n    Channel(EventLoop* loop, int fd);\n    ~Channel();\n\n    void handleEvent(Timestamp receiveTime);\n    void setReadCallback(ReadEventCallback cb)\n    { readCallback_ = std::move(cb); }\n    void setWriteCallback(EventCallback cb)\n    { writeCallback_ = std::move(cb); }\n    void setCloseCallback(EventCallback cb)\n    { closeCallback_ = std::move(cb); }\n    void setErrorCallback(EventCallback cb)\n    { errorCallback_ = std::move(cb); }\n\n    /// Tie this channel to the owner object managed by shared_ptr,\n    /// prevent the owner object being destroyed in handleEvent.\n    void tie(const std::shared_ptr<void>&);\n\n    int fd() const { return fd_; }\n    int events() const { return events_; }\n    void set_revents(int revt) { revents_ = revt; } // used by pollers\n    // int revents() const { return revents_; }\n    bool isNoneEvent() const { return events_ == kNoneEvent; }\n\n    void enableReading() { events_ |= kReadEvent; update(); }\n    void disableReading() { events_ &= ~kReadEvent; update(); }\n    void enableWriting() { events_ |= kWriteEvent; update(); }\n    void disableWriting() { events_ &= ~kWriteEvent; update(); }\n    void disableAll() { events_ = kNoneEvent; update(); }\n    bool isWriting() const { return events_ & kWriteEvent; }\n    bool isReading() const { return events_ & kReadEvent; }\n\n    // for Poller\n    int index() { return index_; }\n    void set_index(int idx) { index_ = idx; }\n\n    // for debug\n    string reventsToString() const;\n    string eventsToString() const;\n\n    void doNotLogHup() { logHup_ = false; }\n\n    EventLoop* ownerLoop() { return loop_; }\n    void remove();\n\nprivate:\n    static string eventsToString(int fd, int ev);\n\n    void update();\n    void handleEventWithGuard(Timestamp receiveTime);\n\n    static const int kNoneEvent;  // 0\n    static const int kReadEvent;  // POLLIN | POLLPRI\n    static const int kWriteEvent; // POLLOUT\n\n    EventLoop* loop_; // channel被那个EventLoop监听\n    const int  fd_; // fd\n    int        events_;\n    int        revents_; // it's the received event types of epoll or poll // 触发的事件\n    int        index_; // used by Poller.\n    bool       logHup_;\n\n    std::weak_ptr<void> tie_;   // 主要解决循环引用的问题\n    bool tied_;\n    bool eventHandling_;  // 正在handleEventWithGuard中处理事件\n    bool addedToLoop_;  // 被添加到EventLoop了没？\n    ReadEventCallback readCallback_;  // 读回调\n    EventCallback writeCallback_; // 写回调\n    EventCallback closeCallback_; // 连接断开回调\n    EventCallback errorCallback_; // 错误处理回调\n};\n```\n\n**实现的伪代码：**\n\n```cpp\nChannel::Channel(EventLoop* loop, int fd__)\n  : loop_(loop),\n    fd_(fd__),\n    events_(0),\n    revents_(0),\n    index_(-1),\n    logHup_(true),\n    tied_(false),\n    eventHandling_(false),\n    addedToLoop_(false)\n{\n}\n\nChannel::~Channel(){\n    assert(!eventHandling_);\n    assert(!addedToLoop_);\n    if (loop_->isInLoopThread()){\n        // 该channel即将销毁，不能被EventLoop监听\n        assert(!loop_->hasChannel(this));\n    }\n}\n\nvoid Channel::tie(const std::shared_ptr<void>& obj){\n    tie_ = obj;   // 循环依赖，做生命周期的绑定\n    tied_ = true;\n}\n\nvoid Channel::update(){\n    // 在EventLoop中进行fd的事件更新\n    addedToLoop_ = true;\n    loop_->updateChannel(this);\n}\n\nvoid Channel::remove(){\n    // 取消EventLoop对channel的监听\n    assert(isNoneEvent());\n    addedToLoop_ = false;\n    loop_->removeChannel(this);\n}\n\nvoid Channel::handleEvent(Timestamp receiveTime){\n    std::shared_ptr<void> guard;\n    if (tied_){\n        guard = tie_.lock();\n        if (guard){ // 保证依赖对象没有被释放\n            handleEventWithGuard(receiveTime);\n        }\n    }else{\n        handleEventWithGuard(receiveTime);\n    }\n}\n\nvoid Channel::handleEventWithGuard(Timestamp receiveTime){\n    eventHandling_ = true;\n    if ((revents_ & POLLHUP) && !(revents_ & POLLIN)){\n        // 连接断开，并且fd上没有可读数据（默认水平触发）\n        // 调用关闭回调\n        if (closeCallback_) closeCallback_();\n    }\n\n    if (revents_ & (POLLERR | POLLNVAL)){\n        // 错误处理\n        if (errorCallback_) errorCallback_();\n    }\n    if (revents_ & (POLLIN | POLLPRI | POLLRDHUP)){\n        // 可读\n        if (readCallback_) readCallback_(receiveTime);\n    }\n    if (revents_ & POLLOUT){\n        // 可写\n        if (writeCallback_) writeCallback_();\n    }\n    eventHandling_ = false;\n}\n\n```\n\n**注意**\n\n**智能指针不是万能的，并不能解决cpp所有内存泄露的问题！！！**\n\n这里多提一句，关于循环引用这种头疼的问题，几个类可能很容易看出来，但是如果项目太大，涉及的类太多，就很容出现循环引用导致内存泄漏的问题！而且难以察觉。所以，在类的设计上，要特别注意这个坑。\n\n自引用：\n\n```cpp\nclass Node;\n\nclass Node {\npublic:\n    std::shared_ptr<Node> next;\n\n    Node() {\n        std::cout << \"Node constructed\" << std::endl;\n    }\n\n    ~Node() {\n        std::cout << \"Node destructed\" << std::endl;\n    }\n};\n\nint main() {\n    std::shared_ptr<Node> node1 = std::make_shared<Node>();\n\n    node1->next = node1;\n    return 0;\n}\n\n```\n\n结果如下：\n\n```\n[root@localhost muduo]# g++ -Wall -std=c++11 -o test.bin test.cc \n[root@localhost muduo]# \n[root@localhost muduo]# \n[root@localhost muduo]# ./test.bin \nNode constructed\n[root@localhost muduo]#\n```\n\n**多个类间的循环引用是同理的，一般是靠weak_ptr解决，单个类的自引用的化话，目前无解。**\n\n### 细节明细：\n\n**疑问：**\n\nMuduo中Channel的成员变量`std::weak_ptr<void> tie_`有什么意义？\n\n**解答：**\n\n使用std::weak_ptr的目的是为了避免循环引用（circular reference），因为TcpConnection对象通常也会持有一个指向Channel的指针。通过使用std::weak_ptr，可以避免引发循环引用导致对象无法正确释放的问题。\n\n**疑问：**\n\nfd上何时返回POLLHUP又何时返回POLLRDHUP？（POLLIN/POLLOUT呢？）\n\n**解答：**\n\n有写过一个deamo（有时间再写这方面的博客）专门测试这些事件触发条件，实验表明，POLLHUP事件一般是系统默认添加的事件，在连接关闭时会触发，而POLLIN/POLLOUT/POLLRDHUP等，需要用户手动添加才会触发。\n\n|   事件        |   水平触发                                                            |   边沿触发                    |\n|   :---:         |   :---:                                                             |   :---:                       |\n|   POLLIN      |   接收缓存有数据就一直触发                                                |   接收缓存有新数据来就触发    |\n|   POLLOUT     |   发送缓存未满就一致触发                                                  |   发送数据就触发              |\n|   POLLRDHUP   |   对端写关闭，本端就触发，同时触发POLLIN                                  |   同水平                      |\n|   POLLHUP     |   连接关闭，同时触发POLLIN/POLLOUT事件（用户添加过什么事件就触发什么事件）    |   同水平                      |\n\n## Poller的实现\n\n简单提一下，在Muduo中，Poller是对原生的linux下，C语言的IO多路复用接口进行了封装，毕竟面向对象用起来更舒服。Poller会在EventLoop中使用。具体，怎么使用，在下一章节，讲到EventLoop时，才会有所领悟，这里可以所见即所得，知道Poller就是封装IO多路复用的即可。\n\n**Poller提供的接口：**\n\n```cpp\nclass Poller : noncopyable{\npublic:\n    typedef std::vector<Channel*> ChannelList;\n\n    Poller(EventLoop* loop);\n    virtual ~Poller();\n\n    /// Polls the I/O events.\n    /// Must be called in the loop thread.\n    virtual Timestamp poll(int timeoutMs, ChannelList* activeChannels) = 0;\n\n    /// Changes the interested I/O events.\n    /// Must be called in the loop thread.\n    virtual void updateChannel(Channel* channel) = 0;\n\n    /// Remove the channel, when it destructs.\n    /// Must be called in the loop thread.\n    virtual void removeChannel(Channel* channel) = 0;\n\n    virtual bool hasChannel(Channel* channel) const;\n\n    static Poller* newDefaultPoller(EventLoop* loop);\n\n    void assertInLoopThread() const{\n        ownerLoop_->assertInLoopThread();\n    }\n\nprotected:\n    typedef std::map<int, Channel*> ChannelMap; \n    ChannelMap channels_;// fd到channel的映射\n\n    private:\n    EventLoop* ownerLoop_;  // 所属的EventLoop\n};\n```\n\n**Poller实现的伪代码：**\n\n```cpp\nPoller::Poller(EventLoop* loop)\n  : ownerLoop_(loop){\n}\n\nPoller::~Poller() = default;\n\nbool Poller::hasChannel(Channel* channel) const{\n    assertInLoopThread();\n    ChannelMap::const_iterator it = channels_.find(channel->fd());\n    return it != channels_.end() && it->second == channel;\n}\n\n```\n\n因为Muduo继承Poller实现了EPollPoller、PollPoller，考虑到篇幅有限，这里讲一下PollPoller的实现吧。\n\n### PollPoller的实现\n\n在muduo网络库中，PollPoller 是对 poll() 系统调用的封装，用于实现事件循环（EventLoop）中的事件分发。PollPoller 负责将 Channel管理的文件描述符注册到 poll() 中，监听各个文件描述符的事件。\n\n以下是对 PollPoller 的简要介绍：\n\n1. 文件位置： PollPoller 类的实现通常位于 PollPoller.cc 文件中。\n\n2. 继承关系： PollPoller 类继承自 Poller 类，而 Poller 类是对事件轮询机制的抽象。\n\n3. 主要方法： 重要的方法包括 poll 和 fillActiveChannels。\n\n    - poll 方法负责调用 poll() 系统调用，等待事件发生。\n    - fillActiveChannels 方法用于将 poll() 返回的就绪事件填充到 activeChannels 中。\n\n4. 事件分发： PollPoller 通过 EventLoop 实现了事件的分发。当有事件发生时，PollPoller 会通知 EventLoop，而后 EventLoop 会调用相应的 Channel 的handleEvent进行事件处理。\n\n**提供的接口**\n\n```cpp\nclass PollPoller : public Poller{\npublic:\n\n    PollPoller(EventLoop* loop);\n    ~PollPoller() override;\n\n    Timestamp poll(int timeoutMs, ChannelList* activeChannels) override;\n    void updateChannel(Channel* channel) override;\n    void removeChannel(Channel* channel) override;\n\nprivate:\n    void fillActiveChannels(int numEvents,\n                            ChannelList* activeChannels) const;\n\n    /*\n    * struct pollfd定义如下：\n    *    struct pollfd {\n    *        int   fd;     // 监听的文件描述符    \n    *       short events;   // 要监听的事件\n    *        short revents; // 监听到得到事件\n    *    };\n    */\n\n    typedef std::vector<struct pollfd> PollFdList;\n    PollFdList pollfds_;\n};\n\n```\n\n**实现的伪代码**\n\n```cpp\nPollPoller::PollPoller(EventLoop* loop)\n  : Poller(loop){\n}\n\nPollPoller::~PollPoller() = default;\n\n// 提供给EventLoop的接口，也是EventLoop 等待事件的程序点。\nTimestamp PollPoller::poll(int timeoutMs, ChannelList* activeChannels){\n    // 等待事件到来，或者超时\n    // XXX pollfds_ shouldn't change\n    int numEvents = ::poll(&*pollfds_.begin(), pollfds_.size(), timeoutMs);\n    int savedErrno = errno;\n    Timestamp now(Timestamp::now());\n    if (numEvents > 0){\n        fillActiveChannels(numEvents, activeChannels);\n    }else if (numEvents == 0){\n        LOG_TRACE << \" nothing happened\";\n    }else{\n        if (savedErrno != EINTR){   // 中断\n            errno = savedErrno;\n            LOG_SYSERR << \"PollPoller::poll()\";\n        }\n    }\n    return now;\n}\n\nvoid PollPoller::fillActiveChannels(int numEvents,\n                                    ChannelList* activeChannels) const{\n    // 将所有发生事件的fd对应的channel，收集到activeChannels，供EventLoop处理\n    for (PollFdList::const_iterator pfd = pollfds_.begin();\n        pfd != pollfds_.end() && numEvents > 0; ++pfd){\n        if (pfd->revents > 0){\n            --numEvents;\n            ChannelMap::const_iterator ch = channels_.find(pfd->fd);\n            assert(ch != channels_.end());   //一定要存在\n            Channel* channel = ch->second;\n            channel->set_revents(pfd->revents);\n            // pfd->revents = 0;    // poll会自动清零\n            activeChannels->push_back(channel);\n        }\n    }\n}\n\nvoid PollPoller::updateChannel(Channel* channel){\n    Poller::assertInLoopThread();\n    if (channel->index() < 0){\n        // 新的channel\n        // a new one, add to pollfds_\n        assert(channels_.find(channel->fd()) == channels_.end());\n        struct pollfd pfd;\n        pfd.fd = channel->fd();\n        pfd.events = static_cast<short>(channel->events());\n        pfd.revents = 0;\n        pollfds_.push_back(pfd);\n        int idx = static_cast<int>(pollfds_.size())-1;\n        channel->set_index(idx);\n        channels_[pfd.fd] = channel;\n    }else{\n        // update existing one\n        assert(channels_.find(channel->fd()) != channels_.end());\n        int idx = channel->index();\n        // idx 有效\n        assert(0 <= idx && idx < static_cast<int>(pollfds_.size()));\n        struct pollfd& pfd = pollfds_[idx];\n        // fd对的上，或者，因为之前不需要监听，被置为-(fd + 1)保证为负，这样，poll不会监听fd为负的channel。\n        assert(pfd.fd == channel->fd() || pfd.fd == -channel->fd()-1);\n        pfd.fd = channel->fd();\n        pfd.events = static_cast<short>(channel->events());\n        pfd.revents = 0;\n        if (channel->isNoneEvent()){\n            // 事件为空，置为负。\n            // ignore this pollfd\n            pfd.fd = -channel->fd()-1;\n        }\n    }\n}\n\nvoid PollPoller::removeChannel(Channel* channel){\n    Poller::assertInLoopThread();\n    assert(channels_.find(channel->fd()) != channels_.end());\n    assert(channels_[channel->fd()] == channel);\n    assert(channel->isNoneEvent());\n    int idx = channel->index();\n    assert(0 <= idx && idx < static_cast<int>(pollfds_.size()));\n    const struct pollfd& pfd = pollfds_[idx]; (void)pfd;\n    assert(pfd.fd == -channel->fd()-1 && pfd.events == channel->events());\n    size_t n = channels_.erase(channel->fd());\n    assert(n == 1); (void)n;\n\n    /*\n    * 因为poll是基于数组做轮询，考虑到数组的删除代价很大，所以Muduo在这里\n    * 做了一个优化：如果删除的fd正好是数组尾部，直接pop_back即可，否则，\n    * 把要删除的fd和数组最后一个元素做交换，并通过父类的channels_设置原来\n    * 最后一个fd对应的cahnnel的index。最后，删除数组最后一个需要删除的fd即\n    * 可。\n    */\n    if (implicit_cast<size_t>(idx) == pollfds_.size()-1){\n        pollfds_.pop_back();\n    }else{\n        int channelAtEnd = pollfds_.back().fd;\n        iter_swap(pollfds_.begin()+idx, pollfds_.end()-1);\n        if (channelAtEnd < 0){\n            channelAtEnd = -channelAtEnd-1;\n        }\n        channels_[channelAtEnd]->set_index(idx);\n        pollfds_.pop_back();\n    }\n}\n```\n\n## 细节明细\n\n**疑问**\n\nMuduo为什么要额外为fd的事件封装一个Channel?\n\n**解答**\n\nChannel和Poller的封装其实有考量Muduo的跨平台，为fd的事件多抽象一层channel，在使用不同平台的IO多路复用接口时，只需编写不同平台的Poller代码，然后触发事件后，统一将事件交由channel由上层统一处理，达到了解耦合的效果。Redis网络部分也做了类似的处理。\n\n---\n\n**本章完结**","slug":"muduo/ChannelAndPoller","published":1,"updated":"2025-09-28T16:06:43.125Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9o0009q8ws2nst23jm","content":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>简单讲，Channel就是对文件描述符（fd）的封装，进行事件管理，将fd和对其操作的回调封装在一起，方便，在fd上有IO事件到来时，利用相应的回调来处理IO事件；Poller就是对Linux下各种IO多路复用进行抽象，提供一个统一的接口，该类是一个虚基类。路径.&#x2F;net&#x2F;poller中的源码，就是对Poller的实现，包括：EPollPoller、PollPoller。</p>\n<p>这部分源代码很朴实易懂，代码量也不大，建议读者，亲自看看源码。</p>\n<h2 id=\"Channel的实现\"><a href=\"#Channel的实现\" class=\"headerlink\" title=\"Channel的实现\"></a>Channel的实现</h2><p><strong>提供的接口：</strong></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Channel</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>()&gt; EventCallback;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(Timestamp)&gt; ReadEventCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Channel</span>(EventLoop* loop, <span class=\"type\">int</span> fd);</span><br><span class=\"line\">    ~<span class=\"built_in\">Channel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleEvent</span><span class=\"params\">(Timestamp receiveTime)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setReadCallback</span><span class=\"params\">(ReadEventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; readCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWriteCallback</span><span class=\"params\">(EventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; writeCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setCloseCallback</span><span class=\"params\">(EventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; closeCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setErrorCallback</span><span class=\"params\">(EventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; errorCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Tie this channel to the owner object managed by shared_ptr,</span></span><br><span class=\"line\">    <span class=\"comment\">/// prevent the owner object being destroyed in handleEvent.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">tie</span><span class=\"params\">(<span class=\"type\">const</span> std::shared_ptr&lt;<span class=\"type\">void</span>&gt;&amp;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fd</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> fd_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">events</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_revents</span><span class=\"params\">(<span class=\"type\">int</span> revt)</span> </span>&#123; revents_ = revt; &#125; <span class=\"comment\">// used by pollers</span></span><br><span class=\"line\">    <span class=\"comment\">// int revents() const &#123; return revents_; &#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isNoneEvent</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_ == kNoneEvent; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enableReading</span><span class=\"params\">()</span> </span>&#123; events_ |= kReadEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disableReading</span><span class=\"params\">()</span> </span>&#123; events_ &amp;= ~kReadEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enableWriting</span><span class=\"params\">()</span> </span>&#123; events_ |= kWriteEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disableWriting</span><span class=\"params\">()</span> </span>&#123; events_ &amp;= ~kWriteEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disableAll</span><span class=\"params\">()</span> </span>&#123; events_ = kNoneEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isWriting</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_ &amp; kWriteEvent; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isReading</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_ &amp; kReadEvent; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for Poller</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">index</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> index_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_index</span><span class=\"params\">(<span class=\"type\">int</span> idx)</span> </span>&#123; index_ = idx; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for debug</span></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">reventsToString</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">eventsToString</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">doNotLogHup</span><span class=\"params\">()</span> </span>&#123; logHup_ = <span class=\"literal\">false</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">ownerLoop</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> loop_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> string <span class=\"title\">eventsToString</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span> ev)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleEventWithGuard</span><span class=\"params\">(Timestamp receiveTime)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kNoneEvent;  <span class=\"comment\">// 0</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kReadEvent;  <span class=\"comment\">// POLLIN | POLLPRI</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kWriteEvent; <span class=\"comment\">// POLLOUT</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// channel被那个EventLoop监听</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span>  fd_; <span class=\"comment\">// fd</span></span><br><span class=\"line\">    <span class=\"type\">int</span>        events_;</span><br><span class=\"line\">    <span class=\"type\">int</span>        revents_; <span class=\"comment\">// it&#x27;s the received event types of epoll or poll // 触发的事件</span></span><br><span class=\"line\">    <span class=\"type\">int</span>        index_; <span class=\"comment\">// used by Poller.</span></span><br><span class=\"line\">    <span class=\"type\">bool</span>       logHup_;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::weak_ptr&lt;<span class=\"type\">void</span>&gt; tie_;   <span class=\"comment\">// 主要解决循环引用的问题</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> tied_;</span><br><span class=\"line\">    <span class=\"type\">bool</span> eventHandling_;  <span class=\"comment\">// 正在handleEventWithGuard中处理事件</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> addedToLoop_;  <span class=\"comment\">// 被添加到EventLoop了没？</span></span><br><span class=\"line\">    ReadEventCallback readCallback_;  <span class=\"comment\">// 读回调</span></span><br><span class=\"line\">    EventCallback writeCallback_; <span class=\"comment\">// 写回调</span></span><br><span class=\"line\">    EventCallback closeCallback_; <span class=\"comment\">// 连接断开回调</span></span><br><span class=\"line\">    EventCallback errorCallback_; <span class=\"comment\">// 错误处理回调</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Channel::<span class=\"built_in\">Channel</span>(EventLoop* loop, <span class=\"type\">int</span> fd__)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(loop),</span><br><span class=\"line\">    <span class=\"built_in\">fd_</span>(fd__),</span><br><span class=\"line\">    <span class=\"built_in\">events_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">revents_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">index_</span>(<span class=\"number\">-1</span>),</span><br><span class=\"line\">    <span class=\"built_in\">logHup_</span>(<span class=\"literal\">true</span>),</span><br><span class=\"line\">    <span class=\"built_in\">tied_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">eventHandling_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">addedToLoop_</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Channel::~<span class=\"built_in\">Channel</span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!eventHandling_);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!addedToLoop_);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loop_-&gt;<span class=\"built_in\">isInLoopThread</span>())&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 该channel即将销毁，不能被EventLoop监听</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(!loop_-&gt;<span class=\"built_in\">hasChannel</span>(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::tie</span><span class=\"params\">(<span class=\"type\">const</span> std::shared_ptr&lt;<span class=\"type\">void</span>&gt;&amp; obj)</span></span>&#123;</span><br><span class=\"line\">    tie_ = obj;   <span class=\"comment\">// 循环依赖，做生命周期的绑定</span></span><br><span class=\"line\">    tied_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::update</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在EventLoop中进行fd的事件更新</span></span><br><span class=\"line\">    addedToLoop_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">updateChannel</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::remove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 取消EventLoop对channel的监听</span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"built_in\">isNoneEvent</span>());</span><br><span class=\"line\">    addedToLoop_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">removeChannel</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::handleEvent</span><span class=\"params\">(Timestamp receiveTime)</span></span>&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;<span class=\"type\">void</span>&gt; guard;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tied_)&#123;</span><br><span class=\"line\">        guard = tie_.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (guard)&#123; <span class=\"comment\">// 保证依赖对象没有被释放</span></span><br><span class=\"line\">            <span class=\"built_in\">handleEventWithGuard</span>(receiveTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">handleEventWithGuard</span>(receiveTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::handleEventWithGuard</span><span class=\"params\">(Timestamp receiveTime)</span></span>&#123;</span><br><span class=\"line\">    eventHandling_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 连接断开，并且fd上没有可读数据（默认水平触发）</span></span><br><span class=\"line\">        <span class=\"comment\">// 调用关闭回调</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (closeCallback_) <span class=\"built_in\">closeCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (revents_ &amp; (POLLERR | POLLNVAL))&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 错误处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errorCallback_) <span class=\"built_in\">errorCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可读</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (readCallback_) <span class=\"built_in\">readCallback_</span>(receiveTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (revents_ &amp; POLLOUT)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可写</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (writeCallback_) <span class=\"built_in\">writeCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eventHandling_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong></p>\n<p><strong>智能指针不是万能的，并不能解决cpp所有内存泄露的问题！！！</strong></p>\n<p>这里多提一句，关于循环引用这种头疼的问题，几个类可能很容易看出来，但是如果项目太大，涉及的类太多，就很容出现循环引用导致内存泄漏的问题！而且难以察觉。所以，在类的设计上，要特别注意这个坑。</p>\n<p>自引用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    std::shared_ptr&lt;Node&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Node</span>() &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Node constructed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">Node</span>() &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Node destructed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;Node&gt; node1 = std::<span class=\"built_in\">make_shared</span>&lt;Node&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    node1-&gt;next = node1;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost muduo]# g++ -Wall -std=c++11 -o test.bin test.cc </span><br><span class=\"line\">[root@localhost muduo]# </span><br><span class=\"line\">[root@localhost muduo]# </span><br><span class=\"line\">[root@localhost muduo]# ./test.bin </span><br><span class=\"line\">Node constructed</span><br><span class=\"line\">[root@localhost muduo]#</span><br></pre></td></tr></table></figure>\n\n<p><strong>多个类间的循环引用是同理的，一般是靠weak_ptr解决，单个类的自引用的化话，目前无解。</strong></p>\n<h3 id=\"细节明细：\"><a href=\"#细节明细：\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h3><p><strong>疑问：</strong></p>\n<p>Muduo中Channel的成员变量<code>std::weak_ptr&lt;void&gt; tie_</code>有什么意义？</p>\n<p><strong>解答：</strong></p>\n<p>使用std::weak_ptr的目的是为了避免循环引用（circular reference），因为TcpConnection对象通常也会持有一个指向Channel的指针。通过使用std::weak_ptr，可以避免引发循环引用导致对象无法正确释放的问题。</p>\n<p><strong>疑问：</strong></p>\n<p>fd上何时返回POLLHUP又何时返回POLLRDHUP？（POLLIN&#x2F;POLLOUT呢？）</p>\n<p><strong>解答：</strong></p>\n<p>有写过一个deamo（有时间再写这方面的博客）专门测试这些事件触发条件，实验表明，POLLHUP事件一般是系统默认添加的事件，在连接关闭时会触发，而POLLIN&#x2F;POLLOUT&#x2F;POLLRDHUP等，需要用户手动添加才会触发。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">事件</th>\n<th align=\"center\">水平触发</th>\n<th align=\"center\">边沿触发</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">POLLIN</td>\n<td align=\"center\">接收缓存有数据就一直触发</td>\n<td align=\"center\">接收缓存有新数据来就触发</td>\n</tr>\n<tr>\n<td align=\"center\">POLLOUT</td>\n<td align=\"center\">发送缓存未满就一致触发</td>\n<td align=\"center\">发送数据就触发</td>\n</tr>\n<tr>\n<td align=\"center\">POLLRDHUP</td>\n<td align=\"center\">对端写关闭，本端就触发，同时触发POLLIN</td>\n<td align=\"center\">同水平</td>\n</tr>\n<tr>\n<td align=\"center\">POLLHUP</td>\n<td align=\"center\">连接关闭，同时触发POLLIN&#x2F;POLLOUT事件（用户添加过什么事件就触发什么事件）</td>\n<td align=\"center\">同水平</td>\n</tr>\n</tbody></table>\n<h2 id=\"Poller的实现\"><a href=\"#Poller的实现\" class=\"headerlink\" title=\"Poller的实现\"></a>Poller的实现</h2><p>简单提一下，在Muduo中，Poller是对原生的linux下，C语言的IO多路复用接口进行了封装，毕竟面向对象用起来更舒服。Poller会在EventLoop中使用。具体，怎么使用，在下一章节，讲到EventLoop时，才会有所领悟，这里可以所见即所得，知道Poller就是封装IO多路复用的即可。</p>\n<p><strong>Poller提供的接口：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Poller</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;Channel*&gt; ChannelList;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Poller</span>(EventLoop* loop);</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Poller</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Polls the I/O events.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the loop thread.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Timestamp <span class=\"title\">poll</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMs, ChannelList* activeChannels)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Changes the interested I/O events.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the loop thread.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">updateChannel</span><span class=\"params\">(Channel* channel)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Remove the channel, when it destructs.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the loop thread.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">removeChannel</span><span class=\"params\">(Channel* channel)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">hasChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> Poller* <span class=\"title\">newDefaultPoller</span><span class=\"params\">(EventLoop* loop)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assertInLoopThread</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        ownerLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::map&lt;<span class=\"type\">int</span>, Channel*&gt; ChannelMap; </span><br><span class=\"line\">    ChannelMap channels_;<span class=\"comment\">// fd到channel的映射</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    EventLoop* ownerLoop_;  <span class=\"comment\">// 所属的EventLoop</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Poller实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Poller::<span class=\"built_in\">Poller</span>(EventLoop* loop)</span><br><span class=\"line\">  : <span class=\"built_in\">ownerLoop_</span>(loop)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Poller::~<span class=\"built_in\">Poller</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Poller::hasChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    ChannelMap::const_iterator it = channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> it != channels_.<span class=\"built_in\">end</span>() &amp;&amp; it-&gt;second == channel;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>因为Muduo继承Poller实现了EPollPoller、PollPoller，考虑到篇幅有限，这里讲一下PollPoller的实现吧。</p>\n<h3 id=\"PollPoller的实现\"><a href=\"#PollPoller的实现\" class=\"headerlink\" title=\"PollPoller的实现\"></a>PollPoller的实现</h3><p>在muduo网络库中，PollPoller 是对 poll() 系统调用的封装，用于实现事件循环（EventLoop）中的事件分发。PollPoller 负责将 Channel管理的文件描述符注册到 poll() 中，监听各个文件描述符的事件。</p>\n<p>以下是对 PollPoller 的简要介绍：</p>\n<ol>\n<li><p>文件位置： PollPoller 类的实现通常位于 PollPoller.cc 文件中。</p>\n</li>\n<li><p>继承关系： PollPoller 类继承自 Poller 类，而 Poller 类是对事件轮询机制的抽象。</p>\n</li>\n<li><p>主要方法： 重要的方法包括 poll 和 fillActiveChannels。</p>\n<ul>\n<li>poll 方法负责调用 poll() 系统调用，等待事件发生。</li>\n<li>fillActiveChannels 方法用于将 poll() 返回的就绪事件填充到 activeChannels 中。</li>\n</ul>\n</li>\n<li><p>事件分发： PollPoller 通过 EventLoop 实现了事件的分发。当有事件发生时，PollPoller 会通知 EventLoop，而后 EventLoop 会调用相应的 Channel 的handleEvent进行事件处理。</p>\n</li>\n</ol>\n<p><strong>提供的接口</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PollPoller</span> : <span class=\"keyword\">public</span> Poller&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">PollPoller</span>(EventLoop* loop);</span><br><span class=\"line\">    ~<span class=\"built_in\">PollPoller</span>() <span class=\"keyword\">override</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Timestamp <span class=\"title\">poll</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMs, ChannelList* activeChannels)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fillActiveChannels</span><span class=\"params\">(<span class=\"type\">int</span> numEvents,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            ChannelList* activeChannels)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * struct pollfd定义如下：</span></span><br><span class=\"line\"><span class=\"comment\">    *    struct pollfd &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    *        int   fd;     // 监听的文件描述符    </span></span><br><span class=\"line\"><span class=\"comment\">    *       short events;   // 要监听的事件</span></span><br><span class=\"line\"><span class=\"comment\">    *        short revents; // 监听到得到事件</span></span><br><span class=\"line\"><span class=\"comment\">    *    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;<span class=\"keyword\">struct</span> pollfd&gt; PollFdList;</span><br><span class=\"line\">    PollFdList pollfds_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>实现的伪代码</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PollPoller::<span class=\"built_in\">PollPoller</span>(EventLoop* loop)</span><br><span class=\"line\">  : <span class=\"built_in\">Poller</span>(loop)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PollPoller::~<span class=\"built_in\">PollPoller</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提供给EventLoop的接口，也是EventLoop 等待事件的程序点。</span></span><br><span class=\"line\"><span class=\"function\">Timestamp <span class=\"title\">PollPoller::poll</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMs, ChannelList* activeChannels)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 等待事件到来，或者超时</span></span><br><span class=\"line\">    <span class=\"comment\">// XXX pollfds_ shouldn&#x27;t change</span></span><br><span class=\"line\">    <span class=\"type\">int</span> numEvents = ::<span class=\"built_in\">poll</span>(&amp;*pollfds_.<span class=\"built_in\">begin</span>(), pollfds_.<span class=\"built_in\">size</span>(), timeoutMs);</span><br><span class=\"line\">    <span class=\"type\">int</span> savedErrno = errno;</span><br><span class=\"line\">    <span class=\"function\">Timestamp <span class=\"title\">now</span><span class=\"params\">(Timestamp::now())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numEvents &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">fillActiveChannels</span>(numEvents, activeChannels);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (numEvents == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        LOG_TRACE &lt;&lt; <span class=\"string\">&quot; nothing happened&quot;</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (savedErrno != EINTR)&#123;   <span class=\"comment\">// 中断</span></span><br><span class=\"line\">            errno = savedErrno;</span><br><span class=\"line\">            LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;PollPoller::poll()&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> now;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PollPoller::fillActiveChannels</span><span class=\"params\">(<span class=\"type\">int</span> numEvents,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                    ChannelList* activeChannels)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将所有发生事件的fd对应的channel，收集到activeChannels，供EventLoop处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (PollFdList::const_iterator pfd = pollfds_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        pfd != pollfds_.<span class=\"built_in\">end</span>() &amp;&amp; numEvents &gt; <span class=\"number\">0</span>; ++pfd)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pfd-&gt;revents &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            --numEvents;</span><br><span class=\"line\">            ChannelMap::const_iterator ch = channels_.<span class=\"built_in\">find</span>(pfd-&gt;fd);</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(ch != channels_.<span class=\"built_in\">end</span>());   <span class=\"comment\">//一定要存在</span></span><br><span class=\"line\">            Channel* channel = ch-&gt;second;</span><br><span class=\"line\">            channel-&gt;<span class=\"built_in\">set_revents</span>(pfd-&gt;revents);</span><br><span class=\"line\">            <span class=\"comment\">// pfd-&gt;revents = 0;    // poll会自动清零</span></span><br><span class=\"line\">            activeChannels-&gt;<span class=\"built_in\">push_back</span>(channel);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PollPoller::updateChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    Poller::<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel-&gt;<span class=\"built_in\">index</span>() &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新的channel</span></span><br><span class=\"line\">        <span class=\"comment\">// a new one, add to pollfds_</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>()) == channels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">pollfd</span> pfd;</span><br><span class=\"line\">        pfd.fd = channel-&gt;<span class=\"built_in\">fd</span>();</span><br><span class=\"line\">        pfd.events = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">short</span>&gt;(channel-&gt;<span class=\"built_in\">events</span>());</span><br><span class=\"line\">        pfd.revents = <span class=\"number\">0</span>;</span><br><span class=\"line\">        pollfds_.<span class=\"built_in\">push_back</span>(pfd);</span><br><span class=\"line\">        <span class=\"type\">int</span> idx = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(pollfds_.<span class=\"built_in\">size</span>())<span class=\"number\">-1</span>;</span><br><span class=\"line\">        channel-&gt;<span class=\"built_in\">set_index</span>(idx);</span><br><span class=\"line\">        channels_[pfd.fd] = channel;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// update existing one</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>()) != channels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"type\">int</span> idx = channel-&gt;<span class=\"built_in\">index</span>();</span><br><span class=\"line\">        <span class=\"comment\">// idx 有效</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"number\">0</span> &lt;= idx &amp;&amp; idx &lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(pollfds_.<span class=\"built_in\">size</span>()));</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">pollfd</span>&amp; pfd = pollfds_[idx];</span><br><span class=\"line\">        <span class=\"comment\">// fd对的上，或者，因为之前不需要监听，被置为-(fd + 1)保证为负，这样，poll不会监听fd为负的channel。</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(pfd.fd == channel-&gt;<span class=\"built_in\">fd</span>() || pfd.fd == -channel-&gt;<span class=\"built_in\">fd</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        pfd.fd = channel-&gt;<span class=\"built_in\">fd</span>();</span><br><span class=\"line\">        pfd.events = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">short</span>&gt;(channel-&gt;<span class=\"built_in\">events</span>());</span><br><span class=\"line\">        pfd.revents = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channel-&gt;<span class=\"built_in\">isNoneEvent</span>())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 事件为空，置为负。</span></span><br><span class=\"line\">            <span class=\"comment\">// ignore this pollfd</span></span><br><span class=\"line\">            pfd.fd = -channel-&gt;<span class=\"built_in\">fd</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PollPoller::removeChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    Poller::<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>()) != channels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channels_[channel-&gt;<span class=\"built_in\">fd</span>()] == channel);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channel-&gt;<span class=\"built_in\">isNoneEvent</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> idx = channel-&gt;<span class=\"built_in\">index</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"number\">0</span> &lt;= idx &amp;&amp; idx &lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(pollfds_.<span class=\"built_in\">size</span>()));</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">pollfd</span>&amp; pfd = pollfds_[idx]; (<span class=\"type\">void</span>)pfd;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(pfd.fd == -channel-&gt;<span class=\"built_in\">fd</span>()<span class=\"number\">-1</span> &amp;&amp; pfd.events == channel-&gt;<span class=\"built_in\">events</span>());</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = channels_.<span class=\"built_in\">erase</span>(channel-&gt;<span class=\"built_in\">fd</span>());</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(n == <span class=\"number\">1</span>); (<span class=\"type\">void</span>)n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * 因为poll是基于数组做轮询，考虑到数组的删除代价很大，所以Muduo在这里</span></span><br><span class=\"line\"><span class=\"comment\">    * 做了一个优化：如果删除的fd正好是数组尾部，直接pop_back即可，否则，</span></span><br><span class=\"line\"><span class=\"comment\">    * 把要删除的fd和数组最后一个元素做交换，并通过父类的channels_设置原来</span></span><br><span class=\"line\"><span class=\"comment\">    * 最后一个fd对应的cahnnel的index。最后，删除数组最后一个需要删除的fd即</span></span><br><span class=\"line\"><span class=\"comment\">    * 可。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">implicit_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(idx) == pollfds_.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        pollfds_.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> channelAtEnd = pollfds_.<span class=\"built_in\">back</span>().fd;</span><br><span class=\"line\">        <span class=\"built_in\">iter_swap</span>(pollfds_.<span class=\"built_in\">begin</span>()+idx, pollfds_.<span class=\"built_in\">end</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channelAtEnd &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            channelAtEnd = -channelAtEnd<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        channels_[channelAtEnd]-&gt;<span class=\"built_in\">set_index</span>(idx);</span><br><span class=\"line\">        pollfds_.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"细节明细\"><a href=\"#细节明细\" class=\"headerlink\" title=\"细节明细\"></a>细节明细</h2><p><strong>疑问</strong></p>\n<p>Muduo为什么要额外为fd的事件封装一个Channel?</p>\n<p><strong>解答</strong></p>\n<p>Channel和Poller的封装其实有考量Muduo的跨平台，为fd的事件多抽象一层channel，在使用不同平台的IO多路复用接口时，只需编写不同平台的Poller代码，然后触发事件后，统一将事件交由channel由上层统一处理，达到了解耦合的效果。Redis网络部分也做了类似的处理。</p>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>简单讲，Channel就是对文件描述符（fd）的封装，进行事件管理，将fd和对其操作的回调封装在一起，方便，在fd上有IO事件到来时，利用相应的回调来处理IO事件；Poller就是对Linux下各种IO多路复用进行抽象，提供一个统一的接口，该类是一个虚基类。路径.&#x2F;net&#x2F;poller中的源码，就是对Poller的实现，包括：EPollPoller、PollPoller。</p>\n<p>这部分源代码很朴实易懂，代码量也不大，建议读者，亲自看看源码。</p>\n<h2 id=\"Channel的实现\"><a href=\"#Channel的实现\" class=\"headerlink\" title=\"Channel的实现\"></a>Channel的实现</h2><p><strong>提供的接口：</strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Channel</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>()&gt; EventCallback;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(Timestamp)&gt; ReadEventCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Channel</span>(EventLoop* loop, <span class=\"type\">int</span> fd);</span><br><span class=\"line\">    ~<span class=\"built_in\">Channel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleEvent</span><span class=\"params\">(Timestamp receiveTime)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setReadCallback</span><span class=\"params\">(ReadEventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; readCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWriteCallback</span><span class=\"params\">(EventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; writeCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setCloseCallback</span><span class=\"params\">(EventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; closeCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setErrorCallback</span><span class=\"params\">(EventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; errorCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Tie this channel to the owner object managed by shared_ptr,</span></span><br><span class=\"line\">    <span class=\"comment\">/// prevent the owner object being destroyed in handleEvent.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">tie</span><span class=\"params\">(<span class=\"type\">const</span> std::shared_ptr&lt;<span class=\"type\">void</span>&gt;&amp;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fd</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> fd_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">events</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_revents</span><span class=\"params\">(<span class=\"type\">int</span> revt)</span> </span>&#123; revents_ = revt; &#125; <span class=\"comment\">// used by pollers</span></span><br><span class=\"line\">    <span class=\"comment\">// int revents() const &#123; return revents_; &#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isNoneEvent</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_ == kNoneEvent; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enableReading</span><span class=\"params\">()</span> </span>&#123; events_ |= kReadEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disableReading</span><span class=\"params\">()</span> </span>&#123; events_ &amp;= ~kReadEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enableWriting</span><span class=\"params\">()</span> </span>&#123; events_ |= kWriteEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disableWriting</span><span class=\"params\">()</span> </span>&#123; events_ &amp;= ~kWriteEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disableAll</span><span class=\"params\">()</span> </span>&#123; events_ = kNoneEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isWriting</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_ &amp; kWriteEvent; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isReading</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_ &amp; kReadEvent; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for Poller</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">index</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> index_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_index</span><span class=\"params\">(<span class=\"type\">int</span> idx)</span> </span>&#123; index_ = idx; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for debug</span></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">reventsToString</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">eventsToString</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">doNotLogHup</span><span class=\"params\">()</span> </span>&#123; logHup_ = <span class=\"literal\">false</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">ownerLoop</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> loop_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> string <span class=\"title\">eventsToString</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span> ev)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleEventWithGuard</span><span class=\"params\">(Timestamp receiveTime)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kNoneEvent;  <span class=\"comment\">// 0</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kReadEvent;  <span class=\"comment\">// POLLIN | POLLPRI</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kWriteEvent; <span class=\"comment\">// POLLOUT</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// channel被那个EventLoop监听</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span>  fd_; <span class=\"comment\">// fd</span></span><br><span class=\"line\">    <span class=\"type\">int</span>        events_;</span><br><span class=\"line\">    <span class=\"type\">int</span>        revents_; <span class=\"comment\">// it&#x27;s the received event types of epoll or poll // 触发的事件</span></span><br><span class=\"line\">    <span class=\"type\">int</span>        index_; <span class=\"comment\">// used by Poller.</span></span><br><span class=\"line\">    <span class=\"type\">bool</span>       logHup_;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::weak_ptr&lt;<span class=\"type\">void</span>&gt; tie_;   <span class=\"comment\">// 主要解决循环引用的问题</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> tied_;</span><br><span class=\"line\">    <span class=\"type\">bool</span> eventHandling_;  <span class=\"comment\">// 正在handleEventWithGuard中处理事件</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> addedToLoop_;  <span class=\"comment\">// 被添加到EventLoop了没？</span></span><br><span class=\"line\">    ReadEventCallback readCallback_;  <span class=\"comment\">// 读回调</span></span><br><span class=\"line\">    EventCallback writeCallback_; <span class=\"comment\">// 写回调</span></span><br><span class=\"line\">    EventCallback closeCallback_; <span class=\"comment\">// 连接断开回调</span></span><br><span class=\"line\">    EventCallback errorCallback_; <span class=\"comment\">// 错误处理回调</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Channel::<span class=\"built_in\">Channel</span>(EventLoop* loop, <span class=\"type\">int</span> fd__)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(loop),</span><br><span class=\"line\">    <span class=\"built_in\">fd_</span>(fd__),</span><br><span class=\"line\">    <span class=\"built_in\">events_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">revents_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">index_</span>(<span class=\"number\">-1</span>),</span><br><span class=\"line\">    <span class=\"built_in\">logHup_</span>(<span class=\"literal\">true</span>),</span><br><span class=\"line\">    <span class=\"built_in\">tied_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">eventHandling_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">addedToLoop_</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Channel::~<span class=\"built_in\">Channel</span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!eventHandling_);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!addedToLoop_);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loop_-&gt;<span class=\"built_in\">isInLoopThread</span>())&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 该channel即将销毁，不能被EventLoop监听</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(!loop_-&gt;<span class=\"built_in\">hasChannel</span>(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::tie</span><span class=\"params\">(<span class=\"type\">const</span> std::shared_ptr&lt;<span class=\"type\">void</span>&gt;&amp; obj)</span></span>&#123;</span><br><span class=\"line\">    tie_ = obj;   <span class=\"comment\">// 循环依赖，做生命周期的绑定</span></span><br><span class=\"line\">    tied_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::update</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在EventLoop中进行fd的事件更新</span></span><br><span class=\"line\">    addedToLoop_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">updateChannel</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::remove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 取消EventLoop对channel的监听</span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"built_in\">isNoneEvent</span>());</span><br><span class=\"line\">    addedToLoop_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">removeChannel</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::handleEvent</span><span class=\"params\">(Timestamp receiveTime)</span></span>&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;<span class=\"type\">void</span>&gt; guard;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tied_)&#123;</span><br><span class=\"line\">        guard = tie_.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (guard)&#123; <span class=\"comment\">// 保证依赖对象没有被释放</span></span><br><span class=\"line\">            <span class=\"built_in\">handleEventWithGuard</span>(receiveTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">handleEventWithGuard</span>(receiveTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::handleEventWithGuard</span><span class=\"params\">(Timestamp receiveTime)</span></span>&#123;</span><br><span class=\"line\">    eventHandling_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 连接断开，并且fd上没有可读数据（默认水平触发）</span></span><br><span class=\"line\">        <span class=\"comment\">// 调用关闭回调</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (closeCallback_) <span class=\"built_in\">closeCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (revents_ &amp; (POLLERR | POLLNVAL))&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 错误处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errorCallback_) <span class=\"built_in\">errorCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可读</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (readCallback_) <span class=\"built_in\">readCallback_</span>(receiveTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (revents_ &amp; POLLOUT)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可写</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (writeCallback_) <span class=\"built_in\">writeCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eventHandling_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong></p>\n<p><strong>智能指针不是万能的，并不能解决cpp所有内存泄露的问题！！！</strong></p>\n<p>这里多提一句，关于循环引用这种头疼的问题，几个类可能很容易看出来，但是如果项目太大，涉及的类太多，就很容出现循环引用导致内存泄漏的问题！而且难以察觉。所以，在类的设计上，要特别注意这个坑。</p>\n<p>自引用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    std::shared_ptr&lt;Node&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Node</span>() &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Node constructed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">Node</span>() &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Node destructed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;Node&gt; node1 = std::<span class=\"built_in\">make_shared</span>&lt;Node&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    node1-&gt;next = node1;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost muduo]# g++ -Wall -std=c++11 -o test.bin test.cc </span><br><span class=\"line\">[root@localhost muduo]# </span><br><span class=\"line\">[root@localhost muduo]# </span><br><span class=\"line\">[root@localhost muduo]# ./test.bin </span><br><span class=\"line\">Node constructed</span><br><span class=\"line\">[root@localhost muduo]#</span><br></pre></td></tr></table></figure>\n\n<p><strong>多个类间的循环引用是同理的，一般是靠weak_ptr解决，单个类的自引用的化话，目前无解。</strong></p>\n<h3 id=\"细节明细：\"><a href=\"#细节明细：\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h3><p><strong>疑问：</strong></p>\n<p>Muduo中Channel的成员变量<code>std::weak_ptr&lt;void&gt; tie_</code>有什么意义？</p>\n<p><strong>解答：</strong></p>\n<p>使用std::weak_ptr的目的是为了避免循环引用（circular reference），因为TcpConnection对象通常也会持有一个指向Channel的指针。通过使用std::weak_ptr，可以避免引发循环引用导致对象无法正确释放的问题。</p>\n<p><strong>疑问：</strong></p>\n<p>fd上何时返回POLLHUP又何时返回POLLRDHUP？（POLLIN&#x2F;POLLOUT呢？）</p>\n<p><strong>解答：</strong></p>\n<p>有写过一个deamo（有时间再写这方面的博客）专门测试这些事件触发条件，实验表明，POLLHUP事件一般是系统默认添加的事件，在连接关闭时会触发，而POLLIN&#x2F;POLLOUT&#x2F;POLLRDHUP等，需要用户手动添加才会触发。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">事件</th>\n<th align=\"center\">水平触发</th>\n<th align=\"center\">边沿触发</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">POLLIN</td>\n<td align=\"center\">接收缓存有数据就一直触发</td>\n<td align=\"center\">接收缓存有新数据来就触发</td>\n</tr>\n<tr>\n<td align=\"center\">POLLOUT</td>\n<td align=\"center\">发送缓存未满就一致触发</td>\n<td align=\"center\">发送数据就触发</td>\n</tr>\n<tr>\n<td align=\"center\">POLLRDHUP</td>\n<td align=\"center\">对端写关闭，本端就触发，同时触发POLLIN</td>\n<td align=\"center\">同水平</td>\n</tr>\n<tr>\n<td align=\"center\">POLLHUP</td>\n<td align=\"center\">连接关闭，同时触发POLLIN&#x2F;POLLOUT事件（用户添加过什么事件就触发什么事件）</td>\n<td align=\"center\">同水平</td>\n</tr>\n</tbody></table>\n<h2 id=\"Poller的实现\"><a href=\"#Poller的实现\" class=\"headerlink\" title=\"Poller的实现\"></a>Poller的实现</h2><p>简单提一下，在Muduo中，Poller是对原生的linux下，C语言的IO多路复用接口进行了封装，毕竟面向对象用起来更舒服。Poller会在EventLoop中使用。具体，怎么使用，在下一章节，讲到EventLoop时，才会有所领悟，这里可以所见即所得，知道Poller就是封装IO多路复用的即可。</p>\n<p><strong>Poller提供的接口：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Poller</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;Channel*&gt; ChannelList;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Poller</span>(EventLoop* loop);</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Poller</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Polls the I/O events.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the loop thread.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Timestamp <span class=\"title\">poll</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMs, ChannelList* activeChannels)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Changes the interested I/O events.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the loop thread.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">updateChannel</span><span class=\"params\">(Channel* channel)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Remove the channel, when it destructs.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the loop thread.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">removeChannel</span><span class=\"params\">(Channel* channel)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">hasChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> Poller* <span class=\"title\">newDefaultPoller</span><span class=\"params\">(EventLoop* loop)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assertInLoopThread</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        ownerLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::map&lt;<span class=\"type\">int</span>, Channel*&gt; ChannelMap; </span><br><span class=\"line\">    ChannelMap channels_;<span class=\"comment\">// fd到channel的映射</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    EventLoop* ownerLoop_;  <span class=\"comment\">// 所属的EventLoop</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Poller实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Poller::<span class=\"built_in\">Poller</span>(EventLoop* loop)</span><br><span class=\"line\">  : <span class=\"built_in\">ownerLoop_</span>(loop)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Poller::~<span class=\"built_in\">Poller</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Poller::hasChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    ChannelMap::const_iterator it = channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> it != channels_.<span class=\"built_in\">end</span>() &amp;&amp; it-&gt;second == channel;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>因为Muduo继承Poller实现了EPollPoller、PollPoller，考虑到篇幅有限，这里讲一下PollPoller的实现吧。</p>\n<h3 id=\"PollPoller的实现\"><a href=\"#PollPoller的实现\" class=\"headerlink\" title=\"PollPoller的实现\"></a>PollPoller的实现</h3><p>在muduo网络库中，PollPoller 是对 poll() 系统调用的封装，用于实现事件循环（EventLoop）中的事件分发。PollPoller 负责将 Channel管理的文件描述符注册到 poll() 中，监听各个文件描述符的事件。</p>\n<p>以下是对 PollPoller 的简要介绍：</p>\n<ol>\n<li><p>文件位置： PollPoller 类的实现通常位于 PollPoller.cc 文件中。</p>\n</li>\n<li><p>继承关系： PollPoller 类继承自 Poller 类，而 Poller 类是对事件轮询机制的抽象。</p>\n</li>\n<li><p>主要方法： 重要的方法包括 poll 和 fillActiveChannels。</p>\n<ul>\n<li>poll 方法负责调用 poll() 系统调用，等待事件发生。</li>\n<li>fillActiveChannels 方法用于将 poll() 返回的就绪事件填充到 activeChannels 中。</li>\n</ul>\n</li>\n<li><p>事件分发： PollPoller 通过 EventLoop 实现了事件的分发。当有事件发生时，PollPoller 会通知 EventLoop，而后 EventLoop 会调用相应的 Channel 的handleEvent进行事件处理。</p>\n</li>\n</ol>\n<p><strong>提供的接口</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PollPoller</span> : <span class=\"keyword\">public</span> Poller&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">PollPoller</span>(EventLoop* loop);</span><br><span class=\"line\">    ~<span class=\"built_in\">PollPoller</span>() <span class=\"keyword\">override</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Timestamp <span class=\"title\">poll</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMs, ChannelList* activeChannels)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fillActiveChannels</span><span class=\"params\">(<span class=\"type\">int</span> numEvents,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            ChannelList* activeChannels)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * struct pollfd定义如下：</span></span><br><span class=\"line\"><span class=\"comment\">    *    struct pollfd &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    *        int   fd;     // 监听的文件描述符    </span></span><br><span class=\"line\"><span class=\"comment\">    *       short events;   // 要监听的事件</span></span><br><span class=\"line\"><span class=\"comment\">    *        short revents; // 监听到得到事件</span></span><br><span class=\"line\"><span class=\"comment\">    *    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;<span class=\"keyword\">struct</span> pollfd&gt; PollFdList;</span><br><span class=\"line\">    PollFdList pollfds_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>实现的伪代码</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PollPoller::<span class=\"built_in\">PollPoller</span>(EventLoop* loop)</span><br><span class=\"line\">  : <span class=\"built_in\">Poller</span>(loop)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PollPoller::~<span class=\"built_in\">PollPoller</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提供给EventLoop的接口，也是EventLoop 等待事件的程序点。</span></span><br><span class=\"line\"><span class=\"function\">Timestamp <span class=\"title\">PollPoller::poll</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMs, ChannelList* activeChannels)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 等待事件到来，或者超时</span></span><br><span class=\"line\">    <span class=\"comment\">// XXX pollfds_ shouldn&#x27;t change</span></span><br><span class=\"line\">    <span class=\"type\">int</span> numEvents = ::<span class=\"built_in\">poll</span>(&amp;*pollfds_.<span class=\"built_in\">begin</span>(), pollfds_.<span class=\"built_in\">size</span>(), timeoutMs);</span><br><span class=\"line\">    <span class=\"type\">int</span> savedErrno = errno;</span><br><span class=\"line\">    <span class=\"function\">Timestamp <span class=\"title\">now</span><span class=\"params\">(Timestamp::now())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numEvents &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">fillActiveChannels</span>(numEvents, activeChannels);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (numEvents == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        LOG_TRACE &lt;&lt; <span class=\"string\">&quot; nothing happened&quot;</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (savedErrno != EINTR)&#123;   <span class=\"comment\">// 中断</span></span><br><span class=\"line\">            errno = savedErrno;</span><br><span class=\"line\">            LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;PollPoller::poll()&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> now;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PollPoller::fillActiveChannels</span><span class=\"params\">(<span class=\"type\">int</span> numEvents,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                    ChannelList* activeChannels)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将所有发生事件的fd对应的channel，收集到activeChannels，供EventLoop处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (PollFdList::const_iterator pfd = pollfds_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        pfd != pollfds_.<span class=\"built_in\">end</span>() &amp;&amp; numEvents &gt; <span class=\"number\">0</span>; ++pfd)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pfd-&gt;revents &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            --numEvents;</span><br><span class=\"line\">            ChannelMap::const_iterator ch = channels_.<span class=\"built_in\">find</span>(pfd-&gt;fd);</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(ch != channels_.<span class=\"built_in\">end</span>());   <span class=\"comment\">//一定要存在</span></span><br><span class=\"line\">            Channel* channel = ch-&gt;second;</span><br><span class=\"line\">            channel-&gt;<span class=\"built_in\">set_revents</span>(pfd-&gt;revents);</span><br><span class=\"line\">            <span class=\"comment\">// pfd-&gt;revents = 0;    // poll会自动清零</span></span><br><span class=\"line\">            activeChannels-&gt;<span class=\"built_in\">push_back</span>(channel);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PollPoller::updateChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    Poller::<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel-&gt;<span class=\"built_in\">index</span>() &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新的channel</span></span><br><span class=\"line\">        <span class=\"comment\">// a new one, add to pollfds_</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>()) == channels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">pollfd</span> pfd;</span><br><span class=\"line\">        pfd.fd = channel-&gt;<span class=\"built_in\">fd</span>();</span><br><span class=\"line\">        pfd.events = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">short</span>&gt;(channel-&gt;<span class=\"built_in\">events</span>());</span><br><span class=\"line\">        pfd.revents = <span class=\"number\">0</span>;</span><br><span class=\"line\">        pollfds_.<span class=\"built_in\">push_back</span>(pfd);</span><br><span class=\"line\">        <span class=\"type\">int</span> idx = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(pollfds_.<span class=\"built_in\">size</span>())<span class=\"number\">-1</span>;</span><br><span class=\"line\">        channel-&gt;<span class=\"built_in\">set_index</span>(idx);</span><br><span class=\"line\">        channels_[pfd.fd] = channel;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// update existing one</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>()) != channels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"type\">int</span> idx = channel-&gt;<span class=\"built_in\">index</span>();</span><br><span class=\"line\">        <span class=\"comment\">// idx 有效</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"number\">0</span> &lt;= idx &amp;&amp; idx &lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(pollfds_.<span class=\"built_in\">size</span>()));</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">pollfd</span>&amp; pfd = pollfds_[idx];</span><br><span class=\"line\">        <span class=\"comment\">// fd对的上，或者，因为之前不需要监听，被置为-(fd + 1)保证为负，这样，poll不会监听fd为负的channel。</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(pfd.fd == channel-&gt;<span class=\"built_in\">fd</span>() || pfd.fd == -channel-&gt;<span class=\"built_in\">fd</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        pfd.fd = channel-&gt;<span class=\"built_in\">fd</span>();</span><br><span class=\"line\">        pfd.events = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">short</span>&gt;(channel-&gt;<span class=\"built_in\">events</span>());</span><br><span class=\"line\">        pfd.revents = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channel-&gt;<span class=\"built_in\">isNoneEvent</span>())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 事件为空，置为负。</span></span><br><span class=\"line\">            <span class=\"comment\">// ignore this pollfd</span></span><br><span class=\"line\">            pfd.fd = -channel-&gt;<span class=\"built_in\">fd</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PollPoller::removeChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    Poller::<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>()) != channels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channels_[channel-&gt;<span class=\"built_in\">fd</span>()] == channel);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channel-&gt;<span class=\"built_in\">isNoneEvent</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> idx = channel-&gt;<span class=\"built_in\">index</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"number\">0</span> &lt;= idx &amp;&amp; idx &lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(pollfds_.<span class=\"built_in\">size</span>()));</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">pollfd</span>&amp; pfd = pollfds_[idx]; (<span class=\"type\">void</span>)pfd;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(pfd.fd == -channel-&gt;<span class=\"built_in\">fd</span>()<span class=\"number\">-1</span> &amp;&amp; pfd.events == channel-&gt;<span class=\"built_in\">events</span>());</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = channels_.<span class=\"built_in\">erase</span>(channel-&gt;<span class=\"built_in\">fd</span>());</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(n == <span class=\"number\">1</span>); (<span class=\"type\">void</span>)n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * 因为poll是基于数组做轮询，考虑到数组的删除代价很大，所以Muduo在这里</span></span><br><span class=\"line\"><span class=\"comment\">    * 做了一个优化：如果删除的fd正好是数组尾部，直接pop_back即可，否则，</span></span><br><span class=\"line\"><span class=\"comment\">    * 把要删除的fd和数组最后一个元素做交换，并通过父类的channels_设置原来</span></span><br><span class=\"line\"><span class=\"comment\">    * 最后一个fd对应的cahnnel的index。最后，删除数组最后一个需要删除的fd即</span></span><br><span class=\"line\"><span class=\"comment\">    * 可。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">implicit_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(idx) == pollfds_.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        pollfds_.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> channelAtEnd = pollfds_.<span class=\"built_in\">back</span>().fd;</span><br><span class=\"line\">        <span class=\"built_in\">iter_swap</span>(pollfds_.<span class=\"built_in\">begin</span>()+idx, pollfds_.<span class=\"built_in\">end</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channelAtEnd &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            channelAtEnd = -channelAtEnd<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        channels_[channelAtEnd]-&gt;<span class=\"built_in\">set_index</span>(idx);</span><br><span class=\"line\">        pollfds_.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"细节明细\"><a href=\"#细节明细\" class=\"headerlink\" title=\"细节明细\"></a>细节明细</h2><p><strong>疑问</strong></p>\n<p>Muduo为什么要额外为fd的事件封装一个Channel?</p>\n<p><strong>解答</strong></p>\n<p>Channel和Poller的封装其实有考量Muduo的跨平台，为fd的事件多抽象一层channel，在使用不同平台的IO多路复用接口时，只需编写不同平台的Poller代码，然后触发事件后，统一将事件交由channel由上层统一处理，达到了解耦合的效果。Redis网络部分也做了类似的处理。</p>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"muduo源码阅读笔记（0、下载编译muduo）","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n[muduo源码阅读笔记（11、TcpClient）](./TcpClient.md)\n\n## 环境搭建以及下载安装\n\n<!-- more -->\n```bash\ngit clone https://github.com/chenshuo/muduo.git #源码下载\n\n# 安装依赖项\nyum install cmake   # cmake安装\nyum install boost-devel # boost库\n\n# 创建build目录\ncd muduo\nmkdir build\ncd build\n\n# 在build目录生成makefile文件\ncmake ..\n\n# 编译\nmake -j4\n\n# 安装（可忽略）\nmake install\n```\n\n## 编译错误的解决\n\n**我编译时唯一遇到的错误如下：**\n\n```bash\n/root/workspace/muduo/muduo/base/TimeZone.cc:171:36: error: conversion to ‘int’ from ‘long unsigned int’ may alter its value [-Werror=conversion]\n   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);\n                                    ^\n/root/workspace/muduo/muduo/base/TimeZone.cc:171:54: error: conversion to ‘int’ from ‘long unsigned int’ may alter its value [-Werror=conversion]\n   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);\n                                                      ^\ncc1plus: all warnings being treated as errors\nmake[2]: *** [muduo/base/CMakeFiles/muduo_base.dir/TimeZone.cc.o] Error 1\nmake[2]: *** Waiting for unfinished jobs....\nmake[1]: *** [muduo/base/CMakeFiles/muduo_base.dir/all] Error 2\nmake: *** [all] Error 2\n```\n\n查阅资料得知：\n\n> 该错误是由于编译时启用了 `-Werror=conversion` 选项，该选项会将警告视为错误。在这里，编译器提示可能由于从 long unsigned int 到 int 的转换而导致值的变化。\n\n在项目的根目录的CMakeLists.txt文件中，将`-Werror`选项注释即可，此时警告不会被视为错误。\n\n---\n\n**本章完结**","source":"_posts/muduo/Start.md","raw":"---\ntitle: muduo源码阅读笔记（0、下载编译muduo）\ndate: 2024-11-02 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n[muduo源码阅读笔记（11、TcpClient）](./TcpClient.md)\n\n## 环境搭建以及下载安装\n\n<!-- more -->\n```bash\ngit clone https://github.com/chenshuo/muduo.git #源码下载\n\n# 安装依赖项\nyum install cmake   # cmake安装\nyum install boost-devel # boost库\n\n# 创建build目录\ncd muduo\nmkdir build\ncd build\n\n# 在build目录生成makefile文件\ncmake ..\n\n# 编译\nmake -j4\n\n# 安装（可忽略）\nmake install\n```\n\n## 编译错误的解决\n\n**我编译时唯一遇到的错误如下：**\n\n```bash\n/root/workspace/muduo/muduo/base/TimeZone.cc:171:36: error: conversion to ‘int’ from ‘long unsigned int’ may alter its value [-Werror=conversion]\n   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);\n                                    ^\n/root/workspace/muduo/muduo/base/TimeZone.cc:171:54: error: conversion to ‘int’ from ‘long unsigned int’ may alter its value [-Werror=conversion]\n   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);\n                                                      ^\ncc1plus: all warnings being treated as errors\nmake[2]: *** [muduo/base/CMakeFiles/muduo_base.dir/TimeZone.cc.o] Error 1\nmake[2]: *** Waiting for unfinished jobs....\nmake[1]: *** [muduo/base/CMakeFiles/muduo_base.dir/all] Error 2\nmake: *** [all] Error 2\n```\n\n查阅资料得知：\n\n> 该错误是由于编译时启用了 `-Werror=conversion` 选项，该选项会将警告视为错误。在这里，编译器提示可能由于从 long unsigned int 到 int 的转换而导致值的变化。\n\n在项目的根目录的CMakeLists.txt文件中，将`-Werror`选项注释即可，此时警告不会被视为错误。\n\n---\n\n**本章完结**","slug":"muduo/Start","published":1,"updated":"2025-09-28T16:06:43.130Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9o000aq8ws7nc90xlj","content":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><a href=\"./TcpClient.md\">muduo源码阅读笔记（11、TcpClient）</a></p>\n<h2 id=\"环境搭建以及下载安装\"><a href=\"#环境搭建以及下载安装\" class=\"headerlink\" title=\"环境搭建以及下载安装\"></a>环境搭建以及下载安装</h2><span id=\"more\"></span>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/chenshuo/muduo.git <span class=\"comment\">#源码下载</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装依赖项</span></span><br><span class=\"line\">yum install cmake   <span class=\"comment\"># cmake安装</span></span><br><span class=\"line\">yum install boost-devel <span class=\"comment\"># boost库</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建build目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> muduo</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> build</span><br><span class=\"line\"><span class=\"built_in\">cd</span> build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在build目录生成makefile文件</span></span><br><span class=\"line\">cmake ..</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译</span></span><br><span class=\"line\">make -j4</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装（可忽略）</span></span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"编译错误的解决\"><a href=\"#编译错误的解决\" class=\"headerlink\" title=\"编译错误的解决\"></a>编译错误的解决</h2><p><strong>我编译时唯一遇到的错误如下：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/root/workspace/muduo/muduo/base/TimeZone.cc:171:36: error: conversion to ‘int’ from ‘long unsigned int’ may alter its value [-Werror=conversion]</span><br><span class=\"line\">   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);</span><br><span class=\"line\">                                    ^</span><br><span class=\"line\">/root/workspace/muduo/muduo/base/TimeZone.cc:171:54: error: conversion to ‘int’ from ‘long unsigned int’ may alter its value [-Werror=conversion]</span><br><span class=\"line\">   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);</span><br><span class=\"line\">                                                      ^</span><br><span class=\"line\">cc1plus: all warnings being treated as errors</span><br><span class=\"line\">make[2]: *** [muduo/base/CMakeFiles/muduo_base.dir/TimeZone.cc.o] Error 1</span><br><span class=\"line\">make[2]: *** Waiting <span class=\"keyword\">for</span> unfinished <span class=\"built_in\">jobs</span>....</span><br><span class=\"line\">make[1]: *** [muduo/base/CMakeFiles/muduo_base.dir/all] Error 2</span><br><span class=\"line\">make: *** [all] Error 2</span><br></pre></td></tr></table></figure>\n\n<p>查阅资料得知：</p>\n<blockquote>\n<p>该错误是由于编译时启用了 <code>-Werror=conversion</code> 选项，该选项会将警告视为错误。在这里，编译器提示可能由于从 long unsigned int 到 int 的转换而导致值的变化。</p>\n</blockquote>\n<p>在项目的根目录的CMakeLists.txt文件中，将<code>-Werror</code>选项注释即可，此时警告不会被视为错误。</p>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><a href=\"./TcpClient.md\">muduo源码阅读笔记（11、TcpClient）</a></p>\n<h2 id=\"环境搭建以及下载安装\"><a href=\"#环境搭建以及下载安装\" class=\"headerlink\" title=\"环境搭建以及下载安装\"></a>环境搭建以及下载安装</h2>","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/chenshuo/muduo.git <span class=\"comment\">#源码下载</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装依赖项</span></span><br><span class=\"line\">yum install cmake   <span class=\"comment\"># cmake安装</span></span><br><span class=\"line\">yum install boost-devel <span class=\"comment\"># boost库</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建build目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> muduo</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> build</span><br><span class=\"line\"><span class=\"built_in\">cd</span> build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在build目录生成makefile文件</span></span><br><span class=\"line\">cmake ..</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译</span></span><br><span class=\"line\">make -j4</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装（可忽略）</span></span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"编译错误的解决\"><a href=\"#编译错误的解决\" class=\"headerlink\" title=\"编译错误的解决\"></a>编译错误的解决</h2><p><strong>我编译时唯一遇到的错误如下：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/root/workspace/muduo/muduo/base/TimeZone.cc:171:36: error: conversion to ‘int’ from ‘long unsigned int’ may alter its value [-Werror=conversion]</span><br><span class=\"line\">   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);</span><br><span class=\"line\">                                    ^</span><br><span class=\"line\">/root/workspace/muduo/muduo/base/TimeZone.cc:171:54: error: conversion to ‘int’ from ‘long unsigned int’ may alter its value [-Werror=conversion]</span><br><span class=\"line\">   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);</span><br><span class=\"line\">                                                      ^</span><br><span class=\"line\">cc1plus: all warnings being treated as errors</span><br><span class=\"line\">make[2]: *** [muduo/base/CMakeFiles/muduo_base.dir/TimeZone.cc.o] Error 1</span><br><span class=\"line\">make[2]: *** Waiting <span class=\"keyword\">for</span> unfinished <span class=\"built_in\">jobs</span>....</span><br><span class=\"line\">make[1]: *** [muduo/base/CMakeFiles/muduo_base.dir/all] Error 2</span><br><span class=\"line\">make: *** [all] Error 2</span><br></pre></td></tr></table></figure>\n\n<p>查阅资料得知：</p>\n<blockquote>\n<p>该错误是由于编译时启用了 <code>-Werror=conversion</code> 选项，该选项会将警告视为错误。在这里，编译器提示可能由于从 long unsigned int 到 int 的转换而导致值的变化。</p>\n</blockquote>\n<p>在项目的根目录的CMakeLists.txt文件中，将<code>-Werror</code>选项注释即可，此时警告不会被视为错误。</p>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"muduo源码阅读笔记（7、EventLoopThreadPool）","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\n与base文件夹下的通用线程池相比，EventLoopThreadPool更加专门化，专为为EventLoopThread而生，专为EventLoop而生，专为One Loop Per Thread而生，专为网络事件驱动而生，专为Muduo而生！\n\n## 实现\n\n**提供的接口：**\n\n<!-- more -->\n```cpp\nclass EventLoopThreadPool : noncopyable{\npublic:\n    typedef std::function<void(EventLoop*)> ThreadInitCallback;\n\n    EventLoopThreadPool(EventLoop* baseLoop, const string& nameArg);\n    ~EventLoopThreadPool();\n    void setThreadNum(int numThreads) { numThreads_ = numThreads; }\n    void start(const ThreadInitCallback& cb = ThreadInitCallback());\n\n    // valid after calling start()\n    /// round-robin\n    EventLoop* getNextLoop();\n\n    /// with the same hash code, it will always return the same EventLoop\n    EventLoop* getLoopForHash(size_t hashCode);\n\n    std::vector<EventLoop*> getAllLoops();\n\n    bool started() const\n    { return started_; }\n\n    const string& name() const\n    { return name_; }\n\nprivate:\n\n    EventLoop* baseLoop_; // 启动EventLoopThreadPool的EventLoop\n    string name_; // 线程池名\n    bool started_;  // 启动了？\n    int numThreads_;  // EventLoopThread线程的数量\n    int next_;    // 使用round-robin算法做线程的负载均衡，调度到了哪一个线程？\n    std::vector<std::unique_ptr<EventLoopThread>> threads_; // 线程池本体\n    std::vector<EventLoop*> loops_; // 每个线程对应的EventLoop\n};\n```\n\n结合[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)简单画了一下EventLoopThreadPool的架构图：\n\n![](./EventLoopThreadPool/photo/EventLoopThreadPool.drawio.png)\n\n**实现的伪代码：**\n\n```cpp\nEventLoopThreadPool::EventLoopThreadPool(EventLoop* baseLoop, const string& nameArg)\n  : baseLoop_(baseLoop),\n    name_(nameArg),\n    started_(false),\n    numThreads_(0),\n    next_(0){\n}\n\nEventLoopThreadPool::~EventLoopThreadPool(){\n    // Don't delete loop, it's stack variable\n}\n\nvoid EventLoopThreadPool::start(const ThreadInitCallback& cb){\n    assert(!started_);\n    baseLoop_->assertInLoopThread();\n\n    started_ = true;\n\n    for (int i = 0; i < numThreads_; ++i){\n        char buf[name_.size() + 32];\n        snprintf(buf, sizeof buf, \"%s%d\", name_.c_str(), i);\n        EventLoopThread* t = new EventLoopThread(cb, buf);\n        threads_.push_back(std::unique_ptr<EventLoopThread>(t));\n        loops_.push_back(t->startLoop()); // 启动线程\n    }\n    if (numThreads_ == 0 && cb){\n        cb(baseLoop_);\n    }\n}\n\nEventLoop* EventLoopThreadPool::getNextLoop(){ // round-robin算法做负载均衡\n    baseLoop_->assertInLoopThread();\n    assert(started_);\n    EventLoop* loop = baseLoop_;  // 线程数为0，就让baseLoop返回\n\n    if (!loops_.empty()){\n        // round-robin\n        loop = loops_[next_];\n        ++next_;\n        if (implicit_cast<size_t>(next_) >= loops_.size()){\n            next_ = 0;\n        }\n    }\n    return loop;\n}\n\nEventLoop* EventLoopThreadPool::getLoopForHash(size_t hashCode){ // hash散列做负载均衡\n    baseLoop_->assertInLoopThread();\n    EventLoop* loop = baseLoop_;// 线程数为0，就让baseLoop返回\n\n    if (!loops_.empty()){\n        loop = loops_[hashCode % loops_.size()];\n    }\n    return loop;\n}\n\nstd::vector<EventLoop*> EventLoopThreadPool::getAllLoops(){\n    baseLoop_->assertInLoopThread();\n    assert(started_);\n    if (loops_.empty()){\n        return std::vector<EventLoop*>(1, baseLoop_);\n    }else{\n        return loops_;\n    }\n}\n```\n\n## 细节明细\n\n**疑问：**\n\n关于`EventLoopThreadPool::getNextLoop()`、`EventLoopThreadPool::getLoopForHash`的作用？\n\n**解答：**\n\n小到线程之间，大到服务器集群之间，都需要保证负载均衡，以免大量的连接集中在某一个线程或者某一台机器，导致压力过大，而使连接任务无法有效处理。\n\n**疑问：**\n\nMuduo为什么大量使用unique_ptr智能指针，而不是使用sahred_ptr智能指针？\n\n以下是一些可能的原因：\n\n1. **所有权的清晰性： std::unique_ptr表示独占所有权，这意味着每个指针拥有对其指向对象的唯一所有权。这种所有权模型有助于明确代码中哪个部分负责释放资源。**\n\n2. 线程安全性： Muduo是一个面向多线程的网络库，而std::shared_ptr的引用计数是原子操作，可能在高并发环境下带来额外的竞争，从而影响性能。相比之下，std::unique_ptr的独占所有权模型更适合并发环境。\n\n3. 性能开销： std::shared_ptr通常会维护一个引用计数，用于跟踪共享对象的所有权信息。这样的引用计数可能引入额外的性能开销，特别是在高并发的网络编程场景下，性能是一个关键因素。\n\n4. 避免循环引用： 使用std::shared_ptr可能导致循环引用的问题，特别是在涉及到复杂的对象关系时。这可能导致资源无法被释放，从而引发内存泄漏。\n\n---\n\n**本章完结**","source":"_posts/muduo/EventLoopThreadPool.md","raw":"---\ntitle: muduo源码阅读笔记（7、EventLoopThreadPool）\ndate: 2024-11-02 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\n与base文件夹下的通用线程池相比，EventLoopThreadPool更加专门化，专为为EventLoopThread而生，专为EventLoop而生，专为One Loop Per Thread而生，专为网络事件驱动而生，专为Muduo而生！\n\n## 实现\n\n**提供的接口：**\n\n<!-- more -->\n```cpp\nclass EventLoopThreadPool : noncopyable{\npublic:\n    typedef std::function<void(EventLoop*)> ThreadInitCallback;\n\n    EventLoopThreadPool(EventLoop* baseLoop, const string& nameArg);\n    ~EventLoopThreadPool();\n    void setThreadNum(int numThreads) { numThreads_ = numThreads; }\n    void start(const ThreadInitCallback& cb = ThreadInitCallback());\n\n    // valid after calling start()\n    /// round-robin\n    EventLoop* getNextLoop();\n\n    /// with the same hash code, it will always return the same EventLoop\n    EventLoop* getLoopForHash(size_t hashCode);\n\n    std::vector<EventLoop*> getAllLoops();\n\n    bool started() const\n    { return started_; }\n\n    const string& name() const\n    { return name_; }\n\nprivate:\n\n    EventLoop* baseLoop_; // 启动EventLoopThreadPool的EventLoop\n    string name_; // 线程池名\n    bool started_;  // 启动了？\n    int numThreads_;  // EventLoopThread线程的数量\n    int next_;    // 使用round-robin算法做线程的负载均衡，调度到了哪一个线程？\n    std::vector<std::unique_ptr<EventLoopThread>> threads_; // 线程池本体\n    std::vector<EventLoop*> loops_; // 每个线程对应的EventLoop\n};\n```\n\n结合[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)简单画了一下EventLoopThreadPool的架构图：\n\n![](./EventLoopThreadPool/photo/EventLoopThreadPool.drawio.png)\n\n**实现的伪代码：**\n\n```cpp\nEventLoopThreadPool::EventLoopThreadPool(EventLoop* baseLoop, const string& nameArg)\n  : baseLoop_(baseLoop),\n    name_(nameArg),\n    started_(false),\n    numThreads_(0),\n    next_(0){\n}\n\nEventLoopThreadPool::~EventLoopThreadPool(){\n    // Don't delete loop, it's stack variable\n}\n\nvoid EventLoopThreadPool::start(const ThreadInitCallback& cb){\n    assert(!started_);\n    baseLoop_->assertInLoopThread();\n\n    started_ = true;\n\n    for (int i = 0; i < numThreads_; ++i){\n        char buf[name_.size() + 32];\n        snprintf(buf, sizeof buf, \"%s%d\", name_.c_str(), i);\n        EventLoopThread* t = new EventLoopThread(cb, buf);\n        threads_.push_back(std::unique_ptr<EventLoopThread>(t));\n        loops_.push_back(t->startLoop()); // 启动线程\n    }\n    if (numThreads_ == 0 && cb){\n        cb(baseLoop_);\n    }\n}\n\nEventLoop* EventLoopThreadPool::getNextLoop(){ // round-robin算法做负载均衡\n    baseLoop_->assertInLoopThread();\n    assert(started_);\n    EventLoop* loop = baseLoop_;  // 线程数为0，就让baseLoop返回\n\n    if (!loops_.empty()){\n        // round-robin\n        loop = loops_[next_];\n        ++next_;\n        if (implicit_cast<size_t>(next_) >= loops_.size()){\n            next_ = 0;\n        }\n    }\n    return loop;\n}\n\nEventLoop* EventLoopThreadPool::getLoopForHash(size_t hashCode){ // hash散列做负载均衡\n    baseLoop_->assertInLoopThread();\n    EventLoop* loop = baseLoop_;// 线程数为0，就让baseLoop返回\n\n    if (!loops_.empty()){\n        loop = loops_[hashCode % loops_.size()];\n    }\n    return loop;\n}\n\nstd::vector<EventLoop*> EventLoopThreadPool::getAllLoops(){\n    baseLoop_->assertInLoopThread();\n    assert(started_);\n    if (loops_.empty()){\n        return std::vector<EventLoop*>(1, baseLoop_);\n    }else{\n        return loops_;\n    }\n}\n```\n\n## 细节明细\n\n**疑问：**\n\n关于`EventLoopThreadPool::getNextLoop()`、`EventLoopThreadPool::getLoopForHash`的作用？\n\n**解答：**\n\n小到线程之间，大到服务器集群之间，都需要保证负载均衡，以免大量的连接集中在某一个线程或者某一台机器，导致压力过大，而使连接任务无法有效处理。\n\n**疑问：**\n\nMuduo为什么大量使用unique_ptr智能指针，而不是使用sahred_ptr智能指针？\n\n以下是一些可能的原因：\n\n1. **所有权的清晰性： std::unique_ptr表示独占所有权，这意味着每个指针拥有对其指向对象的唯一所有权。这种所有权模型有助于明确代码中哪个部分负责释放资源。**\n\n2. 线程安全性： Muduo是一个面向多线程的网络库，而std::shared_ptr的引用计数是原子操作，可能在高并发环境下带来额外的竞争，从而影响性能。相比之下，std::unique_ptr的独占所有权模型更适合并发环境。\n\n3. 性能开销： std::shared_ptr通常会维护一个引用计数，用于跟踪共享对象的所有权信息。这样的引用计数可能引入额外的性能开销，特别是在高并发的网络编程场景下，性能是一个关键因素。\n\n4. 避免循环引用： 使用std::shared_ptr可能导致循环引用的问题，特别是在涉及到复杂的对象关系时。这可能导致资源无法被释放，从而引发内存泄漏。\n\n---\n\n**本章完结**","slug":"muduo/EventLoopThreadPool","published":1,"updated":"2025-09-28T16:06:43.125Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9p000cq8wsbylt7ba0","content":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>与base文件夹下的通用线程池相比，EventLoopThreadPool更加专门化，专为为EventLoopThread而生，专为EventLoop而生，专为One Loop Per Thread而生，专为网络事件驱动而生，专为Muduo而生！</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p><strong>提供的接口：</strong></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EventLoopThreadPool</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(EventLoop*)&gt; ThreadInitCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">EventLoopThreadPool</span>(EventLoop* baseLoop, <span class=\"type\">const</span> string&amp; nameArg);</span><br><span class=\"line\">    ~<span class=\"built_in\">EventLoopThreadPool</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadNum</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span> </span>&#123; numThreads_ = numThreads; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"type\">const</span> ThreadInitCallback&amp; cb = ThreadInitCallback())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// valid after calling start()</span></span><br><span class=\"line\">    <span class=\"comment\">/// round-robin</span></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getNextLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// with the same hash code, it will always return the same EventLoop</span></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getLoopForHash</span><span class=\"params\">(<span class=\"type\">size_t</span> hashCode)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;EventLoop*&gt; <span class=\"title\">getAllLoops</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">started</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> started_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* baseLoop_; <span class=\"comment\">// 启动EventLoopThreadPool的EventLoop</span></span><br><span class=\"line\">    string name_; <span class=\"comment\">// 线程池名</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> started_;  <span class=\"comment\">// 启动了？</span></span><br><span class=\"line\">    <span class=\"type\">int</span> numThreads_;  <span class=\"comment\">// EventLoopThread线程的数量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> next_;    <span class=\"comment\">// 使用round-robin算法做线程的负载均衡，调度到了哪一个线程？</span></span><br><span class=\"line\">    std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; threads_; <span class=\"comment\">// 线程池本体</span></span><br><span class=\"line\">    std::vector&lt;EventLoop*&gt; loops_; <span class=\"comment\">// 每个线程对应的EventLoop</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>结合<a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a>简单画了一下EventLoopThreadPool的架构图：</p>\n<p><img src=\"/2024/11/02/muduo/EventLoopThreadPool/photo/EventLoopThreadPool.drawio.png\"></p>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopThreadPool::<span class=\"built_in\">EventLoopThreadPool</span>(EventLoop* baseLoop, <span class=\"type\">const</span> string&amp; nameArg)</span><br><span class=\"line\">  : <span class=\"built_in\">baseLoop_</span>(baseLoop),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">started_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">numThreads_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">next_</span>(<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoopThreadPool::~<span class=\"built_in\">EventLoopThreadPool</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t delete loop, it&#x27;s stack variable</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoopThreadPool::start</span><span class=\"params\">(<span class=\"type\">const</span> ThreadInitCallback&amp; cb)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!started_);</span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    started_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; numThreads_; ++i)&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> buf[name_.<span class=\"built_in\">size</span>() + <span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;%s%d&quot;</span>, name_.<span class=\"built_in\">c_str</span>(), i);</span><br><span class=\"line\">        EventLoopThread* t = <span class=\"keyword\">new</span> <span class=\"built_in\">EventLoopThread</span>(cb, buf);</span><br><span class=\"line\">        threads_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">unique_ptr</span>&lt;EventLoopThread&gt;(t));</span><br><span class=\"line\">        loops_.<span class=\"built_in\">push_back</span>(t-&gt;<span class=\"built_in\">startLoop</span>()); <span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numThreads_ == <span class=\"number\">0</span> &amp;&amp; cb)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cb</span>(baseLoop_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EventLoop* <span class=\"title\">EventLoopThreadPool::getNextLoop</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// round-robin算法做负载均衡</span></span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(started_);</span><br><span class=\"line\">    EventLoop* loop = baseLoop_;  <span class=\"comment\">// 线程数为0，就让baseLoop返回</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loops_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"comment\">// round-robin</span></span><br><span class=\"line\">        loop = loops_[next_];</span><br><span class=\"line\">        ++next_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">implicit_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(next_) &gt;= loops_.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            next_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EventLoop* <span class=\"title\">EventLoopThreadPool::getLoopForHash</span><span class=\"params\">(<span class=\"type\">size_t</span> hashCode)</span></span>&#123; <span class=\"comment\">// hash散列做负载均衡</span></span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    EventLoop* loop = baseLoop_;<span class=\"comment\">// 线程数为0，就让baseLoop返回</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loops_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        loop = loops_[hashCode % loops_.<span class=\"built_in\">size</span>()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;EventLoop*&gt; <span class=\"title\">EventLoopThreadPool::getAllLoops</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(started_);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loops_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::<span class=\"built_in\">vector</span>&lt;EventLoop*&gt;(<span class=\"number\">1</span>, baseLoop_);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> loops_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"细节明细\"><a href=\"#细节明细\" class=\"headerlink\" title=\"细节明细\"></a>细节明细</h2><p><strong>疑问：</strong></p>\n<p>关于<code>EventLoopThreadPool::getNextLoop()</code>、<code>EventLoopThreadPool::getLoopForHash</code>的作用？</p>\n<p><strong>解答：</strong></p>\n<p>小到线程之间，大到服务器集群之间，都需要保证负载均衡，以免大量的连接集中在某一个线程或者某一台机器，导致压力过大，而使连接任务无法有效处理。</p>\n<p><strong>疑问：</strong></p>\n<p>Muduo为什么大量使用unique_ptr智能指针，而不是使用sahred_ptr智能指针？</p>\n<p>以下是一些可能的原因：</p>\n<ol>\n<li><p><strong>所有权的清晰性： std::unique_ptr表示独占所有权，这意味着每个指针拥有对其指向对象的唯一所有权。这种所有权模型有助于明确代码中哪个部分负责释放资源。</strong></p>\n</li>\n<li><p>线程安全性： Muduo是一个面向多线程的网络库，而std::shared_ptr的引用计数是原子操作，可能在高并发环境下带来额外的竞争，从而影响性能。相比之下，std::unique_ptr的独占所有权模型更适合并发环境。</p>\n</li>\n<li><p>性能开销： std::shared_ptr通常会维护一个引用计数，用于跟踪共享对象的所有权信息。这样的引用计数可能引入额外的性能开销，特别是在高并发的网络编程场景下，性能是一个关键因素。</p>\n</li>\n<li><p>避免循环引用： 使用std::shared_ptr可能导致循环引用的问题，特别是在涉及到复杂的对象关系时。这可能导致资源无法被释放，从而引发内存泄漏。</p>\n</li>\n</ol>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>与base文件夹下的通用线程池相比，EventLoopThreadPool更加专门化，专为为EventLoopThread而生，专为EventLoop而生，专为One Loop Per Thread而生，专为网络事件驱动而生，专为Muduo而生！</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p><strong>提供的接口：</strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EventLoopThreadPool</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(EventLoop*)&gt; ThreadInitCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">EventLoopThreadPool</span>(EventLoop* baseLoop, <span class=\"type\">const</span> string&amp; nameArg);</span><br><span class=\"line\">    ~<span class=\"built_in\">EventLoopThreadPool</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadNum</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span> </span>&#123; numThreads_ = numThreads; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"type\">const</span> ThreadInitCallback&amp; cb = ThreadInitCallback())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// valid after calling start()</span></span><br><span class=\"line\">    <span class=\"comment\">/// round-robin</span></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getNextLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// with the same hash code, it will always return the same EventLoop</span></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getLoopForHash</span><span class=\"params\">(<span class=\"type\">size_t</span> hashCode)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;EventLoop*&gt; <span class=\"title\">getAllLoops</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">started</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> started_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* baseLoop_; <span class=\"comment\">// 启动EventLoopThreadPool的EventLoop</span></span><br><span class=\"line\">    string name_; <span class=\"comment\">// 线程池名</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> started_;  <span class=\"comment\">// 启动了？</span></span><br><span class=\"line\">    <span class=\"type\">int</span> numThreads_;  <span class=\"comment\">// EventLoopThread线程的数量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> next_;    <span class=\"comment\">// 使用round-robin算法做线程的负载均衡，调度到了哪一个线程？</span></span><br><span class=\"line\">    std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; threads_; <span class=\"comment\">// 线程池本体</span></span><br><span class=\"line\">    std::vector&lt;EventLoop*&gt; loops_; <span class=\"comment\">// 每个线程对应的EventLoop</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>结合<a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a>简单画了一下EventLoopThreadPool的架构图：</p>\n<p><img src=\"/2024/11/02/muduo/EventLoopThreadPool/photo/EventLoopThreadPool.drawio.png\"></p>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopThreadPool::<span class=\"built_in\">EventLoopThreadPool</span>(EventLoop* baseLoop, <span class=\"type\">const</span> string&amp; nameArg)</span><br><span class=\"line\">  : <span class=\"built_in\">baseLoop_</span>(baseLoop),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">started_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">numThreads_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">next_</span>(<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoopThreadPool::~<span class=\"built_in\">EventLoopThreadPool</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t delete loop, it&#x27;s stack variable</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoopThreadPool::start</span><span class=\"params\">(<span class=\"type\">const</span> ThreadInitCallback&amp; cb)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!started_);</span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    started_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; numThreads_; ++i)&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> buf[name_.<span class=\"built_in\">size</span>() + <span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;%s%d&quot;</span>, name_.<span class=\"built_in\">c_str</span>(), i);</span><br><span class=\"line\">        EventLoopThread* t = <span class=\"keyword\">new</span> <span class=\"built_in\">EventLoopThread</span>(cb, buf);</span><br><span class=\"line\">        threads_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">unique_ptr</span>&lt;EventLoopThread&gt;(t));</span><br><span class=\"line\">        loops_.<span class=\"built_in\">push_back</span>(t-&gt;<span class=\"built_in\">startLoop</span>()); <span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numThreads_ == <span class=\"number\">0</span> &amp;&amp; cb)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cb</span>(baseLoop_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EventLoop* <span class=\"title\">EventLoopThreadPool::getNextLoop</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// round-robin算法做负载均衡</span></span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(started_);</span><br><span class=\"line\">    EventLoop* loop = baseLoop_;  <span class=\"comment\">// 线程数为0，就让baseLoop返回</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loops_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"comment\">// round-robin</span></span><br><span class=\"line\">        loop = loops_[next_];</span><br><span class=\"line\">        ++next_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">implicit_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(next_) &gt;= loops_.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            next_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EventLoop* <span class=\"title\">EventLoopThreadPool::getLoopForHash</span><span class=\"params\">(<span class=\"type\">size_t</span> hashCode)</span></span>&#123; <span class=\"comment\">// hash散列做负载均衡</span></span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    EventLoop* loop = baseLoop_;<span class=\"comment\">// 线程数为0，就让baseLoop返回</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loops_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        loop = loops_[hashCode % loops_.<span class=\"built_in\">size</span>()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;EventLoop*&gt; <span class=\"title\">EventLoopThreadPool::getAllLoops</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(started_);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loops_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::<span class=\"built_in\">vector</span>&lt;EventLoop*&gt;(<span class=\"number\">1</span>, baseLoop_);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> loops_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"细节明细\"><a href=\"#细节明细\" class=\"headerlink\" title=\"细节明细\"></a>细节明细</h2><p><strong>疑问：</strong></p>\n<p>关于<code>EventLoopThreadPool::getNextLoop()</code>、<code>EventLoopThreadPool::getLoopForHash</code>的作用？</p>\n<p><strong>解答：</strong></p>\n<p>小到线程之间，大到服务器集群之间，都需要保证负载均衡，以免大量的连接集中在某一个线程或者某一台机器，导致压力过大，而使连接任务无法有效处理。</p>\n<p><strong>疑问：</strong></p>\n<p>Muduo为什么大量使用unique_ptr智能指针，而不是使用sahred_ptr智能指针？</p>\n<p>以下是一些可能的原因：</p>\n<ol>\n<li><p><strong>所有权的清晰性： std::unique_ptr表示独占所有权，这意味着每个指针拥有对其指向对象的唯一所有权。这种所有权模型有助于明确代码中哪个部分负责释放资源。</strong></p>\n</li>\n<li><p>线程安全性： Muduo是一个面向多线程的网络库，而std::shared_ptr的引用计数是原子操作，可能在高并发环境下带来额外的竞争，从而影响性能。相比之下，std::unique_ptr的独占所有权模型更适合并发环境。</p>\n</li>\n<li><p>性能开销： std::shared_ptr通常会维护一个引用计数，用于跟踪共享对象的所有权信息。这样的引用计数可能引入额外的性能开销，特别是在高并发的网络编程场景下，性能是一个关键因素。</p>\n</li>\n<li><p>避免循环引用： 使用std::shared_ptr可能导致循环引用的问题，特别是在涉及到复杂的对象关系时。这可能导致资源无法被释放，从而引发内存泄漏。</p>\n</li>\n</ol>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"muduo源码阅读笔记（6、EvevntLoop和Thread）","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\n终于到了Muduo网络库最最核心的部分，这里还是建议大家亲自看看源码。源码很好读，博客最多起到辅助作用。因为EventLoop和Thread是绑定的，所以，可能这两部分放在一起更适合。\n\n了解ExevntLoop和Thread后，对One Loop Per Thread思想，就有了一个大体的轮廓，这种设计思想，真的很高效，因为，每个线程都有自己的资源，比如epoll、IO事件处理，定时器、任务队列等。每个线程内部资源都是自我维护的（自己的事情自己做）， **除了对线程的任务队列进行操作时有一段极小的临界区需要加锁外，不涉及任何锁的竞争。这里为每个线程设置自己的任务队列的思想特别关键，正是利用每个线程只处理自己任务队列里面的回调任务，实现了将并行任务串行化的效果。** 将原本的并发（涉及线程安全，需要加锁）操作，封装成任务（无需加锁）回调，添加到各自的任务队列中，交给线程自己处理。实现了**线程的隔离**、**无锁化编程**，巧妙的利用单线程天生串行执行的优势。活该Muduo高性能、高并发。\n\n## EventLoop的实现\n\n**提供的接口：**\n\n<!-- more -->\n```cpp\nclass EventLoop : noncopyable{\npublic:\n    typedef std::function<void()> Functor;\n\n    EventLoop();\n    ~EventLoop();  // force out-line dtor, for std::unique_ptr members.\n\n    ///\n    /// Loops forever.\n    ///\n    /// Must be called in the same thread as creation of the object.\n    ///\n    void loop();\n\n    /// Quits loop.\n    ///\n    /// This is not 100% thread safe, if you call through a raw pointer,\n    /// better to call through shared_ptr<EventLoop> for 100% safety.\n    void quit();\n\n    /// Runs callback immediately in the loop thread.\n    /// It wakes up the loop, and run the cb.\n    /// If in the same loop thread, cb is run within the function.\n    /// Safe to call from other threads.\n    void runInLoop(Functor cb);\n    /// Queues callback in the loop thread.\n    /// Runs after finish pooling.\n    /// Safe to call from other threads.\n    void queueInLoop(Functor cb);\n\n    size_t queueSize() const;\n\n    // timers\n\n    // ...\n\n    // internal usage\n    void wakeup();\n    void updateChannel(Channel* channel);\n    void removeChannel(Channel* channel);\n\n    // pid_t threadId() const { return threadId_; }\n    void assertInLoopThread()\n\n    bool isInLoopThread() const { return threadId_ == CurrentThread::tid(); }\n    // 获取当前线程的EventLoop\n    static EventLoop* getEventLoopOfCurrentThread();\n\nprivate:\n    void abortNotInLoopThread();\n    void handleRead();  // waked up\n    void doPendingFunctors();\n\n    typedef std::vector<Channel*> ChannelList;\n\n    bool looping_; /* atomic */ // 在loop()中？\n    std::atomic<bool> quit_;  // EventLoop是否退出\n    bool eventHandling_; /* atomic */ // 正在处理事件？\n    bool callingPendingFunctors_; /* atomic */  // 正在处理任务回调？\n    int64_t iteration_;   // loop()循环的次数\n    const pid_t threadId_;  // EventLoop和哪个线程绑定？\n    Timestamp pollReturnTime_;  // epoll_wait返回时的时间戳\n    std::unique_ptr<Poller> poller_;  // epoll/poll\n    std::unique_ptr<TimerQueue> timerQueue_;  // 定时器\n    int wakeupFd_;  // tickleFd，用于手动唤醒epoll_wait，以便即使处理任务\n    // unlike in TimerQueue, which is an internal class,\n    // we don't expose Channel to client.\n    std::unique_ptr<Channel> wakeupChannel_;  // 管理tickleFd的channel\n    boost::any context_;  // 待定\n\n    // scratch variables\n    ChannelList activeChannels_;   // poller_收集到的fd（channel）事件\n    Channel* currentActiveChannel_; // loop()正在处理的channel\n\n    mutable MutexLock mutex_; // 只对pendingFunctors_提供保护\n    std::vector<Functor> pendingFunctors_ GUARDED_BY(mutex_); // 任务队列\n};\n```\n\nMuduo在EventLoop中，使用了Linux系统中EventFd，作为wakeupChannel_的成员。这里主要为了将线程即时唤醒处理回调任务。如果你阅读过sylar的源码应该在这里会有所感知，`EventLoop::wakeup()`函数其实作用和sylar中的`IOManager::tickle()`类似。\n\n此外，为了和Muduo的EventLoop适配，Muduo定时器的实现也是利用Linux上提供的TimeFd，在TimerQueue构造函数中，也会为该fd构造一个Channel，并将该Channel注册到EventLoop的Poller中，这样极大的方便了定时器的管理与维护。\n\n简单画了一下EventLoop中核心函数`EventLoop::loop()`的执行流程图：\n\n![loop执行流程](./EvevntLoopAndThread/photo/EventLoop.drawio.png)\n\n**实现的伪代码：**\n\n```cpp\n// 线程全局变量，for将线程和EventLoop绑定\n__thread EventLoop* t_loopInThisThread = 0;\n\nEventLoop::EventLoop()\n  : // ...\n    threadId_(CurrentThread::tid()),\n    poller_(Poller::newDefaultPoller(this)),    // epoll\n    timerQueue_(new TimerQueue(this)),      // Muduo定时器采用的是timerfd的接口，TimerQueue对象内部也构造了对应的channel，在构造时，会向EventLopp的Poller中注册该fd。\n    wakeupFd_(createEventfd()),   // 创建一个非阻塞eventfd，作为tickle\n    wakeupChannel_(new Channel(this, wakeupFd_)){ // 将eventfd封装成channel\n\n    LOG_DEBUG << \"EventLoop created \" << this << \" in thread \" << threadId_;\n    if (t_loopInThisThread){\n        LOG_FATAL << \"Another EventLoop \" << t_loopInThisThread\n                << \" exists in this thread \" << threadId_;\n    }else{\n        t_loopInThisThread = this;  // 设置线程局部变量\n    }\n    // 为eventfd设置读回调\n    wakeupChannel_->setReadCallback(\n        std::bind(&EventLoop::handleRead, this));\n    // we are always reading the wakeupfd\n    wakeupChannel_->enableReading();\n}\n\nEventLoop::~EventLoop(){\n    // 善后\n    LOG_DEBUG << \"EventLoop \" << this << \" of thread \" << threadId_\n            << \" destructs in thread \" << CurrentThread::tid();\n    wakeupChannel_->disableAll();\n    wakeupChannel_->remove();\n    ::close(wakeupFd_);\n    t_loopInThisThread = NULL;\n}\n\nvoid EventLoop::loop(){\n    assert(!looping_);\n    assertInLoopThread(); // 在自己的线程中？\n    looping_ = true;\n    quit_ = false;  // FIXME: what if someone calls quit() before loop() ?\n    LOG_TRACE << \"EventLoop \" << this << \" start looping\";\n\n    while (!quit_){\n        activeChannels_.clear();\n        pollReturnTime_ = poller_->poll(kPollTimeMs, &activeChannels_); // epoll_wait\n        ++iteration_;\n        if (Logger::logLevel() <= Logger::TRACE){\n            printActiveChannels();\n        }\n        // TODO sort channel by priority\n        eventHandling_ = true;  // 开始处理每一个fd被触发的事件\n        for (Channel* channel : activeChannels_){\n            currentActiveChannel_ = channel;\n            currentActiveChannel_->handleEvent(pollReturnTime_);  // 利用channel处理事件\n        }\n        currentActiveChannel_ = NULL;\n        eventHandling_ = false; // 所有fd的事件被处理完\n        doPendingFunctors();  // 处理任务回调\n    }\n\n    LOG_TRACE << \"EventLoop \" << this << \" stop looping\";\n    looping_ = false;\n}\n\nvoid EventLoop::quit(){\n    quit_ = true;\n    // 有线程安全问题\n    // There is a chance that loop() just executes while(!quit_) and exits,\n    // then EventLoop destructs, then we are accessing an invalid object.\n    // Can be fixed using mutex_ in both places.\n    if (!isInLoopThread()){  // 其他线程调用quit，不确定线程是否是Active的，需要调用wakeup();\n        wakeup();\n    } // 在处理事件或者任务回调时，内部自己调用了quit，说名此时线程是Active的，不用去唤醒\n}\n\nvoid EventLoop::runInLoop(Functor cb){\n    if (isInLoopThread()) {// 线程自己调用runInLoop，本来就是Active，直接顺手处理\n        cb();\n    }else{  // 其他线程调用runInLoop，需要加锁\n        queueInLoop(std::move(cb));\n    }\n}\n\nvoid EventLoop::queueInLoop(Functor cb){\n    {\n        MutexLockGuard lock(mutex_);\n        pendingFunctors_.push_back(std::move(cb));  // 任务放入任务队列\n    }\n\n    if (!isInLoopThread() || callingPendingFunctors_){ \n        // 其他线程调用queueInLoop || 线程在处理任务队列中的任务时调用了queueInLoop\n        //以便让线程不要阻塞在epoll_wait上从而及时处理任务回调。\n        wakeup();\n    }\n}\n\nvoid EventLoop::updateChannel(Channel* channel){\n    assert(channel->ownerLoop() == this);\n    assertInLoopThread();\n    poller_->updateChannel(channel);\n}\n\nvoid EventLoop::removeChannel(Channel* channel){\n    assert(channel->ownerLoop() == this);\n    assertInLoopThread();\n    if (eventHandling_){\n        // channel只有自己能remove自己，其他的channel禁止删除并非自己的channel\n        assert(currentActiveChannel_ == channel ||\n            std::find(activeChannels_.begin(), activeChannels_.end(), channel) == activeChannels_.end());\n    }\n    poller_->removeChannel(channel);\n}\n// 唤醒线程\nvoid EventLoop::wakeup(){\n    uint64_t one = 1;\n    // tickle一下\n    ssize_t n = sockets::write(wakeupFd_, &one, sizeof one);\n    if (n != sizeof one){\n        LOG_ERROR << \"EventLoop::wakeup() writes \" << n << \" bytes instead of 8\";\n    }\n}\n\nvoid EventLoop::handleRead(){\n    uint64_t one = 1;\n    // tickle 回调处理\n    ssize_t n = sockets::read(wakeupFd_, &one, sizeof one);\n    if (n != sizeof one){\n        LOG_ERROR << \"EventLoop::handleRead() reads \" << n << \" bytes instead of 8\";\n    }\n}\n\nvoid EventLoop::doPendingFunctors(){\n    std::vector<Functor> functors;\n    callingPendingFunctors_ = true;\n    // 写时置换，同异步日志，即减少持锁时间，又减少死锁可能。\n    {\n        MutexLockGuard lock(mutex_);\n        functors.swap(pendingFunctors_);\n    }\n\n    for (const Functor& functor : functors){\n        functor();\n    }\n    callingPendingFunctors_ = false;\n}\n```\n\n### 细节明细：\n\n在EventLoop类的成员变量的定义顺序中，poller_的定义位于timerQueue_之上，这个定义的顺序很关键，首先在EventLoop在构造时，先按成员变量的定义顺序构造成员变量，再会构造EventLoop本身。在析构的时候，会先析构自身，再会去按成员变量的定义顺序的倒序，去析构成员变量。考虑到timerQueue_的析构是依赖poller_的，Muduo的定义顺序（先析构timerQueue_，再析构poller_），正好规避了这个问题。\n\n## EventLoopThread的实现\n\n简单讲，EventLoop作用就是让EventLoop::loop()跑在线程上。\n\nEventLoopThread的实现代码是自解释的，代码量很少，也很容易理解。\n\n**提供的接口：**\n\n```cpp\nclass EventLoopThread : noncopyable{\npublic:\n    typedef std::function<void(EventLoop*)> ThreadInitCallback;\n\n    EventLoopThread(const ThreadInitCallback& cb = ThreadInitCallback(),\n                    const string& name = string());\n    ~EventLoopThread();\n    EventLoop* startLoop();\n\nprivate:\n    void threadFunc();\n\n    EventLoop* loop_ GUARDED_BY(mutex_);  // 依赖EventLoop\n    bool exiting_;  // 线程是否living\n    Thread thread_; // 线程实体\n    MutexLock mutex_;\n    Condition cond_ GUARDED_BY(mutex_);\n    ThreadInitCallback callback_;\n};\n```\n\n有了EventLoop和EventLoopThread后，结合[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)一个EventLoopThread线程启动流程如下：\n\n1. EventLoopThread::startLoop() ->\n\n2. Thread::start()  -> \n\n3. pthread_create(..., &detail::startThread,...)    -> \n\n4. startThread(void* obj)   ->\n\n5. ThreadData::runInThread()    -> \n\n6. Thread::func_()  ->\n\n7. EventLoopThread::threadFunc()    ->\n\n8. EventLoop::loop()\n\n\n**实现的伪代码：**\n\n```cpp\nEventLoopThread::EventLoopThread(const ThreadInitCallback& cb,\n                                 const string& name)\n  : loop_(NULL),\n    exiting_(false),\n    thread_(std::bind(&EventLoopThread::threadFunc, this), name),\n    mutex_(),\n    cond_(mutex_),\n    callback_(cb){\n}\n\nEventLoopThread::~EventLoopThread(){\n    exiting_ = true;\n    if (loop_ != NULL){ // not 100% race-free, eg. threadFunc could be running callback_.\n        // still a tiny chance to call destructed object, if threadFunc exits just now.\n        // but when EventLoopThread destructs, usually programming is exiting anyway.\n        loop_->quit();\n        thread_.join();\n    }\n}\n\nEventLoop* EventLoopThread::startLoop(){\n    assert(!thread_.started());\n    thread_.start();\n\n    EventLoop* loop = NULL;\n    {\n        MutexLockGuard lock(mutex_);\n        while (loop_ == NULL){  // 解决条件变量惊群效应/虚唤醒\n            cond_.wait();\n        }\n        loop = loop_;\n    }\n\n    return loop;\n}\n\nvoid EventLoopThread::threadFunc(){\n    EventLoop loop;\n\n    if (callback_){\n        callback_(&loop);\n    }\n\n    {\n        MutexLockGuard lock(mutex_);\n        loop_ = &loop;\n        cond_.notify();\n    }\n\n    loop.loop();\n    //assert(exiting_);\n    MutexLockGuard lock(mutex_);\n    loop_ = NULL;\n}\n```\n\n## 总结\n\n在Muduo网络库的设计中，EventLoop 统一使用文件描述符（file descriptor）的方式来处理事件，主要是基于以下一些好处和设计原则：\n\n1. 一致性： 使用文件描述符作为事件的抽象，使得对于不同类型的事件（包括套接字、定时器等）的处理方式一致。这种一致性简化了 EventLoop 内部的设计和实现，使得对于事件的处理更加通用。\n\n2. 多路复用： 文件描述符是多路复用（Multiplexing）机制的核心。通过将多个文件描述符注册到同一个 EventLoop 中，可以使用诸如 select、poll、epoll 等多路复用技术，实现同时监听多个事件并进行有效的事件分发。\n\n3. 高效性： 文件描述符的处理在操作系统层面已经高度优化，使用多路复用机制可以高效地管理和调度大量的事件。这对于实现高性能的网络库尤为重要。\n\n**如果读者有阅读其他网络库源码就会不可思议的发现，Muduo的One Loop Per Thread设计思想太精妙了，这种设计几乎不存在锁的竞争！！！**\n\n---\n\n**本章完结**","source":"_posts/muduo/EvevntLoopAndThread.md","raw":"---\ntitle: muduo源码阅读笔记（6、EvevntLoop和Thread）\ndate: 2024-11-02 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\n终于到了Muduo网络库最最核心的部分，这里还是建议大家亲自看看源码。源码很好读，博客最多起到辅助作用。因为EventLoop和Thread是绑定的，所以，可能这两部分放在一起更适合。\n\n了解ExevntLoop和Thread后，对One Loop Per Thread思想，就有了一个大体的轮廓，这种设计思想，真的很高效，因为，每个线程都有自己的资源，比如epoll、IO事件处理，定时器、任务队列等。每个线程内部资源都是自我维护的（自己的事情自己做）， **除了对线程的任务队列进行操作时有一段极小的临界区需要加锁外，不涉及任何锁的竞争。这里为每个线程设置自己的任务队列的思想特别关键，正是利用每个线程只处理自己任务队列里面的回调任务，实现了将并行任务串行化的效果。** 将原本的并发（涉及线程安全，需要加锁）操作，封装成任务（无需加锁）回调，添加到各自的任务队列中，交给线程自己处理。实现了**线程的隔离**、**无锁化编程**，巧妙的利用单线程天生串行执行的优势。活该Muduo高性能、高并发。\n\n## EventLoop的实现\n\n**提供的接口：**\n\n<!-- more -->\n```cpp\nclass EventLoop : noncopyable{\npublic:\n    typedef std::function<void()> Functor;\n\n    EventLoop();\n    ~EventLoop();  // force out-line dtor, for std::unique_ptr members.\n\n    ///\n    /// Loops forever.\n    ///\n    /// Must be called in the same thread as creation of the object.\n    ///\n    void loop();\n\n    /// Quits loop.\n    ///\n    /// This is not 100% thread safe, if you call through a raw pointer,\n    /// better to call through shared_ptr<EventLoop> for 100% safety.\n    void quit();\n\n    /// Runs callback immediately in the loop thread.\n    /// It wakes up the loop, and run the cb.\n    /// If in the same loop thread, cb is run within the function.\n    /// Safe to call from other threads.\n    void runInLoop(Functor cb);\n    /// Queues callback in the loop thread.\n    /// Runs after finish pooling.\n    /// Safe to call from other threads.\n    void queueInLoop(Functor cb);\n\n    size_t queueSize() const;\n\n    // timers\n\n    // ...\n\n    // internal usage\n    void wakeup();\n    void updateChannel(Channel* channel);\n    void removeChannel(Channel* channel);\n\n    // pid_t threadId() const { return threadId_; }\n    void assertInLoopThread()\n\n    bool isInLoopThread() const { return threadId_ == CurrentThread::tid(); }\n    // 获取当前线程的EventLoop\n    static EventLoop* getEventLoopOfCurrentThread();\n\nprivate:\n    void abortNotInLoopThread();\n    void handleRead();  // waked up\n    void doPendingFunctors();\n\n    typedef std::vector<Channel*> ChannelList;\n\n    bool looping_; /* atomic */ // 在loop()中？\n    std::atomic<bool> quit_;  // EventLoop是否退出\n    bool eventHandling_; /* atomic */ // 正在处理事件？\n    bool callingPendingFunctors_; /* atomic */  // 正在处理任务回调？\n    int64_t iteration_;   // loop()循环的次数\n    const pid_t threadId_;  // EventLoop和哪个线程绑定？\n    Timestamp pollReturnTime_;  // epoll_wait返回时的时间戳\n    std::unique_ptr<Poller> poller_;  // epoll/poll\n    std::unique_ptr<TimerQueue> timerQueue_;  // 定时器\n    int wakeupFd_;  // tickleFd，用于手动唤醒epoll_wait，以便即使处理任务\n    // unlike in TimerQueue, which is an internal class,\n    // we don't expose Channel to client.\n    std::unique_ptr<Channel> wakeupChannel_;  // 管理tickleFd的channel\n    boost::any context_;  // 待定\n\n    // scratch variables\n    ChannelList activeChannels_;   // poller_收集到的fd（channel）事件\n    Channel* currentActiveChannel_; // loop()正在处理的channel\n\n    mutable MutexLock mutex_; // 只对pendingFunctors_提供保护\n    std::vector<Functor> pendingFunctors_ GUARDED_BY(mutex_); // 任务队列\n};\n```\n\nMuduo在EventLoop中，使用了Linux系统中EventFd，作为wakeupChannel_的成员。这里主要为了将线程即时唤醒处理回调任务。如果你阅读过sylar的源码应该在这里会有所感知，`EventLoop::wakeup()`函数其实作用和sylar中的`IOManager::tickle()`类似。\n\n此外，为了和Muduo的EventLoop适配，Muduo定时器的实现也是利用Linux上提供的TimeFd，在TimerQueue构造函数中，也会为该fd构造一个Channel，并将该Channel注册到EventLoop的Poller中，这样极大的方便了定时器的管理与维护。\n\n简单画了一下EventLoop中核心函数`EventLoop::loop()`的执行流程图：\n\n![loop执行流程](./EvevntLoopAndThread/photo/EventLoop.drawio.png)\n\n**实现的伪代码：**\n\n```cpp\n// 线程全局变量，for将线程和EventLoop绑定\n__thread EventLoop* t_loopInThisThread = 0;\n\nEventLoop::EventLoop()\n  : // ...\n    threadId_(CurrentThread::tid()),\n    poller_(Poller::newDefaultPoller(this)),    // epoll\n    timerQueue_(new TimerQueue(this)),      // Muduo定时器采用的是timerfd的接口，TimerQueue对象内部也构造了对应的channel，在构造时，会向EventLopp的Poller中注册该fd。\n    wakeupFd_(createEventfd()),   // 创建一个非阻塞eventfd，作为tickle\n    wakeupChannel_(new Channel(this, wakeupFd_)){ // 将eventfd封装成channel\n\n    LOG_DEBUG << \"EventLoop created \" << this << \" in thread \" << threadId_;\n    if (t_loopInThisThread){\n        LOG_FATAL << \"Another EventLoop \" << t_loopInThisThread\n                << \" exists in this thread \" << threadId_;\n    }else{\n        t_loopInThisThread = this;  // 设置线程局部变量\n    }\n    // 为eventfd设置读回调\n    wakeupChannel_->setReadCallback(\n        std::bind(&EventLoop::handleRead, this));\n    // we are always reading the wakeupfd\n    wakeupChannel_->enableReading();\n}\n\nEventLoop::~EventLoop(){\n    // 善后\n    LOG_DEBUG << \"EventLoop \" << this << \" of thread \" << threadId_\n            << \" destructs in thread \" << CurrentThread::tid();\n    wakeupChannel_->disableAll();\n    wakeupChannel_->remove();\n    ::close(wakeupFd_);\n    t_loopInThisThread = NULL;\n}\n\nvoid EventLoop::loop(){\n    assert(!looping_);\n    assertInLoopThread(); // 在自己的线程中？\n    looping_ = true;\n    quit_ = false;  // FIXME: what if someone calls quit() before loop() ?\n    LOG_TRACE << \"EventLoop \" << this << \" start looping\";\n\n    while (!quit_){\n        activeChannels_.clear();\n        pollReturnTime_ = poller_->poll(kPollTimeMs, &activeChannels_); // epoll_wait\n        ++iteration_;\n        if (Logger::logLevel() <= Logger::TRACE){\n            printActiveChannels();\n        }\n        // TODO sort channel by priority\n        eventHandling_ = true;  // 开始处理每一个fd被触发的事件\n        for (Channel* channel : activeChannels_){\n            currentActiveChannel_ = channel;\n            currentActiveChannel_->handleEvent(pollReturnTime_);  // 利用channel处理事件\n        }\n        currentActiveChannel_ = NULL;\n        eventHandling_ = false; // 所有fd的事件被处理完\n        doPendingFunctors();  // 处理任务回调\n    }\n\n    LOG_TRACE << \"EventLoop \" << this << \" stop looping\";\n    looping_ = false;\n}\n\nvoid EventLoop::quit(){\n    quit_ = true;\n    // 有线程安全问题\n    // There is a chance that loop() just executes while(!quit_) and exits,\n    // then EventLoop destructs, then we are accessing an invalid object.\n    // Can be fixed using mutex_ in both places.\n    if (!isInLoopThread()){  // 其他线程调用quit，不确定线程是否是Active的，需要调用wakeup();\n        wakeup();\n    } // 在处理事件或者任务回调时，内部自己调用了quit，说名此时线程是Active的，不用去唤醒\n}\n\nvoid EventLoop::runInLoop(Functor cb){\n    if (isInLoopThread()) {// 线程自己调用runInLoop，本来就是Active，直接顺手处理\n        cb();\n    }else{  // 其他线程调用runInLoop，需要加锁\n        queueInLoop(std::move(cb));\n    }\n}\n\nvoid EventLoop::queueInLoop(Functor cb){\n    {\n        MutexLockGuard lock(mutex_);\n        pendingFunctors_.push_back(std::move(cb));  // 任务放入任务队列\n    }\n\n    if (!isInLoopThread() || callingPendingFunctors_){ \n        // 其他线程调用queueInLoop || 线程在处理任务队列中的任务时调用了queueInLoop\n        //以便让线程不要阻塞在epoll_wait上从而及时处理任务回调。\n        wakeup();\n    }\n}\n\nvoid EventLoop::updateChannel(Channel* channel){\n    assert(channel->ownerLoop() == this);\n    assertInLoopThread();\n    poller_->updateChannel(channel);\n}\n\nvoid EventLoop::removeChannel(Channel* channel){\n    assert(channel->ownerLoop() == this);\n    assertInLoopThread();\n    if (eventHandling_){\n        // channel只有自己能remove自己，其他的channel禁止删除并非自己的channel\n        assert(currentActiveChannel_ == channel ||\n            std::find(activeChannels_.begin(), activeChannels_.end(), channel) == activeChannels_.end());\n    }\n    poller_->removeChannel(channel);\n}\n// 唤醒线程\nvoid EventLoop::wakeup(){\n    uint64_t one = 1;\n    // tickle一下\n    ssize_t n = sockets::write(wakeupFd_, &one, sizeof one);\n    if (n != sizeof one){\n        LOG_ERROR << \"EventLoop::wakeup() writes \" << n << \" bytes instead of 8\";\n    }\n}\n\nvoid EventLoop::handleRead(){\n    uint64_t one = 1;\n    // tickle 回调处理\n    ssize_t n = sockets::read(wakeupFd_, &one, sizeof one);\n    if (n != sizeof one){\n        LOG_ERROR << \"EventLoop::handleRead() reads \" << n << \" bytes instead of 8\";\n    }\n}\n\nvoid EventLoop::doPendingFunctors(){\n    std::vector<Functor> functors;\n    callingPendingFunctors_ = true;\n    // 写时置换，同异步日志，即减少持锁时间，又减少死锁可能。\n    {\n        MutexLockGuard lock(mutex_);\n        functors.swap(pendingFunctors_);\n    }\n\n    for (const Functor& functor : functors){\n        functor();\n    }\n    callingPendingFunctors_ = false;\n}\n```\n\n### 细节明细：\n\n在EventLoop类的成员变量的定义顺序中，poller_的定义位于timerQueue_之上，这个定义的顺序很关键，首先在EventLoop在构造时，先按成员变量的定义顺序构造成员变量，再会构造EventLoop本身。在析构的时候，会先析构自身，再会去按成员变量的定义顺序的倒序，去析构成员变量。考虑到timerQueue_的析构是依赖poller_的，Muduo的定义顺序（先析构timerQueue_，再析构poller_），正好规避了这个问题。\n\n## EventLoopThread的实现\n\n简单讲，EventLoop作用就是让EventLoop::loop()跑在线程上。\n\nEventLoopThread的实现代码是自解释的，代码量很少，也很容易理解。\n\n**提供的接口：**\n\n```cpp\nclass EventLoopThread : noncopyable{\npublic:\n    typedef std::function<void(EventLoop*)> ThreadInitCallback;\n\n    EventLoopThread(const ThreadInitCallback& cb = ThreadInitCallback(),\n                    const string& name = string());\n    ~EventLoopThread();\n    EventLoop* startLoop();\n\nprivate:\n    void threadFunc();\n\n    EventLoop* loop_ GUARDED_BY(mutex_);  // 依赖EventLoop\n    bool exiting_;  // 线程是否living\n    Thread thread_; // 线程实体\n    MutexLock mutex_;\n    Condition cond_ GUARDED_BY(mutex_);\n    ThreadInitCallback callback_;\n};\n```\n\n有了EventLoop和EventLoopThread后，结合[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)一个EventLoopThread线程启动流程如下：\n\n1. EventLoopThread::startLoop() ->\n\n2. Thread::start()  -> \n\n3. pthread_create(..., &detail::startThread,...)    -> \n\n4. startThread(void* obj)   ->\n\n5. ThreadData::runInThread()    -> \n\n6. Thread::func_()  ->\n\n7. EventLoopThread::threadFunc()    ->\n\n8. EventLoop::loop()\n\n\n**实现的伪代码：**\n\n```cpp\nEventLoopThread::EventLoopThread(const ThreadInitCallback& cb,\n                                 const string& name)\n  : loop_(NULL),\n    exiting_(false),\n    thread_(std::bind(&EventLoopThread::threadFunc, this), name),\n    mutex_(),\n    cond_(mutex_),\n    callback_(cb){\n}\n\nEventLoopThread::~EventLoopThread(){\n    exiting_ = true;\n    if (loop_ != NULL){ // not 100% race-free, eg. threadFunc could be running callback_.\n        // still a tiny chance to call destructed object, if threadFunc exits just now.\n        // but when EventLoopThread destructs, usually programming is exiting anyway.\n        loop_->quit();\n        thread_.join();\n    }\n}\n\nEventLoop* EventLoopThread::startLoop(){\n    assert(!thread_.started());\n    thread_.start();\n\n    EventLoop* loop = NULL;\n    {\n        MutexLockGuard lock(mutex_);\n        while (loop_ == NULL){  // 解决条件变量惊群效应/虚唤醒\n            cond_.wait();\n        }\n        loop = loop_;\n    }\n\n    return loop;\n}\n\nvoid EventLoopThread::threadFunc(){\n    EventLoop loop;\n\n    if (callback_){\n        callback_(&loop);\n    }\n\n    {\n        MutexLockGuard lock(mutex_);\n        loop_ = &loop;\n        cond_.notify();\n    }\n\n    loop.loop();\n    //assert(exiting_);\n    MutexLockGuard lock(mutex_);\n    loop_ = NULL;\n}\n```\n\n## 总结\n\n在Muduo网络库的设计中，EventLoop 统一使用文件描述符（file descriptor）的方式来处理事件，主要是基于以下一些好处和设计原则：\n\n1. 一致性： 使用文件描述符作为事件的抽象，使得对于不同类型的事件（包括套接字、定时器等）的处理方式一致。这种一致性简化了 EventLoop 内部的设计和实现，使得对于事件的处理更加通用。\n\n2. 多路复用： 文件描述符是多路复用（Multiplexing）机制的核心。通过将多个文件描述符注册到同一个 EventLoop 中，可以使用诸如 select、poll、epoll 等多路复用技术，实现同时监听多个事件并进行有效的事件分发。\n\n3. 高效性： 文件描述符的处理在操作系统层面已经高度优化，使用多路复用机制可以高效地管理和调度大量的事件。这对于实现高性能的网络库尤为重要。\n\n**如果读者有阅读其他网络库源码就会不可思议的发现，Muduo的One Loop Per Thread设计思想太精妙了，这种设计几乎不存在锁的竞争！！！**\n\n---\n\n**本章完结**","slug":"muduo/EvevntLoopAndThread","published":1,"updated":"2025-09-28T16:06:43.125Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9p000eq8ws2a4bco90","content":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>终于到了Muduo网络库最最核心的部分，这里还是建议大家亲自看看源码。源码很好读，博客最多起到辅助作用。因为EventLoop和Thread是绑定的，所以，可能这两部分放在一起更适合。</p>\n<p>了解ExevntLoop和Thread后，对One Loop Per Thread思想，就有了一个大体的轮廓，这种设计思想，真的很高效，因为，每个线程都有自己的资源，比如epoll、IO事件处理，定时器、任务队列等。每个线程内部资源都是自我维护的（自己的事情自己做）， <strong>除了对线程的任务队列进行操作时有一段极小的临界区需要加锁外，不涉及任何锁的竞争。这里为每个线程设置自己的任务队列的思想特别关键，正是利用每个线程只处理自己任务队列里面的回调任务，实现了将并行任务串行化的效果。</strong> 将原本的并发（涉及线程安全，需要加锁）操作，封装成任务（无需加锁）回调，添加到各自的任务队列中，交给线程自己处理。实现了<strong>线程的隔离</strong>、<strong>无锁化编程</strong>，巧妙的利用单线程天生串行执行的优势。活该Muduo高性能、高并发。</p>\n<h2 id=\"EventLoop的实现\"><a href=\"#EventLoop的实现\" class=\"headerlink\" title=\"EventLoop的实现\"></a>EventLoop的实现</h2><p><strong>提供的接口：</strong></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EventLoop</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>()&gt; Functor;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">EventLoop</span>();</span><br><span class=\"line\">    ~<span class=\"built_in\">EventLoop</span>();  <span class=\"comment\">// force out-line dtor, for std::unique_ptr members.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Loops forever.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the same thread as creation of the object.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Quits loop.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// This is not 100% thread safe, if you call through a raw pointer,</span></span><br><span class=\"line\">    <span class=\"comment\">/// better to call through shared_ptr&lt;EventLoop&gt; for 100% safety.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Runs callback immediately in the loop thread.</span></span><br><span class=\"line\">    <span class=\"comment\">/// It wakes up the loop, and run the cb.</span></span><br><span class=\"line\">    <span class=\"comment\">/// If in the same loop thread, cb is run within the function.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Safe to call from other threads.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">runInLoop</span><span class=\"params\">(Functor cb)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Queues callback in the loop thread.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Runs after finish pooling.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Safe to call from other threads.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">queueInLoop</span><span class=\"params\">(Functor cb)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">queueSize</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// timers</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// internal usage</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wakeup</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateChannel</span><span class=\"params\">(Channel* channel)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeChannel</span><span class=\"params\">(Channel* channel)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// pid_t threadId() const &#123; return threadId_; &#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assertInLoopThread</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"type\">bool</span> <span class=\"title\">isInLoopThread</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> threadId_ == CurrentThread::<span class=\"built_in\">tid</span>(); &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程的EventLoop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> EventLoop* <span class=\"title\">getEventLoopOfCurrentThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">abortNotInLoopThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// waked up</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">doPendingFunctors</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;Channel*&gt; ChannelList;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> looping_; <span class=\"comment\">/* atomic */</span> <span class=\"comment\">// 在loop()中？</span></span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">bool</span>&gt; quit_;  <span class=\"comment\">// EventLoop是否退出</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> eventHandling_; <span class=\"comment\">/* atomic */</span> <span class=\"comment\">// 正在处理事件？</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> callingPendingFunctors_; <span class=\"comment\">/* atomic */</span>  <span class=\"comment\">// 正在处理任务回调？</span></span><br><span class=\"line\">    <span class=\"type\">int64_t</span> iteration_;   <span class=\"comment\">// loop()循环的次数</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">pid_t</span> threadId_;  <span class=\"comment\">// EventLoop和哪个线程绑定？</span></span><br><span class=\"line\">    Timestamp pollReturnTime_;  <span class=\"comment\">// epoll_wait返回时的时间戳</span></span><br><span class=\"line\">    std::unique_ptr&lt;Poller&gt; poller_;  <span class=\"comment\">// epoll/poll</span></span><br><span class=\"line\">    std::unique_ptr&lt;TimerQueue&gt; timerQueue_;  <span class=\"comment\">// 定时器</span></span><br><span class=\"line\">    <span class=\"type\">int</span> wakeupFd_;  <span class=\"comment\">// tickleFd，用于手动唤醒epoll_wait，以便即使处理任务</span></span><br><span class=\"line\">    <span class=\"comment\">// unlike in TimerQueue, which is an internal class,</span></span><br><span class=\"line\">    <span class=\"comment\">// we don&#x27;t expose Channel to client.</span></span><br><span class=\"line\">    std::unique_ptr&lt;Channel&gt; wakeupChannel_;  <span class=\"comment\">// 管理tickleFd的channel</span></span><br><span class=\"line\">    boost::any context_;  <span class=\"comment\">// 待定</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// scratch variables</span></span><br><span class=\"line\">    ChannelList activeChannels_;   <span class=\"comment\">// poller_收集到的fd（channel）事件</span></span><br><span class=\"line\">    Channel* currentActiveChannel_; <span class=\"comment\">// loop()正在处理的channel</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_; <span class=\"comment\">// 只对pendingFunctors_提供保护</span></span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;Functor&gt; pendingFunctors_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// 任务队列</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Muduo在EventLoop中，使用了Linux系统中EventFd，作为wakeupChannel_的成员。这里主要为了将线程即时唤醒处理回调任务。如果你阅读过sylar的源码应该在这里会有所感知，<code>EventLoop::wakeup()</code>函数其实作用和sylar中的<code>IOManager::tickle()</code>类似。</p>\n<p>此外，为了和Muduo的EventLoop适配，Muduo定时器的实现也是利用Linux上提供的TimeFd，在TimerQueue构造函数中，也会为该fd构造一个Channel，并将该Channel注册到EventLoop的Poller中，这样极大的方便了定时器的管理与维护。</p>\n<p>简单画了一下EventLoop中核心函数<code>EventLoop::loop()</code>的执行流程图：</p>\n<p><img src=\"/2024/11/02/muduo/EvevntLoopAndThread/photo/EventLoop.drawio.png\" alt=\"loop执行流程\"></p>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程全局变量，for将线程和EventLoop绑定</span></span><br><span class=\"line\">__thread EventLoop* t_loopInThisThread = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoop::<span class=\"built_in\">EventLoop</span>()</span><br><span class=\"line\">  : <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"built_in\">threadId_</span>(CurrentThread::<span class=\"built_in\">tid</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">poller_</span>(Poller::<span class=\"built_in\">newDefaultPoller</span>(<span class=\"keyword\">this</span>)),    <span class=\"comment\">// epoll</span></span><br><span class=\"line\">    <span class=\"built_in\">timerQueue_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">TimerQueue</span>(<span class=\"keyword\">this</span>)),      <span class=\"comment\">// Muduo定时器采用的是timerfd的接口，TimerQueue对象内部也构造了对应的channel，在构造时，会向EventLopp的Poller中注册该fd。</span></span><br><span class=\"line\">    <span class=\"built_in\">wakeupFd_</span>(<span class=\"built_in\">createEventfd</span>()),   <span class=\"comment\">// 创建一个非阻塞eventfd，作为tickle</span></span><br><span class=\"line\">    <span class=\"built_in\">wakeupChannel_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Channel</span>(<span class=\"keyword\">this</span>, wakeupFd_))&#123; <span class=\"comment\">// 将eventfd封装成channel</span></span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;EventLoop created &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; in thread &quot;</span> &lt;&lt; threadId_;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t_loopInThisThread)&#123;</span><br><span class=\"line\">        LOG_FATAL &lt;&lt; <span class=\"string\">&quot;Another EventLoop &quot;</span> &lt;&lt; t_loopInThisThread</span><br><span class=\"line\">                &lt;&lt; <span class=\"string\">&quot; exists in this thread &quot;</span> &lt;&lt; threadId_;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        t_loopInThisThread = <span class=\"keyword\">this</span>;  <span class=\"comment\">// 设置线程局部变量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 为eventfd设置读回调</span></span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">setReadCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;EventLoop::handleRead, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    <span class=\"comment\">// we are always reading the wakeupfd</span></span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">enableReading</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoop::~<span class=\"built_in\">EventLoop</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 善后</span></span><br><span class=\"line\">    LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;EventLoop &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; of thread &quot;</span> &lt;&lt; threadId_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot; destructs in thread &quot;</span> &lt;&lt; CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    ::<span class=\"built_in\">close</span>(wakeupFd_);</span><br><span class=\"line\">    t_loopInThisThread = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::loop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!looping_);</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>(); <span class=\"comment\">// 在自己的线程中？</span></span><br><span class=\"line\">    looping_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    quit_ = <span class=\"literal\">false</span>;  <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> what if someone calls quit() before loop() ?</span></span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;EventLoop &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; start looping&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!quit_)&#123;</span><br><span class=\"line\">        activeChannels_.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        pollReturnTime_ = poller_-&gt;<span class=\"built_in\">poll</span>(kPollTimeMs, &amp;activeChannels_); <span class=\"comment\">// epoll_wait</span></span><br><span class=\"line\">        ++iteration_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Logger::<span class=\"built_in\">logLevel</span>() &lt;= Logger::TRACE)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printActiveChannels</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// TODO sort channel by priority</span></span><br><span class=\"line\">        eventHandling_ = <span class=\"literal\">true</span>;  <span class=\"comment\">// 开始处理每一个fd被触发的事件</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Channel* channel : activeChannels_)&#123;</span><br><span class=\"line\">            currentActiveChannel_ = channel;</span><br><span class=\"line\">            currentActiveChannel_-&gt;<span class=\"built_in\">handleEvent</span>(pollReturnTime_);  <span class=\"comment\">// 利用channel处理事件</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentActiveChannel_ = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        eventHandling_ = <span class=\"literal\">false</span>; <span class=\"comment\">// 所有fd的事件被处理完</span></span><br><span class=\"line\">        <span class=\"built_in\">doPendingFunctors</span>();  <span class=\"comment\">// 处理任务回调</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;EventLoop &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; stop looping&quot;</span>;</span><br><span class=\"line\">    looping_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::quit</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    quit_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 有线程安全问题</span></span><br><span class=\"line\">    <span class=\"comment\">// There is a chance that loop() just executes while(!quit_) and exits,</span></span><br><span class=\"line\">    <span class=\"comment\">// then EventLoop destructs, then we are accessing an invalid object.</span></span><br><span class=\"line\">    <span class=\"comment\">// Can be fixed using mutex_ in both places.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">isInLoopThread</span>())&#123;  <span class=\"comment\">// 其他线程调用quit，不确定线程是否是Active的，需要调用wakeup();</span></span><br><span class=\"line\">        <span class=\"built_in\">wakeup</span>();</span><br><span class=\"line\">    &#125; <span class=\"comment\">// 在处理事件或者任务回调时，内部自己调用了quit，说名此时线程是Active的，不用去唤醒</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::runInLoop</span><span class=\"params\">(Functor cb)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isInLoopThread</span>()) &#123;<span class=\"comment\">// 线程自己调用runInLoop，本来就是Active，直接顺手处理</span></span><br><span class=\"line\">        <span class=\"built_in\">cb</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  <span class=\"comment\">// 其他线程调用runInLoop，需要加锁</span></span><br><span class=\"line\">        <span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">move</span>(cb));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::queueInLoop</span><span class=\"params\">(Functor cb)</span></span>&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        pendingFunctors_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(cb));  <span class=\"comment\">// 任务放入任务队列</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">isInLoopThread</span>() || callingPendingFunctors_)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// 其他线程调用queueInLoop || 线程在处理任务队列中的任务时调用了queueInLoop</span></span><br><span class=\"line\">        <span class=\"comment\">//以便让线程不要阻塞在epoll_wait上从而及时处理任务回调。</span></span><br><span class=\"line\">        <span class=\"built_in\">wakeup</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::updateChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channel-&gt;<span class=\"built_in\">ownerLoop</span>() == <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    poller_-&gt;<span class=\"built_in\">updateChannel</span>(channel);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::removeChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channel-&gt;<span class=\"built_in\">ownerLoop</span>() == <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventHandling_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// channel只有自己能remove自己，其他的channel禁止删除并非自己的channel</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(currentActiveChannel_ == channel ||</span><br><span class=\"line\">            std::<span class=\"built_in\">find</span>(activeChannels_.<span class=\"built_in\">begin</span>(), activeChannels_.<span class=\"built_in\">end</span>(), channel) == activeChannels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poller_-&gt;<span class=\"built_in\">removeChannel</span>(channel);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 唤醒线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::wakeup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> one = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// tickle一下</span></span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">write</span>(wakeupFd_, &amp;one, <span class=\"keyword\">sizeof</span> one);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n != <span class=\"keyword\">sizeof</span> one)&#123;</span><br><span class=\"line\">        LOG_ERROR &lt;&lt; <span class=\"string\">&quot;EventLoop::wakeup() writes &quot;</span> &lt;&lt; n &lt;&lt; <span class=\"string\">&quot; bytes instead of 8&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::handleRead</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> one = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// tickle 回调处理</span></span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">read</span>(wakeupFd_, &amp;one, <span class=\"keyword\">sizeof</span> one);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n != <span class=\"keyword\">sizeof</span> one)&#123;</span><br><span class=\"line\">        LOG_ERROR &lt;&lt; <span class=\"string\">&quot;EventLoop::handleRead() reads &quot;</span> &lt;&lt; n &lt;&lt; <span class=\"string\">&quot; bytes instead of 8&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::doPendingFunctors</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    std::vector&lt;Functor&gt; functors;</span><br><span class=\"line\">    callingPendingFunctors_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 写时置换，同异步日志，即减少持锁时间，又减少死锁可能。</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        functors.<span class=\"built_in\">swap</span>(pendingFunctors_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Functor&amp; functor : functors)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">functor</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    callingPendingFunctors_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"细节明细：\"><a href=\"#细节明细：\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h3><p>在EventLoop类的成员变量的定义顺序中，poller_的定义位于timerQueue_之上，这个定义的顺序很关键，首先在EventLoop在构造时，先按成员变量的定义顺序构造成员变量，再会构造EventLoop本身。在析构的时候，会先析构自身，再会去按成员变量的定义顺序的倒序，去析构成员变量。考虑到timerQueue_的析构是依赖poller_的，Muduo的定义顺序（先析构timerQueue_，再析构poller_），正好规避了这个问题。</p>\n<h2 id=\"EventLoopThread的实现\"><a href=\"#EventLoopThread的实现\" class=\"headerlink\" title=\"EventLoopThread的实现\"></a>EventLoopThread的实现</h2><p>简单讲，EventLoop作用就是让EventLoop::loop()跑在线程上。</p>\n<p>EventLoopThread的实现代码是自解释的，代码量很少，也很容易理解。</p>\n<p><strong>提供的接口：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EventLoopThread</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(EventLoop*)&gt; ThreadInitCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">EventLoopThread</span>(<span class=\"type\">const</span> ThreadInitCallback&amp; cb = <span class=\"built_in\">ThreadInitCallback</span>(),</span><br><span class=\"line\">                    <span class=\"type\">const</span> string&amp; name = <span class=\"built_in\">string</span>());</span><br><span class=\"line\">    ~<span class=\"built_in\">EventLoopThread</span>();</span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">startLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">threadFunc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">EventLoop* loop_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// 依赖EventLoop</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> exiting_;  <span class=\"comment\">// 线程是否living</span></span><br><span class=\"line\">    Thread thread_; <span class=\"comment\">// 线程实体</span></span><br><span class=\"line\">    MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">Condition cond_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    ThreadInitCallback callback_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>有了EventLoop和EventLoopThread后，结合<a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a>一个EventLoopThread线程启动流程如下：</p>\n<ol>\n<li><p>EventLoopThread::startLoop() -&gt;</p>\n</li>\n<li><p>Thread::start()  -&gt; </p>\n</li>\n<li><p>pthread_create(…, &amp;detail::startThread,…)    -&gt; </p>\n</li>\n<li><p>startThread(void* obj)   -&gt;</p>\n</li>\n<li><p>ThreadData::runInThread()    -&gt; </p>\n</li>\n<li><p>Thread::func_()  -&gt;</p>\n</li>\n<li><p>EventLoopThread::threadFunc()    -&gt;</p>\n</li>\n<li><p>EventLoop::loop()</p>\n</li>\n</ol>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopThread::<span class=\"built_in\">EventLoopThread</span>(<span class=\"type\">const</span> ThreadInitCallback&amp; cb,</span><br><span class=\"line\">                                 <span class=\"type\">const</span> string&amp; name)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"literal\">NULL</span>),</span><br><span class=\"line\">    <span class=\"built_in\">exiting_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">thread_</span>(std::<span class=\"built_in\">bind</span>(&amp;EventLoopThread::threadFunc, <span class=\"keyword\">this</span>), name),</span><br><span class=\"line\">    <span class=\"built_in\">mutex_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">cond_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">callback_</span>(cb)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoopThread::~<span class=\"built_in\">EventLoopThread</span>()&#123;</span><br><span class=\"line\">    exiting_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loop_ != <span class=\"literal\">NULL</span>)&#123; <span class=\"comment\">// not 100% race-free, eg. threadFunc could be running callback_.</span></span><br><span class=\"line\">        <span class=\"comment\">// still a tiny chance to call destructed object, if threadFunc exits just now.</span></span><br><span class=\"line\">        <span class=\"comment\">// but when EventLoopThread destructs, usually programming is exiting anyway.</span></span><br><span class=\"line\">        loop_-&gt;<span class=\"built_in\">quit</span>();</span><br><span class=\"line\">        thread_.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EventLoop* <span class=\"title\">EventLoopThread::startLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!thread_.<span class=\"built_in\">started</span>());</span><br><span class=\"line\">    thread_.<span class=\"built_in\">start</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (loop_ == <span class=\"literal\">NULL</span>)&#123;  <span class=\"comment\">// 解决条件变量惊群效应/虚唤醒</span></span><br><span class=\"line\">            cond_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        loop = loop_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoopThread::threadFunc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    EventLoop loop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">callback_</span>(&amp;loop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        loop_ = &amp;loop;</span><br><span class=\"line\">        cond_.<span class=\"built_in\">notify</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    loop.<span class=\"built_in\">loop</span>();</span><br><span class=\"line\">    <span class=\"comment\">//assert(exiting_);</span></span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    loop_ = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在Muduo网络库的设计中，EventLoop 统一使用文件描述符（file descriptor）的方式来处理事件，主要是基于以下一些好处和设计原则：</p>\n<ol>\n<li><p>一致性： 使用文件描述符作为事件的抽象，使得对于不同类型的事件（包括套接字、定时器等）的处理方式一致。这种一致性简化了 EventLoop 内部的设计和实现，使得对于事件的处理更加通用。</p>\n</li>\n<li><p>多路复用： 文件描述符是多路复用（Multiplexing）机制的核心。通过将多个文件描述符注册到同一个 EventLoop 中，可以使用诸如 select、poll、epoll 等多路复用技术，实现同时监听多个事件并进行有效的事件分发。</p>\n</li>\n<li><p>高效性： 文件描述符的处理在操作系统层面已经高度优化，使用多路复用机制可以高效地管理和调度大量的事件。这对于实现高性能的网络库尤为重要。</p>\n</li>\n</ol>\n<p><strong>如果读者有阅读其他网络库源码就会不可思议的发现，Muduo的One Loop Per Thread设计思想太精妙了，这种设计几乎不存在锁的竞争！！！</strong></p>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>终于到了Muduo网络库最最核心的部分，这里还是建议大家亲自看看源码。源码很好读，博客最多起到辅助作用。因为EventLoop和Thread是绑定的，所以，可能这两部分放在一起更适合。</p>\n<p>了解ExevntLoop和Thread后，对One Loop Per Thread思想，就有了一个大体的轮廓，这种设计思想，真的很高效，因为，每个线程都有自己的资源，比如epoll、IO事件处理，定时器、任务队列等。每个线程内部资源都是自我维护的（自己的事情自己做）， <strong>除了对线程的任务队列进行操作时有一段极小的临界区需要加锁外，不涉及任何锁的竞争。这里为每个线程设置自己的任务队列的思想特别关键，正是利用每个线程只处理自己任务队列里面的回调任务，实现了将并行任务串行化的效果。</strong> 将原本的并发（涉及线程安全，需要加锁）操作，封装成任务（无需加锁）回调，添加到各自的任务队列中，交给线程自己处理。实现了<strong>线程的隔离</strong>、<strong>无锁化编程</strong>，巧妙的利用单线程天生串行执行的优势。活该Muduo高性能、高并发。</p>\n<h2 id=\"EventLoop的实现\"><a href=\"#EventLoop的实现\" class=\"headerlink\" title=\"EventLoop的实现\"></a>EventLoop的实现</h2><p><strong>提供的接口：</strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EventLoop</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>()&gt; Functor;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">EventLoop</span>();</span><br><span class=\"line\">    ~<span class=\"built_in\">EventLoop</span>();  <span class=\"comment\">// force out-line dtor, for std::unique_ptr members.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Loops forever.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the same thread as creation of the object.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Quits loop.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// This is not 100% thread safe, if you call through a raw pointer,</span></span><br><span class=\"line\">    <span class=\"comment\">/// better to call through shared_ptr&lt;EventLoop&gt; for 100% safety.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Runs callback immediately in the loop thread.</span></span><br><span class=\"line\">    <span class=\"comment\">/// It wakes up the loop, and run the cb.</span></span><br><span class=\"line\">    <span class=\"comment\">/// If in the same loop thread, cb is run within the function.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Safe to call from other threads.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">runInLoop</span><span class=\"params\">(Functor cb)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Queues callback in the loop thread.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Runs after finish pooling.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Safe to call from other threads.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">queueInLoop</span><span class=\"params\">(Functor cb)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">queueSize</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// timers</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// internal usage</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wakeup</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateChannel</span><span class=\"params\">(Channel* channel)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeChannel</span><span class=\"params\">(Channel* channel)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// pid_t threadId() const &#123; return threadId_; &#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assertInLoopThread</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"type\">bool</span> <span class=\"title\">isInLoopThread</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> threadId_ == CurrentThread::<span class=\"built_in\">tid</span>(); &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程的EventLoop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> EventLoop* <span class=\"title\">getEventLoopOfCurrentThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">abortNotInLoopThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// waked up</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">doPendingFunctors</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;Channel*&gt; ChannelList;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> looping_; <span class=\"comment\">/* atomic */</span> <span class=\"comment\">// 在loop()中？</span></span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">bool</span>&gt; quit_;  <span class=\"comment\">// EventLoop是否退出</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> eventHandling_; <span class=\"comment\">/* atomic */</span> <span class=\"comment\">// 正在处理事件？</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> callingPendingFunctors_; <span class=\"comment\">/* atomic */</span>  <span class=\"comment\">// 正在处理任务回调？</span></span><br><span class=\"line\">    <span class=\"type\">int64_t</span> iteration_;   <span class=\"comment\">// loop()循环的次数</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">pid_t</span> threadId_;  <span class=\"comment\">// EventLoop和哪个线程绑定？</span></span><br><span class=\"line\">    Timestamp pollReturnTime_;  <span class=\"comment\">// epoll_wait返回时的时间戳</span></span><br><span class=\"line\">    std::unique_ptr&lt;Poller&gt; poller_;  <span class=\"comment\">// epoll/poll</span></span><br><span class=\"line\">    std::unique_ptr&lt;TimerQueue&gt; timerQueue_;  <span class=\"comment\">// 定时器</span></span><br><span class=\"line\">    <span class=\"type\">int</span> wakeupFd_;  <span class=\"comment\">// tickleFd，用于手动唤醒epoll_wait，以便即使处理任务</span></span><br><span class=\"line\">    <span class=\"comment\">// unlike in TimerQueue, which is an internal class,</span></span><br><span class=\"line\">    <span class=\"comment\">// we don&#x27;t expose Channel to client.</span></span><br><span class=\"line\">    std::unique_ptr&lt;Channel&gt; wakeupChannel_;  <span class=\"comment\">// 管理tickleFd的channel</span></span><br><span class=\"line\">    boost::any context_;  <span class=\"comment\">// 待定</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// scratch variables</span></span><br><span class=\"line\">    ChannelList activeChannels_;   <span class=\"comment\">// poller_收集到的fd（channel）事件</span></span><br><span class=\"line\">    Channel* currentActiveChannel_; <span class=\"comment\">// loop()正在处理的channel</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_; <span class=\"comment\">// 只对pendingFunctors_提供保护</span></span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;Functor&gt; pendingFunctors_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// 任务队列</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Muduo在EventLoop中，使用了Linux系统中EventFd，作为wakeupChannel_的成员。这里主要为了将线程即时唤醒处理回调任务。如果你阅读过sylar的源码应该在这里会有所感知，<code>EventLoop::wakeup()</code>函数其实作用和sylar中的<code>IOManager::tickle()</code>类似。</p>\n<p>此外，为了和Muduo的EventLoop适配，Muduo定时器的实现也是利用Linux上提供的TimeFd，在TimerQueue构造函数中，也会为该fd构造一个Channel，并将该Channel注册到EventLoop的Poller中，这样极大的方便了定时器的管理与维护。</p>\n<p>简单画了一下EventLoop中核心函数<code>EventLoop::loop()</code>的执行流程图：</p>\n<p><img src=\"/2024/11/02/muduo/EvevntLoopAndThread/photo/EventLoop.drawio.png\" alt=\"loop执行流程\"></p>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程全局变量，for将线程和EventLoop绑定</span></span><br><span class=\"line\">__thread EventLoop* t_loopInThisThread = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoop::<span class=\"built_in\">EventLoop</span>()</span><br><span class=\"line\">  : <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"built_in\">threadId_</span>(CurrentThread::<span class=\"built_in\">tid</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">poller_</span>(Poller::<span class=\"built_in\">newDefaultPoller</span>(<span class=\"keyword\">this</span>)),    <span class=\"comment\">// epoll</span></span><br><span class=\"line\">    <span class=\"built_in\">timerQueue_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">TimerQueue</span>(<span class=\"keyword\">this</span>)),      <span class=\"comment\">// Muduo定时器采用的是timerfd的接口，TimerQueue对象内部也构造了对应的channel，在构造时，会向EventLopp的Poller中注册该fd。</span></span><br><span class=\"line\">    <span class=\"built_in\">wakeupFd_</span>(<span class=\"built_in\">createEventfd</span>()),   <span class=\"comment\">// 创建一个非阻塞eventfd，作为tickle</span></span><br><span class=\"line\">    <span class=\"built_in\">wakeupChannel_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Channel</span>(<span class=\"keyword\">this</span>, wakeupFd_))&#123; <span class=\"comment\">// 将eventfd封装成channel</span></span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;EventLoop created &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; in thread &quot;</span> &lt;&lt; threadId_;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t_loopInThisThread)&#123;</span><br><span class=\"line\">        LOG_FATAL &lt;&lt; <span class=\"string\">&quot;Another EventLoop &quot;</span> &lt;&lt; t_loopInThisThread</span><br><span class=\"line\">                &lt;&lt; <span class=\"string\">&quot; exists in this thread &quot;</span> &lt;&lt; threadId_;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        t_loopInThisThread = <span class=\"keyword\">this</span>;  <span class=\"comment\">// 设置线程局部变量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 为eventfd设置读回调</span></span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">setReadCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;EventLoop::handleRead, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    <span class=\"comment\">// we are always reading the wakeupfd</span></span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">enableReading</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoop::~<span class=\"built_in\">EventLoop</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 善后</span></span><br><span class=\"line\">    LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;EventLoop &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; of thread &quot;</span> &lt;&lt; threadId_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot; destructs in thread &quot;</span> &lt;&lt; CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    ::<span class=\"built_in\">close</span>(wakeupFd_);</span><br><span class=\"line\">    t_loopInThisThread = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::loop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!looping_);</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>(); <span class=\"comment\">// 在自己的线程中？</span></span><br><span class=\"line\">    looping_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    quit_ = <span class=\"literal\">false</span>;  <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> what if someone calls quit() before loop() ?</span></span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;EventLoop &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; start looping&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!quit_)&#123;</span><br><span class=\"line\">        activeChannels_.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        pollReturnTime_ = poller_-&gt;<span class=\"built_in\">poll</span>(kPollTimeMs, &amp;activeChannels_); <span class=\"comment\">// epoll_wait</span></span><br><span class=\"line\">        ++iteration_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Logger::<span class=\"built_in\">logLevel</span>() &lt;= Logger::TRACE)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printActiveChannels</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// TODO sort channel by priority</span></span><br><span class=\"line\">        eventHandling_ = <span class=\"literal\">true</span>;  <span class=\"comment\">// 开始处理每一个fd被触发的事件</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Channel* channel : activeChannels_)&#123;</span><br><span class=\"line\">            currentActiveChannel_ = channel;</span><br><span class=\"line\">            currentActiveChannel_-&gt;<span class=\"built_in\">handleEvent</span>(pollReturnTime_);  <span class=\"comment\">// 利用channel处理事件</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentActiveChannel_ = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        eventHandling_ = <span class=\"literal\">false</span>; <span class=\"comment\">// 所有fd的事件被处理完</span></span><br><span class=\"line\">        <span class=\"built_in\">doPendingFunctors</span>();  <span class=\"comment\">// 处理任务回调</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;EventLoop &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; stop looping&quot;</span>;</span><br><span class=\"line\">    looping_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::quit</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    quit_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 有线程安全问题</span></span><br><span class=\"line\">    <span class=\"comment\">// There is a chance that loop() just executes while(!quit_) and exits,</span></span><br><span class=\"line\">    <span class=\"comment\">// then EventLoop destructs, then we are accessing an invalid object.</span></span><br><span class=\"line\">    <span class=\"comment\">// Can be fixed using mutex_ in both places.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">isInLoopThread</span>())&#123;  <span class=\"comment\">// 其他线程调用quit，不确定线程是否是Active的，需要调用wakeup();</span></span><br><span class=\"line\">        <span class=\"built_in\">wakeup</span>();</span><br><span class=\"line\">    &#125; <span class=\"comment\">// 在处理事件或者任务回调时，内部自己调用了quit，说名此时线程是Active的，不用去唤醒</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::runInLoop</span><span class=\"params\">(Functor cb)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isInLoopThread</span>()) &#123;<span class=\"comment\">// 线程自己调用runInLoop，本来就是Active，直接顺手处理</span></span><br><span class=\"line\">        <span class=\"built_in\">cb</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  <span class=\"comment\">// 其他线程调用runInLoop，需要加锁</span></span><br><span class=\"line\">        <span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">move</span>(cb));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::queueInLoop</span><span class=\"params\">(Functor cb)</span></span>&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        pendingFunctors_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(cb));  <span class=\"comment\">// 任务放入任务队列</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">isInLoopThread</span>() || callingPendingFunctors_)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// 其他线程调用queueInLoop || 线程在处理任务队列中的任务时调用了queueInLoop</span></span><br><span class=\"line\">        <span class=\"comment\">//以便让线程不要阻塞在epoll_wait上从而及时处理任务回调。</span></span><br><span class=\"line\">        <span class=\"built_in\">wakeup</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::updateChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channel-&gt;<span class=\"built_in\">ownerLoop</span>() == <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    poller_-&gt;<span class=\"built_in\">updateChannel</span>(channel);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::removeChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channel-&gt;<span class=\"built_in\">ownerLoop</span>() == <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventHandling_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// channel只有自己能remove自己，其他的channel禁止删除并非自己的channel</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(currentActiveChannel_ == channel ||</span><br><span class=\"line\">            std::<span class=\"built_in\">find</span>(activeChannels_.<span class=\"built_in\">begin</span>(), activeChannels_.<span class=\"built_in\">end</span>(), channel) == activeChannels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poller_-&gt;<span class=\"built_in\">removeChannel</span>(channel);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 唤醒线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::wakeup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> one = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// tickle一下</span></span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">write</span>(wakeupFd_, &amp;one, <span class=\"keyword\">sizeof</span> one);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n != <span class=\"keyword\">sizeof</span> one)&#123;</span><br><span class=\"line\">        LOG_ERROR &lt;&lt; <span class=\"string\">&quot;EventLoop::wakeup() writes &quot;</span> &lt;&lt; n &lt;&lt; <span class=\"string\">&quot; bytes instead of 8&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::handleRead</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> one = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// tickle 回调处理</span></span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">read</span>(wakeupFd_, &amp;one, <span class=\"keyword\">sizeof</span> one);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n != <span class=\"keyword\">sizeof</span> one)&#123;</span><br><span class=\"line\">        LOG_ERROR &lt;&lt; <span class=\"string\">&quot;EventLoop::handleRead() reads &quot;</span> &lt;&lt; n &lt;&lt; <span class=\"string\">&quot; bytes instead of 8&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::doPendingFunctors</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    std::vector&lt;Functor&gt; functors;</span><br><span class=\"line\">    callingPendingFunctors_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 写时置换，同异步日志，即减少持锁时间，又减少死锁可能。</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        functors.<span class=\"built_in\">swap</span>(pendingFunctors_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Functor&amp; functor : functors)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">functor</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    callingPendingFunctors_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"细节明细：\"><a href=\"#细节明细：\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h3><p>在EventLoop类的成员变量的定义顺序中，poller_的定义位于timerQueue_之上，这个定义的顺序很关键，首先在EventLoop在构造时，先按成员变量的定义顺序构造成员变量，再会构造EventLoop本身。在析构的时候，会先析构自身，再会去按成员变量的定义顺序的倒序，去析构成员变量。考虑到timerQueue_的析构是依赖poller_的，Muduo的定义顺序（先析构timerQueue_，再析构poller_），正好规避了这个问题。</p>\n<h2 id=\"EventLoopThread的实现\"><a href=\"#EventLoopThread的实现\" class=\"headerlink\" title=\"EventLoopThread的实现\"></a>EventLoopThread的实现</h2><p>简单讲，EventLoop作用就是让EventLoop::loop()跑在线程上。</p>\n<p>EventLoopThread的实现代码是自解释的，代码量很少，也很容易理解。</p>\n<p><strong>提供的接口：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EventLoopThread</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(EventLoop*)&gt; ThreadInitCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">EventLoopThread</span>(<span class=\"type\">const</span> ThreadInitCallback&amp; cb = <span class=\"built_in\">ThreadInitCallback</span>(),</span><br><span class=\"line\">                    <span class=\"type\">const</span> string&amp; name = <span class=\"built_in\">string</span>());</span><br><span class=\"line\">    ~<span class=\"built_in\">EventLoopThread</span>();</span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">startLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">threadFunc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">EventLoop* loop_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// 依赖EventLoop</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> exiting_;  <span class=\"comment\">// 线程是否living</span></span><br><span class=\"line\">    Thread thread_; <span class=\"comment\">// 线程实体</span></span><br><span class=\"line\">    MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">Condition cond_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    ThreadInitCallback callback_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>有了EventLoop和EventLoopThread后，结合<a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a>一个EventLoopThread线程启动流程如下：</p>\n<ol>\n<li><p>EventLoopThread::startLoop() -&gt;</p>\n</li>\n<li><p>Thread::start()  -&gt; </p>\n</li>\n<li><p>pthread_create(…, &amp;detail::startThread,…)    -&gt; </p>\n</li>\n<li><p>startThread(void* obj)   -&gt;</p>\n</li>\n<li><p>ThreadData::runInThread()    -&gt; </p>\n</li>\n<li><p>Thread::func_()  -&gt;</p>\n</li>\n<li><p>EventLoopThread::threadFunc()    -&gt;</p>\n</li>\n<li><p>EventLoop::loop()</p>\n</li>\n</ol>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopThread::<span class=\"built_in\">EventLoopThread</span>(<span class=\"type\">const</span> ThreadInitCallback&amp; cb,</span><br><span class=\"line\">                                 <span class=\"type\">const</span> string&amp; name)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"literal\">NULL</span>),</span><br><span class=\"line\">    <span class=\"built_in\">exiting_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">thread_</span>(std::<span class=\"built_in\">bind</span>(&amp;EventLoopThread::threadFunc, <span class=\"keyword\">this</span>), name),</span><br><span class=\"line\">    <span class=\"built_in\">mutex_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">cond_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">callback_</span>(cb)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoopThread::~<span class=\"built_in\">EventLoopThread</span>()&#123;</span><br><span class=\"line\">    exiting_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loop_ != <span class=\"literal\">NULL</span>)&#123; <span class=\"comment\">// not 100% race-free, eg. threadFunc could be running callback_.</span></span><br><span class=\"line\">        <span class=\"comment\">// still a tiny chance to call destructed object, if threadFunc exits just now.</span></span><br><span class=\"line\">        <span class=\"comment\">// but when EventLoopThread destructs, usually programming is exiting anyway.</span></span><br><span class=\"line\">        loop_-&gt;<span class=\"built_in\">quit</span>();</span><br><span class=\"line\">        thread_.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EventLoop* <span class=\"title\">EventLoopThread::startLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!thread_.<span class=\"built_in\">started</span>());</span><br><span class=\"line\">    thread_.<span class=\"built_in\">start</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (loop_ == <span class=\"literal\">NULL</span>)&#123;  <span class=\"comment\">// 解决条件变量惊群效应/虚唤醒</span></span><br><span class=\"line\">            cond_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        loop = loop_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoopThread::threadFunc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    EventLoop loop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">callback_</span>(&amp;loop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        loop_ = &amp;loop;</span><br><span class=\"line\">        cond_.<span class=\"built_in\">notify</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    loop.<span class=\"built_in\">loop</span>();</span><br><span class=\"line\">    <span class=\"comment\">//assert(exiting_);</span></span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    loop_ = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在Muduo网络库的设计中，EventLoop 统一使用文件描述符（file descriptor）的方式来处理事件，主要是基于以下一些好处和设计原则：</p>\n<ol>\n<li><p>一致性： 使用文件描述符作为事件的抽象，使得对于不同类型的事件（包括套接字、定时器等）的处理方式一致。这种一致性简化了 EventLoop 内部的设计和实现，使得对于事件的处理更加通用。</p>\n</li>\n<li><p>多路复用： 文件描述符是多路复用（Multiplexing）机制的核心。通过将多个文件描述符注册到同一个 EventLoop 中，可以使用诸如 select、poll、epoll 等多路复用技术，实现同时监听多个事件并进行有效的事件分发。</p>\n</li>\n<li><p>高效性： 文件描述符的处理在操作系统层面已经高度优化，使用多路复用机制可以高效地管理和调度大量的事件。这对于实现高性能的网络库尤为重要。</p>\n</li>\n</ol>\n<p><strong>如果读者有阅读其他网络库源码就会不可思议的发现，Muduo的One Loop Per Thread设计思想太精妙了，这种设计几乎不存在锁的竞争！！！</strong></p>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"muduo源码阅读笔记（1、同步日志）","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\nMuduo的日志设计的非常简单，日志的格式是固定的，一条日志包括：[日志头，日志体，日志尾]。实际上，参考工业级日志的使用来看，日志还应该能支持格式变更，即用户可以自定义日志的格式，选择自己关心的日志条目进行输出，或者在日志中添加一些额外的字符来修饰日志。考虑到Muduo的核心是网络库，而不是日志库，这些点就不过多深入讨论。\n\n## 日志消息体输出到`Impl::stream_`（简化日志的使用方式（宏定义 + 临时对象的编程技巧）\n\n调用匿名对象的`stream()`成员函数，会返回一个类型为LogStream的引用也即`Impl::stream_`对象本身，muduo对`LogStream`类进行了详细的`>>`操作符重载，这部分代码简单易读，就不详细赘述了，这样就能将**字符串类型/数值类型**的数据使用`>>`操作符输出到`Impl::stream_`上（类似std::cout的使用）\n\n日志消息体的输出：\n<!-- more -->\n```cpp\n//\n// CAUTION: do not write:\n//\n// if (good)\n//   LOG_INFO << \"Good news\";\n// else\n//   LOG_WARN << \"Bad news\";\n//\n// this expends to\n//\n// if (good)\n//   if (logging_INFO)\n//     logInfoStream << \"Good news\";\n//   else\n//     logWarnStream << \"Bad news\";\n//\n#define LOG_TRACE if (muduo::Logger::logLevel() <= muduo::Logger::TRACE) \\\n  muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream()\n#define LOG_DEBUG if (muduo::Logger::logLevel() <= muduo::Logger::DEBUG) \\\n  muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream()\n#define LOG_INFO if (muduo::Logger::logLevel() <= muduo::Logger::INFO) \\\n  muduo::Logger(__FILE__, __LINE__).stream()\n#define LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream()\n#define LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream()\n#define LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream()\n#define LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream()\n#define LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream()\n```\n\n综合`Logger`以及`LogStream`的实现可知，在程序运行期间，通过上面的宏使用muduo的日志时，创建的Logger临时对象会在 **栈上开辟一段很大的空间（一般是detail::kSmallBuffer（4000byte））** 缓存日志\n\n## 日志消息头输出到`Impl::stream_`\n\n结合上面的宏定义来讲，在muduo中，当临时的Logger对象构造时，在其构造函数中，首先会自动输出一条日志的基本头部信息，比如对宏定义传来的时间戳进行格式化输出，输出线程所在的tid以及日志级别，如果是一条错误报告的log（此时errno非0），还会输出错误码的字符串信息。\n\n```cpp\nLogger::Impl::Impl(LogLevel level, int savedErrno, const SourceFile& file, int line)\n  : time_(Timestamp::now()),\n    stream_(),\n    level_(level),\n    line_(line),\n    basename_(file)\n{\n  formatTime(); // 输出格式化的时间戳（这部分代码可简略的看一下，了解作用即可，无需细看。\n  CurrentThread::tid(); // 缓存tid\n  stream_ << T(CurrentThread::tidString(), CurrentThread::tidStringLength()); // 输出字符串形式的tid\n  stream_ << T(LogLevelName[level], 6); //输出字符串形式的日志级别\n  if (savedErrno != 0)  //需要输出错误就输出错误\n  {\n    stream_ << strerror_tl(savedErrno) << \" (errno=\" << savedErrno << \") \";\n  }\n}\n\n// ...\n\nLogger::Logger(SourceFile file, int line)\n  : impl_(INFO, 0, file, line)\n{\n}\n// ...\n```\n\n## 日志尾部输出到`Impl::stream_` && `Impl::stream_`对象直接输出到日志输出地（LogAppender）（利用临时对象行生命周期的特点，在析构中，同步（默认）输出日志。\n\n这里的LogAppender可能代表磁盘上的文件、控制台std::cout、数据库等。\n\nMuduo的日志中g_output其实是类型是函数指针的全局变量，这里通过函数指针实现了C语言的多态，Muduo默认的`g_output`是**直接**将`Impl::stream_`拼接的日志输出到控制台，即**输出是同步的**。当然，如果用户参考g_output的定义，实现了自己的输出函数，可以通过`Logger::setOutput()`接口，提供自定义函数的地址作为参数，将自定义函数安装到`g_output`上。后面Muduo实现的异步日志就是这么干的。\n\n```cpp\nvoid defaultOutput(const char* msg, int len)\n{\n  // 同步输出到终端\n  size_t n = fwrite(msg, 1, len, stdout);\n  //FIXME check n\n  (void)n;\n}\n\nvoid defaultFlush()\n{\n  fflush(stdout);\n}\n\n/*\n* 函数指针，实现多态。以及输出的解耦。\n* typedef void (*OutputFunc)(const char* msg, int len);\n* typedef void (*FlushFunc)();\n*/\nLogger::OutputFunc g_output = defaultOutput;\nLogger::FlushFunc g_flush = defaultFlush;\n\n// ...\n\nvoid Logger::Impl::finish()\n{\n  stream_ << \" - \" << basename_ << ':' << line_ << '\\n';    //将文件名以及日志所在行号（临时对象的构造会传入这两个信息）作为日志尾输出到Impl::stream_\n}\n\n// ...\n\nLogger::~Logger()\n{\n  impl_.finish();\n  const LogStream::Buffer& buf(stream().buffer());  // 获取Impl::stream_\n  g_output(buf.data(), buf.length());   // 将Impl::stream_输出到日志输出地（stdout/file/database）\n  if (impl_.level_ == FATAL)\n  {\n    g_flush();\n    abort();\n  }\n}\n```\n\n## 日志效果\n|       LogHeader                    |   LogBody       |   LogTail               |\n|       ----                         |   ----          |   ----                  |\n|       Time ThreadID LogLevel       |   LogMessage    |    - FileName:LineNumber|\n```bash\n20240109 03:21:56.970321Z  3094 INFO  Hello - Logging_test.cc:69\n20240109 03:21:56.970363Z  3094 WARN  World - Logging_test.cc:70\n20240109 03:21:56.970367Z  3094 ERROR Error - Logging_test.cc:71\n```\n\n## 细节明细\n\n在 Muduo 中，为了实现日志的功能，使用了一个内部的 Impl 类来处理日志的具体实现细节。这样的设计有几个优点：\n\n1. 封装性：\n将日志的具体实现封装在 Impl 类中，使得日志系统的使用者无需关心内部的具体实现细节。这样可以减少用户对日志系统内部的依赖，提高系统的封装性和可维护性。\n\n2. 灵活性：\nImpl 类的存在使得 Muduo 可以更加灵活地修改、扩展或者替换日志系统的具体实现，而不会对外部接口产生影响。如果未来需要更换日志库、修改日志输出格式等，只需修改 Impl 类的实现而不必修改用户代码。\n\n3. 解耦：\n通过引入 Impl 类，日志系统的实现与接口之间形成了一种解耦。这种解耦有助于降低模块之间的依赖性，提高代码的灵活性和可维护性。\n\n4. 信息隐藏：\nImpl 类将具体的实现细节隐藏在类的私有部分，只暴露必要的接口给外部。这有助于控制用户对日志系统内部的访问权限，同时防止滥用或错误的使用。\n\nmuduo还统一了日志级别的字符串长度，固定为6，不足的补空格，这样，也提升了一点点性能，毕竟积少成多。同时利用模板，在编译期确定字符串长度的操作，可以参考SourceFile类的数组引用构造的实现。\n\n```cpp\ntemplate<int N>\nSourceFile(const char (&arr)[N])  // 数组引用，编译期就能确定字符串长度。\n    : data_(arr),\n    size_(N-1)\n{\n    const char* slash = strrchr(data_, '/'); // builtin function\n    if (slash)\n    {\n    data_ = slash + 1;\n    size_ -= static_cast<int>(data_ - arr);\n    }\n}\n```\n\n---\n\n**本章完结**","source":"_posts/muduo/SynLogging.md","raw":"---\ntitle: muduo源码阅读笔记（1、同步日志）\ndate: 2024-11-02 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\nMuduo的日志设计的非常简单，日志的格式是固定的，一条日志包括：[日志头，日志体，日志尾]。实际上，参考工业级日志的使用来看，日志还应该能支持格式变更，即用户可以自定义日志的格式，选择自己关心的日志条目进行输出，或者在日志中添加一些额外的字符来修饰日志。考虑到Muduo的核心是网络库，而不是日志库，这些点就不过多深入讨论。\n\n## 日志消息体输出到`Impl::stream_`（简化日志的使用方式（宏定义 + 临时对象的编程技巧）\n\n调用匿名对象的`stream()`成员函数，会返回一个类型为LogStream的引用也即`Impl::stream_`对象本身，muduo对`LogStream`类进行了详细的`>>`操作符重载，这部分代码简单易读，就不详细赘述了，这样就能将**字符串类型/数值类型**的数据使用`>>`操作符输出到`Impl::stream_`上（类似std::cout的使用）\n\n日志消息体的输出：\n<!-- more -->\n```cpp\n//\n// CAUTION: do not write:\n//\n// if (good)\n//   LOG_INFO << \"Good news\";\n// else\n//   LOG_WARN << \"Bad news\";\n//\n// this expends to\n//\n// if (good)\n//   if (logging_INFO)\n//     logInfoStream << \"Good news\";\n//   else\n//     logWarnStream << \"Bad news\";\n//\n#define LOG_TRACE if (muduo::Logger::logLevel() <= muduo::Logger::TRACE) \\\n  muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream()\n#define LOG_DEBUG if (muduo::Logger::logLevel() <= muduo::Logger::DEBUG) \\\n  muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream()\n#define LOG_INFO if (muduo::Logger::logLevel() <= muduo::Logger::INFO) \\\n  muduo::Logger(__FILE__, __LINE__).stream()\n#define LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream()\n#define LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream()\n#define LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream()\n#define LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream()\n#define LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream()\n```\n\n综合`Logger`以及`LogStream`的实现可知，在程序运行期间，通过上面的宏使用muduo的日志时，创建的Logger临时对象会在 **栈上开辟一段很大的空间（一般是detail::kSmallBuffer（4000byte））** 缓存日志\n\n## 日志消息头输出到`Impl::stream_`\n\n结合上面的宏定义来讲，在muduo中，当临时的Logger对象构造时，在其构造函数中，首先会自动输出一条日志的基本头部信息，比如对宏定义传来的时间戳进行格式化输出，输出线程所在的tid以及日志级别，如果是一条错误报告的log（此时errno非0），还会输出错误码的字符串信息。\n\n```cpp\nLogger::Impl::Impl(LogLevel level, int savedErrno, const SourceFile& file, int line)\n  : time_(Timestamp::now()),\n    stream_(),\n    level_(level),\n    line_(line),\n    basename_(file)\n{\n  formatTime(); // 输出格式化的时间戳（这部分代码可简略的看一下，了解作用即可，无需细看。\n  CurrentThread::tid(); // 缓存tid\n  stream_ << T(CurrentThread::tidString(), CurrentThread::tidStringLength()); // 输出字符串形式的tid\n  stream_ << T(LogLevelName[level], 6); //输出字符串形式的日志级别\n  if (savedErrno != 0)  //需要输出错误就输出错误\n  {\n    stream_ << strerror_tl(savedErrno) << \" (errno=\" << savedErrno << \") \";\n  }\n}\n\n// ...\n\nLogger::Logger(SourceFile file, int line)\n  : impl_(INFO, 0, file, line)\n{\n}\n// ...\n```\n\n## 日志尾部输出到`Impl::stream_` && `Impl::stream_`对象直接输出到日志输出地（LogAppender）（利用临时对象行生命周期的特点，在析构中，同步（默认）输出日志。\n\n这里的LogAppender可能代表磁盘上的文件、控制台std::cout、数据库等。\n\nMuduo的日志中g_output其实是类型是函数指针的全局变量，这里通过函数指针实现了C语言的多态，Muduo默认的`g_output`是**直接**将`Impl::stream_`拼接的日志输出到控制台，即**输出是同步的**。当然，如果用户参考g_output的定义，实现了自己的输出函数，可以通过`Logger::setOutput()`接口，提供自定义函数的地址作为参数，将自定义函数安装到`g_output`上。后面Muduo实现的异步日志就是这么干的。\n\n```cpp\nvoid defaultOutput(const char* msg, int len)\n{\n  // 同步输出到终端\n  size_t n = fwrite(msg, 1, len, stdout);\n  //FIXME check n\n  (void)n;\n}\n\nvoid defaultFlush()\n{\n  fflush(stdout);\n}\n\n/*\n* 函数指针，实现多态。以及输出的解耦。\n* typedef void (*OutputFunc)(const char* msg, int len);\n* typedef void (*FlushFunc)();\n*/\nLogger::OutputFunc g_output = defaultOutput;\nLogger::FlushFunc g_flush = defaultFlush;\n\n// ...\n\nvoid Logger::Impl::finish()\n{\n  stream_ << \" - \" << basename_ << ':' << line_ << '\\n';    //将文件名以及日志所在行号（临时对象的构造会传入这两个信息）作为日志尾输出到Impl::stream_\n}\n\n// ...\n\nLogger::~Logger()\n{\n  impl_.finish();\n  const LogStream::Buffer& buf(stream().buffer());  // 获取Impl::stream_\n  g_output(buf.data(), buf.length());   // 将Impl::stream_输出到日志输出地（stdout/file/database）\n  if (impl_.level_ == FATAL)\n  {\n    g_flush();\n    abort();\n  }\n}\n```\n\n## 日志效果\n|       LogHeader                    |   LogBody       |   LogTail               |\n|       ----                         |   ----          |   ----                  |\n|       Time ThreadID LogLevel       |   LogMessage    |    - FileName:LineNumber|\n```bash\n20240109 03:21:56.970321Z  3094 INFO  Hello - Logging_test.cc:69\n20240109 03:21:56.970363Z  3094 WARN  World - Logging_test.cc:70\n20240109 03:21:56.970367Z  3094 ERROR Error - Logging_test.cc:71\n```\n\n## 细节明细\n\n在 Muduo 中，为了实现日志的功能，使用了一个内部的 Impl 类来处理日志的具体实现细节。这样的设计有几个优点：\n\n1. 封装性：\n将日志的具体实现封装在 Impl 类中，使得日志系统的使用者无需关心内部的具体实现细节。这样可以减少用户对日志系统内部的依赖，提高系统的封装性和可维护性。\n\n2. 灵活性：\nImpl 类的存在使得 Muduo 可以更加灵活地修改、扩展或者替换日志系统的具体实现，而不会对外部接口产生影响。如果未来需要更换日志库、修改日志输出格式等，只需修改 Impl 类的实现而不必修改用户代码。\n\n3. 解耦：\n通过引入 Impl 类，日志系统的实现与接口之间形成了一种解耦。这种解耦有助于降低模块之间的依赖性，提高代码的灵活性和可维护性。\n\n4. 信息隐藏：\nImpl 类将具体的实现细节隐藏在类的私有部分，只暴露必要的接口给外部。这有助于控制用户对日志系统内部的访问权限，同时防止滥用或错误的使用。\n\nmuduo还统一了日志级别的字符串长度，固定为6，不足的补空格，这样，也提升了一点点性能，毕竟积少成多。同时利用模板，在编译期确定字符串长度的操作，可以参考SourceFile类的数组引用构造的实现。\n\n```cpp\ntemplate<int N>\nSourceFile(const char (&arr)[N])  // 数组引用，编译期就能确定字符串长度。\n    : data_(arr),\n    size_(N-1)\n{\n    const char* slash = strrchr(data_, '/'); // builtin function\n    if (slash)\n    {\n    data_ = slash + 1;\n    size_ -= static_cast<int>(data_ - arr);\n    }\n}\n```\n\n---\n\n**本章完结**","slug":"muduo/SynLogging","published":1,"updated":"2025-09-28T16:06:43.130Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9q000gq8wscd9u3po5","content":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>Muduo的日志设计的非常简单，日志的格式是固定的，一条日志包括：[日志头，日志体，日志尾]。实际上，参考工业级日志的使用来看，日志还应该能支持格式变更，即用户可以自定义日志的格式，选择自己关心的日志条目进行输出，或者在日志中添加一些额外的字符来修饰日志。考虑到Muduo的核心是网络库，而不是日志库，这些点就不过多深入讨论。</p>\n<h2 id=\"日志消息体输出到Impl-stream-（简化日志的使用方式（宏定义-临时对象的编程技巧）\"><a href=\"#日志消息体输出到Impl-stream-（简化日志的使用方式（宏定义-临时对象的编程技巧）\" class=\"headerlink\" title=\"日志消息体输出到Impl::stream_（简化日志的使用方式（宏定义 + 临时对象的编程技巧）\"></a>日志消息体输出到<code>Impl::stream_</code>（简化日志的使用方式（宏定义 + 临时对象的编程技巧）</h2><p>调用匿名对象的<code>stream()</code>成员函数，会返回一个类型为LogStream的引用也即<code>Impl::stream_</code>对象本身，muduo对<code>LogStream</code>类进行了详细的<code>&gt;&gt;</code>操作符重载，这部分代码简单易读，就不详细赘述了，这样就能将<strong>字符串类型&#x2F;数值类型</strong>的数据使用<code>&gt;&gt;</code>操作符输出到<code>Impl::stream_</code>上（类似std::cout的使用）</p>\n<p>日志消息体的输出：</p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// CAUTION: do not write:</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// if (good)</span></span><br><span class=\"line\"><span class=\"comment\">//   LOG_INFO &lt;&lt; &quot;Good news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">// else</span></span><br><span class=\"line\"><span class=\"comment\">//   LOG_WARN &lt;&lt; &quot;Bad news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// this expends to</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// if (good)</span></span><br><span class=\"line\"><span class=\"comment\">//   if (logging_INFO)</span></span><br><span class=\"line\"><span class=\"comment\">//     logInfoStream &lt;&lt; &quot;Good news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">//   else</span></span><br><span class=\"line\"><span class=\"comment\">//     logWarnStream &lt;&lt; &quot;Bad news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_TRACE <span class=\"keyword\">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::TRACE) \\</span></span><br><span class=\"line\"><span class=\"meta\">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_DEBUG <span class=\"keyword\">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::DEBUG) \\</span></span><br><span class=\"line\"><span class=\"meta\">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_INFO <span class=\"keyword\">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::INFO) \\</span></span><br><span class=\"line\"><span class=\"meta\">  muduo::Logger(__FILE__, __LINE__).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream()</span></span><br></pre></td></tr></table></figure>\n\n<p>综合<code>Logger</code>以及<code>LogStream</code>的实现可知，在程序运行期间，通过上面的宏使用muduo的日志时，创建的Logger临时对象会在 <strong>栈上开辟一段很大的空间（一般是detail::kSmallBuffer（4000byte））</strong> 缓存日志</p>\n<h2 id=\"日志消息头输出到Impl-stream\"><a href=\"#日志消息头输出到Impl-stream\" class=\"headerlink\" title=\"日志消息头输出到Impl::stream_\"></a>日志消息头输出到<code>Impl::stream_</code></h2><p>结合上面的宏定义来讲，在muduo中，当临时的Logger对象构造时，在其构造函数中，首先会自动输出一条日志的基本头部信息，比如对宏定义传来的时间戳进行格式化输出，输出线程所在的tid以及日志级别，如果是一条错误报告的log（此时errno非0），还会输出错误码的字符串信息。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Logger::Impl::<span class=\"built_in\">Impl</span>(LogLevel level, <span class=\"type\">int</span> savedErrno, <span class=\"type\">const</span> SourceFile&amp; file, <span class=\"type\">int</span> line)</span><br><span class=\"line\">  : <span class=\"built_in\">time_</span>(Timestamp::<span class=\"built_in\">now</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">stream_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">level_</span>(level),</span><br><span class=\"line\">    <span class=\"built_in\">line_</span>(line),</span><br><span class=\"line\">    <span class=\"built_in\">basename_</span>(file)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  formatTime(); <span class=\"comment\">// 输出格式化的时间戳（这部分代码可简略的看一下，了解作用即可，无需细看。</span></span><br><span class=\"line\">  CurrentThread::<span class=\"built_in\">tid</span>(); <span class=\"comment\">// 缓存tid</span></span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"built_in\">T</span>(CurrentThread::<span class=\"built_in\">tidString</span>(), CurrentThread::<span class=\"built_in\">tidStringLength</span>()); <span class=\"comment\">// 输出字符串形式的tid</span></span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"built_in\">T</span>(LogLevelName[level], <span class=\"number\">6</span>); <span class=\"comment\">//输出字符串形式的日志级别</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (savedErrno != <span class=\"number\">0</span>)  <span class=\"comment\">//需要输出错误就输出错误</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    stream_ &lt;&lt; <span class=\"built_in\">strerror_tl</span>(savedErrno) &lt;&lt; <span class=\"string\">&quot; (errno=&quot;</span> &lt;&lt; savedErrno &lt;&lt; <span class=\"string\">&quot;) &quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">Logger::<span class=\"built_in\">Logger</span>(SourceFile file, <span class=\"type\">int</span> line)</span><br><span class=\"line\">  : <span class=\"built_in\">impl_</span>(INFO, <span class=\"number\">0</span>, file, line)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日志尾部输出到Impl-stream-Impl-stream-对象直接输出到日志输出地（LogAppender）（利用临时对象行生命周期的特点，在析构中，同步（默认）输出日志。\"><a href=\"#日志尾部输出到Impl-stream-Impl-stream-对象直接输出到日志输出地（LogAppender）（利用临时对象行生命周期的特点，在析构中，同步（默认）输出日志。\" class=\"headerlink\" title=\"日志尾部输出到Impl::stream_ &amp;&amp; Impl::stream_对象直接输出到日志输出地（LogAppender）（利用临时对象行生命周期的特点，在析构中，同步（默认）输出日志。\"></a>日志尾部输出到<code>Impl::stream_</code> &amp;&amp; <code>Impl::stream_</code>对象直接输出到日志输出地（LogAppender）（利用临时对象行生命周期的特点，在析构中，同步（默认）输出日志。</h2><p>这里的LogAppender可能代表磁盘上的文件、控制台std::cout、数据库等。</p>\n<p>Muduo的日志中g_output其实是类型是函数指针的全局变量，这里通过函数指针实现了C语言的多态，Muduo默认的<code>g_output</code>是<strong>直接</strong>将<code>Impl::stream_</code>拼接的日志输出到控制台，即<strong>输出是同步的</strong>。当然，如果用户参考g_output的定义，实现了自己的输出函数，可以通过<code>Logger::setOutput()</code>接口，提供自定义函数的地址作为参数，将自定义函数安装到<code>g_output</code>上。后面Muduo实现的异步日志就是这么干的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">defaultOutput</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* msg, <span class=\"type\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 同步输出到终端</span></span><br><span class=\"line\">  <span class=\"type\">size_t</span> n = <span class=\"built_in\">fwrite</span>(msg, <span class=\"number\">1</span>, len, stdout);</span><br><span class=\"line\">  <span class=\"comment\">//FIXME check n</span></span><br><span class=\"line\">  (<span class=\"type\">void</span>)n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">defaultFlush</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">fflush</span>(stdout);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 函数指针，实现多态。以及输出的解耦。</span></span><br><span class=\"line\"><span class=\"comment\">* typedef void (*OutputFunc)(const char* msg, int len);</span></span><br><span class=\"line\"><span class=\"comment\">* typedef void (*FlushFunc)();</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">Logger::OutputFunc g_output = defaultOutput;</span><br><span class=\"line\">Logger::FlushFunc g_flush = defaultFlush;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> Logger::Impl::<span class=\"built_in\">finish</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"string\">&quot; - &quot;</span> &lt;&lt; basename_ &lt;&lt; <span class=\"string\">&#x27;:&#x27;</span> &lt;&lt; line_ &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;    <span class=\"comment\">//将文件名以及日志所在行号（临时对象的构造会传入这两个信息）作为日志尾输出到Impl::stream_</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">Logger::~<span class=\"built_in\">Logger</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  impl_.<span class=\"built_in\">finish</span>();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">const</span> LogStream::Buffer&amp; <span class=\"title\">buf</span><span class=\"params\">(stream().buffer())</span></span>;  <span class=\"comment\">// 获取Impl::stream_</span></span><br><span class=\"line\">  <span class=\"built_in\">g_output</span>(buf.<span class=\"built_in\">data</span>(), buf.<span class=\"built_in\">length</span>());   <span class=\"comment\">// 将Impl::stream_输出到日志输出地（stdout/file/database）</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (impl_.level_ == FATAL)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">g_flush</span>();</span><br><span class=\"line\">    <span class=\"built_in\">abort</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日志效果\"><a href=\"#日志效果\" class=\"headerlink\" title=\"日志效果\"></a>日志效果</h2><table>\n<thead>\n<tr>\n<th>LogHeader</th>\n<th>LogBody</th>\n<th>LogTail</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Time ThreadID LogLevel</td>\n<td>LogMessage</td>\n<td>- FileName:LineNumber</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20240109 03:21:56.970321Z  3094 INFO  Hello - Logging_test.cc:69</span><br><span class=\"line\">20240109 03:21:56.970363Z  3094 WARN  World - Logging_test.cc:70</span><br><span class=\"line\">20240109 03:21:56.970367Z  3094 ERROR Error - Logging_test.cc:71</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"细节明细\"><a href=\"#细节明细\" class=\"headerlink\" title=\"细节明细\"></a>细节明细</h2><p>在 Muduo 中，为了实现日志的功能，使用了一个内部的 Impl 类来处理日志的具体实现细节。这样的设计有几个优点：</p>\n<ol>\n<li><p>封装性：<br>将日志的具体实现封装在 Impl 类中，使得日志系统的使用者无需关心内部的具体实现细节。这样可以减少用户对日志系统内部的依赖，提高系统的封装性和可维护性。</p>\n</li>\n<li><p>灵活性：<br>Impl 类的存在使得 Muduo 可以更加灵活地修改、扩展或者替换日志系统的具体实现，而不会对外部接口产生影响。如果未来需要更换日志库、修改日志输出格式等，只需修改 Impl 类的实现而不必修改用户代码。</p>\n</li>\n<li><p>解耦：<br>通过引入 Impl 类，日志系统的实现与接口之间形成了一种解耦。这种解耦有助于降低模块之间的依赖性，提高代码的灵活性和可维护性。</p>\n</li>\n<li><p>信息隐藏：<br>Impl 类将具体的实现细节隐藏在类的私有部分，只暴露必要的接口给外部。这有助于控制用户对日志系统内部的访问权限，同时防止滥用或错误的使用。</p>\n</li>\n</ol>\n<p>muduo还统一了日志级别的字符串长度，固定为6，不足的补空格，这样，也提升了一点点性能，毕竟积少成多。同时利用模板，在编译期确定字符串长度的操作，可以参考SourceFile类的数组引用构造的实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">int</span> N&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">SourceFile</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> (&amp;arr)[N])</span>  <span class=\"comment\">// 数组引用，编译期就能确定字符串长度。</span></span></span><br><span class=\"line\"><span class=\"function\">    : data_(arr),</span></span><br><span class=\"line\"><span class=\"function\">    size_(N<span class=\"number\">-1</span>)</span></span><br><span class=\"line\"><span class=\"function\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* slash = <span class=\"built_in\">strrchr</span>(data_, <span class=\"string\">&#x27;/&#x27;</span>); <span class=\"comment\">// builtin function</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slash)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    data_ = slash + <span class=\"number\">1</span>;</span><br><span class=\"line\">    size_ -= <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(data_ - arr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>Muduo的日志设计的非常简单，日志的格式是固定的，一条日志包括：[日志头，日志体，日志尾]。实际上，参考工业级日志的使用来看，日志还应该能支持格式变更，即用户可以自定义日志的格式，选择自己关心的日志条目进行输出，或者在日志中添加一些额外的字符来修饰日志。考虑到Muduo的核心是网络库，而不是日志库，这些点就不过多深入讨论。</p>\n<h2 id=\"日志消息体输出到Impl-stream-（简化日志的使用方式（宏定义-临时对象的编程技巧）\"><a href=\"#日志消息体输出到Impl-stream-（简化日志的使用方式（宏定义-临时对象的编程技巧）\" class=\"headerlink\" title=\"日志消息体输出到Impl::stream_（简化日志的使用方式（宏定义 + 临时对象的编程技巧）\"></a>日志消息体输出到<code>Impl::stream_</code>（简化日志的使用方式（宏定义 + 临时对象的编程技巧）</h2><p>调用匿名对象的<code>stream()</code>成员函数，会返回一个类型为LogStream的引用也即<code>Impl::stream_</code>对象本身，muduo对<code>LogStream</code>类进行了详细的<code>&gt;&gt;</code>操作符重载，这部分代码简单易读，就不详细赘述了，这样就能将<strong>字符串类型&#x2F;数值类型</strong>的数据使用<code>&gt;&gt;</code>操作符输出到<code>Impl::stream_</code>上（类似std::cout的使用）</p>\n<p>日志消息体的输出：</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// CAUTION: do not write:</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// if (good)</span></span><br><span class=\"line\"><span class=\"comment\">//   LOG_INFO &lt;&lt; &quot;Good news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">// else</span></span><br><span class=\"line\"><span class=\"comment\">//   LOG_WARN &lt;&lt; &quot;Bad news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// this expends to</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// if (good)</span></span><br><span class=\"line\"><span class=\"comment\">//   if (logging_INFO)</span></span><br><span class=\"line\"><span class=\"comment\">//     logInfoStream &lt;&lt; &quot;Good news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">//   else</span></span><br><span class=\"line\"><span class=\"comment\">//     logWarnStream &lt;&lt; &quot;Bad news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_TRACE <span class=\"keyword\">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::TRACE) \\</span></span><br><span class=\"line\"><span class=\"meta\">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_DEBUG <span class=\"keyword\">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::DEBUG) \\</span></span><br><span class=\"line\"><span class=\"meta\">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_INFO <span class=\"keyword\">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::INFO) \\</span></span><br><span class=\"line\"><span class=\"meta\">  muduo::Logger(__FILE__, __LINE__).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream()</span></span><br></pre></td></tr></table></figure>\n\n<p>综合<code>Logger</code>以及<code>LogStream</code>的实现可知，在程序运行期间，通过上面的宏使用muduo的日志时，创建的Logger临时对象会在 <strong>栈上开辟一段很大的空间（一般是detail::kSmallBuffer（4000byte））</strong> 缓存日志</p>\n<h2 id=\"日志消息头输出到Impl-stream\"><a href=\"#日志消息头输出到Impl-stream\" class=\"headerlink\" title=\"日志消息头输出到Impl::stream_\"></a>日志消息头输出到<code>Impl::stream_</code></h2><p>结合上面的宏定义来讲，在muduo中，当临时的Logger对象构造时，在其构造函数中，首先会自动输出一条日志的基本头部信息，比如对宏定义传来的时间戳进行格式化输出，输出线程所在的tid以及日志级别，如果是一条错误报告的log（此时errno非0），还会输出错误码的字符串信息。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Logger::Impl::<span class=\"built_in\">Impl</span>(LogLevel level, <span class=\"type\">int</span> savedErrno, <span class=\"type\">const</span> SourceFile&amp; file, <span class=\"type\">int</span> line)</span><br><span class=\"line\">  : <span class=\"built_in\">time_</span>(Timestamp::<span class=\"built_in\">now</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">stream_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">level_</span>(level),</span><br><span class=\"line\">    <span class=\"built_in\">line_</span>(line),</span><br><span class=\"line\">    <span class=\"built_in\">basename_</span>(file)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  formatTime(); <span class=\"comment\">// 输出格式化的时间戳（这部分代码可简略的看一下，了解作用即可，无需细看。</span></span><br><span class=\"line\">  CurrentThread::<span class=\"built_in\">tid</span>(); <span class=\"comment\">// 缓存tid</span></span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"built_in\">T</span>(CurrentThread::<span class=\"built_in\">tidString</span>(), CurrentThread::<span class=\"built_in\">tidStringLength</span>()); <span class=\"comment\">// 输出字符串形式的tid</span></span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"built_in\">T</span>(LogLevelName[level], <span class=\"number\">6</span>); <span class=\"comment\">//输出字符串形式的日志级别</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (savedErrno != <span class=\"number\">0</span>)  <span class=\"comment\">//需要输出错误就输出错误</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    stream_ &lt;&lt; <span class=\"built_in\">strerror_tl</span>(savedErrno) &lt;&lt; <span class=\"string\">&quot; (errno=&quot;</span> &lt;&lt; savedErrno &lt;&lt; <span class=\"string\">&quot;) &quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">Logger::<span class=\"built_in\">Logger</span>(SourceFile file, <span class=\"type\">int</span> line)</span><br><span class=\"line\">  : <span class=\"built_in\">impl_</span>(INFO, <span class=\"number\">0</span>, file, line)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日志尾部输出到Impl-stream-Impl-stream-对象直接输出到日志输出地（LogAppender）（利用临时对象行生命周期的特点，在析构中，同步（默认）输出日志。\"><a href=\"#日志尾部输出到Impl-stream-Impl-stream-对象直接输出到日志输出地（LogAppender）（利用临时对象行生命周期的特点，在析构中，同步（默认）输出日志。\" class=\"headerlink\" title=\"日志尾部输出到Impl::stream_ &amp;&amp; Impl::stream_对象直接输出到日志输出地（LogAppender）（利用临时对象行生命周期的特点，在析构中，同步（默认）输出日志。\"></a>日志尾部输出到<code>Impl::stream_</code> &amp;&amp; <code>Impl::stream_</code>对象直接输出到日志输出地（LogAppender）（利用临时对象行生命周期的特点，在析构中，同步（默认）输出日志。</h2><p>这里的LogAppender可能代表磁盘上的文件、控制台std::cout、数据库等。</p>\n<p>Muduo的日志中g_output其实是类型是函数指针的全局变量，这里通过函数指针实现了C语言的多态，Muduo默认的<code>g_output</code>是<strong>直接</strong>将<code>Impl::stream_</code>拼接的日志输出到控制台，即<strong>输出是同步的</strong>。当然，如果用户参考g_output的定义，实现了自己的输出函数，可以通过<code>Logger::setOutput()</code>接口，提供自定义函数的地址作为参数，将自定义函数安装到<code>g_output</code>上。后面Muduo实现的异步日志就是这么干的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">defaultOutput</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* msg, <span class=\"type\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 同步输出到终端</span></span><br><span class=\"line\">  <span class=\"type\">size_t</span> n = <span class=\"built_in\">fwrite</span>(msg, <span class=\"number\">1</span>, len, stdout);</span><br><span class=\"line\">  <span class=\"comment\">//FIXME check n</span></span><br><span class=\"line\">  (<span class=\"type\">void</span>)n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">defaultFlush</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">fflush</span>(stdout);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 函数指针，实现多态。以及输出的解耦。</span></span><br><span class=\"line\"><span class=\"comment\">* typedef void (*OutputFunc)(const char* msg, int len);</span></span><br><span class=\"line\"><span class=\"comment\">* typedef void (*FlushFunc)();</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">Logger::OutputFunc g_output = defaultOutput;</span><br><span class=\"line\">Logger::FlushFunc g_flush = defaultFlush;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> Logger::Impl::<span class=\"built_in\">finish</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"string\">&quot; - &quot;</span> &lt;&lt; basename_ &lt;&lt; <span class=\"string\">&#x27;:&#x27;</span> &lt;&lt; line_ &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;    <span class=\"comment\">//将文件名以及日志所在行号（临时对象的构造会传入这两个信息）作为日志尾输出到Impl::stream_</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">Logger::~<span class=\"built_in\">Logger</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  impl_.<span class=\"built_in\">finish</span>();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">const</span> LogStream::Buffer&amp; <span class=\"title\">buf</span><span class=\"params\">(stream().buffer())</span></span>;  <span class=\"comment\">// 获取Impl::stream_</span></span><br><span class=\"line\">  <span class=\"built_in\">g_output</span>(buf.<span class=\"built_in\">data</span>(), buf.<span class=\"built_in\">length</span>());   <span class=\"comment\">// 将Impl::stream_输出到日志输出地（stdout/file/database）</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (impl_.level_ == FATAL)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">g_flush</span>();</span><br><span class=\"line\">    <span class=\"built_in\">abort</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日志效果\"><a href=\"#日志效果\" class=\"headerlink\" title=\"日志效果\"></a>日志效果</h2><table>\n<thead>\n<tr>\n<th>LogHeader</th>\n<th>LogBody</th>\n<th>LogTail</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Time ThreadID LogLevel</td>\n<td>LogMessage</td>\n<td>- FileName:LineNumber</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20240109 03:21:56.970321Z  3094 INFO  Hello - Logging_test.cc:69</span><br><span class=\"line\">20240109 03:21:56.970363Z  3094 WARN  World - Logging_test.cc:70</span><br><span class=\"line\">20240109 03:21:56.970367Z  3094 ERROR Error - Logging_test.cc:71</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"细节明细\"><a href=\"#细节明细\" class=\"headerlink\" title=\"细节明细\"></a>细节明细</h2><p>在 Muduo 中，为了实现日志的功能，使用了一个内部的 Impl 类来处理日志的具体实现细节。这样的设计有几个优点：</p>\n<ol>\n<li><p>封装性：<br>将日志的具体实现封装在 Impl 类中，使得日志系统的使用者无需关心内部的具体实现细节。这样可以减少用户对日志系统内部的依赖，提高系统的封装性和可维护性。</p>\n</li>\n<li><p>灵活性：<br>Impl 类的存在使得 Muduo 可以更加灵活地修改、扩展或者替换日志系统的具体实现，而不会对外部接口产生影响。如果未来需要更换日志库、修改日志输出格式等，只需修改 Impl 类的实现而不必修改用户代码。</p>\n</li>\n<li><p>解耦：<br>通过引入 Impl 类，日志系统的实现与接口之间形成了一种解耦。这种解耦有助于降低模块之间的依赖性，提高代码的灵活性和可维护性。</p>\n</li>\n<li><p>信息隐藏：<br>Impl 类将具体的实现细节隐藏在类的私有部分，只暴露必要的接口给外部。这有助于控制用户对日志系统内部的访问权限，同时防止滥用或错误的使用。</p>\n</li>\n</ol>\n<p>muduo还统一了日志级别的字符串长度，固定为6，不足的补空格，这样，也提升了一点点性能，毕竟积少成多。同时利用模板，在编译期确定字符串长度的操作，可以参考SourceFile类的数组引用构造的实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">int</span> N&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">SourceFile</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> (&amp;arr)[N])</span>  <span class=\"comment\">// 数组引用，编译期就能确定字符串长度。</span></span></span><br><span class=\"line\"><span class=\"function\">    : data_(arr),</span></span><br><span class=\"line\"><span class=\"function\">    size_(N<span class=\"number\">-1</span>)</span></span><br><span class=\"line\"><span class=\"function\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* slash = <span class=\"built_in\">strrchr</span>(data_, <span class=\"string\">&#x27;/&#x27;</span>); <span class=\"comment\">// builtin function</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slash)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    data_ = slash + <span class=\"number\">1</span>;</span><br><span class=\"line\">    size_ -= <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(data_ - arr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"muduo源码阅读笔记（11、TcpClient）","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n[muduo源码阅读笔记（11、TcpClient）](./TcpClient.md)\n\n**前言**\n\n本章新涉及的文件有：\n\n1. TcpClient.h/cc：和TcpServer不同的是，TcpClient位于客户端，主要是对客户发起的连接进行管理，TcpClient只有一个loop，也会和TcpConnection配合，将三次握手连接成功的sockfd交由TcpConnection管理。\n\n2. Connector.h/cc：Muduo将一个客户端的sock分成了两个阶段，分别是：连接阶段、读写阶段，Connector就是负责fd的连接阶段，当一个sockfd连接成功后，将sockfd传给TcpClient，由TcpClient将sockfd传给TcpConnection进行读写管理，Connector和TcpServer的Acceptor在设计上有这类似的思想，不同的是，Connector是可以针对同一个ip地址进行多次连接，产生不同的sockfd、而Acceptor是去读listen sock来接收连接，产生不同sockfd。\n\n总体来说，TcpClient的实现是**严格遵循**TcpServer的实现的，\n\n## Connector的实现\n\n**提供的接口：**\n\n<!-- more -->\n```cpp\nclass Connector : noncopyable,\n                  public std::enable_shared_from_this<Connector>{\npublic:\n    typedef std::function<void (int sockfd)> NewConnectionCallback;\n\n    Connector(EventLoop* loop, const InetAddress& serverAddr);\n    ~Connector();\n\n    void setNewConnectionCallback(const NewConnectionCallback& cb)\n    { newConnectionCallback_ = cb; }\n\n    void start();  // can be called in any thread\n    void restart();  // must be called in loop thread\n    void stop();  // can be called in any thread\n\n    const InetAddress& serverAddress() const { return serverAddr_; }\n\n    private:\n    enum States { kDisconnected, kConnecting, kConnected };\n    static const int kMaxRetryDelayMs = 30*1000;\n    static const int kInitRetryDelayMs = 500;\n\n    void setState(States s) { state_ = s; }\n    void startInLoop();\n    void stopInLoop();\n    void connect();\n    void connecting(int sockfd);\n    void handleWrite();\n    void handleError();\n    void retry(int sockfd);\n    int removeAndResetChannel();\n    void resetChannel();\n\n    EventLoop* loop_; // 连接发起所在loop\n    InetAddress serverAddr_;  // 连接到哪里\n    bool connect_; // atomic  // 开始连接？\n    States state_;  // FIXME: use atomic variable // 连接状态\n    std::unique_ptr<Channel> channel_;  // fd读写以及读写事件管理，对epoll/poll/selectIO多路复用的抽象，方便跨平台。\n    NewConnectionCallback newConnectionCallback_; // 一般是：TcpClient::newConnection\n    int retryDelayMs_;  // 连接重试毫秒数。\n};\n```\n\n简单记录一下连接阶段启动流程：\n\n调用Connector::start()->\n\n1. connect_ 赋值为 true。\n\n2. 在loop任务队列追加Connector::startInLoop()回调任务\n\n    1. 执行回调任务：Connector::startInLoop()\n\n    2. 调用Connector::connect()\n\n        1. 创建非阻塞的连接sock\n        \n        2. ::connect(sock, ...)\n        \n        3. 调用Connector::connecting(int sockfd)\n\n            1. new channel(sockfd)赋值给channel_将Connector::handleWrite()和Connector::handleError()设置给cahnnel的写回调以及错误处理回调\n\n            2. 使能Poller开始监听sockfd\n\n当连接成功，会触发sockfd的写事件，从而调用Connector::handleWrite()->\n\n1. 将sockfd和channel_解绑，并将channel_ rest。\n\n2. 调用newConnectionCallback_（也即TcpClient::newConnection）将连接完成的sockfd传给TcpClient处理\n\n感兴趣的读者，可以自行阅读源码，了解连接过程中，stop、retry的流程。\n\n**实现的伪代码：**\n\n```cpp\n\nvoid Connector::start(){\n    connect_ = true;\n    loop_->runInLoop(std::bind(&Connector::startInLoop, this)); // FIXME: unsafe\n}\n\nvoid Connector::startInLoop(){\n    loop_->assertInLoopThread();\n    assert(state_ == kDisconnected);\n    if (connect_){\n        connect();\n    }else{\n        LOG_DEBUG << \"do not connect\";\n    }\n}\n\nvoid Connector::stop(){\n    connect_ = false;\n    loop_->queueInLoop(std::bind(&Connector::stopInLoop, this)); // FIXME: unsafe\n    // FIXME: cancel timer\n}\n\nvoid Connector::stopInLoop(){\n    loop_->assertInLoopThread();\n    if (state_ == kConnecting){\n        setState(kDisconnected);\n        int sockfd = removeAndResetChannel();\n        retry(sockfd);\n    }\n}\n\nvoid Connector::connect(){\n    int sockfd = sockets::createNonblockingOrDie(serverAddr_.family());\n    int ret = sockets::connect(sockfd, serverAddr_.getSockAddr());\n    int savedErrno = (ret == 0) ? 0 : errno;\n    switch (savedErrno){\n        case 0:\n        case EINPROGRESS:\n        case EINTR:\n        case EISCONN:\n            connecting(sockfd);\n            break;\n        /*...*/\n    }\n}\n\nvoid Connector::connecting(int sockfd){\n    setState(kConnecting);\n    assert(!channel_);\n    channel_.reset(new Channel(loop_, sockfd));\n    channel_->setWriteCallback(\n        std::bind(&Connector::handleWrite, this)); // FIXME: unsafe\n    channel_->setErrorCallback(\n        std::bind(&Connector::handleError, this)); // FIXME: unsafe\n\n    // channel_->tie(shared_from_this()); is not working,\n    // as channel_ is not managed by shared_ptr\n    channel_->enableWriting();\n}\n\nint Connector::removeAndResetChannel(){\n    channel_->disableAll();\n    channel_->remove();\n    int sockfd = channel_->fd();\n    // Can't reset channel_ here, because we are inside Channel::handleEvent\n    loop_->queueInLoop(std::bind(&Connector::resetChannel, this)); // FIXME: unsafe\n    return sockfd;\n}\n\nvoid Connector::resetChannel(){\n    channel_.reset();\n}\n\nvoid Connector::handleWrite(){\n    LOG_TRACE << \"Connector::handleWrite \" << state_;\n\n    if (state_ == kConnecting){\n        int sockfd = removeAndResetChannel();\n        int err = sockets::getSocketError(sockfd);\n\n        if (err){\n            LOG_WARN << \"Connector::handleWrite - SO_ERROR = \"\n                    << err << \" \" << strerror_tl(err);\n            retry(sockfd);\n        }else{\n            setState(kConnected);\n            if (connect_){\n                newConnectionCallback_(sockfd);\n            }else{\n                sockets::close(sockfd);\n            }\n        }\n    }else{\n        // what happened?\n        assert(state_ == kDisconnected);\n    }\n}\n\nvoid Connector::handleError(){\n    LOG_ERROR << \"Connector::handleError state=\" << state_;\n    if (state_ == kConnecting){\n        int sockfd = removeAndResetChannel();\n        int err = sockets::getSocketError(sockfd);\n        LOG_TRACE << \"SO_ERROR = \" << err << \" \" << strerror_tl(err);\n        retry(sockfd);\n    }\n}\n\nvoid Connector::retry(int sockfd){\n    sockets::close(sockfd);\n    setState(kDisconnected);\n    if (connect_){\n        LOG_INFO << \"Connector::retry - Retry connecting to \" << serverAddr_.toIpPort()\n                    << \" in \" << retryDelayMs_ << \" milliseconds. \";\n        loop_->runAfter(retryDelayMs_/1000.0, // 稍后重试\n                        std::bind(&Connector::startInLoop, shared_from_this()));\n        retryDelayMs_ = std::min(retryDelayMs_ * 2, kMaxRetryDelayMs);  // 超时加倍\n    }else{\n        LOG_DEBUG << \"do not connect\";\n    }\n}\n```\n\n## TcpClient的实现\n\n**提供的接口：**\n\n```cpp\nclass TcpClient : noncopyable\n{\npublic:\n    // TcpClient(EventLoop* loop);\n    // TcpClient(EventLoop* loop, const string& host, uint16_t port);\n    TcpClient(EventLoop* loop,\n            const InetAddress& serverAddr,\n            const string& nameArg);\n    ~TcpClient();  // force out-line dtor, for std::unique_ptr members.\n\n    void connect();\n    void disconnect();\n    void stop();\n\n    TcpConnectionPtr connection() const\n    {\n    MutexLockGuard lock(mutex_);\n    return connection_;\n    }\n\n    EventLoop* getLoop() const { return loop_; }\n    bool retry() const { return retry_; }\n    void enableRetry() { retry_ = true; }\n\n    const string& name() const\n    { return name_; }\n\n    /// Set connection callback.\n    /// Not thread safe.\n    void setConnectionCallback(ConnectionCallback cb)\n    { connectionCallback_ = std::move(cb); }\n\n    /// Set message callback.\n    /// Not thread safe.\n    void setMessageCallback(MessageCallback cb)\n    { messageCallback_ = std::move(cb); }\n\n    /// Set write complete callback.\n    /// Not thread safe.\n    void setWriteCompleteCallback(WriteCompleteCallback cb)\n    { writeCompleteCallback_ = std::move(cb); }\n\nprivate:\n    /// Not thread safe, but in loop\n    void newConnection(int sockfd);\n    /// Not thread safe, but in loop\n    void removeConnection(const TcpConnectionPtr& conn);\n\n    EventLoop* loop_; // 运行在那个loop\n    ConnectorPtr connector_; // avoid revealing Connector // 连接器\n    const string name_; // TcpClient名\n    ConnectionCallback connectionCallback_;   // 连接建立和断开回调\n    MessageCallback messageCallback_;   // 可读回调\n    WriteCompleteCallback writeCompleteCallback_;   // 写完回调\n    bool retry_;   // atomic  重连\n    bool connect_; // atomic  // 已经连接？\n    // always in loop thread\n    int nextConnId_;  // 字面意思\n    mutable MutexLock mutex_;\n    TcpConnectionPtr connection_ GUARDED_BY(mutex_);  // 连接读写管理器\n};\n```\n\nTcpClient核心函数TcpClient::newConnection，该函数会作为连接器的回调，当sockfd连接成功后，该函数被调用，设置必要信息后，为该sockfd产生一个TcpConnection对象，后续该fd的读写，全权交由TcpConnection处理。逻辑比较简单，实现如下：\n\n**实现的伪代码：**\n\n```cpp\nTcpClient::TcpClient(EventLoop* loop,\n                     const InetAddress& serverAddr,\n                     const string& nameArg)\n  : loop_(CHECK_NOTNULL(loop)),\n    connector_(new Connector(loop, serverAddr)),\n    name_(nameArg),\n    connectionCallback_(defaultConnectionCallback),\n    messageCallback_(defaultMessageCallback),\n    retry_(false),\n    connect_(true),\n    nextConnId_(1){\n    \n    connector_->setNewConnectionCallback(\n        std::bind(&TcpClient::newConnection, this, _1));\n    // FIXME setConnectFailedCallback\n    LOG_INFO << \"TcpClient::TcpClient[\" << name_\n            << \"] - connector \" << get_pointer(connector_);\n}\n\nvoid TcpClient::connect(){\n    // FIXME: check state\n    LOG_INFO << \"TcpClient::connect[\" << name_ << \"] - connecting to \"\n            << connector_->serverAddress().toIpPort();\n    connect_ = true;\n    connector_->start();\n}\n\nvoid TcpClient::disconnect(){\n    connect_ = false;\n\n    {\n        MutexLockGuard lock(mutex_);\n        if (connection_){\n            connection_->shutdown();\n        }\n    }\n}\n\nvoid TcpClient::stop(){\n    connect_ = false;\n    connector_->stop();\n}\n\nvoid TcpClient::newConnection(int sockfd){\n    loop_->assertInLoopThread();\n    InetAddress peerAddr(sockets::getPeerAddr(sockfd));\n    char buf[32];\n    snprintf(buf, sizeof buf, \":%s#%d\", peerAddr.toIpPort().c_str(), nextConnId_);\n    ++nextConnId_;\n    string connName = name_ + buf;\n\n    InetAddress localAddr(sockets::getLocalAddr(sockfd));\n    // FIXME poll with zero timeout to double confirm the new connection\n    // FIXME use make_shared if necessary\n    TcpConnectionPtr conn(new TcpConnection(loop_,\n                                            connName,\n                                            sockfd,\n                                            localAddr,\n                                            peerAddr));\n\n    conn->setConnectionCallback(connectionCallback_);\n    conn->setMessageCallback(messageCallback_);\n    conn->setWriteCompleteCallback(writeCompleteCallback_);\n    conn->setCloseCallback(\n        std::bind(&TcpClient::removeConnection, this, _1)); // FIXME: unsafe\n    {\n        MutexLockGuard lock(mutex_);\n        connection_ = conn;\n    }\n    conn->connectEstablished(); // 同一loop，可以直接调用\n}\n\nvoid TcpClient::removeConnection(const TcpConnectionPtr& conn){\n    loop_->assertInLoopThread();\n    assert(loop_ == conn->getLoop());\n\n    {\n        MutexLockGuard lock(mutex_);\n        assert(connection_ == conn);\n        connection_.reset();\n    }\n\n    loop_->queueInLoop(std::bind(&TcpConnection::connectDestroyed, conn));\n    if (retry_ && connect_){\n    LOG_INFO << \"TcpClient::connect[\" << name_ << \"] - Reconnecting to \"\n                << connector_->serverAddress().toIpPort();\n    connector_->restart();\n    }\n}\n```\n\n### 细节明细：\n\n**疑问**\n\n在TcpConnection::handleClose()实现当中，为什么没有调用close，关闭sockfd？也看了一下TcpConnection的析构、TcpConnection::connectDestroyed()，没有一个地方调用了close来关闭sockfd\n\n**解答**\n\n在 TcpConnection 对象析构的时候。TcpConnection 持有一个 Socket 对象，Socket 是一个 RAII handler，它的析构函数会 close(sockfd_)。这样，如果发生 TcpConnection 对象泄漏，那么我们从 /proc/pid/fd/ 就能找到没有关闭的文件描述符，便于查错。\n\n原文链接：https://blog.csdn.net/Solstice/article/details/6208634\n\n## 总结\n\nMuduo设计的TcpServer和TcpClient代码思想及其统一，一些算法题也是需要这样的抽象思维，所以我认为这也是以后从事it最重要的品质，可以避免很多不必要的bug。","source":"_posts/muduo/TcpClient.md","raw":"---\ntitle: muduo源码阅读笔记（11、TcpClient）\ndate: 2024-11-02 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n[muduo源码阅读笔记（11、TcpClient）](./TcpClient.md)\n\n**前言**\n\n本章新涉及的文件有：\n\n1. TcpClient.h/cc：和TcpServer不同的是，TcpClient位于客户端，主要是对客户发起的连接进行管理，TcpClient只有一个loop，也会和TcpConnection配合，将三次握手连接成功的sockfd交由TcpConnection管理。\n\n2. Connector.h/cc：Muduo将一个客户端的sock分成了两个阶段，分别是：连接阶段、读写阶段，Connector就是负责fd的连接阶段，当一个sockfd连接成功后，将sockfd传给TcpClient，由TcpClient将sockfd传给TcpConnection进行读写管理，Connector和TcpServer的Acceptor在设计上有这类似的思想，不同的是，Connector是可以针对同一个ip地址进行多次连接，产生不同的sockfd、而Acceptor是去读listen sock来接收连接，产生不同sockfd。\n\n总体来说，TcpClient的实现是**严格遵循**TcpServer的实现的，\n\n## Connector的实现\n\n**提供的接口：**\n\n<!-- more -->\n```cpp\nclass Connector : noncopyable,\n                  public std::enable_shared_from_this<Connector>{\npublic:\n    typedef std::function<void (int sockfd)> NewConnectionCallback;\n\n    Connector(EventLoop* loop, const InetAddress& serverAddr);\n    ~Connector();\n\n    void setNewConnectionCallback(const NewConnectionCallback& cb)\n    { newConnectionCallback_ = cb; }\n\n    void start();  // can be called in any thread\n    void restart();  // must be called in loop thread\n    void stop();  // can be called in any thread\n\n    const InetAddress& serverAddress() const { return serverAddr_; }\n\n    private:\n    enum States { kDisconnected, kConnecting, kConnected };\n    static const int kMaxRetryDelayMs = 30*1000;\n    static const int kInitRetryDelayMs = 500;\n\n    void setState(States s) { state_ = s; }\n    void startInLoop();\n    void stopInLoop();\n    void connect();\n    void connecting(int sockfd);\n    void handleWrite();\n    void handleError();\n    void retry(int sockfd);\n    int removeAndResetChannel();\n    void resetChannel();\n\n    EventLoop* loop_; // 连接发起所在loop\n    InetAddress serverAddr_;  // 连接到哪里\n    bool connect_; // atomic  // 开始连接？\n    States state_;  // FIXME: use atomic variable // 连接状态\n    std::unique_ptr<Channel> channel_;  // fd读写以及读写事件管理，对epoll/poll/selectIO多路复用的抽象，方便跨平台。\n    NewConnectionCallback newConnectionCallback_; // 一般是：TcpClient::newConnection\n    int retryDelayMs_;  // 连接重试毫秒数。\n};\n```\n\n简单记录一下连接阶段启动流程：\n\n调用Connector::start()->\n\n1. connect_ 赋值为 true。\n\n2. 在loop任务队列追加Connector::startInLoop()回调任务\n\n    1. 执行回调任务：Connector::startInLoop()\n\n    2. 调用Connector::connect()\n\n        1. 创建非阻塞的连接sock\n        \n        2. ::connect(sock, ...)\n        \n        3. 调用Connector::connecting(int sockfd)\n\n            1. new channel(sockfd)赋值给channel_将Connector::handleWrite()和Connector::handleError()设置给cahnnel的写回调以及错误处理回调\n\n            2. 使能Poller开始监听sockfd\n\n当连接成功，会触发sockfd的写事件，从而调用Connector::handleWrite()->\n\n1. 将sockfd和channel_解绑，并将channel_ rest。\n\n2. 调用newConnectionCallback_（也即TcpClient::newConnection）将连接完成的sockfd传给TcpClient处理\n\n感兴趣的读者，可以自行阅读源码，了解连接过程中，stop、retry的流程。\n\n**实现的伪代码：**\n\n```cpp\n\nvoid Connector::start(){\n    connect_ = true;\n    loop_->runInLoop(std::bind(&Connector::startInLoop, this)); // FIXME: unsafe\n}\n\nvoid Connector::startInLoop(){\n    loop_->assertInLoopThread();\n    assert(state_ == kDisconnected);\n    if (connect_){\n        connect();\n    }else{\n        LOG_DEBUG << \"do not connect\";\n    }\n}\n\nvoid Connector::stop(){\n    connect_ = false;\n    loop_->queueInLoop(std::bind(&Connector::stopInLoop, this)); // FIXME: unsafe\n    // FIXME: cancel timer\n}\n\nvoid Connector::stopInLoop(){\n    loop_->assertInLoopThread();\n    if (state_ == kConnecting){\n        setState(kDisconnected);\n        int sockfd = removeAndResetChannel();\n        retry(sockfd);\n    }\n}\n\nvoid Connector::connect(){\n    int sockfd = sockets::createNonblockingOrDie(serverAddr_.family());\n    int ret = sockets::connect(sockfd, serverAddr_.getSockAddr());\n    int savedErrno = (ret == 0) ? 0 : errno;\n    switch (savedErrno){\n        case 0:\n        case EINPROGRESS:\n        case EINTR:\n        case EISCONN:\n            connecting(sockfd);\n            break;\n        /*...*/\n    }\n}\n\nvoid Connector::connecting(int sockfd){\n    setState(kConnecting);\n    assert(!channel_);\n    channel_.reset(new Channel(loop_, sockfd));\n    channel_->setWriteCallback(\n        std::bind(&Connector::handleWrite, this)); // FIXME: unsafe\n    channel_->setErrorCallback(\n        std::bind(&Connector::handleError, this)); // FIXME: unsafe\n\n    // channel_->tie(shared_from_this()); is not working,\n    // as channel_ is not managed by shared_ptr\n    channel_->enableWriting();\n}\n\nint Connector::removeAndResetChannel(){\n    channel_->disableAll();\n    channel_->remove();\n    int sockfd = channel_->fd();\n    // Can't reset channel_ here, because we are inside Channel::handleEvent\n    loop_->queueInLoop(std::bind(&Connector::resetChannel, this)); // FIXME: unsafe\n    return sockfd;\n}\n\nvoid Connector::resetChannel(){\n    channel_.reset();\n}\n\nvoid Connector::handleWrite(){\n    LOG_TRACE << \"Connector::handleWrite \" << state_;\n\n    if (state_ == kConnecting){\n        int sockfd = removeAndResetChannel();\n        int err = sockets::getSocketError(sockfd);\n\n        if (err){\n            LOG_WARN << \"Connector::handleWrite - SO_ERROR = \"\n                    << err << \" \" << strerror_tl(err);\n            retry(sockfd);\n        }else{\n            setState(kConnected);\n            if (connect_){\n                newConnectionCallback_(sockfd);\n            }else{\n                sockets::close(sockfd);\n            }\n        }\n    }else{\n        // what happened?\n        assert(state_ == kDisconnected);\n    }\n}\n\nvoid Connector::handleError(){\n    LOG_ERROR << \"Connector::handleError state=\" << state_;\n    if (state_ == kConnecting){\n        int sockfd = removeAndResetChannel();\n        int err = sockets::getSocketError(sockfd);\n        LOG_TRACE << \"SO_ERROR = \" << err << \" \" << strerror_tl(err);\n        retry(sockfd);\n    }\n}\n\nvoid Connector::retry(int sockfd){\n    sockets::close(sockfd);\n    setState(kDisconnected);\n    if (connect_){\n        LOG_INFO << \"Connector::retry - Retry connecting to \" << serverAddr_.toIpPort()\n                    << \" in \" << retryDelayMs_ << \" milliseconds. \";\n        loop_->runAfter(retryDelayMs_/1000.0, // 稍后重试\n                        std::bind(&Connector::startInLoop, shared_from_this()));\n        retryDelayMs_ = std::min(retryDelayMs_ * 2, kMaxRetryDelayMs);  // 超时加倍\n    }else{\n        LOG_DEBUG << \"do not connect\";\n    }\n}\n```\n\n## TcpClient的实现\n\n**提供的接口：**\n\n```cpp\nclass TcpClient : noncopyable\n{\npublic:\n    // TcpClient(EventLoop* loop);\n    // TcpClient(EventLoop* loop, const string& host, uint16_t port);\n    TcpClient(EventLoop* loop,\n            const InetAddress& serverAddr,\n            const string& nameArg);\n    ~TcpClient();  // force out-line dtor, for std::unique_ptr members.\n\n    void connect();\n    void disconnect();\n    void stop();\n\n    TcpConnectionPtr connection() const\n    {\n    MutexLockGuard lock(mutex_);\n    return connection_;\n    }\n\n    EventLoop* getLoop() const { return loop_; }\n    bool retry() const { return retry_; }\n    void enableRetry() { retry_ = true; }\n\n    const string& name() const\n    { return name_; }\n\n    /// Set connection callback.\n    /// Not thread safe.\n    void setConnectionCallback(ConnectionCallback cb)\n    { connectionCallback_ = std::move(cb); }\n\n    /// Set message callback.\n    /// Not thread safe.\n    void setMessageCallback(MessageCallback cb)\n    { messageCallback_ = std::move(cb); }\n\n    /// Set write complete callback.\n    /// Not thread safe.\n    void setWriteCompleteCallback(WriteCompleteCallback cb)\n    { writeCompleteCallback_ = std::move(cb); }\n\nprivate:\n    /// Not thread safe, but in loop\n    void newConnection(int sockfd);\n    /// Not thread safe, but in loop\n    void removeConnection(const TcpConnectionPtr& conn);\n\n    EventLoop* loop_; // 运行在那个loop\n    ConnectorPtr connector_; // avoid revealing Connector // 连接器\n    const string name_; // TcpClient名\n    ConnectionCallback connectionCallback_;   // 连接建立和断开回调\n    MessageCallback messageCallback_;   // 可读回调\n    WriteCompleteCallback writeCompleteCallback_;   // 写完回调\n    bool retry_;   // atomic  重连\n    bool connect_; // atomic  // 已经连接？\n    // always in loop thread\n    int nextConnId_;  // 字面意思\n    mutable MutexLock mutex_;\n    TcpConnectionPtr connection_ GUARDED_BY(mutex_);  // 连接读写管理器\n};\n```\n\nTcpClient核心函数TcpClient::newConnection，该函数会作为连接器的回调，当sockfd连接成功后，该函数被调用，设置必要信息后，为该sockfd产生一个TcpConnection对象，后续该fd的读写，全权交由TcpConnection处理。逻辑比较简单，实现如下：\n\n**实现的伪代码：**\n\n```cpp\nTcpClient::TcpClient(EventLoop* loop,\n                     const InetAddress& serverAddr,\n                     const string& nameArg)\n  : loop_(CHECK_NOTNULL(loop)),\n    connector_(new Connector(loop, serverAddr)),\n    name_(nameArg),\n    connectionCallback_(defaultConnectionCallback),\n    messageCallback_(defaultMessageCallback),\n    retry_(false),\n    connect_(true),\n    nextConnId_(1){\n    \n    connector_->setNewConnectionCallback(\n        std::bind(&TcpClient::newConnection, this, _1));\n    // FIXME setConnectFailedCallback\n    LOG_INFO << \"TcpClient::TcpClient[\" << name_\n            << \"] - connector \" << get_pointer(connector_);\n}\n\nvoid TcpClient::connect(){\n    // FIXME: check state\n    LOG_INFO << \"TcpClient::connect[\" << name_ << \"] - connecting to \"\n            << connector_->serverAddress().toIpPort();\n    connect_ = true;\n    connector_->start();\n}\n\nvoid TcpClient::disconnect(){\n    connect_ = false;\n\n    {\n        MutexLockGuard lock(mutex_);\n        if (connection_){\n            connection_->shutdown();\n        }\n    }\n}\n\nvoid TcpClient::stop(){\n    connect_ = false;\n    connector_->stop();\n}\n\nvoid TcpClient::newConnection(int sockfd){\n    loop_->assertInLoopThread();\n    InetAddress peerAddr(sockets::getPeerAddr(sockfd));\n    char buf[32];\n    snprintf(buf, sizeof buf, \":%s#%d\", peerAddr.toIpPort().c_str(), nextConnId_);\n    ++nextConnId_;\n    string connName = name_ + buf;\n\n    InetAddress localAddr(sockets::getLocalAddr(sockfd));\n    // FIXME poll with zero timeout to double confirm the new connection\n    // FIXME use make_shared if necessary\n    TcpConnectionPtr conn(new TcpConnection(loop_,\n                                            connName,\n                                            sockfd,\n                                            localAddr,\n                                            peerAddr));\n\n    conn->setConnectionCallback(connectionCallback_);\n    conn->setMessageCallback(messageCallback_);\n    conn->setWriteCompleteCallback(writeCompleteCallback_);\n    conn->setCloseCallback(\n        std::bind(&TcpClient::removeConnection, this, _1)); // FIXME: unsafe\n    {\n        MutexLockGuard lock(mutex_);\n        connection_ = conn;\n    }\n    conn->connectEstablished(); // 同一loop，可以直接调用\n}\n\nvoid TcpClient::removeConnection(const TcpConnectionPtr& conn){\n    loop_->assertInLoopThread();\n    assert(loop_ == conn->getLoop());\n\n    {\n        MutexLockGuard lock(mutex_);\n        assert(connection_ == conn);\n        connection_.reset();\n    }\n\n    loop_->queueInLoop(std::bind(&TcpConnection::connectDestroyed, conn));\n    if (retry_ && connect_){\n    LOG_INFO << \"TcpClient::connect[\" << name_ << \"] - Reconnecting to \"\n                << connector_->serverAddress().toIpPort();\n    connector_->restart();\n    }\n}\n```\n\n### 细节明细：\n\n**疑问**\n\n在TcpConnection::handleClose()实现当中，为什么没有调用close，关闭sockfd？也看了一下TcpConnection的析构、TcpConnection::connectDestroyed()，没有一个地方调用了close来关闭sockfd\n\n**解答**\n\n在 TcpConnection 对象析构的时候。TcpConnection 持有一个 Socket 对象，Socket 是一个 RAII handler，它的析构函数会 close(sockfd_)。这样，如果发生 TcpConnection 对象泄漏，那么我们从 /proc/pid/fd/ 就能找到没有关闭的文件描述符，便于查错。\n\n原文链接：https://blog.csdn.net/Solstice/article/details/6208634\n\n## 总结\n\nMuduo设计的TcpServer和TcpClient代码思想及其统一，一些算法题也是需要这样的抽象思维，所以我认为这也是以后从事it最重要的品质，可以避免很多不必要的bug。","slug":"muduo/TcpClient","published":1,"updated":"2025-09-28T16:06:43.130Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9q000iq8ws6f7reaee","content":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><a href=\"./TcpClient.md\">muduo源码阅读笔记（11、TcpClient）</a></p>\n<p><strong>前言</strong></p>\n<p>本章新涉及的文件有：</p>\n<ol>\n<li><p>TcpClient.h&#x2F;cc：和TcpServer不同的是，TcpClient位于客户端，主要是对客户发起的连接进行管理，TcpClient只有一个loop，也会和TcpConnection配合，将三次握手连接成功的sockfd交由TcpConnection管理。</p>\n</li>\n<li><p>Connector.h&#x2F;cc：Muduo将一个客户端的sock分成了两个阶段，分别是：连接阶段、读写阶段，Connector就是负责fd的连接阶段，当一个sockfd连接成功后，将sockfd传给TcpClient，由TcpClient将sockfd传给TcpConnection进行读写管理，Connector和TcpServer的Acceptor在设计上有这类似的思想，不同的是，Connector是可以针对同一个ip地址进行多次连接，产生不同的sockfd、而Acceptor是去读listen sock来接收连接，产生不同sockfd。</p>\n</li>\n</ol>\n<p>总体来说，TcpClient的实现是<strong>严格遵循</strong>TcpServer的实现的，</p>\n<h2 id=\"Connector的实现\"><a href=\"#Connector的实现\" class=\"headerlink\" title=\"Connector的实现\"></a>Connector的实现</h2><p><strong>提供的接口：</strong></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Connector</span> : noncopyable,</span><br><span class=\"line\">                  <span class=\"keyword\">public</span> std::enable_shared_from_this&lt;Connector&gt;&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> (<span class=\"type\">int</span> sockfd)&gt; NewConnectionCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Connector</span>(EventLoop* loop, <span class=\"type\">const</span> InetAddress&amp; serverAddr);</span><br><span class=\"line\">    ~<span class=\"built_in\">Connector</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setNewConnectionCallback</span><span class=\"params\">(<span class=\"type\">const</span> NewConnectionCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; newConnectionCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// can be called in any thread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">restart</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// must be called in loop thread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// can be called in any thread</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> InetAddress&amp; <span class=\"title\">serverAddress</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> serverAddr_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"title class_\">States</span> &#123; kDisconnected, kConnecting, kConnected &#125;;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kMaxRetryDelayMs = <span class=\"number\">30</span>*<span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kInitRetryDelayMs = <span class=\"number\">500</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setState</span><span class=\"params\">(States s)</span> </span>&#123; state_ = s; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">startInLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stopInLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">connect</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">connecting</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleWrite</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleError</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">retry</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeAndResetChannel</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">resetChannel</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// 连接发起所在loop</span></span><br><span class=\"line\">    InetAddress serverAddr_;  <span class=\"comment\">// 连接到哪里</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> connect_; <span class=\"comment\">// atomic  // 开始连接？</span></span><br><span class=\"line\">    States state_;  <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use atomic variable // 连接状态</span></span><br><span class=\"line\">    std::unique_ptr&lt;Channel&gt; channel_;  <span class=\"comment\">// fd读写以及读写事件管理，对epoll/poll/selectIO多路复用的抽象，方便跨平台。</span></span><br><span class=\"line\">    NewConnectionCallback newConnectionCallback_; <span class=\"comment\">// 一般是：TcpClient::newConnection</span></span><br><span class=\"line\">    <span class=\"type\">int</span> retryDelayMs_;  <span class=\"comment\">// 连接重试毫秒数。</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>简单记录一下连接阶段启动流程：</p>\n<p>调用Connector::start()-&gt;</p>\n<ol>\n<li><p>connect_ 赋值为 true。</p>\n</li>\n<li><p>在loop任务队列追加Connector::startInLoop()回调任务</p>\n<ol>\n<li><p>执行回调任务：Connector::startInLoop()</p>\n</li>\n<li><p>调用Connector::connect()</p>\n<ol>\n<li><p>创建非阻塞的连接sock</p>\n</li>\n<li><p>::connect(sock, …)</p>\n</li>\n<li><p>调用Connector::connecting(int sockfd)</p>\n<ol>\n<li><p>new channel(sockfd)赋值给channel_将Connector::handleWrite()和Connector::handleError()设置给cahnnel的写回调以及错误处理回调</p>\n</li>\n<li><p>使能Poller开始监听sockfd</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>当连接成功，会触发sockfd的写事件，从而调用Connector::handleWrite()-&gt;</p>\n<ol>\n<li><p>将sockfd和channel_解绑，并将channel_ rest。</p>\n</li>\n<li><p>调用newConnectionCallback_（也即TcpClient::newConnection）将连接完成的sockfd传给TcpClient处理</p>\n</li>\n</ol>\n<p>感兴趣的读者，可以自行阅读源码，了解连接过程中，stop、retry的流程。</p>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;Connector::startInLoop, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::startInLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(state_ == kDisconnected);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">connect</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;do not connect&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::stop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;Connector::stopInLoop, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> cancel timer</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::stopInLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnecting)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = <span class=\"built_in\">removeAndResetChannel</span>();</span><br><span class=\"line\">        <span class=\"built_in\">retry</span>(sockfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::connect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> sockfd = sockets::<span class=\"built_in\">createNonblockingOrDie</span>(serverAddr_.<span class=\"built_in\">family</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = sockets::<span class=\"built_in\">connect</span>(sockfd, serverAddr_.<span class=\"built_in\">getSockAddr</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> savedErrno = (ret == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : errno;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (savedErrno)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EINPROGRESS:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EINTR:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EISCONN:</span><br><span class=\"line\">            <span class=\"built_in\">connecting</span>(sockfd);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::connecting</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kConnecting);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!channel_);</span><br><span class=\"line\">    channel_.<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Channel</span>(loop_, sockfd));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setWriteCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Connector::handleWrite, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setErrorCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Connector::handleError, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// channel_-&gt;tie(shared_from_this()); is not working,</span></span><br><span class=\"line\">    <span class=\"comment\">// as channel_ is not managed by shared_ptr</span></span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">enableWriting</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Connector::removeAndResetChannel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> sockfd = channel_-&gt;<span class=\"built_in\">fd</span>();</span><br><span class=\"line\">    <span class=\"comment\">// Can&#x27;t reset channel_ here, because we are inside Channel::handleEvent</span></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;Connector::resetChannel, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sockfd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::resetChannel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    channel_.<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::handleWrite</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;Connector::handleWrite &quot;</span> &lt;&lt; state_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnecting)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = <span class=\"built_in\">removeAndResetChannel</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> err = sockets::<span class=\"built_in\">getSocketError</span>(sockfd);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err)&#123;</span><br><span class=\"line\">            LOG_WARN &lt;&lt; <span class=\"string\">&quot;Connector::handleWrite - SO_ERROR = &quot;</span></span><br><span class=\"line\">                    &lt;&lt; err &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; <span class=\"built_in\">strerror_tl</span>(err);</span><br><span class=\"line\">            <span class=\"built_in\">retry</span>(sockfd);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">setState</span>(kConnected);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (connect_)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">newConnectionCallback_</span>(sockfd);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                sockets::<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// what happened?</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(state_ == kDisconnected);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::handleError</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    LOG_ERROR &lt;&lt; <span class=\"string\">&quot;Connector::handleError state=&quot;</span> &lt;&lt; state_;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnecting)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = <span class=\"built_in\">removeAndResetChannel</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> err = sockets::<span class=\"built_in\">getSocketError</span>(sockfd);</span><br><span class=\"line\">        LOG_TRACE &lt;&lt; <span class=\"string\">&quot;SO_ERROR = &quot;</span> &lt;&lt; err &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; <span class=\"built_in\">strerror_tl</span>(err);</span><br><span class=\"line\">        <span class=\"built_in\">retry</span>(sockfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::retry</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>&#123;</span><br><span class=\"line\">    sockets::<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect_)&#123;</span><br><span class=\"line\">        LOG_INFO &lt;&lt; <span class=\"string\">&quot;Connector::retry - Retry connecting to &quot;</span> &lt;&lt; serverAddr_.<span class=\"built_in\">toIpPort</span>()</span><br><span class=\"line\">                    &lt;&lt; <span class=\"string\">&quot; in &quot;</span> &lt;&lt; retryDelayMs_ &lt;&lt; <span class=\"string\">&quot; milliseconds. &quot;</span>;</span><br><span class=\"line\">        loop_-&gt;<span class=\"built_in\">runAfter</span>(retryDelayMs_/<span class=\"number\">1000.0</span>, <span class=\"comment\">// 稍后重试</span></span><br><span class=\"line\">                        std::<span class=\"built_in\">bind</span>(&amp;Connector::startInLoop, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">        retryDelayMs_ = std::<span class=\"built_in\">min</span>(retryDelayMs_ * <span class=\"number\">2</span>, kMaxRetryDelayMs);  <span class=\"comment\">// 超时加倍</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;do not connect&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"TcpClient的实现\"><a href=\"#TcpClient的实现\" class=\"headerlink\" title=\"TcpClient的实现\"></a>TcpClient的实现</h2><p><strong>提供的接口：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TcpClient</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// TcpClient(EventLoop* loop);</span></span><br><span class=\"line\">    <span class=\"comment\">// TcpClient(EventLoop* loop, const string&amp; host, uint16_t port);</span></span><br><span class=\"line\">    <span class=\"built_in\">TcpClient</span>(EventLoop* loop,</span><br><span class=\"line\">            <span class=\"type\">const</span> InetAddress&amp; serverAddr,</span><br><span class=\"line\">            <span class=\"type\">const</span> string&amp; nameArg);</span><br><span class=\"line\">    ~<span class=\"built_in\">TcpClient</span>();  <span class=\"comment\">// force out-line dtor, for std::unique_ptr members.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">connect</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disconnect</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">connection</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> connection_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getLoop</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> loop_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">retry</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> retry_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enableRetry</span><span class=\"params\">()</span> </span>&#123; retry_ = <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set connection callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setConnectionCallback</span><span class=\"params\">(ConnectionCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; connectionCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set message callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setMessageCallback</span><span class=\"params\">(MessageCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; messageCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set write complete callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWriteCompleteCallback</span><span class=\"params\">(WriteCompleteCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; writeCompleteCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// 运行在那个loop</span></span><br><span class=\"line\">    ConnectorPtr connector_; <span class=\"comment\">// avoid revealing Connector // 连接器</span></span><br><span class=\"line\">    <span class=\"type\">const</span> string name_; <span class=\"comment\">// TcpClient名</span></span><br><span class=\"line\">    ConnectionCallback connectionCallback_;   <span class=\"comment\">// 连接建立和断开回调</span></span><br><span class=\"line\">    MessageCallback messageCallback_;   <span class=\"comment\">// 可读回调</span></span><br><span class=\"line\">    WriteCompleteCallback writeCompleteCallback_;   <span class=\"comment\">// 写完回调</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> retry_;   <span class=\"comment\">// atomic  重连</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> connect_; <span class=\"comment\">// atomic  // 已经连接？</span></span><br><span class=\"line\">    <span class=\"comment\">// always in loop thread</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nextConnId_;  <span class=\"comment\">// 字面意思</span></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr connection_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// 连接读写管理器</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>TcpClient核心函数TcpClient::newConnection，该函数会作为连接器的回调，当sockfd连接成功后，该函数被调用，设置必要信息后，为该sockfd产生一个TcpConnection对象，后续该fd的读写，全权交由TcpConnection处理。逻辑比较简单，实现如下：</p>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TcpClient::<span class=\"built_in\">TcpClient</span>(EventLoop* loop,</span><br><span class=\"line\">                     <span class=\"type\">const</span> InetAddress&amp; serverAddr,</span><br><span class=\"line\">                     <span class=\"type\">const</span> string&amp; nameArg)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"built_in\">CHECK_NOTNULL</span>(loop)),</span><br><span class=\"line\">    <span class=\"built_in\">connector_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Connector</span>(loop, serverAddr)),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(defaultConnectionCallback),</span><br><span class=\"line\">    <span class=\"built_in\">messageCallback_</span>(defaultMessageCallback),</span><br><span class=\"line\">    <span class=\"built_in\">retry_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">connect_</span>(<span class=\"literal\">true</span>),</span><br><span class=\"line\">    <span class=\"built_in\">nextConnId_</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">setNewConnectionCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpClient::newConnection, <span class=\"keyword\">this</span>, _1));</span><br><span class=\"line\">    <span class=\"comment\">// FIXME setConnectFailedCallback</span></span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpClient::TcpClient[&quot;</span> &lt;&lt; name_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] - connector &quot;</span> &lt;&lt; <span class=\"built_in\">get_pointer</span>(connector_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::connect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> check state</span></span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpClient::connect[&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;] - connecting to &quot;</span></span><br><span class=\"line\">            &lt;&lt; connector_-&gt;<span class=\"built_in\">serverAddress</span>().<span class=\"built_in\">toIpPort</span>();</span><br><span class=\"line\">    connect_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">start</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::disconnect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection_)&#123;</span><br><span class=\"line\">            connection_-&gt;<span class=\"built_in\">shutdown</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::stop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">stop</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"function\">InetAddress <span class=\"title\">peerAddr</span><span class=\"params\">(sockets::getPeerAddr(sockfd))</span></span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;:%s#%d&quot;</span>, peerAddr.<span class=\"built_in\">toIpPort</span>().<span class=\"built_in\">c_str</span>(), nextConnId_);</span><br><span class=\"line\">    ++nextConnId_;</span><br><span class=\"line\">    string connName = name_ + buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">InetAddress <span class=\"title\">localAddr</span><span class=\"params\">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class=\"line\">    <span class=\"comment\">// FIXME use make_shared if necessary</span></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">conn</span><span class=\"params\">(<span class=\"keyword\">new</span> TcpConnection(loop_,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            connName,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            sockfd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            localAddr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            peerAddr))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setConnectionCallback</span>(connectionCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setMessageCallback</span>(messageCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setCloseCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpClient::removeConnection, <span class=\"keyword\">this</span>, _1)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        connection_ = conn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">connectEstablished</span>(); <span class=\"comment\">// 同一loop，可以直接调用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(loop_ == conn-&gt;<span class=\"built_in\">getLoop</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(connection_ == conn);</span><br><span class=\"line\">        connection_.<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retry_ &amp;&amp; connect_)&#123;</span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpClient::connect[&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;] - Reconnecting to &quot;</span></span><br><span class=\"line\">                &lt;&lt; connector_-&gt;<span class=\"built_in\">serverAddress</span>().<span class=\"built_in\">toIpPort</span>();</span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">restart</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"细节明细：\"><a href=\"#细节明细：\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h3><p><strong>疑问</strong></p>\n<p>在TcpConnection::handleClose()实现当中，为什么没有调用close，关闭sockfd？也看了一下TcpConnection的析构、TcpConnection::connectDestroyed()，没有一个地方调用了close来关闭sockfd</p>\n<p><strong>解答</strong></p>\n<p>在 TcpConnection 对象析构的时候。TcpConnection 持有一个 Socket 对象，Socket 是一个 RAII handler，它的析构函数会 close(sockfd_)。这样，如果发生 TcpConnection 对象泄漏，那么我们从 &#x2F;proc&#x2F;pid&#x2F;fd&#x2F; 就能找到没有关闭的文件描述符，便于查错。</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/Solstice/article/details/6208634\">https://blog.csdn.net/Solstice/article/details/6208634</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Muduo设计的TcpServer和TcpClient代码思想及其统一，一些算法题也是需要这样的抽象思维，所以我认为这也是以后从事it最重要的品质，可以避免很多不必要的bug。</p>\n","excerpt":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><a href=\"./TcpClient.md\">muduo源码阅读笔记（11、TcpClient）</a></p>\n<p><strong>前言</strong></p>\n<p>本章新涉及的文件有：</p>\n<ol>\n<li><p>TcpClient.h&#x2F;cc：和TcpServer不同的是，TcpClient位于客户端，主要是对客户发起的连接进行管理，TcpClient只有一个loop，也会和TcpConnection配合，将三次握手连接成功的sockfd交由TcpConnection管理。</p>\n</li>\n<li><p>Connector.h&#x2F;cc：Muduo将一个客户端的sock分成了两个阶段，分别是：连接阶段、读写阶段，Connector就是负责fd的连接阶段，当一个sockfd连接成功后，将sockfd传给TcpClient，由TcpClient将sockfd传给TcpConnection进行读写管理，Connector和TcpServer的Acceptor在设计上有这类似的思想，不同的是，Connector是可以针对同一个ip地址进行多次连接，产生不同的sockfd、而Acceptor是去读listen sock来接收连接，产生不同sockfd。</p>\n</li>\n</ol>\n<p>总体来说，TcpClient的实现是<strong>严格遵循</strong>TcpServer的实现的，</p>\n<h2 id=\"Connector的实现\"><a href=\"#Connector的实现\" class=\"headerlink\" title=\"Connector的实现\"></a>Connector的实现</h2><p><strong>提供的接口：</strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Connector</span> : noncopyable,</span><br><span class=\"line\">                  <span class=\"keyword\">public</span> std::enable_shared_from_this&lt;Connector&gt;&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> (<span class=\"type\">int</span> sockfd)&gt; NewConnectionCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Connector</span>(EventLoop* loop, <span class=\"type\">const</span> InetAddress&amp; serverAddr);</span><br><span class=\"line\">    ~<span class=\"built_in\">Connector</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setNewConnectionCallback</span><span class=\"params\">(<span class=\"type\">const</span> NewConnectionCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; newConnectionCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// can be called in any thread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">restart</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// must be called in loop thread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// can be called in any thread</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> InetAddress&amp; <span class=\"title\">serverAddress</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> serverAddr_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"title class_\">States</span> &#123; kDisconnected, kConnecting, kConnected &#125;;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kMaxRetryDelayMs = <span class=\"number\">30</span>*<span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kInitRetryDelayMs = <span class=\"number\">500</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setState</span><span class=\"params\">(States s)</span> </span>&#123; state_ = s; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">startInLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stopInLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">connect</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">connecting</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleWrite</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleError</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">retry</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeAndResetChannel</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">resetChannel</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// 连接发起所在loop</span></span><br><span class=\"line\">    InetAddress serverAddr_;  <span class=\"comment\">// 连接到哪里</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> connect_; <span class=\"comment\">// atomic  // 开始连接？</span></span><br><span class=\"line\">    States state_;  <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use atomic variable // 连接状态</span></span><br><span class=\"line\">    std::unique_ptr&lt;Channel&gt; channel_;  <span class=\"comment\">// fd读写以及读写事件管理，对epoll/poll/selectIO多路复用的抽象，方便跨平台。</span></span><br><span class=\"line\">    NewConnectionCallback newConnectionCallback_; <span class=\"comment\">// 一般是：TcpClient::newConnection</span></span><br><span class=\"line\">    <span class=\"type\">int</span> retryDelayMs_;  <span class=\"comment\">// 连接重试毫秒数。</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>简单记录一下连接阶段启动流程：</p>\n<p>调用Connector::start()-&gt;</p>\n<ol>\n<li><p>connect_ 赋值为 true。</p>\n</li>\n<li><p>在loop任务队列追加Connector::startInLoop()回调任务</p>\n<ol>\n<li><p>执行回调任务：Connector::startInLoop()</p>\n</li>\n<li><p>调用Connector::connect()</p>\n<ol>\n<li><p>创建非阻塞的连接sock</p>\n</li>\n<li><p>::connect(sock, …)</p>\n</li>\n<li><p>调用Connector::connecting(int sockfd)</p>\n<ol>\n<li><p>new channel(sockfd)赋值给channel_将Connector::handleWrite()和Connector::handleError()设置给cahnnel的写回调以及错误处理回调</p>\n</li>\n<li><p>使能Poller开始监听sockfd</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>当连接成功，会触发sockfd的写事件，从而调用Connector::handleWrite()-&gt;</p>\n<ol>\n<li><p>将sockfd和channel_解绑，并将channel_ rest。</p>\n</li>\n<li><p>调用newConnectionCallback_（也即TcpClient::newConnection）将连接完成的sockfd传给TcpClient处理</p>\n</li>\n</ol>\n<p>感兴趣的读者，可以自行阅读源码，了解连接过程中，stop、retry的流程。</p>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;Connector::startInLoop, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::startInLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(state_ == kDisconnected);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">connect</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;do not connect&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::stop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;Connector::stopInLoop, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> cancel timer</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::stopInLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnecting)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = <span class=\"built_in\">removeAndResetChannel</span>();</span><br><span class=\"line\">        <span class=\"built_in\">retry</span>(sockfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::connect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> sockfd = sockets::<span class=\"built_in\">createNonblockingOrDie</span>(serverAddr_.<span class=\"built_in\">family</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = sockets::<span class=\"built_in\">connect</span>(sockfd, serverAddr_.<span class=\"built_in\">getSockAddr</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> savedErrno = (ret == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : errno;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (savedErrno)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EINPROGRESS:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EINTR:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EISCONN:</span><br><span class=\"line\">            <span class=\"built_in\">connecting</span>(sockfd);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::connecting</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kConnecting);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!channel_);</span><br><span class=\"line\">    channel_.<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Channel</span>(loop_, sockfd));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setWriteCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Connector::handleWrite, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setErrorCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Connector::handleError, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// channel_-&gt;tie(shared_from_this()); is not working,</span></span><br><span class=\"line\">    <span class=\"comment\">// as channel_ is not managed by shared_ptr</span></span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">enableWriting</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Connector::removeAndResetChannel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> sockfd = channel_-&gt;<span class=\"built_in\">fd</span>();</span><br><span class=\"line\">    <span class=\"comment\">// Can&#x27;t reset channel_ here, because we are inside Channel::handleEvent</span></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;Connector::resetChannel, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sockfd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::resetChannel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    channel_.<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::handleWrite</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;Connector::handleWrite &quot;</span> &lt;&lt; state_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnecting)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = <span class=\"built_in\">removeAndResetChannel</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> err = sockets::<span class=\"built_in\">getSocketError</span>(sockfd);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err)&#123;</span><br><span class=\"line\">            LOG_WARN &lt;&lt; <span class=\"string\">&quot;Connector::handleWrite - SO_ERROR = &quot;</span></span><br><span class=\"line\">                    &lt;&lt; err &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; <span class=\"built_in\">strerror_tl</span>(err);</span><br><span class=\"line\">            <span class=\"built_in\">retry</span>(sockfd);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">setState</span>(kConnected);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (connect_)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">newConnectionCallback_</span>(sockfd);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                sockets::<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// what happened?</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(state_ == kDisconnected);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::handleError</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    LOG_ERROR &lt;&lt; <span class=\"string\">&quot;Connector::handleError state=&quot;</span> &lt;&lt; state_;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnecting)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = <span class=\"built_in\">removeAndResetChannel</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> err = sockets::<span class=\"built_in\">getSocketError</span>(sockfd);</span><br><span class=\"line\">        LOG_TRACE &lt;&lt; <span class=\"string\">&quot;SO_ERROR = &quot;</span> &lt;&lt; err &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; <span class=\"built_in\">strerror_tl</span>(err);</span><br><span class=\"line\">        <span class=\"built_in\">retry</span>(sockfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::retry</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>&#123;</span><br><span class=\"line\">    sockets::<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect_)&#123;</span><br><span class=\"line\">        LOG_INFO &lt;&lt; <span class=\"string\">&quot;Connector::retry - Retry connecting to &quot;</span> &lt;&lt; serverAddr_.<span class=\"built_in\">toIpPort</span>()</span><br><span class=\"line\">                    &lt;&lt; <span class=\"string\">&quot; in &quot;</span> &lt;&lt; retryDelayMs_ &lt;&lt; <span class=\"string\">&quot; milliseconds. &quot;</span>;</span><br><span class=\"line\">        loop_-&gt;<span class=\"built_in\">runAfter</span>(retryDelayMs_/<span class=\"number\">1000.0</span>, <span class=\"comment\">// 稍后重试</span></span><br><span class=\"line\">                        std::<span class=\"built_in\">bind</span>(&amp;Connector::startInLoop, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">        retryDelayMs_ = std::<span class=\"built_in\">min</span>(retryDelayMs_ * <span class=\"number\">2</span>, kMaxRetryDelayMs);  <span class=\"comment\">// 超时加倍</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;do not connect&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"TcpClient的实现\"><a href=\"#TcpClient的实现\" class=\"headerlink\" title=\"TcpClient的实现\"></a>TcpClient的实现</h2><p><strong>提供的接口：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TcpClient</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// TcpClient(EventLoop* loop);</span></span><br><span class=\"line\">    <span class=\"comment\">// TcpClient(EventLoop* loop, const string&amp; host, uint16_t port);</span></span><br><span class=\"line\">    <span class=\"built_in\">TcpClient</span>(EventLoop* loop,</span><br><span class=\"line\">            <span class=\"type\">const</span> InetAddress&amp; serverAddr,</span><br><span class=\"line\">            <span class=\"type\">const</span> string&amp; nameArg);</span><br><span class=\"line\">    ~<span class=\"built_in\">TcpClient</span>();  <span class=\"comment\">// force out-line dtor, for std::unique_ptr members.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">connect</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disconnect</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">connection</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> connection_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getLoop</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> loop_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">retry</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> retry_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enableRetry</span><span class=\"params\">()</span> </span>&#123; retry_ = <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set connection callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setConnectionCallback</span><span class=\"params\">(ConnectionCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; connectionCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set message callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setMessageCallback</span><span class=\"params\">(MessageCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; messageCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set write complete callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWriteCompleteCallback</span><span class=\"params\">(WriteCompleteCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; writeCompleteCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// 运行在那个loop</span></span><br><span class=\"line\">    ConnectorPtr connector_; <span class=\"comment\">// avoid revealing Connector // 连接器</span></span><br><span class=\"line\">    <span class=\"type\">const</span> string name_; <span class=\"comment\">// TcpClient名</span></span><br><span class=\"line\">    ConnectionCallback connectionCallback_;   <span class=\"comment\">// 连接建立和断开回调</span></span><br><span class=\"line\">    MessageCallback messageCallback_;   <span class=\"comment\">// 可读回调</span></span><br><span class=\"line\">    WriteCompleteCallback writeCompleteCallback_;   <span class=\"comment\">// 写完回调</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> retry_;   <span class=\"comment\">// atomic  重连</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> connect_; <span class=\"comment\">// atomic  // 已经连接？</span></span><br><span class=\"line\">    <span class=\"comment\">// always in loop thread</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nextConnId_;  <span class=\"comment\">// 字面意思</span></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr connection_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// 连接读写管理器</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>TcpClient核心函数TcpClient::newConnection，该函数会作为连接器的回调，当sockfd连接成功后，该函数被调用，设置必要信息后，为该sockfd产生一个TcpConnection对象，后续该fd的读写，全权交由TcpConnection处理。逻辑比较简单，实现如下：</p>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TcpClient::<span class=\"built_in\">TcpClient</span>(EventLoop* loop,</span><br><span class=\"line\">                     <span class=\"type\">const</span> InetAddress&amp; serverAddr,</span><br><span class=\"line\">                     <span class=\"type\">const</span> string&amp; nameArg)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"built_in\">CHECK_NOTNULL</span>(loop)),</span><br><span class=\"line\">    <span class=\"built_in\">connector_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Connector</span>(loop, serverAddr)),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(defaultConnectionCallback),</span><br><span class=\"line\">    <span class=\"built_in\">messageCallback_</span>(defaultMessageCallback),</span><br><span class=\"line\">    <span class=\"built_in\">retry_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">connect_</span>(<span class=\"literal\">true</span>),</span><br><span class=\"line\">    <span class=\"built_in\">nextConnId_</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">setNewConnectionCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpClient::newConnection, <span class=\"keyword\">this</span>, _1));</span><br><span class=\"line\">    <span class=\"comment\">// FIXME setConnectFailedCallback</span></span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpClient::TcpClient[&quot;</span> &lt;&lt; name_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] - connector &quot;</span> &lt;&lt; <span class=\"built_in\">get_pointer</span>(connector_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::connect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> check state</span></span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpClient::connect[&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;] - connecting to &quot;</span></span><br><span class=\"line\">            &lt;&lt; connector_-&gt;<span class=\"built_in\">serverAddress</span>().<span class=\"built_in\">toIpPort</span>();</span><br><span class=\"line\">    connect_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">start</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::disconnect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection_)&#123;</span><br><span class=\"line\">            connection_-&gt;<span class=\"built_in\">shutdown</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::stop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">stop</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"function\">InetAddress <span class=\"title\">peerAddr</span><span class=\"params\">(sockets::getPeerAddr(sockfd))</span></span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;:%s#%d&quot;</span>, peerAddr.<span class=\"built_in\">toIpPort</span>().<span class=\"built_in\">c_str</span>(), nextConnId_);</span><br><span class=\"line\">    ++nextConnId_;</span><br><span class=\"line\">    string connName = name_ + buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">InetAddress <span class=\"title\">localAddr</span><span class=\"params\">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class=\"line\">    <span class=\"comment\">// FIXME use make_shared if necessary</span></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">conn</span><span class=\"params\">(<span class=\"keyword\">new</span> TcpConnection(loop_,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            connName,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            sockfd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            localAddr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            peerAddr))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setConnectionCallback</span>(connectionCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setMessageCallback</span>(messageCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setCloseCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpClient::removeConnection, <span class=\"keyword\">this</span>, _1)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        connection_ = conn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">connectEstablished</span>(); <span class=\"comment\">// 同一loop，可以直接调用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(loop_ == conn-&gt;<span class=\"built_in\">getLoop</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(connection_ == conn);</span><br><span class=\"line\">        connection_.<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retry_ &amp;&amp; connect_)&#123;</span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpClient::connect[&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;] - Reconnecting to &quot;</span></span><br><span class=\"line\">                &lt;&lt; connector_-&gt;<span class=\"built_in\">serverAddress</span>().<span class=\"built_in\">toIpPort</span>();</span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">restart</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"细节明细：\"><a href=\"#细节明细：\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h3><p><strong>疑问</strong></p>\n<p>在TcpConnection::handleClose()实现当中，为什么没有调用close，关闭sockfd？也看了一下TcpConnection的析构、TcpConnection::connectDestroyed()，没有一个地方调用了close来关闭sockfd</p>\n<p><strong>解答</strong></p>\n<p>在 TcpConnection 对象析构的时候。TcpConnection 持有一个 Socket 对象，Socket 是一个 RAII handler，它的析构函数会 close(sockfd_)。这样，如果发生 TcpConnection 对象泄漏，那么我们从 &#x2F;proc&#x2F;pid&#x2F;fd&#x2F; 就能找到没有关闭的文件描述符，便于查错。</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/Solstice/article/details/6208634\">https://blog.csdn.net/Solstice/article/details/6208634</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Muduo设计的TcpServer和TcpClient代码思想及其统一，一些算法题也是需要这样的抽象思维，所以我认为这也是以后从事it最重要的品质，可以避免很多不必要的bug。</p>"},{"title":"muduo源码阅读笔记（10、TcpConnection）","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\n本章涉及两个新模块：TcpConnection、Buffer。本文重点集中在TcpConnection上，对于Buffer会进行简单的描述。\n\n## Buffer\n\nMuduo的Buffer类实际上就是基于vector\\<char\\>实现了一个缓存区，在vector的基础上，自己封装了扩容和缩容的接口。每个TcpConnection都会自带两个Buffer，一个读缓存区和一个写缓存区。\n\n这里只列出TcpConnection用到的接口的实现。\n\n**提供的接口：**\n\n<!-- more -->\n```cpp\nclass Buffer : public muduo::copyable{\npublic:\n    static const size_t kCheapPrepend = 8;  // 为prepend预留\n    static const size_t kInitialSize = 1024;    // 默认大小\n\n    explicit Buffer(size_t initialSize = kInitialSize)\n    : buffer_(kCheapPrepend + initialSize),\n        readerIndex_(kCheapPrepend),\n        writerIndex_(kCheapPrepend){\n        assert(readableBytes() == 0);\n        assert(writableBytes() == initialSize);\n        assert(prependableBytes() == kCheapPrepend);\n    }\n    size_t readableBytes() const\n    { return writerIndex_ - readerIndex_; }\n\n    size_t writableBytes() const\n    { return buffer_.size() - writerIndex_; }\n\n    size_t prependableBytes() const\n    { return readerIndex_; }\n\n    const char* peek() const\n    { return begin() + readerIndex_; }\n    //各种读写操作省略\n    // ...\n\n    \n    void append(const char* /*restrict*/ data, size_t len){\n        ensureWritableBytes(len);\n        std::copy(data, data+len, beginWrite());\n        hasWritten(len);\n    }\n\n    void ensureWritableBytes(size_t len){\n        if (writableBytes() < len){\n            makeSpace(len);\n        }\n        assert(writableBytes() >= len);\n    }\n\n    void shrink(size_t reserve){    // 缩容\n        // FIXME: use vector::shrink_to_fit() in C++ 11 if possible.\n        Buffer other;\n        other.ensureWritableBytes(readableBytes()+reserve);\n        other.append(toStringPiece());\n        swap(other);\n    }\n\n    /// Read data directly into buffer.\n    ///\n    /// It may implement with readv(2)\n    /// @return result of read(2), @c errno is saved\n    ssize_t readFd(int fd, int* savedErrno);\n\nprivate:\n\n    char* begin()\n    { return &*buffer_.begin(); }\n\n    void makeSpace(size_t len){\n        if (writableBytes() + prependableBytes() < len + kCheapPrepend){ // 扩容。\n            // FIXME: move readable data\n            buffer_.resize(writerIndex_+len);\n        }else{ // 原地腾空间\n            // move readable data to the front, make space inside buffer\n            assert(kCheapPrepend < readerIndex_);\n            size_t readable = readableBytes();\n            std::copy(begin()+readerIndex_,\n                    begin()+writerIndex_,\n                    begin()+kCheapPrepend);\n            readerIndex_ = kCheapPrepend;\n            writerIndex_ = readerIndex_ + readable;\n            assert(readable == readableBytes());\n        }\n    }\n\nprivate:\n  std::vector<char> buffer_;\n  size_t readerIndex_;  // 读到哪里\n  size_t writerIndex_;  // 写到哪里\n};\n\n```\n\nBuffer的结构如下：\n\n```\n/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer\n///\n/// @code\n/// +-------------------+------------------+------------------+\n/// | prependable bytes |  readable bytes  |  writable bytes  |\n/// |                   |     (CONTENT)    |                  |\n/// +-------------------+------------------+------------------+\n/// |                   |                  |                  |\n/// 0      <=      readerIndex   <=   writerIndex    <=     size\n/// @endcode\n```\n\n**实现的伪代码：**\n\n```cpp\n/*\n* 将sockfd上的数据读到buffer上。\n*/\nssize_t Buffer::readFd(int fd, int* savedErrno){\n    // saved an ioctl()/FIONREAD call to tell how much to read\n    char extrabuf[65536];\n    struct iovec vec[2];\n    const size_t writable = writableBytes();\n    vec[0].iov_base = begin()+writerIndex_;\n    vec[0].iov_len = writable;\n    vec[1].iov_base = extrabuf;\n    vec[1].iov_len = sizeof extrabuf;\n    // when there is enough space in this buffer, don't read into extrabuf.\n    // when extrabuf is used, we read 128k-1 bytes at most.\n    // buffer够大，只用buffer，否者buffer和extrabuf一起用\n    const int iovcnt = (writable < sizeof extrabuf) ? 2 : 1;\n    const ssize_t n = sockets::readv(fd, vec, iovcnt);\n    if (n < 0){\n        *savedErrno = errno;\n    }else if (implicit_cast<size_t>(n) <= writable){\n        writerIndex_ += n;\n    }else{\n        writerIndex_ = buffer_.size();\n        append(extrabuf, n - writable); // 将extrabuf的数据append到buffer中\n    }\n    return n;\n}\n\n```\n\n## TcpConnection\n\n仔细阅读源码，结合前面的TimeQueue和Acceptor，TcpConnection的整体结构其实和这两个类差不多。内部都是维护了专门的fd的channel，实现了各种事件处理回调。只不过TcpConnection管理的是数据读写套接字，涉及的事件比较多，回调处理部分也稍稍复杂点。\n\n**TcpConnection对象的构造：**\n\n根据传进来的sockfd、loop，为sockfd构造一个channel，并为channel设置事件的回调处理函数，最后将sockfd设置为SO_KEEPALIVE。（TcpConnection::state_初始化为kConnecting）\n\n代码如下：\n\n```cpp\nTcpConnection::TcpConnection(EventLoop* loop,\n                             const string& nameArg,\n                             int sockfd,\n                             const InetAddress& localAddr,\n                             const InetAddress& peerAddr)\n  : loop_(CHECK_NOTNULL(loop)),\n    name_(nameArg),\n    state_(kConnecting),\n    reading_(true),\n    socket_(new Socket(sockfd)),\n    channel_(new Channel(loop, sockfd)),\n    localAddr_(localAddr),\n    peerAddr_(peerAddr),\n    highWaterMark_(64*1024*1024){\n\n    channel_->setReadCallback(  // 读回调\n        std::bind(&TcpConnection::handleRead, this, _1));\n    channel_->setWriteCallback( // 写回调\n        std::bind(&TcpConnection::handleWrite, this));\n    channel_->setCloseCallback( // sockfd关闭回调\n        std::bind(&TcpConnection::handleClose, this));\n    channel_->setErrorCallback( // 错误处理回调\n        std::bind(&TcpConnection::handleError, this));\n    LOG_DEBUG << \"TcpConnection::ctor[\" <<  name_ << \"] at \" << this\n            << \" fd=\" << sockfd;\n    socket_->setKeepAlive(true);    // 长连接\n}\n```\n\n**连接的建立：**\n\n接着[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)。\n\n1. 在绑定的ioloop中执行`TcpConnection::connectEstablished()`，进行连接的初始化，过程如下：\n\n    1. 将TcpConnection::state_设置成kConnected。\n\n    2. 将channel_的生命周期和TcpConnection绑定，以免TcpConnection被销毁后，channel的回调继续错误的被执行。\n\n    3. 向ioloop的Poller中注册channel_并使能读事件。\n\n    4. 调用TcpConnection::connectionCallback_回调。\n\n    5. 连接建立完毕。\n\n代码如下：\n\n```cpp\nvoid TcpConnection::connectEstablished(){\n    loop_->assertInLoopThread();\n    assert(state_ == kConnecting);\n    setState(kConnected);\n    channel_->tie(shared_from_this());\n    channel_->enableReading();  // 使能读事件\n\n    connectionCallback_(shared_from_this());\n}\n```\n\n**接收数据：**\n\n全权由读回调接收：\n\n1. 将数据读到TcpConnection::inputBuffer_，返回值n（读到字节数）\n\n2. \n    - n > 0，调用TcpConnection::messageCallback_处理数据\n    - n == 0，说明连接关闭，调用TcpConnection::handleClose()回调。\n    - n < 0，出错，调用TcpConnection::handleError处理。\n\n代码如下：\n\n```cpp\nvoid TcpConnection::handleRead(Timestamp receiveTime){\n    loop_->assertInLoopThread();\n    int savedErrno = 0;\n    ssize_t n = inputBuffer_.readFd(channel_->fd(), &savedErrno);\n    if (n > 0){\n        messageCallback_(shared_from_this(), &inputBuffer_, receiveTime);\n    }else if (n == 0){\n        handleClose();\n    }else{\n        errno = savedErrno;\n        LOG_SYSERR << \"TcpConnection::handleRead\";\n        handleError();\n    }\n}\n```\n\n**发送数据：**\n\n主动发送：\n\n1. 用户调用TcpConnection::send\n\n    1. 如果正好在ioloop内，直接调用TcpConnection::sendInLoop()，否则，向ioloop的任务队列中添加TcpConnection::sendInLoop()异步回调。\n\n    2. 执行TcpConnection::sendInLoop()\n        1. 如果连接状态为kDisconnected，说明连接断开，直接返回。\n\n        2. 先直接调用::write，能写多少是多少，触发errno == EPIPE || errno == ECONNRESET错误就直接返回。\n\n        3. 如果写完了，异步调用一下writeCompleteCallback_回调。否者，说明底层的发送缓存满了，剩余的数据追加到outputBuffer_，并使能channel_的写事件，异步通知写outputBuffer_。当然，如果outputBuffer_积累的数据太多，达到阈值，就异步调用一下highWaterMarkCallback_。\n\nsendInLoop代码如下：\n\n```cpp\nvoid TcpConnection::sendInLoop(const void* data, size_t len){\n    loop_->assertInLoopThread();\n    ssize_t nwrote = 0;\n    size_t remaining = len; // 还剩多少没发\n    bool faultError = false;\n    if (state_ == kDisconnected){ // 连接断开\n        LOG_WARN << \"disconnected, give up writing\";\n        return;\n    }\n    // if no thing in output queue, try writing directly\n    if (!channel_->isWriting() && outputBuffer_.readableBytes() == 0){ // Poller没有监听conn fd的写事件 && TcpConnection::outputBuffer_缓存没有数据等待发送（完全空闲）。\n\n        // 尽最大努力写一次，能写多少是多少\n        // 如果数据没写完，说明TCP发送缓存满，就需要向Poller注册写事件，来通知异步写，将剩余的数据写完。\n        nwrote = sockets::write(channel_->fd(), data, len); \n        if (nwrote >= 0){\n            remaining = len - nwrote;\n            if (remaining == 0 && writeCompleteCallback_){\n                loop_->queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));\n            }\n        }else{ // nwrote < 0\n            nwrote = 0;\n            if (errno != EWOULDBLOCK){\n                LOG_SYSERR << \"TcpConnection::sendInLoop\";\n                if (errno == EPIPE || errno == ECONNRESET) {// FIXME: any others?// 本端sock写关闭，但是还向sock里面写，会触发EPIPE || 连接关闭\n                    faultError = true;\n                }\n            }\n        }\n    }\n\n    assert(remaining <= len);\n    if (!faultError && remaining > 0){  // TCP写缓存满，还有代写数据，只能异步写。\n        size_t oldLen = outputBuffer_.readableBytes();\n        if (oldLen + remaining >= highWaterMark_\n            && oldLen < highWaterMark_\n            && highWaterMarkCallback_){\n            loop_->queueInLoop(std::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));\n        }\n        outputBuffer_.append(static_cast<const char*>(data)+nwrote, remaining);\n        if (!channel_->isWriting()){\n            channel_->enableWriting();\n        }\n    }\n}\n```\n\n异步发送：\n\n因为发送缓存区满了，所以不得不由Poller异步通知来发送数据\n\n1. 发送缓存未满，Poller触发可写事件，调用TcpConnection::handleWrite()\n\n    1. 保证channel_->isWriting() == true，否则什么也不做输出日志后返回。\n\n    2. 调用::write()发送outputBuffer_数据。\n\n    3. 如果outputBuffer_数据发送完了，取消cahnnel_的写事件，并异步调用一下writeCompleteCallback_ && 如果连接状态是kDisconnecting，执行shutdownInLoop()。关闭本端写。\n\nhandleWrite()代码如下：\n\n```cpp\nvoid TcpConnection::handleWrite(){\n    loop_->assertInLoopThread();\n    if (channel_->isWriting()){\n        ssize_t n = sockets::write(channel_->fd(),\n                                outputBuffer_.peek(),\n                                outputBuffer_.readableBytes());\n        if (n > 0){\n            outputBuffer_.retrieve(n);\n            if (outputBuffer_.readableBytes() == 0){\n                channel_->disableWriting();\n                if (writeCompleteCallback_){\n                    loop_->queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));\n                }\n                if (state_ == kDisconnecting){\n                    shutdownInLoop();\n                }\n            }\n        }else{\n            LOG_SYSERR << \"TcpConnection::handleWrite\";\n        }\n    }else{\n        LOG_TRACE << \"Connection fd = \" << channel_->fd()\n                << \" is down, no more writing\";\n    }\n}\n```\n\n**关闭连接：**\n\n主动关闭：\n\n1. 主动调用TcpConnection::forceClose。\n\n2. 将连接状态设置成kDisconnecting \n\n3. 异步回调TcpConnection::forceCloseInLoop()\n\n    1. 调用handleClose()\n\n        1. 将连接状态设置成kDisconnected\n\n        2. 取消channel_所有事件\n\n        3. 调用connectionCallback_\n\n        4. 调用closeCallback_（即将TcpServer上的连接信息删除掉）\n\n        5. 异步回调TcpConnection::connectDestroyed\n\n            - 将channel从Poller中移除。\n\n相关代码如下：\n\n```cpp\nvoid TcpConnection::forceClose(){\n    // FIXME: use compare and swap\n    if (state_ == kConnected || state_ == kDisconnecting){\n        setState(kDisconnecting);\n        loop_->queueInLoop(std::bind(&TcpConnection::forceCloseInLoop, shared_from_this()));\n    }\n}\n\nvoid TcpConnection::forceCloseInLoop(){\n    loop_->assertInLoopThread();\n    if (state_ == kConnected || state_ == kDisconnecting){\n        // as if we received 0 byte in handleRead();\n        handleClose();\n    }\n}\n\nvoid TcpConnection::handleClose(){\n    loop_->assertInLoopThread();\n    LOG_TRACE << \"fd = \" << channel_->fd() << \" state = \" << stateToString();\n    assert(state_ == kConnected || state_ == kDisconnecting);\n    // we don't close fd, leave it to dtor, so we can find leaks easily.\n    setState(kDisconnected);\n    channel_->disableAll();\n\n    TcpConnectionPtr guardThis(shared_from_this());\n    connectionCallback_(guardThis);   // connectionCallback_见TcpServer\n    // must be the last line\n    closeCallback_(guardThis);    // closeCallback_见TcpServer\n}\n\nvoid TcpConnection::connectDestroyed(){\n    loop_->assertInLoopThread();\n    if (state_ == kConnected){\n        setState(kDisconnected);\n        channel_->disableAll();\n\n        connectionCallback_(shared_from_this());\n    }\n    channel_->remove();\n}\n```\n\n被动关闭：\n\n- TcpConnection::handleRead：因为read返回0，代表连接已经被关闭。会被动调用handleClose。\n\n- Channel::handleEventWithGuard：channel_触发POLLHUP事件，连接被关闭，会被动调用handleClose。\n\n## 细节明细\n\n**疑问：**\n\n为什么 muduo 要设计一个 shutdown() 半关闭TCP连接？\n\n**解答：**\n\n用 shutdown 而不用 close 的效果是，如果对方已经发送了数据，这些数据还“在路上”，那么 muduo 不会漏收这些数据。换句话说，muduo 在 TCP 这一层面解决了“当你打算关闭网络连接的时候，如何得知对方有没有发了一些数据而你还没有收到？”这一问题。当然，这个问题也可以在上面的协议层解决，双方商量好不再互发数据，就可以直接断开连接。\n\n完整的流程是：我们发完了数据，于是 shutdownWrite，发送 TCP FIN 分节，对方会读到 0 字节，然后对方通常会关闭连接，这样 muduo 会读到 0 字节，然后 muduo 关闭连接。\n\n原文链接：https://blog.csdn.net/Solstice/article/details/6208634\n\n## 小结\n\n本章涉及的回调有些复杂，有遗漏的，后面会补充。至此，Muduo服务端源码分析，基本完成。真心建议各位读者能反复去阅读Muduo的源码。\n\n后续可能会计划出一下sylar的源码笔记。然后看有没有时间整理一下LevelDB的源码笔记（可能会鸽，因为马上要春招了，并没有多少时间去写博客）但找到工作之后，也会坚持写的。而且存储方面我也就了解点LevelDB，没有其他存储引擎的底子，没有对比理解的可能也不是很深。\n\n---\n\n**本章完结**","source":"_posts/muduo/TcpConnection.md","raw":"---\ntitle: muduo源码阅读笔记（10、TcpConnection）\ndate: 2024-11-02 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\n本章涉及两个新模块：TcpConnection、Buffer。本文重点集中在TcpConnection上，对于Buffer会进行简单的描述。\n\n## Buffer\n\nMuduo的Buffer类实际上就是基于vector\\<char\\>实现了一个缓存区，在vector的基础上，自己封装了扩容和缩容的接口。每个TcpConnection都会自带两个Buffer，一个读缓存区和一个写缓存区。\n\n这里只列出TcpConnection用到的接口的实现。\n\n**提供的接口：**\n\n<!-- more -->\n```cpp\nclass Buffer : public muduo::copyable{\npublic:\n    static const size_t kCheapPrepend = 8;  // 为prepend预留\n    static const size_t kInitialSize = 1024;    // 默认大小\n\n    explicit Buffer(size_t initialSize = kInitialSize)\n    : buffer_(kCheapPrepend + initialSize),\n        readerIndex_(kCheapPrepend),\n        writerIndex_(kCheapPrepend){\n        assert(readableBytes() == 0);\n        assert(writableBytes() == initialSize);\n        assert(prependableBytes() == kCheapPrepend);\n    }\n    size_t readableBytes() const\n    { return writerIndex_ - readerIndex_; }\n\n    size_t writableBytes() const\n    { return buffer_.size() - writerIndex_; }\n\n    size_t prependableBytes() const\n    { return readerIndex_; }\n\n    const char* peek() const\n    { return begin() + readerIndex_; }\n    //各种读写操作省略\n    // ...\n\n    \n    void append(const char* /*restrict*/ data, size_t len){\n        ensureWritableBytes(len);\n        std::copy(data, data+len, beginWrite());\n        hasWritten(len);\n    }\n\n    void ensureWritableBytes(size_t len){\n        if (writableBytes() < len){\n            makeSpace(len);\n        }\n        assert(writableBytes() >= len);\n    }\n\n    void shrink(size_t reserve){    // 缩容\n        // FIXME: use vector::shrink_to_fit() in C++ 11 if possible.\n        Buffer other;\n        other.ensureWritableBytes(readableBytes()+reserve);\n        other.append(toStringPiece());\n        swap(other);\n    }\n\n    /// Read data directly into buffer.\n    ///\n    /// It may implement with readv(2)\n    /// @return result of read(2), @c errno is saved\n    ssize_t readFd(int fd, int* savedErrno);\n\nprivate:\n\n    char* begin()\n    { return &*buffer_.begin(); }\n\n    void makeSpace(size_t len){\n        if (writableBytes() + prependableBytes() < len + kCheapPrepend){ // 扩容。\n            // FIXME: move readable data\n            buffer_.resize(writerIndex_+len);\n        }else{ // 原地腾空间\n            // move readable data to the front, make space inside buffer\n            assert(kCheapPrepend < readerIndex_);\n            size_t readable = readableBytes();\n            std::copy(begin()+readerIndex_,\n                    begin()+writerIndex_,\n                    begin()+kCheapPrepend);\n            readerIndex_ = kCheapPrepend;\n            writerIndex_ = readerIndex_ + readable;\n            assert(readable == readableBytes());\n        }\n    }\n\nprivate:\n  std::vector<char> buffer_;\n  size_t readerIndex_;  // 读到哪里\n  size_t writerIndex_;  // 写到哪里\n};\n\n```\n\nBuffer的结构如下：\n\n```\n/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer\n///\n/// @code\n/// +-------------------+------------------+------------------+\n/// | prependable bytes |  readable bytes  |  writable bytes  |\n/// |                   |     (CONTENT)    |                  |\n/// +-------------------+------------------+------------------+\n/// |                   |                  |                  |\n/// 0      <=      readerIndex   <=   writerIndex    <=     size\n/// @endcode\n```\n\n**实现的伪代码：**\n\n```cpp\n/*\n* 将sockfd上的数据读到buffer上。\n*/\nssize_t Buffer::readFd(int fd, int* savedErrno){\n    // saved an ioctl()/FIONREAD call to tell how much to read\n    char extrabuf[65536];\n    struct iovec vec[2];\n    const size_t writable = writableBytes();\n    vec[0].iov_base = begin()+writerIndex_;\n    vec[0].iov_len = writable;\n    vec[1].iov_base = extrabuf;\n    vec[1].iov_len = sizeof extrabuf;\n    // when there is enough space in this buffer, don't read into extrabuf.\n    // when extrabuf is used, we read 128k-1 bytes at most.\n    // buffer够大，只用buffer，否者buffer和extrabuf一起用\n    const int iovcnt = (writable < sizeof extrabuf) ? 2 : 1;\n    const ssize_t n = sockets::readv(fd, vec, iovcnt);\n    if (n < 0){\n        *savedErrno = errno;\n    }else if (implicit_cast<size_t>(n) <= writable){\n        writerIndex_ += n;\n    }else{\n        writerIndex_ = buffer_.size();\n        append(extrabuf, n - writable); // 将extrabuf的数据append到buffer中\n    }\n    return n;\n}\n\n```\n\n## TcpConnection\n\n仔细阅读源码，结合前面的TimeQueue和Acceptor，TcpConnection的整体结构其实和这两个类差不多。内部都是维护了专门的fd的channel，实现了各种事件处理回调。只不过TcpConnection管理的是数据读写套接字，涉及的事件比较多，回调处理部分也稍稍复杂点。\n\n**TcpConnection对象的构造：**\n\n根据传进来的sockfd、loop，为sockfd构造一个channel，并为channel设置事件的回调处理函数，最后将sockfd设置为SO_KEEPALIVE。（TcpConnection::state_初始化为kConnecting）\n\n代码如下：\n\n```cpp\nTcpConnection::TcpConnection(EventLoop* loop,\n                             const string& nameArg,\n                             int sockfd,\n                             const InetAddress& localAddr,\n                             const InetAddress& peerAddr)\n  : loop_(CHECK_NOTNULL(loop)),\n    name_(nameArg),\n    state_(kConnecting),\n    reading_(true),\n    socket_(new Socket(sockfd)),\n    channel_(new Channel(loop, sockfd)),\n    localAddr_(localAddr),\n    peerAddr_(peerAddr),\n    highWaterMark_(64*1024*1024){\n\n    channel_->setReadCallback(  // 读回调\n        std::bind(&TcpConnection::handleRead, this, _1));\n    channel_->setWriteCallback( // 写回调\n        std::bind(&TcpConnection::handleWrite, this));\n    channel_->setCloseCallback( // sockfd关闭回调\n        std::bind(&TcpConnection::handleClose, this));\n    channel_->setErrorCallback( // 错误处理回调\n        std::bind(&TcpConnection::handleError, this));\n    LOG_DEBUG << \"TcpConnection::ctor[\" <<  name_ << \"] at \" << this\n            << \" fd=\" << sockfd;\n    socket_->setKeepAlive(true);    // 长连接\n}\n```\n\n**连接的建立：**\n\n接着[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)。\n\n1. 在绑定的ioloop中执行`TcpConnection::connectEstablished()`，进行连接的初始化，过程如下：\n\n    1. 将TcpConnection::state_设置成kConnected。\n\n    2. 将channel_的生命周期和TcpConnection绑定，以免TcpConnection被销毁后，channel的回调继续错误的被执行。\n\n    3. 向ioloop的Poller中注册channel_并使能读事件。\n\n    4. 调用TcpConnection::connectionCallback_回调。\n\n    5. 连接建立完毕。\n\n代码如下：\n\n```cpp\nvoid TcpConnection::connectEstablished(){\n    loop_->assertInLoopThread();\n    assert(state_ == kConnecting);\n    setState(kConnected);\n    channel_->tie(shared_from_this());\n    channel_->enableReading();  // 使能读事件\n\n    connectionCallback_(shared_from_this());\n}\n```\n\n**接收数据：**\n\n全权由读回调接收：\n\n1. 将数据读到TcpConnection::inputBuffer_，返回值n（读到字节数）\n\n2. \n    - n > 0，调用TcpConnection::messageCallback_处理数据\n    - n == 0，说明连接关闭，调用TcpConnection::handleClose()回调。\n    - n < 0，出错，调用TcpConnection::handleError处理。\n\n代码如下：\n\n```cpp\nvoid TcpConnection::handleRead(Timestamp receiveTime){\n    loop_->assertInLoopThread();\n    int savedErrno = 0;\n    ssize_t n = inputBuffer_.readFd(channel_->fd(), &savedErrno);\n    if (n > 0){\n        messageCallback_(shared_from_this(), &inputBuffer_, receiveTime);\n    }else if (n == 0){\n        handleClose();\n    }else{\n        errno = savedErrno;\n        LOG_SYSERR << \"TcpConnection::handleRead\";\n        handleError();\n    }\n}\n```\n\n**发送数据：**\n\n主动发送：\n\n1. 用户调用TcpConnection::send\n\n    1. 如果正好在ioloop内，直接调用TcpConnection::sendInLoop()，否则，向ioloop的任务队列中添加TcpConnection::sendInLoop()异步回调。\n\n    2. 执行TcpConnection::sendInLoop()\n        1. 如果连接状态为kDisconnected，说明连接断开，直接返回。\n\n        2. 先直接调用::write，能写多少是多少，触发errno == EPIPE || errno == ECONNRESET错误就直接返回。\n\n        3. 如果写完了，异步调用一下writeCompleteCallback_回调。否者，说明底层的发送缓存满了，剩余的数据追加到outputBuffer_，并使能channel_的写事件，异步通知写outputBuffer_。当然，如果outputBuffer_积累的数据太多，达到阈值，就异步调用一下highWaterMarkCallback_。\n\nsendInLoop代码如下：\n\n```cpp\nvoid TcpConnection::sendInLoop(const void* data, size_t len){\n    loop_->assertInLoopThread();\n    ssize_t nwrote = 0;\n    size_t remaining = len; // 还剩多少没发\n    bool faultError = false;\n    if (state_ == kDisconnected){ // 连接断开\n        LOG_WARN << \"disconnected, give up writing\";\n        return;\n    }\n    // if no thing in output queue, try writing directly\n    if (!channel_->isWriting() && outputBuffer_.readableBytes() == 0){ // Poller没有监听conn fd的写事件 && TcpConnection::outputBuffer_缓存没有数据等待发送（完全空闲）。\n\n        // 尽最大努力写一次，能写多少是多少\n        // 如果数据没写完，说明TCP发送缓存满，就需要向Poller注册写事件，来通知异步写，将剩余的数据写完。\n        nwrote = sockets::write(channel_->fd(), data, len); \n        if (nwrote >= 0){\n            remaining = len - nwrote;\n            if (remaining == 0 && writeCompleteCallback_){\n                loop_->queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));\n            }\n        }else{ // nwrote < 0\n            nwrote = 0;\n            if (errno != EWOULDBLOCK){\n                LOG_SYSERR << \"TcpConnection::sendInLoop\";\n                if (errno == EPIPE || errno == ECONNRESET) {// FIXME: any others?// 本端sock写关闭，但是还向sock里面写，会触发EPIPE || 连接关闭\n                    faultError = true;\n                }\n            }\n        }\n    }\n\n    assert(remaining <= len);\n    if (!faultError && remaining > 0){  // TCP写缓存满，还有代写数据，只能异步写。\n        size_t oldLen = outputBuffer_.readableBytes();\n        if (oldLen + remaining >= highWaterMark_\n            && oldLen < highWaterMark_\n            && highWaterMarkCallback_){\n            loop_->queueInLoop(std::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));\n        }\n        outputBuffer_.append(static_cast<const char*>(data)+nwrote, remaining);\n        if (!channel_->isWriting()){\n            channel_->enableWriting();\n        }\n    }\n}\n```\n\n异步发送：\n\n因为发送缓存区满了，所以不得不由Poller异步通知来发送数据\n\n1. 发送缓存未满，Poller触发可写事件，调用TcpConnection::handleWrite()\n\n    1. 保证channel_->isWriting() == true，否则什么也不做输出日志后返回。\n\n    2. 调用::write()发送outputBuffer_数据。\n\n    3. 如果outputBuffer_数据发送完了，取消cahnnel_的写事件，并异步调用一下writeCompleteCallback_ && 如果连接状态是kDisconnecting，执行shutdownInLoop()。关闭本端写。\n\nhandleWrite()代码如下：\n\n```cpp\nvoid TcpConnection::handleWrite(){\n    loop_->assertInLoopThread();\n    if (channel_->isWriting()){\n        ssize_t n = sockets::write(channel_->fd(),\n                                outputBuffer_.peek(),\n                                outputBuffer_.readableBytes());\n        if (n > 0){\n            outputBuffer_.retrieve(n);\n            if (outputBuffer_.readableBytes() == 0){\n                channel_->disableWriting();\n                if (writeCompleteCallback_){\n                    loop_->queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));\n                }\n                if (state_ == kDisconnecting){\n                    shutdownInLoop();\n                }\n            }\n        }else{\n            LOG_SYSERR << \"TcpConnection::handleWrite\";\n        }\n    }else{\n        LOG_TRACE << \"Connection fd = \" << channel_->fd()\n                << \" is down, no more writing\";\n    }\n}\n```\n\n**关闭连接：**\n\n主动关闭：\n\n1. 主动调用TcpConnection::forceClose。\n\n2. 将连接状态设置成kDisconnecting \n\n3. 异步回调TcpConnection::forceCloseInLoop()\n\n    1. 调用handleClose()\n\n        1. 将连接状态设置成kDisconnected\n\n        2. 取消channel_所有事件\n\n        3. 调用connectionCallback_\n\n        4. 调用closeCallback_（即将TcpServer上的连接信息删除掉）\n\n        5. 异步回调TcpConnection::connectDestroyed\n\n            - 将channel从Poller中移除。\n\n相关代码如下：\n\n```cpp\nvoid TcpConnection::forceClose(){\n    // FIXME: use compare and swap\n    if (state_ == kConnected || state_ == kDisconnecting){\n        setState(kDisconnecting);\n        loop_->queueInLoop(std::bind(&TcpConnection::forceCloseInLoop, shared_from_this()));\n    }\n}\n\nvoid TcpConnection::forceCloseInLoop(){\n    loop_->assertInLoopThread();\n    if (state_ == kConnected || state_ == kDisconnecting){\n        // as if we received 0 byte in handleRead();\n        handleClose();\n    }\n}\n\nvoid TcpConnection::handleClose(){\n    loop_->assertInLoopThread();\n    LOG_TRACE << \"fd = \" << channel_->fd() << \" state = \" << stateToString();\n    assert(state_ == kConnected || state_ == kDisconnecting);\n    // we don't close fd, leave it to dtor, so we can find leaks easily.\n    setState(kDisconnected);\n    channel_->disableAll();\n\n    TcpConnectionPtr guardThis(shared_from_this());\n    connectionCallback_(guardThis);   // connectionCallback_见TcpServer\n    // must be the last line\n    closeCallback_(guardThis);    // closeCallback_见TcpServer\n}\n\nvoid TcpConnection::connectDestroyed(){\n    loop_->assertInLoopThread();\n    if (state_ == kConnected){\n        setState(kDisconnected);\n        channel_->disableAll();\n\n        connectionCallback_(shared_from_this());\n    }\n    channel_->remove();\n}\n```\n\n被动关闭：\n\n- TcpConnection::handleRead：因为read返回0，代表连接已经被关闭。会被动调用handleClose。\n\n- Channel::handleEventWithGuard：channel_触发POLLHUP事件，连接被关闭，会被动调用handleClose。\n\n## 细节明细\n\n**疑问：**\n\n为什么 muduo 要设计一个 shutdown() 半关闭TCP连接？\n\n**解答：**\n\n用 shutdown 而不用 close 的效果是，如果对方已经发送了数据，这些数据还“在路上”，那么 muduo 不会漏收这些数据。换句话说，muduo 在 TCP 这一层面解决了“当你打算关闭网络连接的时候，如何得知对方有没有发了一些数据而你还没有收到？”这一问题。当然，这个问题也可以在上面的协议层解决，双方商量好不再互发数据，就可以直接断开连接。\n\n完整的流程是：我们发完了数据，于是 shutdownWrite，发送 TCP FIN 分节，对方会读到 0 字节，然后对方通常会关闭连接，这样 muduo 会读到 0 字节，然后 muduo 关闭连接。\n\n原文链接：https://blog.csdn.net/Solstice/article/details/6208634\n\n## 小结\n\n本章涉及的回调有些复杂，有遗漏的，后面会补充。至此，Muduo服务端源码分析，基本完成。真心建议各位读者能反复去阅读Muduo的源码。\n\n后续可能会计划出一下sylar的源码笔记。然后看有没有时间整理一下LevelDB的源码笔记（可能会鸽，因为马上要春招了，并没有多少时间去写博客）但找到工作之后，也会坚持写的。而且存储方面我也就了解点LevelDB，没有其他存储引擎的底子，没有对比理解的可能也不是很深。\n\n---\n\n**本章完结**","slug":"muduo/TcpConnection","published":1,"updated":"2025-09-28T16:06:43.130Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9q000kq8ws5wshe41s","content":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>本章涉及两个新模块：TcpConnection、Buffer。本文重点集中在TcpConnection上，对于Buffer会进行简单的描述。</p>\n<h2 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h2><p>Muduo的Buffer类实际上就是基于vector&lt;char&gt;实现了一个缓存区，在vector的基础上，自己封装了扩容和缩容的接口。每个TcpConnection都会自带两个Buffer，一个读缓存区和一个写缓存区。</p>\n<p>这里只列出TcpConnection用到的接口的实现。</p>\n<p><strong>提供的接口：</strong></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Buffer</span> : <span class=\"keyword\">public</span> muduo::copyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> kCheapPrepend = <span class=\"number\">8</span>;  <span class=\"comment\">// 为prepend预留</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> kInitialSize = <span class=\"number\">1024</span>;    <span class=\"comment\">// 默认大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Buffer</span><span class=\"params\">(<span class=\"type\">size_t</span> initialSize = kInitialSize)</span></span></span><br><span class=\"line\"><span class=\"function\">    : buffer_(kCheapPrepend + initialSize),</span></span><br><span class=\"line\"><span class=\"function\">        readerIndex_(kCheapPrepend),</span></span><br><span class=\"line\"><span class=\"function\">        writerIndex_(kCheapPrepend)&#123;</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">readableBytes</span>() == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">writableBytes</span>() == initialSize);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">prependableBytes</span>() == kCheapPrepend);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">readableBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> writerIndex_ - readerIndex_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">writableBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> buffer_.<span class=\"built_in\">size</span>() - writerIndex_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">prependableBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> readerIndex_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title\">peek</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">begin</span>() + readerIndex_; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//各种读写操作省略</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"comment\">/*restrict*/</span> data, <span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">ensureWritableBytes</span>(len);</span><br><span class=\"line\">        std::<span class=\"built_in\">copy</span>(data, data+len, <span class=\"built_in\">beginWrite</span>());</span><br><span class=\"line\">        <span class=\"built_in\">hasWritten</span>(len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ensureWritableBytes</span><span class=\"params\">(<span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">writableBytes</span>() &lt; len)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">makeSpace</span>(len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">writableBytes</span>() &gt;= len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shrink</span><span class=\"params\">(<span class=\"type\">size_t</span> reserve)</span></span>&#123;    <span class=\"comment\">// 缩容</span></span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use vector::shrink_to_fit() in C++ 11 if possible.</span></span><br><span class=\"line\">        Buffer other;</span><br><span class=\"line\">        other.<span class=\"built_in\">ensureWritableBytes</span>(<span class=\"built_in\">readableBytes</span>()+reserve);</span><br><span class=\"line\">        other.<span class=\"built_in\">append</span>(<span class=\"built_in\">toStringPiece</span>());</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(other);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Read data directly into buffer.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// It may implement with readv(2)</span></span><br><span class=\"line\">    <span class=\"comment\">/// @return result of read(2), @c errno is saved</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">ssize_t</span> <span class=\"title\">readFd</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span>* savedErrno)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">char</span>* <span class=\"title\">begin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> &amp;*buffer_.<span class=\"built_in\">begin</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">makeSpace</span><span class=\"params\">(<span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">writableBytes</span>() + <span class=\"built_in\">prependableBytes</span>() &lt; len + kCheapPrepend)&#123; <span class=\"comment\">// 扩容。</span></span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> move readable data</span></span><br><span class=\"line\">            buffer_.<span class=\"built_in\">resize</span>(writerIndex_+len);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 原地腾空间</span></span><br><span class=\"line\">            <span class=\"comment\">// move readable data to the front, make space inside buffer</span></span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(kCheapPrepend &lt; readerIndex_);</span><br><span class=\"line\">            <span class=\"type\">size_t</span> readable = <span class=\"built_in\">readableBytes</span>();</span><br><span class=\"line\">            std::<span class=\"built_in\">copy</span>(<span class=\"built_in\">begin</span>()+readerIndex_,</span><br><span class=\"line\">                    <span class=\"built_in\">begin</span>()+writerIndex_,</span><br><span class=\"line\">                    <span class=\"built_in\">begin</span>()+kCheapPrepend);</span><br><span class=\"line\">            readerIndex_ = kCheapPrepend;</span><br><span class=\"line\">            writerIndex_ = readerIndex_ + readable;</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(readable == <span class=\"built_in\">readableBytes</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  std::vector&lt;<span class=\"type\">char</span>&gt; buffer_;</span><br><span class=\"line\">  <span class=\"type\">size_t</span> readerIndex_;  <span class=\"comment\">// 读到哪里</span></span><br><span class=\"line\">  <span class=\"type\">size_t</span> writerIndex_;  <span class=\"comment\">// 写到哪里</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Buffer的结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer</span><br><span class=\"line\">///</span><br><span class=\"line\">/// @code</span><br><span class=\"line\">/// +-------------------+------------------+------------------+</span><br><span class=\"line\">/// | prependable bytes |  readable bytes  |  writable bytes  |</span><br><span class=\"line\">/// |                   |     (CONTENT)    |                  |</span><br><span class=\"line\">/// +-------------------+------------------+------------------+</span><br><span class=\"line\">/// |                   |                  |                  |</span><br><span class=\"line\">/// 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size</span><br><span class=\"line\">/// @endcode</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 将sockfd上的数据读到buffer上。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">ssize_t</span> <span class=\"title\">Buffer::readFd</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span>* savedErrno)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// saved an ioctl()/FIONREAD call to tell how much to read</span></span><br><span class=\"line\">    <span class=\"type\">char</span> extrabuf[<span class=\"number\">65536</span>];</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> vec[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">size_t</span> writable = <span class=\"built_in\">writableBytes</span>();</span><br><span class=\"line\">    vec[<span class=\"number\">0</span>].iov_base = <span class=\"built_in\">begin</span>()+writerIndex_;</span><br><span class=\"line\">    vec[<span class=\"number\">0</span>].iov_len = writable;</span><br><span class=\"line\">    vec[<span class=\"number\">1</span>].iov_base = extrabuf;</span><br><span class=\"line\">    vec[<span class=\"number\">1</span>].iov_len = <span class=\"keyword\">sizeof</span> extrabuf;</span><br><span class=\"line\">    <span class=\"comment\">// when there is enough space in this buffer, don&#x27;t read into extrabuf.</span></span><br><span class=\"line\">    <span class=\"comment\">// when extrabuf is used, we read 128k-1 bytes at most.</span></span><br><span class=\"line\">    <span class=\"comment\">// buffer够大，只用buffer，否者buffer和extrabuf一起用</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> iovcnt = (writable &lt; <span class=\"keyword\">sizeof</span> extrabuf) ? <span class=\"number\">2</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">readv</span>(fd, vec, iovcnt);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        *savedErrno = errno;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">implicit_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(n) &lt;= writable)&#123;</span><br><span class=\"line\">        writerIndex_ += n;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        writerIndex_ = buffer_.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">append</span>(extrabuf, n - writable); <span class=\"comment\">// 将extrabuf的数据append到buffer中</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"TcpConnection\"><a href=\"#TcpConnection\" class=\"headerlink\" title=\"TcpConnection\"></a>TcpConnection</h2><p>仔细阅读源码，结合前面的TimeQueue和Acceptor，TcpConnection的整体结构其实和这两个类差不多。内部都是维护了专门的fd的channel，实现了各种事件处理回调。只不过TcpConnection管理的是数据读写套接字，涉及的事件比较多，回调处理部分也稍稍复杂点。</p>\n<p><strong>TcpConnection对象的构造：</strong></p>\n<p>根据传进来的sockfd、loop，为sockfd构造一个channel，并为channel设置事件的回调处理函数，最后将sockfd设置为SO_KEEPALIVE。（TcpConnection::state_初始化为kConnecting）</p>\n<p>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TcpConnection::<span class=\"built_in\">TcpConnection</span>(EventLoop* loop,</span><br><span class=\"line\">                             <span class=\"type\">const</span> string&amp; nameArg,</span><br><span class=\"line\">                             <span class=\"type\">int</span> sockfd,</span><br><span class=\"line\">                             <span class=\"type\">const</span> InetAddress&amp; localAddr,</span><br><span class=\"line\">                             <span class=\"type\">const</span> InetAddress&amp; peerAddr)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"built_in\">CHECK_NOTNULL</span>(loop)),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">state_</span>(kConnecting),</span><br><span class=\"line\">    <span class=\"built_in\">reading_</span>(<span class=\"literal\">true</span>),</span><br><span class=\"line\">    <span class=\"built_in\">socket_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Socket</span>(sockfd)),</span><br><span class=\"line\">    <span class=\"built_in\">channel_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Channel</span>(loop, sockfd)),</span><br><span class=\"line\">    <span class=\"built_in\">localAddr_</span>(localAddr),</span><br><span class=\"line\">    <span class=\"built_in\">peerAddr_</span>(peerAddr),</span><br><span class=\"line\">    <span class=\"built_in\">highWaterMark_</span>(<span class=\"number\">64</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setReadCallback</span>(  <span class=\"comment\">// 读回调</span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleRead, <span class=\"keyword\">this</span>, _1));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setWriteCallback</span>( <span class=\"comment\">// 写回调</span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleWrite, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setCloseCallback</span>( <span class=\"comment\">// sockfd关闭回调</span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleClose, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setErrorCallback</span>( <span class=\"comment\">// 错误处理回调</span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleError, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;TcpConnection::ctor[&quot;</span> &lt;&lt;  name_ &lt;&lt; <span class=\"string\">&quot;] at &quot;</span> &lt;&lt; <span class=\"keyword\">this</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot; fd=&quot;</span> &lt;&lt; sockfd;</span><br><span class=\"line\">    socket_-&gt;<span class=\"built_in\">setKeepAlive</span>(<span class=\"literal\">true</span>);    <span class=\"comment\">// 长连接</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>连接的建立：</strong></p>\n<p>接着<a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a>。</p>\n<ol>\n<li><p>在绑定的ioloop中执行<code>TcpConnection::connectEstablished()</code>，进行连接的初始化，过程如下：</p>\n<ol>\n<li><p>将TcpConnection::state_设置成kConnected。</p>\n</li>\n<li><p>将channel_的生命周期和TcpConnection绑定，以免TcpConnection被销毁后，channel的回调继续错误的被执行。</p>\n</li>\n<li><p>向ioloop的Poller中注册channel_并使能读事件。</p>\n</li>\n<li><p>调用TcpConnection::connectionCallback_回调。</p>\n</li>\n<li><p>连接建立完毕。</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::connectEstablished</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(state_ == kConnecting);</span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kConnected);</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">tie</span>(<span class=\"built_in\">shared_from_this</span>());</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">enableReading</span>();  <span class=\"comment\">// 使能读事件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(<span class=\"built_in\">shared_from_this</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>接收数据：</strong></p>\n<p>全权由读回调接收：</p>\n<ol>\n<li><p>将数据读到TcpConnection::inputBuffer_，返回值n（读到字节数）</p>\n</li>\n<li><ul>\n<li>n &gt; 0，调用TcpConnection::messageCallback_处理数据</li>\n<li>n &#x3D;&#x3D; 0，说明连接关闭，调用TcpConnection::handleClose()回调。</li>\n<li>n &lt; 0，出错，调用TcpConnection::handleError处理。</li>\n</ul>\n</li>\n</ol>\n<p>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::handleRead</span><span class=\"params\">(Timestamp receiveTime)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> savedErrno = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> n = inputBuffer_.<span class=\"built_in\">readFd</span>(channel_-&gt;<span class=\"built_in\">fd</span>(), &amp;savedErrno);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">messageCallback_</span>(<span class=\"built_in\">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">handleClose</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        errno = savedErrno;</span><br><span class=\"line\">        LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;TcpConnection::handleRead&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">handleError</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>发送数据：</strong></p>\n<p>主动发送：</p>\n<ol>\n<li><p>用户调用TcpConnection::send</p>\n<ol>\n<li><p>如果正好在ioloop内，直接调用TcpConnection::sendInLoop()，否则，向ioloop的任务队列中添加TcpConnection::sendInLoop()异步回调。</p>\n</li>\n<li><p>执行TcpConnection::sendInLoop()</p>\n<ol>\n<li><p>如果连接状态为kDisconnected，说明连接断开，直接返回。</p>\n</li>\n<li><p>先直接调用::write，能写多少是多少，触发errno &#x3D;&#x3D; EPIPE || errno &#x3D;&#x3D; ECONNRESET错误就直接返回。</p>\n</li>\n<li><p>如果写完了，异步调用一下writeCompleteCallback_回调。否者，说明底层的发送缓存满了，剩余的数据追加到outputBuffer_，并使能channel_的写事件，异步通知写outputBuffer_。当然，如果outputBuffer_积累的数据太多，达到阈值，就异步调用一下highWaterMarkCallback_。</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>sendInLoop代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::sendInLoop</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* data, <span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> nwrote = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> remaining = len; <span class=\"comment\">// 还剩多少没发</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> faultError = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kDisconnected)&#123; <span class=\"comment\">// 连接断开</span></span><br><span class=\"line\">        LOG_WARN &lt;&lt; <span class=\"string\">&quot;disconnected, give up writing&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// if no thing in output queue, try writing directly</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!channel_-&gt;<span class=\"built_in\">isWriting</span>() &amp;&amp; outputBuffer_.<span class=\"built_in\">readableBytes</span>() == <span class=\"number\">0</span>)&#123; <span class=\"comment\">// Poller没有监听conn fd的写事件 &amp;&amp; TcpConnection::outputBuffer_缓存没有数据等待发送（完全空闲）。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 尽最大努力写一次，能写多少是多少</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果数据没写完，说明TCP发送缓存满，就需要向Poller注册写事件，来通知异步写，将剩余的数据写完。</span></span><br><span class=\"line\">        nwrote = sockets::<span class=\"built_in\">write</span>(channel_-&gt;<span class=\"built_in\">fd</span>(), data, len); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nwrote &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            remaining = len - nwrote;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remaining == <span class=\"number\">0</span> &amp;&amp; writeCompleteCallback_)&#123;</span><br><span class=\"line\">                loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(writeCompleteCallback_, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// nwrote &lt; 0</span></span><br><span class=\"line\">            nwrote = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (errno != EWOULDBLOCK)&#123;</span><br><span class=\"line\">                LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;TcpConnection::sendInLoop&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (errno == EPIPE || errno == ECONNRESET) &#123;<span class=\"comment\">// <span class=\"doctag\">FIXME:</span> any others?// 本端sock写关闭，但是还向sock里面写，会触发EPIPE || 连接关闭</span></span><br><span class=\"line\">                    faultError = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(remaining &lt;= len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!faultError &amp;&amp; remaining &gt; <span class=\"number\">0</span>)&#123;  <span class=\"comment\">// TCP写缓存满，还有代写数据，只能异步写。</span></span><br><span class=\"line\">        <span class=\"type\">size_t</span> oldLen = outputBuffer_.<span class=\"built_in\">readableBytes</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldLen + remaining &gt;= highWaterMark_</span><br><span class=\"line\">            &amp;&amp; oldLen &lt; highWaterMark_</span><br><span class=\"line\">            &amp;&amp; highWaterMarkCallback_)&#123;</span><br><span class=\"line\">            loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(highWaterMarkCallback_, <span class=\"built_in\">shared_from_this</span>(), oldLen + remaining));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        outputBuffer_.<span class=\"built_in\">append</span>(<span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">const</span> <span class=\"type\">char</span>*&gt;(data)+nwrote, remaining);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!channel_-&gt;<span class=\"built_in\">isWriting</span>())&#123;</span><br><span class=\"line\">            channel_-&gt;<span class=\"built_in\">enableWriting</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>异步发送：</p>\n<p>因为发送缓存区满了，所以不得不由Poller异步通知来发送数据</p>\n<ol>\n<li><p>发送缓存未满，Poller触发可写事件，调用TcpConnection::handleWrite()</p>\n<ol>\n<li><p>保证channel_-&gt;isWriting() &#x3D;&#x3D; true，否则什么也不做输出日志后返回。</p>\n</li>\n<li><p>调用::write()发送outputBuffer_数据。</p>\n</li>\n<li><p>如果outputBuffer_数据发送完了，取消cahnnel_的写事件，并异步调用一下writeCompleteCallback_ &amp;&amp; 如果连接状态是kDisconnecting，执行shutdownInLoop()。关闭本端写。</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>handleWrite()代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::handleWrite</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel_-&gt;<span class=\"built_in\">isWriting</span>())&#123;</span><br><span class=\"line\">        <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">write</span>(channel_-&gt;<span class=\"built_in\">fd</span>(),</span><br><span class=\"line\">                                outputBuffer_.<span class=\"built_in\">peek</span>(),</span><br><span class=\"line\">                                outputBuffer_.<span class=\"built_in\">readableBytes</span>());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            outputBuffer_.<span class=\"built_in\">retrieve</span>(n);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (outputBuffer_.<span class=\"built_in\">readableBytes</span>() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                channel_-&gt;<span class=\"built_in\">disableWriting</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (writeCompleteCallback_)&#123;</span><br><span class=\"line\">                    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(writeCompleteCallback_, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (state_ == kDisconnecting)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">shutdownInLoop</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;TcpConnection::handleWrite&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_TRACE &lt;&lt; <span class=\"string\">&quot;Connection fd = &quot;</span> &lt;&lt; channel_-&gt;<span class=\"built_in\">fd</span>()</span><br><span class=\"line\">                &lt;&lt; <span class=\"string\">&quot; is down, no more writing&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>关闭连接：</strong></p>\n<p>主动关闭：</p>\n<ol>\n<li><p>主动调用TcpConnection::forceClose。</p>\n</li>\n<li><p>将连接状态设置成kDisconnecting </p>\n</li>\n<li><p>异步回调TcpConnection::forceCloseInLoop()</p>\n<ol>\n<li><p>调用handleClose()</p>\n<ol>\n<li><p>将连接状态设置成kDisconnected</p>\n</li>\n<li><p>取消channel_所有事件</p>\n</li>\n<li><p>调用connectionCallback_</p>\n</li>\n<li><p>调用closeCallback_（即将TcpServer上的连接信息删除掉）</p>\n</li>\n<li><p>异步回调TcpConnection::connectDestroyed</p>\n<ul>\n<li>将channel从Poller中移除。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>相关代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::forceClose</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use compare and swap</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnected || state_ == kDisconnecting)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setState</span>(kDisconnecting);</span><br><span class=\"line\">        loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::forceCloseInLoop, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::forceCloseInLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnected || state_ == kDisconnecting)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// as if we received 0 byte in handleRead();</span></span><br><span class=\"line\">        <span class=\"built_in\">handleClose</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::handleClose</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;fd = &quot;</span> &lt;&lt; channel_-&gt;<span class=\"built_in\">fd</span>() &lt;&lt; <span class=\"string\">&quot; state = &quot;</span> &lt;&lt; <span class=\"built_in\">stateToString</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(state_ == kConnected || state_ == kDisconnecting);</span><br><span class=\"line\">    <span class=\"comment\">// we don&#x27;t close fd, leave it to dtor, so we can find leaks easily.</span></span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">guardThis</span><span class=\"params\">(shared_from_this())</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(guardThis);   <span class=\"comment\">// connectionCallback_见TcpServer</span></span><br><span class=\"line\">    <span class=\"comment\">// must be the last line</span></span><br><span class=\"line\">    <span class=\"built_in\">closeCallback_</span>(guardThis);    <span class=\"comment\">// closeCallback_见TcpServer</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::connectDestroyed</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnected)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">        channel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">connectionCallback_</span>(<span class=\"built_in\">shared_from_this</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>被动关闭：</p>\n<ul>\n<li><p>TcpConnection::handleRead：因为read返回0，代表连接已经被关闭。会被动调用handleClose。</p>\n</li>\n<li><p>Channel::handleEventWithGuard：channel_触发POLLHUP事件，连接被关闭，会被动调用handleClose。</p>\n</li>\n</ul>\n<h2 id=\"细节明细\"><a href=\"#细节明细\" class=\"headerlink\" title=\"细节明细\"></a>细节明细</h2><p><strong>疑问：</strong></p>\n<p>为什么 muduo 要设计一个 shutdown() 半关闭TCP连接？</p>\n<p><strong>解答：</strong></p>\n<p>用 shutdown 而不用 close 的效果是，如果对方已经发送了数据，这些数据还“在路上”，那么 muduo 不会漏收这些数据。换句话说，muduo 在 TCP 这一层面解决了“当你打算关闭网络连接的时候，如何得知对方有没有发了一些数据而你还没有收到？”这一问题。当然，这个问题也可以在上面的协议层解决，双方商量好不再互发数据，就可以直接断开连接。</p>\n<p>完整的流程是：我们发完了数据，于是 shutdownWrite，发送 TCP FIN 分节，对方会读到 0 字节，然后对方通常会关闭连接，这样 muduo 会读到 0 字节，然后 muduo 关闭连接。</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/Solstice/article/details/6208634\">https://blog.csdn.net/Solstice/article/details/6208634</a></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本章涉及的回调有些复杂，有遗漏的，后面会补充。至此，Muduo服务端源码分析，基本完成。真心建议各位读者能反复去阅读Muduo的源码。</p>\n<p>后续可能会计划出一下sylar的源码笔记。然后看有没有时间整理一下LevelDB的源码笔记（可能会鸽，因为马上要春招了，并没有多少时间去写博客）但找到工作之后，也会坚持写的。而且存储方面我也就了解点LevelDB，没有其他存储引擎的底子，没有对比理解的可能也不是很深。</p>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>本章涉及两个新模块：TcpConnection、Buffer。本文重点集中在TcpConnection上，对于Buffer会进行简单的描述。</p>\n<h2 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h2><p>Muduo的Buffer类实际上就是基于vector&lt;char&gt;实现了一个缓存区，在vector的基础上，自己封装了扩容和缩容的接口。每个TcpConnection都会自带两个Buffer，一个读缓存区和一个写缓存区。</p>\n<p>这里只列出TcpConnection用到的接口的实现。</p>\n<p><strong>提供的接口：</strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Buffer</span> : <span class=\"keyword\">public</span> muduo::copyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> kCheapPrepend = <span class=\"number\">8</span>;  <span class=\"comment\">// 为prepend预留</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> kInitialSize = <span class=\"number\">1024</span>;    <span class=\"comment\">// 默认大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Buffer</span><span class=\"params\">(<span class=\"type\">size_t</span> initialSize = kInitialSize)</span></span></span><br><span class=\"line\"><span class=\"function\">    : buffer_(kCheapPrepend + initialSize),</span></span><br><span class=\"line\"><span class=\"function\">        readerIndex_(kCheapPrepend),</span></span><br><span class=\"line\"><span class=\"function\">        writerIndex_(kCheapPrepend)&#123;</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">readableBytes</span>() == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">writableBytes</span>() == initialSize);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">prependableBytes</span>() == kCheapPrepend);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">readableBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> writerIndex_ - readerIndex_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">writableBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> buffer_.<span class=\"built_in\">size</span>() - writerIndex_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">prependableBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> readerIndex_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title\">peek</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">begin</span>() + readerIndex_; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//各种读写操作省略</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"comment\">/*restrict*/</span> data, <span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">ensureWritableBytes</span>(len);</span><br><span class=\"line\">        std::<span class=\"built_in\">copy</span>(data, data+len, <span class=\"built_in\">beginWrite</span>());</span><br><span class=\"line\">        <span class=\"built_in\">hasWritten</span>(len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ensureWritableBytes</span><span class=\"params\">(<span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">writableBytes</span>() &lt; len)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">makeSpace</span>(len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">writableBytes</span>() &gt;= len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shrink</span><span class=\"params\">(<span class=\"type\">size_t</span> reserve)</span></span>&#123;    <span class=\"comment\">// 缩容</span></span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use vector::shrink_to_fit() in C++ 11 if possible.</span></span><br><span class=\"line\">        Buffer other;</span><br><span class=\"line\">        other.<span class=\"built_in\">ensureWritableBytes</span>(<span class=\"built_in\">readableBytes</span>()+reserve);</span><br><span class=\"line\">        other.<span class=\"built_in\">append</span>(<span class=\"built_in\">toStringPiece</span>());</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(other);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Read data directly into buffer.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// It may implement with readv(2)</span></span><br><span class=\"line\">    <span class=\"comment\">/// @return result of read(2), @c errno is saved</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">ssize_t</span> <span class=\"title\">readFd</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span>* savedErrno)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">char</span>* <span class=\"title\">begin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> &amp;*buffer_.<span class=\"built_in\">begin</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">makeSpace</span><span class=\"params\">(<span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">writableBytes</span>() + <span class=\"built_in\">prependableBytes</span>() &lt; len + kCheapPrepend)&#123; <span class=\"comment\">// 扩容。</span></span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> move readable data</span></span><br><span class=\"line\">            buffer_.<span class=\"built_in\">resize</span>(writerIndex_+len);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 原地腾空间</span></span><br><span class=\"line\">            <span class=\"comment\">// move readable data to the front, make space inside buffer</span></span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(kCheapPrepend &lt; readerIndex_);</span><br><span class=\"line\">            <span class=\"type\">size_t</span> readable = <span class=\"built_in\">readableBytes</span>();</span><br><span class=\"line\">            std::<span class=\"built_in\">copy</span>(<span class=\"built_in\">begin</span>()+readerIndex_,</span><br><span class=\"line\">                    <span class=\"built_in\">begin</span>()+writerIndex_,</span><br><span class=\"line\">                    <span class=\"built_in\">begin</span>()+kCheapPrepend);</span><br><span class=\"line\">            readerIndex_ = kCheapPrepend;</span><br><span class=\"line\">            writerIndex_ = readerIndex_ + readable;</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(readable == <span class=\"built_in\">readableBytes</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  std::vector&lt;<span class=\"type\">char</span>&gt; buffer_;</span><br><span class=\"line\">  <span class=\"type\">size_t</span> readerIndex_;  <span class=\"comment\">// 读到哪里</span></span><br><span class=\"line\">  <span class=\"type\">size_t</span> writerIndex_;  <span class=\"comment\">// 写到哪里</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Buffer的结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer</span><br><span class=\"line\">///</span><br><span class=\"line\">/// @code</span><br><span class=\"line\">/// +-------------------+------------------+------------------+</span><br><span class=\"line\">/// | prependable bytes |  readable bytes  |  writable bytes  |</span><br><span class=\"line\">/// |                   |     (CONTENT)    |                  |</span><br><span class=\"line\">/// +-------------------+------------------+------------------+</span><br><span class=\"line\">/// |                   |                  |                  |</span><br><span class=\"line\">/// 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size</span><br><span class=\"line\">/// @endcode</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 将sockfd上的数据读到buffer上。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">ssize_t</span> <span class=\"title\">Buffer::readFd</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span>* savedErrno)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// saved an ioctl()/FIONREAD call to tell how much to read</span></span><br><span class=\"line\">    <span class=\"type\">char</span> extrabuf[<span class=\"number\">65536</span>];</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> vec[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">size_t</span> writable = <span class=\"built_in\">writableBytes</span>();</span><br><span class=\"line\">    vec[<span class=\"number\">0</span>].iov_base = <span class=\"built_in\">begin</span>()+writerIndex_;</span><br><span class=\"line\">    vec[<span class=\"number\">0</span>].iov_len = writable;</span><br><span class=\"line\">    vec[<span class=\"number\">1</span>].iov_base = extrabuf;</span><br><span class=\"line\">    vec[<span class=\"number\">1</span>].iov_len = <span class=\"keyword\">sizeof</span> extrabuf;</span><br><span class=\"line\">    <span class=\"comment\">// when there is enough space in this buffer, don&#x27;t read into extrabuf.</span></span><br><span class=\"line\">    <span class=\"comment\">// when extrabuf is used, we read 128k-1 bytes at most.</span></span><br><span class=\"line\">    <span class=\"comment\">// buffer够大，只用buffer，否者buffer和extrabuf一起用</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> iovcnt = (writable &lt; <span class=\"keyword\">sizeof</span> extrabuf) ? <span class=\"number\">2</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">readv</span>(fd, vec, iovcnt);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        *savedErrno = errno;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">implicit_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(n) &lt;= writable)&#123;</span><br><span class=\"line\">        writerIndex_ += n;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        writerIndex_ = buffer_.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">append</span>(extrabuf, n - writable); <span class=\"comment\">// 将extrabuf的数据append到buffer中</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"TcpConnection\"><a href=\"#TcpConnection\" class=\"headerlink\" title=\"TcpConnection\"></a>TcpConnection</h2><p>仔细阅读源码，结合前面的TimeQueue和Acceptor，TcpConnection的整体结构其实和这两个类差不多。内部都是维护了专门的fd的channel，实现了各种事件处理回调。只不过TcpConnection管理的是数据读写套接字，涉及的事件比较多，回调处理部分也稍稍复杂点。</p>\n<p><strong>TcpConnection对象的构造：</strong></p>\n<p>根据传进来的sockfd、loop，为sockfd构造一个channel，并为channel设置事件的回调处理函数，最后将sockfd设置为SO_KEEPALIVE。（TcpConnection::state_初始化为kConnecting）</p>\n<p>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TcpConnection::<span class=\"built_in\">TcpConnection</span>(EventLoop* loop,</span><br><span class=\"line\">                             <span class=\"type\">const</span> string&amp; nameArg,</span><br><span class=\"line\">                             <span class=\"type\">int</span> sockfd,</span><br><span class=\"line\">                             <span class=\"type\">const</span> InetAddress&amp; localAddr,</span><br><span class=\"line\">                             <span class=\"type\">const</span> InetAddress&amp; peerAddr)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"built_in\">CHECK_NOTNULL</span>(loop)),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">state_</span>(kConnecting),</span><br><span class=\"line\">    <span class=\"built_in\">reading_</span>(<span class=\"literal\">true</span>),</span><br><span class=\"line\">    <span class=\"built_in\">socket_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Socket</span>(sockfd)),</span><br><span class=\"line\">    <span class=\"built_in\">channel_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Channel</span>(loop, sockfd)),</span><br><span class=\"line\">    <span class=\"built_in\">localAddr_</span>(localAddr),</span><br><span class=\"line\">    <span class=\"built_in\">peerAddr_</span>(peerAddr),</span><br><span class=\"line\">    <span class=\"built_in\">highWaterMark_</span>(<span class=\"number\">64</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setReadCallback</span>(  <span class=\"comment\">// 读回调</span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleRead, <span class=\"keyword\">this</span>, _1));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setWriteCallback</span>( <span class=\"comment\">// 写回调</span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleWrite, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setCloseCallback</span>( <span class=\"comment\">// sockfd关闭回调</span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleClose, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setErrorCallback</span>( <span class=\"comment\">// 错误处理回调</span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleError, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;TcpConnection::ctor[&quot;</span> &lt;&lt;  name_ &lt;&lt; <span class=\"string\">&quot;] at &quot;</span> &lt;&lt; <span class=\"keyword\">this</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot; fd=&quot;</span> &lt;&lt; sockfd;</span><br><span class=\"line\">    socket_-&gt;<span class=\"built_in\">setKeepAlive</span>(<span class=\"literal\">true</span>);    <span class=\"comment\">// 长连接</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>连接的建立：</strong></p>\n<p>接着<a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a>。</p>\n<ol>\n<li><p>在绑定的ioloop中执行<code>TcpConnection::connectEstablished()</code>，进行连接的初始化，过程如下：</p>\n<ol>\n<li><p>将TcpConnection::state_设置成kConnected。</p>\n</li>\n<li><p>将channel_的生命周期和TcpConnection绑定，以免TcpConnection被销毁后，channel的回调继续错误的被执行。</p>\n</li>\n<li><p>向ioloop的Poller中注册channel_并使能读事件。</p>\n</li>\n<li><p>调用TcpConnection::connectionCallback_回调。</p>\n</li>\n<li><p>连接建立完毕。</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::connectEstablished</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(state_ == kConnecting);</span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kConnected);</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">tie</span>(<span class=\"built_in\">shared_from_this</span>());</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">enableReading</span>();  <span class=\"comment\">// 使能读事件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(<span class=\"built_in\">shared_from_this</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>接收数据：</strong></p>\n<p>全权由读回调接收：</p>\n<ol>\n<li><p>将数据读到TcpConnection::inputBuffer_，返回值n（读到字节数）</p>\n</li>\n<li><ul>\n<li>n &gt; 0，调用TcpConnection::messageCallback_处理数据</li>\n<li>n &#x3D;&#x3D; 0，说明连接关闭，调用TcpConnection::handleClose()回调。</li>\n<li>n &lt; 0，出错，调用TcpConnection::handleError处理。</li>\n</ul>\n</li>\n</ol>\n<p>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::handleRead</span><span class=\"params\">(Timestamp receiveTime)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> savedErrno = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> n = inputBuffer_.<span class=\"built_in\">readFd</span>(channel_-&gt;<span class=\"built_in\">fd</span>(), &amp;savedErrno);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">messageCallback_</span>(<span class=\"built_in\">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">handleClose</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        errno = savedErrno;</span><br><span class=\"line\">        LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;TcpConnection::handleRead&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">handleError</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>发送数据：</strong></p>\n<p>主动发送：</p>\n<ol>\n<li><p>用户调用TcpConnection::send</p>\n<ol>\n<li><p>如果正好在ioloop内，直接调用TcpConnection::sendInLoop()，否则，向ioloop的任务队列中添加TcpConnection::sendInLoop()异步回调。</p>\n</li>\n<li><p>执行TcpConnection::sendInLoop()</p>\n<ol>\n<li><p>如果连接状态为kDisconnected，说明连接断开，直接返回。</p>\n</li>\n<li><p>先直接调用::write，能写多少是多少，触发errno &#x3D;&#x3D; EPIPE || errno &#x3D;&#x3D; ECONNRESET错误就直接返回。</p>\n</li>\n<li><p>如果写完了，异步调用一下writeCompleteCallback_回调。否者，说明底层的发送缓存满了，剩余的数据追加到outputBuffer_，并使能channel_的写事件，异步通知写outputBuffer_。当然，如果outputBuffer_积累的数据太多，达到阈值，就异步调用一下highWaterMarkCallback_。</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>sendInLoop代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::sendInLoop</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* data, <span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> nwrote = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> remaining = len; <span class=\"comment\">// 还剩多少没发</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> faultError = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kDisconnected)&#123; <span class=\"comment\">// 连接断开</span></span><br><span class=\"line\">        LOG_WARN &lt;&lt; <span class=\"string\">&quot;disconnected, give up writing&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// if no thing in output queue, try writing directly</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!channel_-&gt;<span class=\"built_in\">isWriting</span>() &amp;&amp; outputBuffer_.<span class=\"built_in\">readableBytes</span>() == <span class=\"number\">0</span>)&#123; <span class=\"comment\">// Poller没有监听conn fd的写事件 &amp;&amp; TcpConnection::outputBuffer_缓存没有数据等待发送（完全空闲）。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 尽最大努力写一次，能写多少是多少</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果数据没写完，说明TCP发送缓存满，就需要向Poller注册写事件，来通知异步写，将剩余的数据写完。</span></span><br><span class=\"line\">        nwrote = sockets::<span class=\"built_in\">write</span>(channel_-&gt;<span class=\"built_in\">fd</span>(), data, len); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nwrote &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            remaining = len - nwrote;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remaining == <span class=\"number\">0</span> &amp;&amp; writeCompleteCallback_)&#123;</span><br><span class=\"line\">                loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(writeCompleteCallback_, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// nwrote &lt; 0</span></span><br><span class=\"line\">            nwrote = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (errno != EWOULDBLOCK)&#123;</span><br><span class=\"line\">                LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;TcpConnection::sendInLoop&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (errno == EPIPE || errno == ECONNRESET) &#123;<span class=\"comment\">// <span class=\"doctag\">FIXME:</span> any others?// 本端sock写关闭，但是还向sock里面写，会触发EPIPE || 连接关闭</span></span><br><span class=\"line\">                    faultError = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(remaining &lt;= len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!faultError &amp;&amp; remaining &gt; <span class=\"number\">0</span>)&#123;  <span class=\"comment\">// TCP写缓存满，还有代写数据，只能异步写。</span></span><br><span class=\"line\">        <span class=\"type\">size_t</span> oldLen = outputBuffer_.<span class=\"built_in\">readableBytes</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldLen + remaining &gt;= highWaterMark_</span><br><span class=\"line\">            &amp;&amp; oldLen &lt; highWaterMark_</span><br><span class=\"line\">            &amp;&amp; highWaterMarkCallback_)&#123;</span><br><span class=\"line\">            loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(highWaterMarkCallback_, <span class=\"built_in\">shared_from_this</span>(), oldLen + remaining));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        outputBuffer_.<span class=\"built_in\">append</span>(<span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">const</span> <span class=\"type\">char</span>*&gt;(data)+nwrote, remaining);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!channel_-&gt;<span class=\"built_in\">isWriting</span>())&#123;</span><br><span class=\"line\">            channel_-&gt;<span class=\"built_in\">enableWriting</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>异步发送：</p>\n<p>因为发送缓存区满了，所以不得不由Poller异步通知来发送数据</p>\n<ol>\n<li><p>发送缓存未满，Poller触发可写事件，调用TcpConnection::handleWrite()</p>\n<ol>\n<li><p>保证channel_-&gt;isWriting() &#x3D;&#x3D; true，否则什么也不做输出日志后返回。</p>\n</li>\n<li><p>调用::write()发送outputBuffer_数据。</p>\n</li>\n<li><p>如果outputBuffer_数据发送完了，取消cahnnel_的写事件，并异步调用一下writeCompleteCallback_ &amp;&amp; 如果连接状态是kDisconnecting，执行shutdownInLoop()。关闭本端写。</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>handleWrite()代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::handleWrite</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel_-&gt;<span class=\"built_in\">isWriting</span>())&#123;</span><br><span class=\"line\">        <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">write</span>(channel_-&gt;<span class=\"built_in\">fd</span>(),</span><br><span class=\"line\">                                outputBuffer_.<span class=\"built_in\">peek</span>(),</span><br><span class=\"line\">                                outputBuffer_.<span class=\"built_in\">readableBytes</span>());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            outputBuffer_.<span class=\"built_in\">retrieve</span>(n);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (outputBuffer_.<span class=\"built_in\">readableBytes</span>() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                channel_-&gt;<span class=\"built_in\">disableWriting</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (writeCompleteCallback_)&#123;</span><br><span class=\"line\">                    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(writeCompleteCallback_, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (state_ == kDisconnecting)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">shutdownInLoop</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;TcpConnection::handleWrite&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_TRACE &lt;&lt; <span class=\"string\">&quot;Connection fd = &quot;</span> &lt;&lt; channel_-&gt;<span class=\"built_in\">fd</span>()</span><br><span class=\"line\">                &lt;&lt; <span class=\"string\">&quot; is down, no more writing&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>关闭连接：</strong></p>\n<p>主动关闭：</p>\n<ol>\n<li><p>主动调用TcpConnection::forceClose。</p>\n</li>\n<li><p>将连接状态设置成kDisconnecting </p>\n</li>\n<li><p>异步回调TcpConnection::forceCloseInLoop()</p>\n<ol>\n<li><p>调用handleClose()</p>\n<ol>\n<li><p>将连接状态设置成kDisconnected</p>\n</li>\n<li><p>取消channel_所有事件</p>\n</li>\n<li><p>调用connectionCallback_</p>\n</li>\n<li><p>调用closeCallback_（即将TcpServer上的连接信息删除掉）</p>\n</li>\n<li><p>异步回调TcpConnection::connectDestroyed</p>\n<ul>\n<li>将channel从Poller中移除。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>相关代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::forceClose</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use compare and swap</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnected || state_ == kDisconnecting)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setState</span>(kDisconnecting);</span><br><span class=\"line\">        loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::forceCloseInLoop, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::forceCloseInLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnected || state_ == kDisconnecting)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// as if we received 0 byte in handleRead();</span></span><br><span class=\"line\">        <span class=\"built_in\">handleClose</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::handleClose</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;fd = &quot;</span> &lt;&lt; channel_-&gt;<span class=\"built_in\">fd</span>() &lt;&lt; <span class=\"string\">&quot; state = &quot;</span> &lt;&lt; <span class=\"built_in\">stateToString</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(state_ == kConnected || state_ == kDisconnecting);</span><br><span class=\"line\">    <span class=\"comment\">// we don&#x27;t close fd, leave it to dtor, so we can find leaks easily.</span></span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">guardThis</span><span class=\"params\">(shared_from_this())</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(guardThis);   <span class=\"comment\">// connectionCallback_见TcpServer</span></span><br><span class=\"line\">    <span class=\"comment\">// must be the last line</span></span><br><span class=\"line\">    <span class=\"built_in\">closeCallback_</span>(guardThis);    <span class=\"comment\">// closeCallback_见TcpServer</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::connectDestroyed</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnected)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">        channel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">connectionCallback_</span>(<span class=\"built_in\">shared_from_this</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>被动关闭：</p>\n<ul>\n<li><p>TcpConnection::handleRead：因为read返回0，代表连接已经被关闭。会被动调用handleClose。</p>\n</li>\n<li><p>Channel::handleEventWithGuard：channel_触发POLLHUP事件，连接被关闭，会被动调用handleClose。</p>\n</li>\n</ul>\n<h2 id=\"细节明细\"><a href=\"#细节明细\" class=\"headerlink\" title=\"细节明细\"></a>细节明细</h2><p><strong>疑问：</strong></p>\n<p>为什么 muduo 要设计一个 shutdown() 半关闭TCP连接？</p>\n<p><strong>解答：</strong></p>\n<p>用 shutdown 而不用 close 的效果是，如果对方已经发送了数据，这些数据还“在路上”，那么 muduo 不会漏收这些数据。换句话说，muduo 在 TCP 这一层面解决了“当你打算关闭网络连接的时候，如何得知对方有没有发了一些数据而你还没有收到？”这一问题。当然，这个问题也可以在上面的协议层解决，双方商量好不再互发数据，就可以直接断开连接。</p>\n<p>完整的流程是：我们发完了数据，于是 shutdownWrite，发送 TCP FIN 分节，对方会读到 0 字节，然后对方通常会关闭连接，这样 muduo 会读到 0 字节，然后 muduo 关闭连接。</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/Solstice/article/details/6208634\">https://blog.csdn.net/Solstice/article/details/6208634</a></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本章涉及的回调有些复杂，有遗漏的，后面会补充。至此，Muduo服务端源码分析，基本完成。真心建议各位读者能反复去阅读Muduo的源码。</p>\n<p>后续可能会计划出一下sylar的源码笔记。然后看有没有时间整理一下LevelDB的源码笔记（可能会鸽，因为马上要春招了，并没有多少时间去写博客）但找到工作之后，也会坚持写的。而且存储方面我也就了解点LevelDB，没有其他存储引擎的底子，没有对比理解的可能也不是很深。</p>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"muduo源码阅读笔记（9、TcpServer）","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\n本章涉及的文件有：\n\n1. TcpServer.h/cc：一个主从Reactor模型的TcpServer，主EventLoop接收连接，并且将连接sock fd负载均衡分发给一个IOLoop。\n\n2. Acceptor.h/cc：一个监听套接字的包装器，内部创建了一个Channel管理连接套接字的回调。\n\n3. Socket.h/cc：封装原生socket，提供绑定、监听、接受连接、设置socket属性等接口。\n\n4. SocketsOps.h/cc：Socket.h/cc接口的底层实现，在创建套接字（::socket()/::accept()）时，会将socketfd设置为非阻塞。\n\n5. InetAddress.h/cc：对sockaddr_in/sockaddr_in6网络地址进行封装，使其更方便使用。\n\n本章重点集中在1、2，对于3、4、5，见名知意即可，感兴趣的读者，可以自行深入阅读。\n\n## Acceptor的实现\n\n**提供的接口：**\n<!-- more -->\n\n```cpp\n///\n/// Acceptor of incoming TCP connections.\n///\nclass Acceptor : noncopyable{\npublic:\n    typedef std::function<void (int sockfd, const InetAddress&)> NewConnectionCallback;\n\n    Acceptor(EventLoop* loop, const InetAddress& listenAddr, bool reuseport);\n    ~Acceptor();\n\n    void setNewConnectionCallback(const NewConnectionCallback& cb)\n    { newConnectionCallback_ = cb; }\n\n    void listen();\n\n    bool listening() const { return listening_; }\n\n    // Deprecated, use the correct spelling one above.\n    // Leave the wrong spelling here in case one needs to grep it for error messages.\n    // bool listenning() const { return listening(); }\n\nprivate:\n    void handleRead();\n\n    EventLoop* loop_; // 绑定在哪个EventLoop上\n    Socket acceptSocket_; // accept sock fd\n    Channel acceptChannel_; // 对accept sock fd channel的封装\n    NewConnectionCallback newConnectionCallback_;   // 连接sock fd分发器\n    bool listening_;  // accept sock fd已经listen？\n    int idleFd_;  // 预留一个fd，以免文件描述符消耗完毕，无法继续处理连接。\n};\n```\n\n其实从成员变量就可以看出来，Acceptor和TimeQueue有着及其相似的地方。\n\n\n**实现的伪代码：**\n\n```cpp\nAcceptor::Acceptor(EventLoop* loop, const InetAddress& listenAddr, bool reuseport)\n  : loop_(loop),\n    acceptSocket_(sockets::createNonblockingOrDie(listenAddr.family())),\n    acceptChannel_(loop, acceptSocket_.fd()),\n    listening_(false),\n    idleFd_(::open(\"/dev/null\", O_RDONLY | O_CLOEXEC)){\n\n    assert(idleFd_ >= 0);\n    acceptSocket_.setReuseAddr(true);       // 地址重用\n    acceptSocket_.setReusePort(reuseport);  // 端口重用\n    acceptSocket_.bindAddress(listenAddr);  // 地址绑定\n    acceptChannel_.setReadCallback(         // 设置回调\n        std::bind(&Acceptor::handleRead, this));\n}\n\nAcceptor::~Acceptor(){\n    acceptChannel_.disableAll();\n    acceptChannel_.remove();\n    ::close(idleFd_);\n}\n\nvoid Acceptor::listen(){\n    loop_->assertInLoopThread();\n    listening_ = true;\n    acceptSocket_.listen(); // sock fd 开始listen\n    acceptChannel_.enableReading(); // 向Poller注册sock fd\n}\n\nvoid Acceptor::handleRead(){\n    loop_->assertInLoopThread();\n    InetAddress peerAddr;\n    //FIXME loop until no more\n    int connfd = acceptSocket_.accept(&peerAddr);\n    if (connfd >= 0){\n        // string hostport = peerAddr.toIpPort();\n        // LOG_TRACE << \"Accepts of \" << hostport;\n        if (newConnectionCallback_){\n            newConnectionCallback_(connfd, peerAddr);   // 连接分发器\n        }else{\n            sockets::close(connfd);\n        }\n    }else{\n        LOG_SYSERR << \"in Acceptor::handleRead\";\n        // Read the section named \"The special problem of\n        // accept()ing when you can't\" in libev's doc.\n        // By Marc Lehmann, author of libev.\n        if (errno == EMFILE) { // 超过文件描述符最大限制\n            ::close(idleFd_);   // 归还预留的idleFd_，利用idleFd_来接收连接\n            idleFd_ = ::accept(acceptSocket_.fd(), NULL, NULL); // 接受连接\n            // 什么也不做就关闭连接。\n            ::close(idleFd_);\n            idleFd_ = ::open(\"/dev/null\", O_RDONLY | O_CLOEXEC);    // 继续预留fd。\n        }\n    }\n}\n```\n\n### 细节明细：\n\n**疑问**\n\nAcceptor::idleFd_成员变量存在的意义？Acceptor::handleRead函数中为什么出现EMFILE错误时，关闭idleFd_，::accept接受连接，又关闭idleFd_，又打开idleFd_？\n\n**解答**\n\n出现EMFILE错误，关闭 idleFd_ 后，执行 ::accept 操作，通常情况下这个操作并不会失败。这是因为在 ::accept 函数成功返回时，会返回一个值和关闭idleFd_前值相同的连接文件描述符，这个文件描述符会被用于处理新连接。这里主要目的是消耗一个连接，尽管什么也不做。但可以确保服务器能够继续正常运行。\n\n## TcpServer的实现\n\n**提供的接口：**\n\n```cpp\n///\n/// TCP server, supports single-threaded and thread-pool models.\n///\n/// This is an interface class, so don't expose too much details.\nclass TcpServer : noncopyable{\npublic:\n    typedef std::function<void(EventLoop*)> ThreadInitCallback;\n    enum Option{\n        kNoReusePort,\n        kReusePort,\n    };\n    TcpServer(EventLoop* loop,\n            const InetAddress& listenAddr,\n            const string& nameArg,\n            Option option = kNoReusePort);\n    ~TcpServer();  // force out-line dtor, for std::unique_ptr members.\n\n    const string& ipPort() const { return ipPort_; }\n    const string& name() const { return name_; }\n    EventLoop* getLoop() const { return loop_; }\n\n    // 必须再start前调用\n    void setThreadNum(int numThreads);\n    void setThreadInitCallback(const ThreadInitCallback& cb)\n    { threadInitCallback_ = cb; }\n    /// valid after calling start()\n    std::shared_ptr<EventLoopThreadPool> threadPool()\n    { return threadPool_; }\n\n    /// Starts the server if it's not listening.\n    ///\n    /// It's harmless to call it multiple times.\n    /// Thread safe.\n    void start();\n\n    /// Set connection callback.\n    /// Not thread safe.\n    void setConnectionCallback(const ConnectionCallback& cb)\n    { connectionCallback_ = cb; }\n\n    /// Set message callback.\n    /// Not thread safe.\n    void setMessageCallback(const MessageCallback& cb)\n    { messageCallback_ = cb; }\n\n    /// Set write complete callback.\n    /// Not thread safe.\n    void setWriteCompleteCallback(const WriteCompleteCallback& cb)\n    { writeCompleteCallback_ = cb; }\n\nprivate:\n    /// Not thread safe, but in loop\n    void newConnection(int sockfd, const InetAddress& peerAddr);\n    /// Thread safe.\n    void removeConnection(const TcpConnectionPtr& conn);\n    /// Not thread safe, but in loop\n    void removeConnectionInLoop(const TcpConnectionPtr& conn);\n\n    typedef std::map<string, TcpConnectionPtr> ConnectionMap;\n\n    EventLoop* loop_;  // the acceptor loop\n    const string ipPort_; // ip:port\n    const string name_; // TcpServer Name\n    std::unique_ptr<Acceptor> acceptor_; // avoid revealing Acceptor\n    std::shared_ptr<EventLoopThreadPool> threadPool_; // 线程池\n    ConnectionCallback connectionCallback_; // 连接建立和断开回调\n    MessageCallback messageCallback_;   // 读数据回调\n    WriteCompleteCallback writeCompleteCallback_;   // 数据发送完毕的回调\n    ThreadInitCallback threadInitCallback_;\n    AtomicInt32 started_; // TcpServer启动了？\n    // always in loop thread\n    int nextConnId_;  // 连接计数器\n    ConnectionMap connections_; // 连接信息维护\n};\n```\n\n简单画了一下TcpServer整体架构图：\n\n![TcpServer](./TcpServer/photo/TcpServer.drawio.png)\n\n整体流程就是：\n\n1. 客户端发送连接请求。\n\n2. listen套接字所在的EventLoop（假设为base loop）接受连接请求并创建io套接字。\n\n3. base loop 通过EventLoopThreadPool的负载均衡算法选择一个io EventLoop，将io套接字传给该loop。\n\n4. 客户端和指定的loop进行TCP通信。\n\n---\n\n**实现伪代码：**\n\n```cpp\n\nTcpServer::TcpServer(EventLoop* loop,\n                     const InetAddress& listenAddr,\n                     const string& nameArg,\n                     Option option)\n  : loop_(CHECK_NOTNULL(loop)),\n    ipPort_(listenAddr.toIpPort()),\n    name_(nameArg),\n    acceptor_(new Acceptor(loop, listenAddr, option == kReusePort)),\n    threadPool_(new EventLoopThreadPool(loop, name_)),\n    connectionCallback_(defaultConnectionCallback),\n    messageCallback_(defaultMessageCallback),\n    nextConnId_(1){\n\n    acceptor_->setNewConnectionCallback(    // 设定连接分发器\n        std::bind(&TcpServer::newConnection, this, _1, _2));    \n}\n\nTcpServer::~TcpServer(){\n    loop_->assertInLoopThread();\n    LOG_TRACE << \"TcpServer::~TcpServer [\" << name_ << \"] destructing\";\n\n    for (auto& item : connections_){\n        TcpConnectionPtr conn(item.second);\n        item.second.reset();    // 释放引用计数\n        conn->getLoop()->runInLoop( // 在自己的loop中执行连接销毁。\n            std::bind(&TcpConnection::connectDestroyed, conn));\n    }\n}\n// 在start前调用\nvoid TcpServer::setThreadNum(int numThreads){\n    assert(0 <= numThreads);\n    threadPool_->setThreadNum(numThreads);\n}\n\nvoid TcpServer::start(){\n    if (started_.getAndSet(1) == 0){\n    threadPool_->start(threadInitCallback_);\n\n    assert(!acceptor_->listening());\n    loop_->runInLoop(\n        std::bind(&Acceptor::listen, get_pointer(acceptor_)));  // get_pointer(acceptor_)获取裸指针。\n    }\n}\n\nvoid TcpServer::newConnection(int sockfd, const InetAddress& peerAddr){\n    loop_->assertInLoopThread();\n    EventLoop* ioLoop = threadPool_->getNextLoop();\n    char buf[64];\n    snprintf(buf, sizeof buf, \"-%s#%d\", ipPort_.c_str(), nextConnId_);\n    ++nextConnId_;\n    string connName = name_ + buf;\n\n    LOG_INFO << \"TcpServer::newConnection [\" << name_\n            << \"] - new connection [\" << connName\n            << \"] from \" << peerAddr.toIpPort();\n    InetAddress localAddr(sockets::getLocalAddr(sockfd));\n    // FIXME poll with zero timeout to double confirm the new connection\n    // FIXME use make_shared if necessary\n    TcpConnectionPtr conn(new TcpConnection(ioLoop,\n                                            connName,\n                                            sockfd,\n                                            localAddr,\n                                            peerAddr));\n    connections_[connName] = conn;\n    conn->setConnectionCallback(connectionCallback_);\n    conn->setMessageCallback(messageCallback_);\n    conn->setWriteCompleteCallback(writeCompleteCallback_);\n    conn->setCloseCallback(\n        std::bind(&TcpServer::removeConnection, this, _1)); // FIXME: unsafe\n    ioLoop->runInLoop(std::bind(&TcpConnection::connectEstablished, conn));\n}\n\nvoid TcpServer::removeConnection(const TcpConnectionPtr& conn){\n    // FIXME: unsafe\n    loop_->runInLoop(std::bind(&TcpServer::removeConnectionInLoop, this, conn));    // 尽管conn是引用，bind包装后也会增加引用计数\n}\n\nvoid TcpServer::removeConnectionInLoop(const TcpConnectionPtr& conn){\n    loop_->assertInLoopThread();\n    LOG_INFO << \"TcpServer::removeConnectionInLoop [\" << name_\n            << \"] - connection \" << conn->name();\n    size_t n = connections_.erase(conn->name());\n    (void)n;\n    assert(n == 1);\n    EventLoop* ioLoop = conn->getLoop();\n    ioLoop->queueInLoop(\n        std::bind(&TcpConnection::connectDestroyed, conn));\n}\n```\n\n**这里简单备忘一下**\n\n连接建立的回调过程：\n\n1. base loop中listen套接字触发可读事件，调用Acceptor::handleRead函数处理事件（由Acceptor::acceptChannel_注册）\n\n2. 调用::accept接受连接并创建sockfd。将sockfd作为参数，调用Acceptor::newConnectionCallback_连接分发回调，也即TcpServer::newConnection（由TcpServer构造函数设置）\n\n3. 利用负载均衡算法，选择一个合适的ioloop，然后为连接拼接一个唯一的connect name，并用sockfd、ioloop等创建一个TcpConnection对象（智能指针），设置好回调。将 **<key : connect name, value : TcpConnection>** 作为TcpServer::connections_的一个记录（TcpConnection对象引用计数加一）。最后向ioloop的任务队列中添加一项回调任务：TcpConnection::connectEstablished，并将TcpConnection对象作为回调任务的参数。\n\n4. 执行TcpConnection::connectEstablished，连接建立。\n\n\n连接拆除的回调过程：\n\n1. 调用TcpConnection::closeCallback_回调，即TcpServer::removeConnection，传入TcpConnection对象（引用）作为参数。\n\n2. 向base loop任务队列添加一项回调任务：TcpServer::removeConnectionInLoop，传入TcpConnection对象（引用）作为参数。\n\n3. 执行TcpServer::removeConnectionInLoop：通过TcpConnection对象的name，在TcpServer::connections_上删除连接记录（智能指针引用计数减一），然后向TcpConnection对象的ioloop的任务队列添加一项回调任务：TcpConnection::connectDestroyed，同样以TcpConnection对象作为回调任务的参数。\n\n**本章完结**","source":"_posts/muduo/TcpServer.md","raw":"---\ntitle: muduo源码阅读笔记（9、TcpServer）\ndate: 2024-11-02 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\n本章涉及的文件有：\n\n1. TcpServer.h/cc：一个主从Reactor模型的TcpServer，主EventLoop接收连接，并且将连接sock fd负载均衡分发给一个IOLoop。\n\n2. Acceptor.h/cc：一个监听套接字的包装器，内部创建了一个Channel管理连接套接字的回调。\n\n3. Socket.h/cc：封装原生socket，提供绑定、监听、接受连接、设置socket属性等接口。\n\n4. SocketsOps.h/cc：Socket.h/cc接口的底层实现，在创建套接字（::socket()/::accept()）时，会将socketfd设置为非阻塞。\n\n5. InetAddress.h/cc：对sockaddr_in/sockaddr_in6网络地址进行封装，使其更方便使用。\n\n本章重点集中在1、2，对于3、4、5，见名知意即可，感兴趣的读者，可以自行深入阅读。\n\n## Acceptor的实现\n\n**提供的接口：**\n<!-- more -->\n\n```cpp\n///\n/// Acceptor of incoming TCP connections.\n///\nclass Acceptor : noncopyable{\npublic:\n    typedef std::function<void (int sockfd, const InetAddress&)> NewConnectionCallback;\n\n    Acceptor(EventLoop* loop, const InetAddress& listenAddr, bool reuseport);\n    ~Acceptor();\n\n    void setNewConnectionCallback(const NewConnectionCallback& cb)\n    { newConnectionCallback_ = cb; }\n\n    void listen();\n\n    bool listening() const { return listening_; }\n\n    // Deprecated, use the correct spelling one above.\n    // Leave the wrong spelling here in case one needs to grep it for error messages.\n    // bool listenning() const { return listening(); }\n\nprivate:\n    void handleRead();\n\n    EventLoop* loop_; // 绑定在哪个EventLoop上\n    Socket acceptSocket_; // accept sock fd\n    Channel acceptChannel_; // 对accept sock fd channel的封装\n    NewConnectionCallback newConnectionCallback_;   // 连接sock fd分发器\n    bool listening_;  // accept sock fd已经listen？\n    int idleFd_;  // 预留一个fd，以免文件描述符消耗完毕，无法继续处理连接。\n};\n```\n\n其实从成员变量就可以看出来，Acceptor和TimeQueue有着及其相似的地方。\n\n\n**实现的伪代码：**\n\n```cpp\nAcceptor::Acceptor(EventLoop* loop, const InetAddress& listenAddr, bool reuseport)\n  : loop_(loop),\n    acceptSocket_(sockets::createNonblockingOrDie(listenAddr.family())),\n    acceptChannel_(loop, acceptSocket_.fd()),\n    listening_(false),\n    idleFd_(::open(\"/dev/null\", O_RDONLY | O_CLOEXEC)){\n\n    assert(idleFd_ >= 0);\n    acceptSocket_.setReuseAddr(true);       // 地址重用\n    acceptSocket_.setReusePort(reuseport);  // 端口重用\n    acceptSocket_.bindAddress(listenAddr);  // 地址绑定\n    acceptChannel_.setReadCallback(         // 设置回调\n        std::bind(&Acceptor::handleRead, this));\n}\n\nAcceptor::~Acceptor(){\n    acceptChannel_.disableAll();\n    acceptChannel_.remove();\n    ::close(idleFd_);\n}\n\nvoid Acceptor::listen(){\n    loop_->assertInLoopThread();\n    listening_ = true;\n    acceptSocket_.listen(); // sock fd 开始listen\n    acceptChannel_.enableReading(); // 向Poller注册sock fd\n}\n\nvoid Acceptor::handleRead(){\n    loop_->assertInLoopThread();\n    InetAddress peerAddr;\n    //FIXME loop until no more\n    int connfd = acceptSocket_.accept(&peerAddr);\n    if (connfd >= 0){\n        // string hostport = peerAddr.toIpPort();\n        // LOG_TRACE << \"Accepts of \" << hostport;\n        if (newConnectionCallback_){\n            newConnectionCallback_(connfd, peerAddr);   // 连接分发器\n        }else{\n            sockets::close(connfd);\n        }\n    }else{\n        LOG_SYSERR << \"in Acceptor::handleRead\";\n        // Read the section named \"The special problem of\n        // accept()ing when you can't\" in libev's doc.\n        // By Marc Lehmann, author of libev.\n        if (errno == EMFILE) { // 超过文件描述符最大限制\n            ::close(idleFd_);   // 归还预留的idleFd_，利用idleFd_来接收连接\n            idleFd_ = ::accept(acceptSocket_.fd(), NULL, NULL); // 接受连接\n            // 什么也不做就关闭连接。\n            ::close(idleFd_);\n            idleFd_ = ::open(\"/dev/null\", O_RDONLY | O_CLOEXEC);    // 继续预留fd。\n        }\n    }\n}\n```\n\n### 细节明细：\n\n**疑问**\n\nAcceptor::idleFd_成员变量存在的意义？Acceptor::handleRead函数中为什么出现EMFILE错误时，关闭idleFd_，::accept接受连接，又关闭idleFd_，又打开idleFd_？\n\n**解答**\n\n出现EMFILE错误，关闭 idleFd_ 后，执行 ::accept 操作，通常情况下这个操作并不会失败。这是因为在 ::accept 函数成功返回时，会返回一个值和关闭idleFd_前值相同的连接文件描述符，这个文件描述符会被用于处理新连接。这里主要目的是消耗一个连接，尽管什么也不做。但可以确保服务器能够继续正常运行。\n\n## TcpServer的实现\n\n**提供的接口：**\n\n```cpp\n///\n/// TCP server, supports single-threaded and thread-pool models.\n///\n/// This is an interface class, so don't expose too much details.\nclass TcpServer : noncopyable{\npublic:\n    typedef std::function<void(EventLoop*)> ThreadInitCallback;\n    enum Option{\n        kNoReusePort,\n        kReusePort,\n    };\n    TcpServer(EventLoop* loop,\n            const InetAddress& listenAddr,\n            const string& nameArg,\n            Option option = kNoReusePort);\n    ~TcpServer();  // force out-line dtor, for std::unique_ptr members.\n\n    const string& ipPort() const { return ipPort_; }\n    const string& name() const { return name_; }\n    EventLoop* getLoop() const { return loop_; }\n\n    // 必须再start前调用\n    void setThreadNum(int numThreads);\n    void setThreadInitCallback(const ThreadInitCallback& cb)\n    { threadInitCallback_ = cb; }\n    /// valid after calling start()\n    std::shared_ptr<EventLoopThreadPool> threadPool()\n    { return threadPool_; }\n\n    /// Starts the server if it's not listening.\n    ///\n    /// It's harmless to call it multiple times.\n    /// Thread safe.\n    void start();\n\n    /// Set connection callback.\n    /// Not thread safe.\n    void setConnectionCallback(const ConnectionCallback& cb)\n    { connectionCallback_ = cb; }\n\n    /// Set message callback.\n    /// Not thread safe.\n    void setMessageCallback(const MessageCallback& cb)\n    { messageCallback_ = cb; }\n\n    /// Set write complete callback.\n    /// Not thread safe.\n    void setWriteCompleteCallback(const WriteCompleteCallback& cb)\n    { writeCompleteCallback_ = cb; }\n\nprivate:\n    /// Not thread safe, but in loop\n    void newConnection(int sockfd, const InetAddress& peerAddr);\n    /// Thread safe.\n    void removeConnection(const TcpConnectionPtr& conn);\n    /// Not thread safe, but in loop\n    void removeConnectionInLoop(const TcpConnectionPtr& conn);\n\n    typedef std::map<string, TcpConnectionPtr> ConnectionMap;\n\n    EventLoop* loop_;  // the acceptor loop\n    const string ipPort_; // ip:port\n    const string name_; // TcpServer Name\n    std::unique_ptr<Acceptor> acceptor_; // avoid revealing Acceptor\n    std::shared_ptr<EventLoopThreadPool> threadPool_; // 线程池\n    ConnectionCallback connectionCallback_; // 连接建立和断开回调\n    MessageCallback messageCallback_;   // 读数据回调\n    WriteCompleteCallback writeCompleteCallback_;   // 数据发送完毕的回调\n    ThreadInitCallback threadInitCallback_;\n    AtomicInt32 started_; // TcpServer启动了？\n    // always in loop thread\n    int nextConnId_;  // 连接计数器\n    ConnectionMap connections_; // 连接信息维护\n};\n```\n\n简单画了一下TcpServer整体架构图：\n\n![TcpServer](./TcpServer/photo/TcpServer.drawio.png)\n\n整体流程就是：\n\n1. 客户端发送连接请求。\n\n2. listen套接字所在的EventLoop（假设为base loop）接受连接请求并创建io套接字。\n\n3. base loop 通过EventLoopThreadPool的负载均衡算法选择一个io EventLoop，将io套接字传给该loop。\n\n4. 客户端和指定的loop进行TCP通信。\n\n---\n\n**实现伪代码：**\n\n```cpp\n\nTcpServer::TcpServer(EventLoop* loop,\n                     const InetAddress& listenAddr,\n                     const string& nameArg,\n                     Option option)\n  : loop_(CHECK_NOTNULL(loop)),\n    ipPort_(listenAddr.toIpPort()),\n    name_(nameArg),\n    acceptor_(new Acceptor(loop, listenAddr, option == kReusePort)),\n    threadPool_(new EventLoopThreadPool(loop, name_)),\n    connectionCallback_(defaultConnectionCallback),\n    messageCallback_(defaultMessageCallback),\n    nextConnId_(1){\n\n    acceptor_->setNewConnectionCallback(    // 设定连接分发器\n        std::bind(&TcpServer::newConnection, this, _1, _2));    \n}\n\nTcpServer::~TcpServer(){\n    loop_->assertInLoopThread();\n    LOG_TRACE << \"TcpServer::~TcpServer [\" << name_ << \"] destructing\";\n\n    for (auto& item : connections_){\n        TcpConnectionPtr conn(item.second);\n        item.second.reset();    // 释放引用计数\n        conn->getLoop()->runInLoop( // 在自己的loop中执行连接销毁。\n            std::bind(&TcpConnection::connectDestroyed, conn));\n    }\n}\n// 在start前调用\nvoid TcpServer::setThreadNum(int numThreads){\n    assert(0 <= numThreads);\n    threadPool_->setThreadNum(numThreads);\n}\n\nvoid TcpServer::start(){\n    if (started_.getAndSet(1) == 0){\n    threadPool_->start(threadInitCallback_);\n\n    assert(!acceptor_->listening());\n    loop_->runInLoop(\n        std::bind(&Acceptor::listen, get_pointer(acceptor_)));  // get_pointer(acceptor_)获取裸指针。\n    }\n}\n\nvoid TcpServer::newConnection(int sockfd, const InetAddress& peerAddr){\n    loop_->assertInLoopThread();\n    EventLoop* ioLoop = threadPool_->getNextLoop();\n    char buf[64];\n    snprintf(buf, sizeof buf, \"-%s#%d\", ipPort_.c_str(), nextConnId_);\n    ++nextConnId_;\n    string connName = name_ + buf;\n\n    LOG_INFO << \"TcpServer::newConnection [\" << name_\n            << \"] - new connection [\" << connName\n            << \"] from \" << peerAddr.toIpPort();\n    InetAddress localAddr(sockets::getLocalAddr(sockfd));\n    // FIXME poll with zero timeout to double confirm the new connection\n    // FIXME use make_shared if necessary\n    TcpConnectionPtr conn(new TcpConnection(ioLoop,\n                                            connName,\n                                            sockfd,\n                                            localAddr,\n                                            peerAddr));\n    connections_[connName] = conn;\n    conn->setConnectionCallback(connectionCallback_);\n    conn->setMessageCallback(messageCallback_);\n    conn->setWriteCompleteCallback(writeCompleteCallback_);\n    conn->setCloseCallback(\n        std::bind(&TcpServer::removeConnection, this, _1)); // FIXME: unsafe\n    ioLoop->runInLoop(std::bind(&TcpConnection::connectEstablished, conn));\n}\n\nvoid TcpServer::removeConnection(const TcpConnectionPtr& conn){\n    // FIXME: unsafe\n    loop_->runInLoop(std::bind(&TcpServer::removeConnectionInLoop, this, conn));    // 尽管conn是引用，bind包装后也会增加引用计数\n}\n\nvoid TcpServer::removeConnectionInLoop(const TcpConnectionPtr& conn){\n    loop_->assertInLoopThread();\n    LOG_INFO << \"TcpServer::removeConnectionInLoop [\" << name_\n            << \"] - connection \" << conn->name();\n    size_t n = connections_.erase(conn->name());\n    (void)n;\n    assert(n == 1);\n    EventLoop* ioLoop = conn->getLoop();\n    ioLoop->queueInLoop(\n        std::bind(&TcpConnection::connectDestroyed, conn));\n}\n```\n\n**这里简单备忘一下**\n\n连接建立的回调过程：\n\n1. base loop中listen套接字触发可读事件，调用Acceptor::handleRead函数处理事件（由Acceptor::acceptChannel_注册）\n\n2. 调用::accept接受连接并创建sockfd。将sockfd作为参数，调用Acceptor::newConnectionCallback_连接分发回调，也即TcpServer::newConnection（由TcpServer构造函数设置）\n\n3. 利用负载均衡算法，选择一个合适的ioloop，然后为连接拼接一个唯一的connect name，并用sockfd、ioloop等创建一个TcpConnection对象（智能指针），设置好回调。将 **<key : connect name, value : TcpConnection>** 作为TcpServer::connections_的一个记录（TcpConnection对象引用计数加一）。最后向ioloop的任务队列中添加一项回调任务：TcpConnection::connectEstablished，并将TcpConnection对象作为回调任务的参数。\n\n4. 执行TcpConnection::connectEstablished，连接建立。\n\n\n连接拆除的回调过程：\n\n1. 调用TcpConnection::closeCallback_回调，即TcpServer::removeConnection，传入TcpConnection对象（引用）作为参数。\n\n2. 向base loop任务队列添加一项回调任务：TcpServer::removeConnectionInLoop，传入TcpConnection对象（引用）作为参数。\n\n3. 执行TcpServer::removeConnectionInLoop：通过TcpConnection对象的name，在TcpServer::connections_上删除连接记录（智能指针引用计数减一），然后向TcpConnection对象的ioloop的任务队列添加一项回调任务：TcpConnection::connectDestroyed，同样以TcpConnection对象作为回调任务的参数。\n\n**本章完结**","slug":"muduo/TcpServer","published":1,"updated":"2025-09-28T16:06:43.130Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9r000mq8wsbnlaectd","content":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>本章涉及的文件有：</p>\n<ol>\n<li><p>TcpServer.h&#x2F;cc：一个主从Reactor模型的TcpServer，主EventLoop接收连接，并且将连接sock fd负载均衡分发给一个IOLoop。</p>\n</li>\n<li><p>Acceptor.h&#x2F;cc：一个监听套接字的包装器，内部创建了一个Channel管理连接套接字的回调。</p>\n</li>\n<li><p>Socket.h&#x2F;cc：封装原生socket，提供绑定、监听、接受连接、设置socket属性等接口。</p>\n</li>\n<li><p>SocketsOps.h&#x2F;cc：Socket.h&#x2F;cc接口的底层实现，在创建套接字（::socket()&#x2F;::accept()）时，会将socketfd设置为非阻塞。</p>\n</li>\n<li><p>InetAddress.h&#x2F;cc：对sockaddr_in&#x2F;sockaddr_in6网络地址进行封装，使其更方便使用。</p>\n</li>\n</ol>\n<p>本章重点集中在1、2，对于3、4、5，见名知意即可，感兴趣的读者，可以自行深入阅读。</p>\n<h2 id=\"Acceptor的实现\"><a href=\"#Acceptor的实现\" class=\"headerlink\" title=\"Acceptor的实现\"></a>Acceptor的实现</h2><p><strong>提供的接口：</strong></p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// Acceptor of incoming TCP connections.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Acceptor</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> (<span class=\"type\">int</span> sockfd, <span class=\"type\">const</span> InetAddress&amp;)&gt; NewConnectionCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Acceptor</span>(EventLoop* loop, <span class=\"type\">const</span> InetAddress&amp; listenAddr, <span class=\"type\">bool</span> reuseport);</span><br><span class=\"line\">    ~<span class=\"built_in\">Acceptor</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setNewConnectionCallback</span><span class=\"params\">(<span class=\"type\">const</span> NewConnectionCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; newConnectionCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">listen</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">listening</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> listening_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Deprecated, use the correct spelling one above.</span></span><br><span class=\"line\">    <span class=\"comment\">// Leave the wrong spelling here in case one needs to grep it for error messages.</span></span><br><span class=\"line\">    <span class=\"comment\">// bool listenning() const &#123; return listening(); &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// 绑定在哪个EventLoop上</span></span><br><span class=\"line\">    Socket acceptSocket_; <span class=\"comment\">// accept sock fd</span></span><br><span class=\"line\">    Channel acceptChannel_; <span class=\"comment\">// 对accept sock fd channel的封装</span></span><br><span class=\"line\">    NewConnectionCallback newConnectionCallback_;   <span class=\"comment\">// 连接sock fd分发器</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> listening_;  <span class=\"comment\">// accept sock fd已经listen？</span></span><br><span class=\"line\">    <span class=\"type\">int</span> idleFd_;  <span class=\"comment\">// 预留一个fd，以免文件描述符消耗完毕，无法继续处理连接。</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其实从成员变量就可以看出来，Acceptor和TimeQueue有着及其相似的地方。</p>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Acceptor::<span class=\"built_in\">Acceptor</span>(EventLoop* loop, <span class=\"type\">const</span> InetAddress&amp; listenAddr, <span class=\"type\">bool</span> reuseport)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(loop),</span><br><span class=\"line\">    <span class=\"built_in\">acceptSocket_</span>(sockets::<span class=\"built_in\">createNonblockingOrDie</span>(listenAddr.<span class=\"built_in\">family</span>())),</span><br><span class=\"line\">    <span class=\"built_in\">acceptChannel_</span>(loop, acceptSocket_.<span class=\"built_in\">fd</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">listening_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">idleFd_</span>(::<span class=\"built_in\">open</span>(<span class=\"string\">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(idleFd_ &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">setReuseAddr</span>(<span class=\"literal\">true</span>);       <span class=\"comment\">// 地址重用</span></span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">setReusePort</span>(reuseport);  <span class=\"comment\">// 端口重用</span></span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">bindAddress</span>(listenAddr);  <span class=\"comment\">// 地址绑定</span></span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">setReadCallback</span>(         <span class=\"comment\">// 设置回调</span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Acceptor::handleRead, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Acceptor::~<span class=\"built_in\">Acceptor</span>()&#123;</span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    ::<span class=\"built_in\">close</span>(idleFd_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Acceptor::listen</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    listening_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">listen</span>(); <span class=\"comment\">// sock fd 开始listen</span></span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">enableReading</span>(); <span class=\"comment\">// 向Poller注册sock fd</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Acceptor::handleRead</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    InetAddress peerAddr;</span><br><span class=\"line\">    <span class=\"comment\">//FIXME loop until no more</span></span><br><span class=\"line\">    <span class=\"type\">int</span> connfd = acceptSocket_.<span class=\"built_in\">accept</span>(&amp;peerAddr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connfd &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// string hostport = peerAddr.toIpPort();</span></span><br><span class=\"line\">        <span class=\"comment\">// LOG_TRACE &lt;&lt; &quot;Accepts of &quot; &lt;&lt; hostport;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newConnectionCallback_)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">newConnectionCallback_</span>(connfd, peerAddr);   <span class=\"comment\">// 连接分发器</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            sockets::<span class=\"built_in\">close</span>(connfd);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;in Acceptor::handleRead&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Read the section named &quot;The special problem of</span></span><br><span class=\"line\">        <span class=\"comment\">// accept()ing when you can&#x27;t&quot; in libev&#x27;s doc.</span></span><br><span class=\"line\">        <span class=\"comment\">// By Marc Lehmann, author of libev.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EMFILE) &#123; <span class=\"comment\">// 超过文件描述符最大限制</span></span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(idleFd_);   <span class=\"comment\">// 归还预留的idleFd_，利用idleFd_来接收连接</span></span><br><span class=\"line\">            idleFd_ = ::<span class=\"built_in\">accept</span>(acceptSocket_.<span class=\"built_in\">fd</span>(), <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>); <span class=\"comment\">// 接受连接</span></span><br><span class=\"line\">            <span class=\"comment\">// 什么也不做就关闭连接。</span></span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(idleFd_);</span><br><span class=\"line\">            idleFd_ = ::<span class=\"built_in\">open</span>(<span class=\"string\">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);    <span class=\"comment\">// 继续预留fd。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"细节明细：\"><a href=\"#细节明细：\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h3><p><strong>疑问</strong></p>\n<p>Acceptor::idleFd_成员变量存在的意义？Acceptor::handleRead函数中为什么出现EMFILE错误时，关闭idleFd_，::accept接受连接，又关闭idleFd_，又打开idleFd_？</p>\n<p><strong>解答</strong></p>\n<p>出现EMFILE错误，关闭 idleFd_ 后，执行 ::accept 操作，通常情况下这个操作并不会失败。这是因为在 ::accept 函数成功返回时，会返回一个值和关闭idleFd_前值相同的连接文件描述符，这个文件描述符会被用于处理新连接。这里主要目的是消耗一个连接，尽管什么也不做。但可以确保服务器能够继续正常运行。</p>\n<h2 id=\"TcpServer的实现\"><a href=\"#TcpServer的实现\" class=\"headerlink\" title=\"TcpServer的实现\"></a>TcpServer的实现</h2><p><strong>提供的接口：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// TCP server, supports single-threaded and thread-pool models.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// This is an interface class, so don&#x27;t expose too much details.</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TcpServer</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(EventLoop*)&gt; ThreadInitCallback;</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"title class_\">Option</span>&#123;</span><br><span class=\"line\">        kNoReusePort,</span><br><span class=\"line\">        kReusePort,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">TcpServer</span>(EventLoop* loop,</span><br><span class=\"line\">            <span class=\"type\">const</span> InetAddress&amp; listenAddr,</span><br><span class=\"line\">            <span class=\"type\">const</span> string&amp; nameArg,</span><br><span class=\"line\">            Option option = kNoReusePort);</span><br><span class=\"line\">    ~<span class=\"built_in\">TcpServer</span>();  <span class=\"comment\">// force out-line dtor, for std::unique_ptr members.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">ipPort</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> ipPort_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getLoop</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> loop_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 必须再start前调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadNum</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadInitCallback</span><span class=\"params\">(<span class=\"type\">const</span> ThreadInitCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; threadInitCallback_ = cb; &#125;</span><br><span class=\"line\">    <span class=\"comment\">/// valid after calling start()</span></span><br><span class=\"line\">    <span class=\"function\">std::shared_ptr&lt;EventLoopThreadPool&gt; <span class=\"title\">threadPool</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> threadPool_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Starts the server if it&#x27;s not listening.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// It&#x27;s harmless to call it multiple times.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set connection callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setConnectionCallback</span><span class=\"params\">(<span class=\"type\">const</span> ConnectionCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; connectionCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set message callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setMessageCallback</span><span class=\"params\">(<span class=\"type\">const</span> MessageCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; messageCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set write complete callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWriteCompleteCallback</span><span class=\"params\">(<span class=\"type\">const</span> WriteCompleteCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; writeCompleteCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">const</span> InetAddress&amp; peerAddr)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeConnectionInLoop</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::map&lt;string, TcpConnectionPtr&gt; ConnectionMap;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_;  <span class=\"comment\">// the acceptor loop</span></span><br><span class=\"line\">    <span class=\"type\">const</span> string ipPort_; <span class=\"comment\">// ip:port</span></span><br><span class=\"line\">    <span class=\"type\">const</span> string name_; <span class=\"comment\">// TcpServer Name</span></span><br><span class=\"line\">    std::unique_ptr&lt;Acceptor&gt; acceptor_; <span class=\"comment\">// avoid revealing Acceptor</span></span><br><span class=\"line\">    std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_; <span class=\"comment\">// 线程池</span></span><br><span class=\"line\">    ConnectionCallback connectionCallback_; <span class=\"comment\">// 连接建立和断开回调</span></span><br><span class=\"line\">    MessageCallback messageCallback_;   <span class=\"comment\">// 读数据回调</span></span><br><span class=\"line\">    WriteCompleteCallback writeCompleteCallback_;   <span class=\"comment\">// 数据发送完毕的回调</span></span><br><span class=\"line\">    ThreadInitCallback threadInitCallback_;</span><br><span class=\"line\">    AtomicInt32 started_; <span class=\"comment\">// TcpServer启动了？</span></span><br><span class=\"line\">    <span class=\"comment\">// always in loop thread</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nextConnId_;  <span class=\"comment\">// 连接计数器</span></span><br><span class=\"line\">    ConnectionMap connections_; <span class=\"comment\">// 连接信息维护</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>简单画了一下TcpServer整体架构图：</p>\n<p><img src=\"/2024/11/02/muduo/TcpServer/photo/TcpServer.drawio.png\" alt=\"TcpServer\"></p>\n<p>整体流程就是：</p>\n<ol>\n<li><p>客户端发送连接请求。</p>\n</li>\n<li><p>listen套接字所在的EventLoop（假设为base loop）接受连接请求并创建io套接字。</p>\n</li>\n<li><p>base loop 通过EventLoopThreadPool的负载均衡算法选择一个io EventLoop，将io套接字传给该loop。</p>\n</li>\n<li><p>客户端和指定的loop进行TCP通信。</p>\n</li>\n</ol>\n<hr>\n<p><strong>实现伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">TcpServer::<span class=\"built_in\">TcpServer</span>(EventLoop* loop,</span><br><span class=\"line\">                     <span class=\"type\">const</span> InetAddress&amp; listenAddr,</span><br><span class=\"line\">                     <span class=\"type\">const</span> string&amp; nameArg,</span><br><span class=\"line\">                     Option option)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"built_in\">CHECK_NOTNULL</span>(loop)),</span><br><span class=\"line\">    <span class=\"built_in\">ipPort_</span>(listenAddr.<span class=\"built_in\">toIpPort</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">acceptor_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Acceptor</span>(loop, listenAddr, option == kReusePort)),</span><br><span class=\"line\">    <span class=\"built_in\">threadPool_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">EventLoopThreadPool</span>(loop, name_)),</span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(defaultConnectionCallback),</span><br><span class=\"line\">    <span class=\"built_in\">messageCallback_</span>(defaultMessageCallback),</span><br><span class=\"line\">    <span class=\"built_in\">nextConnId_</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    acceptor_-&gt;<span class=\"built_in\">setNewConnectionCallback</span>(    <span class=\"comment\">// 设定连接分发器</span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpServer::newConnection, <span class=\"keyword\">this</span>, _1, _2));    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TcpServer::~<span class=\"built_in\">TcpServer</span>()&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;TcpServer::~TcpServer [&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;] destructing&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; item : connections_)&#123;</span><br><span class=\"line\">        <span class=\"function\">TcpConnectionPtr <span class=\"title\">conn</span><span class=\"params\">(item.second)</span></span>;</span><br><span class=\"line\">        item.second.<span class=\"built_in\">reset</span>();    <span class=\"comment\">// 释放引用计数</span></span><br><span class=\"line\">        conn-&gt;<span class=\"built_in\">getLoop</span>()-&gt;<span class=\"built_in\">runInLoop</span>( <span class=\"comment\">// 在自己的loop中执行连接销毁。</span></span><br><span class=\"line\">            std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在start前调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::setThreadNum</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"number\">0</span> &lt;= numThreads);</span><br><span class=\"line\">    threadPool_-&gt;<span class=\"built_in\">setThreadNum</span>(numThreads);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (started_.<span class=\"built_in\">getAndSet</span>(<span class=\"number\">1</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    threadPool_-&gt;<span class=\"built_in\">start</span>(threadInitCallback_);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!acceptor_-&gt;<span class=\"built_in\">listening</span>());</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Acceptor::listen, <span class=\"built_in\">get_pointer</span>(acceptor_)));  <span class=\"comment\">// get_pointer(acceptor_)获取裸指针。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">const</span> InetAddress&amp; peerAddr)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    EventLoop* ioLoop = threadPool_-&gt;<span class=\"built_in\">getNextLoop</span>();</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;-%s#%d&quot;</span>, ipPort_.<span class=\"built_in\">c_str</span>(), nextConnId_);</span><br><span class=\"line\">    ++nextConnId_;</span><br><span class=\"line\">    string connName = name_ + buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpServer::newConnection [&quot;</span> &lt;&lt; name_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] - new connection [&quot;</span> &lt;&lt; connName</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] from &quot;</span> &lt;&lt; peerAddr.<span class=\"built_in\">toIpPort</span>();</span><br><span class=\"line\">    <span class=\"function\">InetAddress <span class=\"title\">localAddr</span><span class=\"params\">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class=\"line\">    <span class=\"comment\">// FIXME use make_shared if necessary</span></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">conn</span><span class=\"params\">(<span class=\"keyword\">new</span> TcpConnection(ioLoop,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            connName,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            sockfd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            localAddr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            peerAddr))</span></span>;</span><br><span class=\"line\">    connections_[connName] = conn;</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setConnectionCallback</span>(connectionCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setMessageCallback</span>(messageCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setCloseCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpServer::removeConnection, <span class=\"keyword\">this</span>, _1)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    ioLoop-&gt;<span class=\"built_in\">runInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class=\"keyword\">this</span>, conn));    <span class=\"comment\">// 尽管conn是引用，bind包装后也会增加引用计数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::removeConnectionInLoop</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpServer::removeConnectionInLoop [&quot;</span> &lt;&lt; name_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] - connection &quot;</span> &lt;&lt; conn-&gt;<span class=\"built_in\">name</span>();</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = connections_.<span class=\"built_in\">erase</span>(conn-&gt;<span class=\"built_in\">name</span>());</span><br><span class=\"line\">    (<span class=\"type\">void</span>)n;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(n == <span class=\"number\">1</span>);</span><br><span class=\"line\">    EventLoop* ioLoop = conn-&gt;<span class=\"built_in\">getLoop</span>();</span><br><span class=\"line\">    ioLoop-&gt;<span class=\"built_in\">queueInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>这里简单备忘一下</strong></p>\n<p>连接建立的回调过程：</p>\n<ol>\n<li><p>base loop中listen套接字触发可读事件，调用Acceptor::handleRead函数处理事件（由Acceptor::acceptChannel_注册）</p>\n</li>\n<li><p>调用::accept接受连接并创建sockfd。将sockfd作为参数，调用Acceptor::newConnectionCallback_连接分发回调，也即TcpServer::newConnection（由TcpServer构造函数设置）</p>\n</li>\n<li><p>利用负载均衡算法，选择一个合适的ioloop，然后为连接拼接一个唯一的connect name，并用sockfd、ioloop等创建一个TcpConnection对象（智能指针），设置好回调。将 <strong>&lt;key : connect name, value : TcpConnection&gt;</strong> 作为TcpServer::connections_的一个记录（TcpConnection对象引用计数加一）。最后向ioloop的任务队列中添加一项回调任务：TcpConnection::connectEstablished，并将TcpConnection对象作为回调任务的参数。</p>\n</li>\n<li><p>执行TcpConnection::connectEstablished，连接建立。</p>\n</li>\n</ol>\n<p>连接拆除的回调过程：</p>\n<ol>\n<li><p>调用TcpConnection::closeCallback_回调，即TcpServer::removeConnection，传入TcpConnection对象（引用）作为参数。</p>\n</li>\n<li><p>向base loop任务队列添加一项回调任务：TcpServer::removeConnectionInLoop，传入TcpConnection对象（引用）作为参数。</p>\n</li>\n<li><p>执行TcpServer::removeConnectionInLoop：通过TcpConnection对象的name，在TcpServer::connections_上删除连接记录（智能指针引用计数减一），然后向TcpConnection对象的ioloop的任务队列添加一项回调任务：TcpConnection::connectDestroyed，同样以TcpConnection对象作为回调任务的参数。</p>\n</li>\n</ol>\n<p><strong>本章完结</strong></p>\n","excerpt":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>本章涉及的文件有：</p>\n<ol>\n<li><p>TcpServer.h&#x2F;cc：一个主从Reactor模型的TcpServer，主EventLoop接收连接，并且将连接sock fd负载均衡分发给一个IOLoop。</p>\n</li>\n<li><p>Acceptor.h&#x2F;cc：一个监听套接字的包装器，内部创建了一个Channel管理连接套接字的回调。</p>\n</li>\n<li><p>Socket.h&#x2F;cc：封装原生socket，提供绑定、监听、接受连接、设置socket属性等接口。</p>\n</li>\n<li><p>SocketsOps.h&#x2F;cc：Socket.h&#x2F;cc接口的底层实现，在创建套接字（::socket()&#x2F;::accept()）时，会将socketfd设置为非阻塞。</p>\n</li>\n<li><p>InetAddress.h&#x2F;cc：对sockaddr_in&#x2F;sockaddr_in6网络地址进行封装，使其更方便使用。</p>\n</li>\n</ol>\n<p>本章重点集中在1、2，对于3、4、5，见名知意即可，感兴趣的读者，可以自行深入阅读。</p>\n<h2 id=\"Acceptor的实现\"><a href=\"#Acceptor的实现\" class=\"headerlink\" title=\"Acceptor的实现\"></a>Acceptor的实现</h2><p><strong>提供的接口：</strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// Acceptor of incoming TCP connections.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Acceptor</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> (<span class=\"type\">int</span> sockfd, <span class=\"type\">const</span> InetAddress&amp;)&gt; NewConnectionCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Acceptor</span>(EventLoop* loop, <span class=\"type\">const</span> InetAddress&amp; listenAddr, <span class=\"type\">bool</span> reuseport);</span><br><span class=\"line\">    ~<span class=\"built_in\">Acceptor</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setNewConnectionCallback</span><span class=\"params\">(<span class=\"type\">const</span> NewConnectionCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; newConnectionCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">listen</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">listening</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> listening_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Deprecated, use the correct spelling one above.</span></span><br><span class=\"line\">    <span class=\"comment\">// Leave the wrong spelling here in case one needs to grep it for error messages.</span></span><br><span class=\"line\">    <span class=\"comment\">// bool listenning() const &#123; return listening(); &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// 绑定在哪个EventLoop上</span></span><br><span class=\"line\">    Socket acceptSocket_; <span class=\"comment\">// accept sock fd</span></span><br><span class=\"line\">    Channel acceptChannel_; <span class=\"comment\">// 对accept sock fd channel的封装</span></span><br><span class=\"line\">    NewConnectionCallback newConnectionCallback_;   <span class=\"comment\">// 连接sock fd分发器</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> listening_;  <span class=\"comment\">// accept sock fd已经listen？</span></span><br><span class=\"line\">    <span class=\"type\">int</span> idleFd_;  <span class=\"comment\">// 预留一个fd，以免文件描述符消耗完毕，无法继续处理连接。</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其实从成员变量就可以看出来，Acceptor和TimeQueue有着及其相似的地方。</p>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Acceptor::<span class=\"built_in\">Acceptor</span>(EventLoop* loop, <span class=\"type\">const</span> InetAddress&amp; listenAddr, <span class=\"type\">bool</span> reuseport)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(loop),</span><br><span class=\"line\">    <span class=\"built_in\">acceptSocket_</span>(sockets::<span class=\"built_in\">createNonblockingOrDie</span>(listenAddr.<span class=\"built_in\">family</span>())),</span><br><span class=\"line\">    <span class=\"built_in\">acceptChannel_</span>(loop, acceptSocket_.<span class=\"built_in\">fd</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">listening_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">idleFd_</span>(::<span class=\"built_in\">open</span>(<span class=\"string\">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(idleFd_ &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">setReuseAddr</span>(<span class=\"literal\">true</span>);       <span class=\"comment\">// 地址重用</span></span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">setReusePort</span>(reuseport);  <span class=\"comment\">// 端口重用</span></span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">bindAddress</span>(listenAddr);  <span class=\"comment\">// 地址绑定</span></span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">setReadCallback</span>(         <span class=\"comment\">// 设置回调</span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Acceptor::handleRead, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Acceptor::~<span class=\"built_in\">Acceptor</span>()&#123;</span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    ::<span class=\"built_in\">close</span>(idleFd_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Acceptor::listen</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    listening_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">listen</span>(); <span class=\"comment\">// sock fd 开始listen</span></span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">enableReading</span>(); <span class=\"comment\">// 向Poller注册sock fd</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Acceptor::handleRead</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    InetAddress peerAddr;</span><br><span class=\"line\">    <span class=\"comment\">//FIXME loop until no more</span></span><br><span class=\"line\">    <span class=\"type\">int</span> connfd = acceptSocket_.<span class=\"built_in\">accept</span>(&amp;peerAddr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connfd &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// string hostport = peerAddr.toIpPort();</span></span><br><span class=\"line\">        <span class=\"comment\">// LOG_TRACE &lt;&lt; &quot;Accepts of &quot; &lt;&lt; hostport;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newConnectionCallback_)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">newConnectionCallback_</span>(connfd, peerAddr);   <span class=\"comment\">// 连接分发器</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            sockets::<span class=\"built_in\">close</span>(connfd);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;in Acceptor::handleRead&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Read the section named &quot;The special problem of</span></span><br><span class=\"line\">        <span class=\"comment\">// accept()ing when you can&#x27;t&quot; in libev&#x27;s doc.</span></span><br><span class=\"line\">        <span class=\"comment\">// By Marc Lehmann, author of libev.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EMFILE) &#123; <span class=\"comment\">// 超过文件描述符最大限制</span></span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(idleFd_);   <span class=\"comment\">// 归还预留的idleFd_，利用idleFd_来接收连接</span></span><br><span class=\"line\">            idleFd_ = ::<span class=\"built_in\">accept</span>(acceptSocket_.<span class=\"built_in\">fd</span>(), <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>); <span class=\"comment\">// 接受连接</span></span><br><span class=\"line\">            <span class=\"comment\">// 什么也不做就关闭连接。</span></span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(idleFd_);</span><br><span class=\"line\">            idleFd_ = ::<span class=\"built_in\">open</span>(<span class=\"string\">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);    <span class=\"comment\">// 继续预留fd。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"细节明细：\"><a href=\"#细节明细：\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h3><p><strong>疑问</strong></p>\n<p>Acceptor::idleFd_成员变量存在的意义？Acceptor::handleRead函数中为什么出现EMFILE错误时，关闭idleFd_，::accept接受连接，又关闭idleFd_，又打开idleFd_？</p>\n<p><strong>解答</strong></p>\n<p>出现EMFILE错误，关闭 idleFd_ 后，执行 ::accept 操作，通常情况下这个操作并不会失败。这是因为在 ::accept 函数成功返回时，会返回一个值和关闭idleFd_前值相同的连接文件描述符，这个文件描述符会被用于处理新连接。这里主要目的是消耗一个连接，尽管什么也不做。但可以确保服务器能够继续正常运行。</p>\n<h2 id=\"TcpServer的实现\"><a href=\"#TcpServer的实现\" class=\"headerlink\" title=\"TcpServer的实现\"></a>TcpServer的实现</h2><p><strong>提供的接口：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// TCP server, supports single-threaded and thread-pool models.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// This is an interface class, so don&#x27;t expose too much details.</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TcpServer</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(EventLoop*)&gt; ThreadInitCallback;</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"title class_\">Option</span>&#123;</span><br><span class=\"line\">        kNoReusePort,</span><br><span class=\"line\">        kReusePort,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">TcpServer</span>(EventLoop* loop,</span><br><span class=\"line\">            <span class=\"type\">const</span> InetAddress&amp; listenAddr,</span><br><span class=\"line\">            <span class=\"type\">const</span> string&amp; nameArg,</span><br><span class=\"line\">            Option option = kNoReusePort);</span><br><span class=\"line\">    ~<span class=\"built_in\">TcpServer</span>();  <span class=\"comment\">// force out-line dtor, for std::unique_ptr members.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">ipPort</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> ipPort_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getLoop</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> loop_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 必须再start前调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadNum</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadInitCallback</span><span class=\"params\">(<span class=\"type\">const</span> ThreadInitCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; threadInitCallback_ = cb; &#125;</span><br><span class=\"line\">    <span class=\"comment\">/// valid after calling start()</span></span><br><span class=\"line\">    <span class=\"function\">std::shared_ptr&lt;EventLoopThreadPool&gt; <span class=\"title\">threadPool</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> threadPool_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Starts the server if it&#x27;s not listening.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// It&#x27;s harmless to call it multiple times.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set connection callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setConnectionCallback</span><span class=\"params\">(<span class=\"type\">const</span> ConnectionCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; connectionCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set message callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setMessageCallback</span><span class=\"params\">(<span class=\"type\">const</span> MessageCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; messageCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set write complete callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWriteCompleteCallback</span><span class=\"params\">(<span class=\"type\">const</span> WriteCompleteCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; writeCompleteCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">const</span> InetAddress&amp; peerAddr)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeConnectionInLoop</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::map&lt;string, TcpConnectionPtr&gt; ConnectionMap;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_;  <span class=\"comment\">// the acceptor loop</span></span><br><span class=\"line\">    <span class=\"type\">const</span> string ipPort_; <span class=\"comment\">// ip:port</span></span><br><span class=\"line\">    <span class=\"type\">const</span> string name_; <span class=\"comment\">// TcpServer Name</span></span><br><span class=\"line\">    std::unique_ptr&lt;Acceptor&gt; acceptor_; <span class=\"comment\">// avoid revealing Acceptor</span></span><br><span class=\"line\">    std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_; <span class=\"comment\">// 线程池</span></span><br><span class=\"line\">    ConnectionCallback connectionCallback_; <span class=\"comment\">// 连接建立和断开回调</span></span><br><span class=\"line\">    MessageCallback messageCallback_;   <span class=\"comment\">// 读数据回调</span></span><br><span class=\"line\">    WriteCompleteCallback writeCompleteCallback_;   <span class=\"comment\">// 数据发送完毕的回调</span></span><br><span class=\"line\">    ThreadInitCallback threadInitCallback_;</span><br><span class=\"line\">    AtomicInt32 started_; <span class=\"comment\">// TcpServer启动了？</span></span><br><span class=\"line\">    <span class=\"comment\">// always in loop thread</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nextConnId_;  <span class=\"comment\">// 连接计数器</span></span><br><span class=\"line\">    ConnectionMap connections_; <span class=\"comment\">// 连接信息维护</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>简单画了一下TcpServer整体架构图：</p>\n<p><img src=\"/2024/11/02/muduo/TcpServer/photo/TcpServer.drawio.png\" alt=\"TcpServer\"></p>\n<p>整体流程就是：</p>\n<ol>\n<li><p>客户端发送连接请求。</p>\n</li>\n<li><p>listen套接字所在的EventLoop（假设为base loop）接受连接请求并创建io套接字。</p>\n</li>\n<li><p>base loop 通过EventLoopThreadPool的负载均衡算法选择一个io EventLoop，将io套接字传给该loop。</p>\n</li>\n<li><p>客户端和指定的loop进行TCP通信。</p>\n</li>\n</ol>\n<hr>\n<p><strong>实现伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">TcpServer::<span class=\"built_in\">TcpServer</span>(EventLoop* loop,</span><br><span class=\"line\">                     <span class=\"type\">const</span> InetAddress&amp; listenAddr,</span><br><span class=\"line\">                     <span class=\"type\">const</span> string&amp; nameArg,</span><br><span class=\"line\">                     Option option)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"built_in\">CHECK_NOTNULL</span>(loop)),</span><br><span class=\"line\">    <span class=\"built_in\">ipPort_</span>(listenAddr.<span class=\"built_in\">toIpPort</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">acceptor_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Acceptor</span>(loop, listenAddr, option == kReusePort)),</span><br><span class=\"line\">    <span class=\"built_in\">threadPool_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">EventLoopThreadPool</span>(loop, name_)),</span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(defaultConnectionCallback),</span><br><span class=\"line\">    <span class=\"built_in\">messageCallback_</span>(defaultMessageCallback),</span><br><span class=\"line\">    <span class=\"built_in\">nextConnId_</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    acceptor_-&gt;<span class=\"built_in\">setNewConnectionCallback</span>(    <span class=\"comment\">// 设定连接分发器</span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpServer::newConnection, <span class=\"keyword\">this</span>, _1, _2));    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TcpServer::~<span class=\"built_in\">TcpServer</span>()&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;TcpServer::~TcpServer [&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;] destructing&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; item : connections_)&#123;</span><br><span class=\"line\">        <span class=\"function\">TcpConnectionPtr <span class=\"title\">conn</span><span class=\"params\">(item.second)</span></span>;</span><br><span class=\"line\">        item.second.<span class=\"built_in\">reset</span>();    <span class=\"comment\">// 释放引用计数</span></span><br><span class=\"line\">        conn-&gt;<span class=\"built_in\">getLoop</span>()-&gt;<span class=\"built_in\">runInLoop</span>( <span class=\"comment\">// 在自己的loop中执行连接销毁。</span></span><br><span class=\"line\">            std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在start前调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::setThreadNum</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"number\">0</span> &lt;= numThreads);</span><br><span class=\"line\">    threadPool_-&gt;<span class=\"built_in\">setThreadNum</span>(numThreads);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (started_.<span class=\"built_in\">getAndSet</span>(<span class=\"number\">1</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    threadPool_-&gt;<span class=\"built_in\">start</span>(threadInitCallback_);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!acceptor_-&gt;<span class=\"built_in\">listening</span>());</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Acceptor::listen, <span class=\"built_in\">get_pointer</span>(acceptor_)));  <span class=\"comment\">// get_pointer(acceptor_)获取裸指针。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">const</span> InetAddress&amp; peerAddr)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    EventLoop* ioLoop = threadPool_-&gt;<span class=\"built_in\">getNextLoop</span>();</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;-%s#%d&quot;</span>, ipPort_.<span class=\"built_in\">c_str</span>(), nextConnId_);</span><br><span class=\"line\">    ++nextConnId_;</span><br><span class=\"line\">    string connName = name_ + buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpServer::newConnection [&quot;</span> &lt;&lt; name_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] - new connection [&quot;</span> &lt;&lt; connName</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] from &quot;</span> &lt;&lt; peerAddr.<span class=\"built_in\">toIpPort</span>();</span><br><span class=\"line\">    <span class=\"function\">InetAddress <span class=\"title\">localAddr</span><span class=\"params\">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class=\"line\">    <span class=\"comment\">// FIXME use make_shared if necessary</span></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">conn</span><span class=\"params\">(<span class=\"keyword\">new</span> TcpConnection(ioLoop,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            connName,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            sockfd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            localAddr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            peerAddr))</span></span>;</span><br><span class=\"line\">    connections_[connName] = conn;</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setConnectionCallback</span>(connectionCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setMessageCallback</span>(messageCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setCloseCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpServer::removeConnection, <span class=\"keyword\">this</span>, _1)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    ioLoop-&gt;<span class=\"built_in\">runInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class=\"keyword\">this</span>, conn));    <span class=\"comment\">// 尽管conn是引用，bind包装后也会增加引用计数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::removeConnectionInLoop</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpServer::removeConnectionInLoop [&quot;</span> &lt;&lt; name_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] - connection &quot;</span> &lt;&lt; conn-&gt;<span class=\"built_in\">name</span>();</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = connections_.<span class=\"built_in\">erase</span>(conn-&gt;<span class=\"built_in\">name</span>());</span><br><span class=\"line\">    (<span class=\"type\">void</span>)n;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(n == <span class=\"number\">1</span>);</span><br><span class=\"line\">    EventLoop* ioLoop = conn-&gt;<span class=\"built_in\">getLoop</span>();</span><br><span class=\"line\">    ioLoop-&gt;<span class=\"built_in\">queueInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>这里简单备忘一下</strong></p>\n<p>连接建立的回调过程：</p>\n<ol>\n<li><p>base loop中listen套接字触发可读事件，调用Acceptor::handleRead函数处理事件（由Acceptor::acceptChannel_注册）</p>\n</li>\n<li><p>调用::accept接受连接并创建sockfd。将sockfd作为参数，调用Acceptor::newConnectionCallback_连接分发回调，也即TcpServer::newConnection（由TcpServer构造函数设置）</p>\n</li>\n<li><p>利用负载均衡算法，选择一个合适的ioloop，然后为连接拼接一个唯一的connect name，并用sockfd、ioloop等创建一个TcpConnection对象（智能指针），设置好回调。将 <strong>&lt;key : connect name, value : TcpConnection&gt;</strong> 作为TcpServer::connections_的一个记录（TcpConnection对象引用计数加一）。最后向ioloop的任务队列中添加一项回调任务：TcpConnection::connectEstablished，并将TcpConnection对象作为回调任务的参数。</p>\n</li>\n<li><p>执行TcpConnection::connectEstablished，连接建立。</p>\n</li>\n</ol>\n<p>连接拆除的回调过程：</p>\n<ol>\n<li><p>调用TcpConnection::closeCallback_回调，即TcpServer::removeConnection，传入TcpConnection对象（引用）作为参数。</p>\n</li>\n<li><p>向base loop任务队列添加一项回调任务：TcpServer::removeConnectionInLoop，传入TcpConnection对象（引用）作为参数。</p>\n</li>\n<li><p>执行TcpServer::removeConnectionInLoop：通过TcpConnection对象的name，在TcpServer::connections_上删除连接记录（智能指针引用计数减一），然后向TcpConnection对象的ioloop的任务队列添加一项回调任务：TcpConnection::connectDestroyed，同样以TcpConnection对象作为回调任务的参数。</p>\n</li>\n</ol>\n<p><strong>本章完结</strong></p>"},{"title":"muduo源码阅读笔记（3、线程和线程池的封装）","date":"2024-11-02T04:00:00.000Z","_content":"\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**闲聊**\n\nMuduo对线程和线程池的封装，涉及得到源码也不多，大概加一起300多行，这部分读者可以好好精读一下。\n\n## 线程\n\n在阅读cpp的源码，分析一个类具体的实现的时候，首先应该看类的.h文件，主要看类的成员变量有哪些，毕竟成员函数，就是对成员变量进行代码层面的操作的。\n\n**提供的接口：**\n\n<!-- more -->\n```cpp\nclass Thread : noncopyable {\npublic:\n    typedef std::function<void ()> ThreadFunc;\n\n    explicit Thread(ThreadFunc, const string& name = string());\n    // FIXME: make it movable in C++11\n    ~Thread();\n\n    void start();\n    int join(); // return pthread_join()\n\n    bool started() const { return started_; }\n    // pthread_t pthreadId() const { return pthreadId_; }\n    pid_t tid() const { return tid_; }\n    const string& name() const { return name_; }\n\n    static int numCreated() { return numCreated_.get(); }\n\nprivate:\n    void setDefaultName();\n\n    bool       started_;    // 线程正在运行？\n    bool       joined_;     // 有其他线程对该线程join？\n    pthread_t  pthreadId_;  // Posix中的线程id\n    pid_t      tid_;        // 线程真实的id（进程id）\n    ThreadFunc func_;       // 线程回调函数\n    string     name_;       // 线程名\n    CountDownLatch latch_;  // 在父线程继续运行前，确保创建的子线程正在运行\n\n    static AtomicInt32 numCreated_; // 对已经创建的线程计个数，所有线程对象共享的变量，线程默认名可能会用到\n};\n```\n\n**线程启动流程：**\n\n1. Thread::start()  -> \n\n    2. pthread_create(..., &detail::startThread,...)    -> \n\n        3. startThread(void* obj)   ->\n\n            4. ThreadData::runInThread()    -> \n\n                5. Thread::func_()\n\n**实现的伪代码：**\n\n```cpp\n\nstruct ThreadData {\n    typedef muduo::Thread::ThreadFunc ThreadFunc;\n    ThreadFunc func_;\n    string name_;\n    pid_t* tid_;\n    CountDownLatch* latch_;\n\n    ThreadData(ThreadFunc func,\n                const string& name,\n                pid_t* tid,\n                CountDownLatch* latch)\n    : func_(std::move(func)),\n        name_(name),\n        tid_(tid),\n        latch_(latch)\n    { }\n\n    void runInThread(){\n        *tid_ = muduo::CurrentThread::tid();  // 获取&&缓存tid，并赋值给Thread::tid_对象\n        tid_ = NULL;  // 取消对Thread::tid_的指向，保证安全\n        latch_->countDown();  // 倒计数器减为0（初始化为1），通知父线程，子线程启动完毕\n        latch_ = NULL;  // 取消对Thread::latch__的指向，保证安全\n\n        muduo::CurrentThread::t_threadName = name_.empty() ? \"muduoThread\" : name_.c_str(); // 将线程名赋值给线程全局变量\n        ::prctl(PR_SET_NAME, muduo::CurrentThread::t_threadName); // 设置真正的线程的进程名。\n        try{\n            func_();  // 真正开始执行Thread的回调函数\n            muduo::CurrentThread::t_threadName = \"finished\";\n        }\n        catch (...){\n            // 异常处理...\n        }\n    }\n};\n\n/*\n* pthread_create回调函数\n*/\nvoid* startThread(void* obj){\n    ThreadData* data = static_cast<ThreadData*>(obj);\n    data->runInThread();\n    delete data;\n    return NULL;\n}\n\nThread::Thread(ThreadFunc func, const string& n)\n  : started_(false),\n    joined_(false),\n    pthreadId_(0),\n    tid_(0),\n    func_(std::move(func)),\n    name_(n),\n    latch_(1){\n    setDefaultName();\n}\n\nThread::~Thread(){\n    /*\n    * 如果线程启动了并且没有任何线程join过该线程，就调用pthread_detach将该线程分\n    * 离，接触父子关系，让该线程自生自灭。\n    */\n    if (started_ && !joined_){\n        pthread_detach(pthreadId_);\n    }\n}\n\nvoid Thread::setDefaultName(){\n    int num = numCreated_.incrementAndGet();  // 原子自增\n    if (name_.empty()){  // 如果用户没有设置name\n        char buf[32];\n        snprintf(buf, sizeof buf, \"Thread%d\", num); // 利用numCreated_构造一个唯一的name\n        name_ = buf;\n    }\n}\n\nvoid Thread::start(){\n    assert(!started_);\n    started_ = true;\n    /*\n    * ThreadData对象的创建是为了父子线程数据的初始化和传输，比如，Thread对象最开始被创建\n    * 在父线程，子线程要执行的回调函数，以及其线程名，而且，Thread对象的一些成员变量还要等\n    * 子线程启动后，才能得知，比如tid，此外，父子线程同步也要依附子线程的启动。\n    */\n    // FIXME: move(func_)\n    detail::ThreadData* data = new detail::ThreadData(func_, name_, &tid_, &latch_);\n    if (pthread_create(&pthreadId_, NULL, &detail::startThread, data)){\n        started_ = false;\n        delete data; // or no delete?\n        LOG_SYSFATAL << \"Failed in pthread_create\";\n    }else{\n        latch_.wait();  // 父子线程的同步，在子线程启动后，会调用latch_.down()唤醒父线程。\n        assert(tid_ > 0);\n    }\n}\n  /*\n  * 简单的调用join即可\n  */\nint Thread::join(){\n    assert(started_);\n    assert(!joined_);\n    joined_ = true;\n    return pthread_join(pthreadId_, NULL);\n}\n```\n\n### 细节明细：\n\n**疑问：**\n\nMuduo网络库在封装Thread时，为什么不直接向子线程传递Thread对象本身，反而去创建一个ThreadData对象去传递呢？\n\n**解答：**\n\nMuduo网络库在封装Thread时选择创建一个ThreadData对象而不是直接向子线程传递Thread对象本身，有一些合理的设计考虑：\n\n1. 线程安全性： 直接向子线程传递Thread对象可能会引入线程安全的问题。Thread对象的生命周期和线程的执行是相关联的，如果在子线程中直接访问或修改Thread对象，可能导致竞态条件和不确定的行为。通过ThreadData的设计，可以更好地封装线程私有数据，确保线程安全性。\n\n2. 封装线程私有数据： ThreadData的存在允许封装线程私有数据，这些数据对于特定线程是独立的。如果直接传递Thread对象，就需要确保Thread对象的成员变量在多线程环境下的正确性和安全性，而通过ThreadData可以更容易实现这一点。\n\n3. 用户数据传递： ThreadData允许用户在创建线程时传递额外的用户数据。这使得用户可以通过ThreadData传递一些上下文信息，而不必直接依赖Thread对象。\n\n4. 解耦设计： 通过ThreadData的设计，Thread类的内部实现与线程的具体执行逻辑解耦。Thread对象可以专注于线程的管理，而线程的执行逻辑则通过ThreadData实现，提高了代码的模块化和可维护性。\n\n**Muduo中，对Posix线程调用fork函数的处理:**\n\n**背景：** 我有写过一个deamo，结果表明，posix线程在调用fork后，子进程并不会复制父进程的所有线程，即子进程只有一个线程（也是子线程的主线程），该线程就是父进程调用fork函数的子线程的上下文复制版。\n\n**Muduo中的处理：** Muduo设计了一个ThreadNameInitializer类，该类定义了一个全局对象，在程序创建时，构造函数会调用pthread_atfork函数，设置了chile回调`afterFork()`，在子进程被创建时，系统会调用`afterFork()`回调，重新设置子进程中主线程的线程局部变量包括：t_cachedTid、t_threadName等。\n\n回调代码如下：\n\n```cpp\nvoid afterFork(){\n    muduo::CurrentThread::t_cachedTid = 0;\n    muduo::CurrentThread::t_threadName = \"main\";\n    CurrentThread::tid();\n    // no need to call pthread_atfork(NULL, NULL, &afterFork);\n}\n```\n\n## 线程池\n\nMuduo设计的线程池，可以直接当模板来使用，设计的非常精妙。不仅线程池的初始化和运行，而且**线程池的析构停止**做的也非常清晰。\n\n**架构图：**\n简单画一下线程池的架构图吧：\n\n![线程池](./ThreadAndThreadPool/photo/ThreadPool.drawio.png)\n\n线程池的每个线程执行的线程回调，都是处于一个while循环中，循环往复的执行：\n\n1. 到任务队列取回调任务。\n2. 执行回调任务。\n3. 回到1。\n\n当然，如果线程池停止了，就会跳出循环。\n\n**提供的接口：**\n\n```cpp\nclass ThreadPool : noncopyable{\npublic:\n    typedef std::function<void ()> Task;\n\n    explicit ThreadPool(const string& nameArg = string(\"ThreadPool\"));\n    ~ThreadPool();\n\n    // Must be called before start().\n    void setMaxQueueSize(int maxSize) { maxQueueSize_ = maxSize; }\n    void setThreadInitCallback(const Task& cb)\n    { threadInitCallback_ = cb; }\n\n    void start(int numThreads);\n    void stop();\n\n    const string& name() const\n    { return name_; }\n\n    size_t queueSize() const;\n\n    // Could block if maxQueueSize > 0\n    // Call after stop() will return immediately.\n    // There is no move-only version of std::function in C++ as of C++14.\n    // So we don't need to overload a const& and an && versions\n    // as we do in (Bounded)BlockingQueue.\n    // https://stackoverflow.com/a/25408989\n    void run(Task f);\n\nprivate:\n    bool isFull() const REQUIRES(mutex_);\n    void runInThread();\n    Task take();\n\n    mutable MutexLock mutex_;                       // 线程池全局互斥锁\n    Condition notEmpty_ GUARDED_BY(mutex_);         // 等待任务队列非空的条件变量\n    Condition notFull_ GUARDED_BY(mutex_);          // 等待任务队列未满的条件变量\n    string name_;                                   //线程池的名，线程名就是依据它来拼接\n    Task threadInitCallback_;                       // 线程池中，线程共享的线程初始化的回调\n    std::vector<std::unique_ptr<muduo::Thread>> threads_; // 线程池本体，除了调用start时会写，其他时期都是读，可以不受mutex保护\n    std::deque<Task> queue_ GUARDED_BY(mutex_);     // 任务队列\n    size_t maxQueueSize_;                           //任务队列中，最多存放任务数，不受互斥锁保护。（原生数据类型在很少去写的情况下（可能不太严格，但是为了性能，也无所谓）看成是原子的）\n    bool running_;                                  // 线程池是否正在运行，不受互斥锁保护。（原生数据类型在很少去写的情况下（可能不太严格，但是为了性能，也无所谓）看成是原子的）\n};\n```\n\n**注意：**\n\n线程池中，在调用`ThreadPool::start()`启动线程池之前，必须先调用`ThreadPool::setMaxQueueSize`来设定任务队列的最大任务数。\n\n**实现的伪代码：**\n\n```cpp\nThreadPool::ThreadPool(const string& nameArg)\n  : mutex_(),\n    notEmpty_(mutex_),\n    notFull_(mutex_),\n    name_(nameArg),\n    maxQueueSize_(0),\n    running_(false){\n}\n\nThreadPool::~ThreadPool(){\n    /*\n    * 如果线程池在析构时，没有停止，就调用stop()回收。\n    */\n    if (running_){\n        stop();\n    }\n}\n/*\n* 调用start前先设置任务队列的最大任务数。\n* 参数：提供创建线程池的线程数\n*/\nvoid ThreadPool::start(int numThreads){\n    assert(threads_.empty());\n    running_ = true;\n    threads_.reserve(numThreads);   // 提前预留好内存\n    for (int i = 0; i < numThreads; ++i){   // 创建numThreads个线程，并起名。\n        char id[32];\n        snprintf(id, sizeof id, \"%d\", i+1);\n        threads_.emplace_back(new muduo::Thread(\n                std::bind(&ThreadPool::runInThread, this), name_+id));\n        threads_[i]->start();   // 启动\n    }\n    if (numThreads == 0 && threadInitCallback_){\n        // 如果numThreads为零，就让父线程作为任务执行线程，并调用线程初始化函数。\n        threadInitCallback_();\n    }\n}\n\nvoid ThreadPool::stop(){\n    {\n        MutexLockGuard lock(mutex_);\n        running_ = false;\n        notEmpty_.notifyAll();  // 唤醒所有调用notFull_.wait()的函数\n        notFull_.notifyAll();   // 唤醒所有调用notEmpty_.wait()的函数\n    }\n    for (auto& thr : threads_){\n        // 除了调用start时会写，其他时期都是读，可以不受mutex保护\n        thr->join();\n    }\n}\n\nsize_t ThreadPool::queueSize() const{\n    MutexLockGuard lock(mutex_);\n    return queue_.size();\n}\n\nvoid ThreadPool::run(Task task){\n    if (threads_.empty()){  // 既然无线程可用，线程就自己执行任务。\n        task();\n    }else{\n        MutexLockGuard lock(mutex_);\n        while (isFull() && running_){\n            // while解决惊群，可能会被take（任务队列未满）或stop（线程池停止）唤醒\n            notFull_.wait();\n        }\n        if (!running_) return;\n        assert(!isFull());\n\n        queue_.push_back(std::move(task));  // 存任务\n        notEmpty_.notify(); // 任务队列至少有一个任务，所以非空，调用一下notEmpty_.notify();\n    }\n}\n\nThreadPool::Task ThreadPool::take(){\n    MutexLockGuard lock(mutex_);\n  // always use a while-loop, due to spurious wakeup\n    while (queue_.empty() && running_){\n        // while解决惊群，可能会被run（任务队列非空）或stop（线程池停止）唤醒\n        notEmpty_.wait();\n    }\n\n    Task task;\n    if (!queue_.empty()){   // 任务队列为空，就返回空任务，一般是调用stop停止线程池导致。\n        task = queue_.front();  // 取任务。\n        queue_.pop_front();     // pop任务\n\n        if (maxQueueSize_ > 0){ \n            /*\n            * 如果任务太多，达到了上限，如果其他线程还想，加入任务，会阻塞在run函数的\n            * notFull_.wait()上。保证任务队列任务数量不超过上限，此时在take函数中占\n            * 锁取走了一个任务，任务队列一定未满，所以放心调用notFull_.notify()通知\n            * run函数即可。\n            */\n            notFull_.notify();  \n        }// else 若maxQueueSize_ == 0，说明任务队列大小无限，不存在执行notFull_.wait()分支的线程，无需调用notFull_.notify()。\n    }\n    return task;\n}\n\nbool ThreadPool::isFull() const{\n    mutex_.assertLocked();\n    return maxQueueSize_ > 0 && queue_.size() >= maxQueueSize_;\n}\n\nvoid ThreadPool::runInThread(){\n    try{\n        if (threadInitCallback_){\n            threadInitCallback_();  // 执行一下初始化回调\n        }\n        while (running_){   // 就算要停止了，如果任务队列里面还有任务不继续消化任务吗？\n            Task task(take());  // 取任务\n            if (task){  // 空任务一般发生在线程池停止阶段。\n                task(); // 执行任务。\n            }\n        }\n    }catch (...){\n        // 异常处理...\n    }\n}\n\n```\n\n### 细节明细：\n\n**疑问：**\n\nMuduo的线程池中为什么要设置一个maxQueueSize_成员来限制任务队列的大小？\n\n**解答：**\n\n在Muduo网络库的线程池中设置maxQueueSize_成员来限制任务队列的大小是为了防止无限制的任务积压，以保护系统的稳定性和资源管理。这样的设计有以下几个原因：\n\n1. 资源控制： 通过设置任务队列的最大大小，可以控制线程池在高负载情况下的资源占用。如果不限制任务队列大小，当任务提交速度远远大于线程池处理速度时，可能会导致任务队列无限增长，消耗大量内存资源，最终导致系统资源耗尽。\n\n2. 避免任务积压： 如果任务队列无限制增长，可能导致待处理的任务数量不断累积，进而导致系统的响应时间变长。通过设置最大队列大小，可以避免任务积压，确保系统对任务的响应是有限度的。\n\n3. 反馈机制： 当任务队列达到最大大小时，新的任务可能会被拒绝或者触发一些警告机制。这样的反馈机制可以让开发者或者系统管理员及时感知到系统的负载情况，并采取相应的措施，如调整线程池大小、优化任务处理逻辑等。（**尽管在Muduo中，在代码实现上并没有实现这一点**）\n\n**疑问：**\n\n在ThreadPool::runInThread函数中，如果线程池要停止了（running_ == false），假如任务队列里面还有任务不继续消化任务吗？我看Muduo的实现是，线程池停止，即使任务队列还有任务，ThreadPool::runInThread()也会直接跳出循环。为什么要这样设计？\n\n**解答：**\n\n线程池的停止有两种：\n\n1. Graceful Shutdown： 线程池的停止过程可能是优雅的，即允许已经在任务队列中的任务执行完毕，但不再接受新的任务。在这种情况下，可以通过设置running_为false来触发线程池停止，但允许已在队列中的任务继续执行。\n\n2. 快速停止： 另一种设计考虑是快速停止，即立即停止线程的执行，无论任务队列中是否还有任务。这可能是为了迅速释放线程池占用的资源，例如在应用程序关闭时。在这种情况下，即使有未执行的任务，也可以选择快速停止线程池。\n\n具体选择采用哪种停止方式取决于应用程序的需求和设计目标。如果对任务的完成有严格的要求，可以选择优雅停止，确保所有任务得以执行。如果更注重迅速释放资源，可以选择快速停止。\n\n在Muduo中的设计选择了快速停止，一旦running_为false，即使任务队列中还有任务，线程也会直接退出。这种设计可能符合Muduo网络库的使用场景和性能需求。\n\n**maxQueueSize_ == 0的特殊含义：**\n\n在Muduo网络库中，仔细梳理线程池的源码逻辑可以发现，如果maxQueueSize_的大小被设置为0，表示任务队列的大小没有限制，即队列可以无限增长。ThreadPool::isFull函数会始终返回false，此时在调用ThreadPool::run向任务队列添加任务时，会无条件将任务添加到任务队列，而且ThreadPool::take函数中，由于maxQueueSize_ == 0，也不会去调用notFull_.notify()通知阻塞在ThreadPool::run的线程，因为在maxQueueSize_ == 0条件下根本不可能有线程会阻塞在ThreadPool::run中。\n\n---\n\n**本章完结**","source":"_posts/muduo/ThreadAndThreadPool.md","raw":"---\ntitle: muduo源码阅读笔记（3、线程和线程池的封装）\ndate: 2024-11-02 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**闲聊**\n\nMuduo对线程和线程池的封装，涉及得到源码也不多，大概加一起300多行，这部分读者可以好好精读一下。\n\n## 线程\n\n在阅读cpp的源码，分析一个类具体的实现的时候，首先应该看类的.h文件，主要看类的成员变量有哪些，毕竟成员函数，就是对成员变量进行代码层面的操作的。\n\n**提供的接口：**\n\n<!-- more -->\n```cpp\nclass Thread : noncopyable {\npublic:\n    typedef std::function<void ()> ThreadFunc;\n\n    explicit Thread(ThreadFunc, const string& name = string());\n    // FIXME: make it movable in C++11\n    ~Thread();\n\n    void start();\n    int join(); // return pthread_join()\n\n    bool started() const { return started_; }\n    // pthread_t pthreadId() const { return pthreadId_; }\n    pid_t tid() const { return tid_; }\n    const string& name() const { return name_; }\n\n    static int numCreated() { return numCreated_.get(); }\n\nprivate:\n    void setDefaultName();\n\n    bool       started_;    // 线程正在运行？\n    bool       joined_;     // 有其他线程对该线程join？\n    pthread_t  pthreadId_;  // Posix中的线程id\n    pid_t      tid_;        // 线程真实的id（进程id）\n    ThreadFunc func_;       // 线程回调函数\n    string     name_;       // 线程名\n    CountDownLatch latch_;  // 在父线程继续运行前，确保创建的子线程正在运行\n\n    static AtomicInt32 numCreated_; // 对已经创建的线程计个数，所有线程对象共享的变量，线程默认名可能会用到\n};\n```\n\n**线程启动流程：**\n\n1. Thread::start()  -> \n\n    2. pthread_create(..., &detail::startThread,...)    -> \n\n        3. startThread(void* obj)   ->\n\n            4. ThreadData::runInThread()    -> \n\n                5. Thread::func_()\n\n**实现的伪代码：**\n\n```cpp\n\nstruct ThreadData {\n    typedef muduo::Thread::ThreadFunc ThreadFunc;\n    ThreadFunc func_;\n    string name_;\n    pid_t* tid_;\n    CountDownLatch* latch_;\n\n    ThreadData(ThreadFunc func,\n                const string& name,\n                pid_t* tid,\n                CountDownLatch* latch)\n    : func_(std::move(func)),\n        name_(name),\n        tid_(tid),\n        latch_(latch)\n    { }\n\n    void runInThread(){\n        *tid_ = muduo::CurrentThread::tid();  // 获取&&缓存tid，并赋值给Thread::tid_对象\n        tid_ = NULL;  // 取消对Thread::tid_的指向，保证安全\n        latch_->countDown();  // 倒计数器减为0（初始化为1），通知父线程，子线程启动完毕\n        latch_ = NULL;  // 取消对Thread::latch__的指向，保证安全\n\n        muduo::CurrentThread::t_threadName = name_.empty() ? \"muduoThread\" : name_.c_str(); // 将线程名赋值给线程全局变量\n        ::prctl(PR_SET_NAME, muduo::CurrentThread::t_threadName); // 设置真正的线程的进程名。\n        try{\n            func_();  // 真正开始执行Thread的回调函数\n            muduo::CurrentThread::t_threadName = \"finished\";\n        }\n        catch (...){\n            // 异常处理...\n        }\n    }\n};\n\n/*\n* pthread_create回调函数\n*/\nvoid* startThread(void* obj){\n    ThreadData* data = static_cast<ThreadData*>(obj);\n    data->runInThread();\n    delete data;\n    return NULL;\n}\n\nThread::Thread(ThreadFunc func, const string& n)\n  : started_(false),\n    joined_(false),\n    pthreadId_(0),\n    tid_(0),\n    func_(std::move(func)),\n    name_(n),\n    latch_(1){\n    setDefaultName();\n}\n\nThread::~Thread(){\n    /*\n    * 如果线程启动了并且没有任何线程join过该线程，就调用pthread_detach将该线程分\n    * 离，接触父子关系，让该线程自生自灭。\n    */\n    if (started_ && !joined_){\n        pthread_detach(pthreadId_);\n    }\n}\n\nvoid Thread::setDefaultName(){\n    int num = numCreated_.incrementAndGet();  // 原子自增\n    if (name_.empty()){  // 如果用户没有设置name\n        char buf[32];\n        snprintf(buf, sizeof buf, \"Thread%d\", num); // 利用numCreated_构造一个唯一的name\n        name_ = buf;\n    }\n}\n\nvoid Thread::start(){\n    assert(!started_);\n    started_ = true;\n    /*\n    * ThreadData对象的创建是为了父子线程数据的初始化和传输，比如，Thread对象最开始被创建\n    * 在父线程，子线程要执行的回调函数，以及其线程名，而且，Thread对象的一些成员变量还要等\n    * 子线程启动后，才能得知，比如tid，此外，父子线程同步也要依附子线程的启动。\n    */\n    // FIXME: move(func_)\n    detail::ThreadData* data = new detail::ThreadData(func_, name_, &tid_, &latch_);\n    if (pthread_create(&pthreadId_, NULL, &detail::startThread, data)){\n        started_ = false;\n        delete data; // or no delete?\n        LOG_SYSFATAL << \"Failed in pthread_create\";\n    }else{\n        latch_.wait();  // 父子线程的同步，在子线程启动后，会调用latch_.down()唤醒父线程。\n        assert(tid_ > 0);\n    }\n}\n  /*\n  * 简单的调用join即可\n  */\nint Thread::join(){\n    assert(started_);\n    assert(!joined_);\n    joined_ = true;\n    return pthread_join(pthreadId_, NULL);\n}\n```\n\n### 细节明细：\n\n**疑问：**\n\nMuduo网络库在封装Thread时，为什么不直接向子线程传递Thread对象本身，反而去创建一个ThreadData对象去传递呢？\n\n**解答：**\n\nMuduo网络库在封装Thread时选择创建一个ThreadData对象而不是直接向子线程传递Thread对象本身，有一些合理的设计考虑：\n\n1. 线程安全性： 直接向子线程传递Thread对象可能会引入线程安全的问题。Thread对象的生命周期和线程的执行是相关联的，如果在子线程中直接访问或修改Thread对象，可能导致竞态条件和不确定的行为。通过ThreadData的设计，可以更好地封装线程私有数据，确保线程安全性。\n\n2. 封装线程私有数据： ThreadData的存在允许封装线程私有数据，这些数据对于特定线程是独立的。如果直接传递Thread对象，就需要确保Thread对象的成员变量在多线程环境下的正确性和安全性，而通过ThreadData可以更容易实现这一点。\n\n3. 用户数据传递： ThreadData允许用户在创建线程时传递额外的用户数据。这使得用户可以通过ThreadData传递一些上下文信息，而不必直接依赖Thread对象。\n\n4. 解耦设计： 通过ThreadData的设计，Thread类的内部实现与线程的具体执行逻辑解耦。Thread对象可以专注于线程的管理，而线程的执行逻辑则通过ThreadData实现，提高了代码的模块化和可维护性。\n\n**Muduo中，对Posix线程调用fork函数的处理:**\n\n**背景：** 我有写过一个deamo，结果表明，posix线程在调用fork后，子进程并不会复制父进程的所有线程，即子进程只有一个线程（也是子线程的主线程），该线程就是父进程调用fork函数的子线程的上下文复制版。\n\n**Muduo中的处理：** Muduo设计了一个ThreadNameInitializer类，该类定义了一个全局对象，在程序创建时，构造函数会调用pthread_atfork函数，设置了chile回调`afterFork()`，在子进程被创建时，系统会调用`afterFork()`回调，重新设置子进程中主线程的线程局部变量包括：t_cachedTid、t_threadName等。\n\n回调代码如下：\n\n```cpp\nvoid afterFork(){\n    muduo::CurrentThread::t_cachedTid = 0;\n    muduo::CurrentThread::t_threadName = \"main\";\n    CurrentThread::tid();\n    // no need to call pthread_atfork(NULL, NULL, &afterFork);\n}\n```\n\n## 线程池\n\nMuduo设计的线程池，可以直接当模板来使用，设计的非常精妙。不仅线程池的初始化和运行，而且**线程池的析构停止**做的也非常清晰。\n\n**架构图：**\n简单画一下线程池的架构图吧：\n\n![线程池](./ThreadAndThreadPool/photo/ThreadPool.drawio.png)\n\n线程池的每个线程执行的线程回调，都是处于一个while循环中，循环往复的执行：\n\n1. 到任务队列取回调任务。\n2. 执行回调任务。\n3. 回到1。\n\n当然，如果线程池停止了，就会跳出循环。\n\n**提供的接口：**\n\n```cpp\nclass ThreadPool : noncopyable{\npublic:\n    typedef std::function<void ()> Task;\n\n    explicit ThreadPool(const string& nameArg = string(\"ThreadPool\"));\n    ~ThreadPool();\n\n    // Must be called before start().\n    void setMaxQueueSize(int maxSize) { maxQueueSize_ = maxSize; }\n    void setThreadInitCallback(const Task& cb)\n    { threadInitCallback_ = cb; }\n\n    void start(int numThreads);\n    void stop();\n\n    const string& name() const\n    { return name_; }\n\n    size_t queueSize() const;\n\n    // Could block if maxQueueSize > 0\n    // Call after stop() will return immediately.\n    // There is no move-only version of std::function in C++ as of C++14.\n    // So we don't need to overload a const& and an && versions\n    // as we do in (Bounded)BlockingQueue.\n    // https://stackoverflow.com/a/25408989\n    void run(Task f);\n\nprivate:\n    bool isFull() const REQUIRES(mutex_);\n    void runInThread();\n    Task take();\n\n    mutable MutexLock mutex_;                       // 线程池全局互斥锁\n    Condition notEmpty_ GUARDED_BY(mutex_);         // 等待任务队列非空的条件变量\n    Condition notFull_ GUARDED_BY(mutex_);          // 等待任务队列未满的条件变量\n    string name_;                                   //线程池的名，线程名就是依据它来拼接\n    Task threadInitCallback_;                       // 线程池中，线程共享的线程初始化的回调\n    std::vector<std::unique_ptr<muduo::Thread>> threads_; // 线程池本体，除了调用start时会写，其他时期都是读，可以不受mutex保护\n    std::deque<Task> queue_ GUARDED_BY(mutex_);     // 任务队列\n    size_t maxQueueSize_;                           //任务队列中，最多存放任务数，不受互斥锁保护。（原生数据类型在很少去写的情况下（可能不太严格，但是为了性能，也无所谓）看成是原子的）\n    bool running_;                                  // 线程池是否正在运行，不受互斥锁保护。（原生数据类型在很少去写的情况下（可能不太严格，但是为了性能，也无所谓）看成是原子的）\n};\n```\n\n**注意：**\n\n线程池中，在调用`ThreadPool::start()`启动线程池之前，必须先调用`ThreadPool::setMaxQueueSize`来设定任务队列的最大任务数。\n\n**实现的伪代码：**\n\n```cpp\nThreadPool::ThreadPool(const string& nameArg)\n  : mutex_(),\n    notEmpty_(mutex_),\n    notFull_(mutex_),\n    name_(nameArg),\n    maxQueueSize_(0),\n    running_(false){\n}\n\nThreadPool::~ThreadPool(){\n    /*\n    * 如果线程池在析构时，没有停止，就调用stop()回收。\n    */\n    if (running_){\n        stop();\n    }\n}\n/*\n* 调用start前先设置任务队列的最大任务数。\n* 参数：提供创建线程池的线程数\n*/\nvoid ThreadPool::start(int numThreads){\n    assert(threads_.empty());\n    running_ = true;\n    threads_.reserve(numThreads);   // 提前预留好内存\n    for (int i = 0; i < numThreads; ++i){   // 创建numThreads个线程，并起名。\n        char id[32];\n        snprintf(id, sizeof id, \"%d\", i+1);\n        threads_.emplace_back(new muduo::Thread(\n                std::bind(&ThreadPool::runInThread, this), name_+id));\n        threads_[i]->start();   // 启动\n    }\n    if (numThreads == 0 && threadInitCallback_){\n        // 如果numThreads为零，就让父线程作为任务执行线程，并调用线程初始化函数。\n        threadInitCallback_();\n    }\n}\n\nvoid ThreadPool::stop(){\n    {\n        MutexLockGuard lock(mutex_);\n        running_ = false;\n        notEmpty_.notifyAll();  // 唤醒所有调用notFull_.wait()的函数\n        notFull_.notifyAll();   // 唤醒所有调用notEmpty_.wait()的函数\n    }\n    for (auto& thr : threads_){\n        // 除了调用start时会写，其他时期都是读，可以不受mutex保护\n        thr->join();\n    }\n}\n\nsize_t ThreadPool::queueSize() const{\n    MutexLockGuard lock(mutex_);\n    return queue_.size();\n}\n\nvoid ThreadPool::run(Task task){\n    if (threads_.empty()){  // 既然无线程可用，线程就自己执行任务。\n        task();\n    }else{\n        MutexLockGuard lock(mutex_);\n        while (isFull() && running_){\n            // while解决惊群，可能会被take（任务队列未满）或stop（线程池停止）唤醒\n            notFull_.wait();\n        }\n        if (!running_) return;\n        assert(!isFull());\n\n        queue_.push_back(std::move(task));  // 存任务\n        notEmpty_.notify(); // 任务队列至少有一个任务，所以非空，调用一下notEmpty_.notify();\n    }\n}\n\nThreadPool::Task ThreadPool::take(){\n    MutexLockGuard lock(mutex_);\n  // always use a while-loop, due to spurious wakeup\n    while (queue_.empty() && running_){\n        // while解决惊群，可能会被run（任务队列非空）或stop（线程池停止）唤醒\n        notEmpty_.wait();\n    }\n\n    Task task;\n    if (!queue_.empty()){   // 任务队列为空，就返回空任务，一般是调用stop停止线程池导致。\n        task = queue_.front();  // 取任务。\n        queue_.pop_front();     // pop任务\n\n        if (maxQueueSize_ > 0){ \n            /*\n            * 如果任务太多，达到了上限，如果其他线程还想，加入任务，会阻塞在run函数的\n            * notFull_.wait()上。保证任务队列任务数量不超过上限，此时在take函数中占\n            * 锁取走了一个任务，任务队列一定未满，所以放心调用notFull_.notify()通知\n            * run函数即可。\n            */\n            notFull_.notify();  \n        }// else 若maxQueueSize_ == 0，说明任务队列大小无限，不存在执行notFull_.wait()分支的线程，无需调用notFull_.notify()。\n    }\n    return task;\n}\n\nbool ThreadPool::isFull() const{\n    mutex_.assertLocked();\n    return maxQueueSize_ > 0 && queue_.size() >= maxQueueSize_;\n}\n\nvoid ThreadPool::runInThread(){\n    try{\n        if (threadInitCallback_){\n            threadInitCallback_();  // 执行一下初始化回调\n        }\n        while (running_){   // 就算要停止了，如果任务队列里面还有任务不继续消化任务吗？\n            Task task(take());  // 取任务\n            if (task){  // 空任务一般发生在线程池停止阶段。\n                task(); // 执行任务。\n            }\n        }\n    }catch (...){\n        // 异常处理...\n    }\n}\n\n```\n\n### 细节明细：\n\n**疑问：**\n\nMuduo的线程池中为什么要设置一个maxQueueSize_成员来限制任务队列的大小？\n\n**解答：**\n\n在Muduo网络库的线程池中设置maxQueueSize_成员来限制任务队列的大小是为了防止无限制的任务积压，以保护系统的稳定性和资源管理。这样的设计有以下几个原因：\n\n1. 资源控制： 通过设置任务队列的最大大小，可以控制线程池在高负载情况下的资源占用。如果不限制任务队列大小，当任务提交速度远远大于线程池处理速度时，可能会导致任务队列无限增长，消耗大量内存资源，最终导致系统资源耗尽。\n\n2. 避免任务积压： 如果任务队列无限制增长，可能导致待处理的任务数量不断累积，进而导致系统的响应时间变长。通过设置最大队列大小，可以避免任务积压，确保系统对任务的响应是有限度的。\n\n3. 反馈机制： 当任务队列达到最大大小时，新的任务可能会被拒绝或者触发一些警告机制。这样的反馈机制可以让开发者或者系统管理员及时感知到系统的负载情况，并采取相应的措施，如调整线程池大小、优化任务处理逻辑等。（**尽管在Muduo中，在代码实现上并没有实现这一点**）\n\n**疑问：**\n\n在ThreadPool::runInThread函数中，如果线程池要停止了（running_ == false），假如任务队列里面还有任务不继续消化任务吗？我看Muduo的实现是，线程池停止，即使任务队列还有任务，ThreadPool::runInThread()也会直接跳出循环。为什么要这样设计？\n\n**解答：**\n\n线程池的停止有两种：\n\n1. Graceful Shutdown： 线程池的停止过程可能是优雅的，即允许已经在任务队列中的任务执行完毕，但不再接受新的任务。在这种情况下，可以通过设置running_为false来触发线程池停止，但允许已在队列中的任务继续执行。\n\n2. 快速停止： 另一种设计考虑是快速停止，即立即停止线程的执行，无论任务队列中是否还有任务。这可能是为了迅速释放线程池占用的资源，例如在应用程序关闭时。在这种情况下，即使有未执行的任务，也可以选择快速停止线程池。\n\n具体选择采用哪种停止方式取决于应用程序的需求和设计目标。如果对任务的完成有严格的要求，可以选择优雅停止，确保所有任务得以执行。如果更注重迅速释放资源，可以选择快速停止。\n\n在Muduo中的设计选择了快速停止，一旦running_为false，即使任务队列中还有任务，线程也会直接退出。这种设计可能符合Muduo网络库的使用场景和性能需求。\n\n**maxQueueSize_ == 0的特殊含义：**\n\n在Muduo网络库中，仔细梳理线程池的源码逻辑可以发现，如果maxQueueSize_的大小被设置为0，表示任务队列的大小没有限制，即队列可以无限增长。ThreadPool::isFull函数会始终返回false，此时在调用ThreadPool::run向任务队列添加任务时，会无条件将任务添加到任务队列，而且ThreadPool::take函数中，由于maxQueueSize_ == 0，也不会去调用notFull_.notify()通知阻塞在ThreadPool::run的线程，因为在maxQueueSize_ == 0条件下根本不可能有线程会阻塞在ThreadPool::run中。\n\n---\n\n**本章完结**","slug":"muduo/ThreadAndThreadPool","published":1,"updated":"2025-09-28T16:06:43.135Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9r000oq8ws4u2pb7o9","content":"<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>闲聊</strong></p>\n<p>Muduo对线程和线程池的封装，涉及得到源码也不多，大概加一起300多行，这部分读者可以好好精读一下。</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>在阅读cpp的源码，分析一个类具体的实现的时候，首先应该看类的.h文件，主要看类的成员变量有哪些，毕竟成员函数，就是对成员变量进行代码层面的操作的。</p>\n<p><strong>提供的接口：</strong></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Thread</span> : noncopyable &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> ()&gt; ThreadFunc;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Thread</span><span class=\"params\">(ThreadFunc, <span class=\"type\">const</span> string&amp; name = string())</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> make it movable in C++11</span></span><br><span class=\"line\">    ~<span class=\"built_in\">Thread</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">join</span><span class=\"params\">()</span></span>; <span class=\"comment\">// return pthread_join()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">started</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> started_; &#125;</span><br><span class=\"line\">    <span class=\"comment\">// pthread_t pthreadId() const &#123; return pthreadId_; &#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">tid</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> tid_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">numCreated</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> numCreated_.<span class=\"built_in\">get</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setDefaultName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span>       started_;    <span class=\"comment\">// 线程正在运行？</span></span><br><span class=\"line\">    <span class=\"type\">bool</span>       joined_;     <span class=\"comment\">// 有其他线程对该线程join？</span></span><br><span class=\"line\">    <span class=\"type\">pthread_t</span>  pthreadId_;  <span class=\"comment\">// Posix中的线程id</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span>      tid_;        <span class=\"comment\">// 线程真实的id（进程id）</span></span><br><span class=\"line\">    ThreadFunc func_;       <span class=\"comment\">// 线程回调函数</span></span><br><span class=\"line\">    string     name_;       <span class=\"comment\">// 线程名</span></span><br><span class=\"line\">    CountDownLatch latch_;  <span class=\"comment\">// 在父线程继续运行前，确保创建的子线程正在运行</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">static</span> AtomicInt32 numCreated_; <span class=\"comment\">// 对已经创建的线程计个数，所有线程对象共享的变量，线程默认名可能会用到</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>线程启动流程：</strong></p>\n<ol>\n<li><p>Thread::start()  -&gt; </p>\n<ol start=\"2\">\n<li><p>pthread_create(…, &amp;detail::startThread,…)    -&gt; </p>\n<ol start=\"3\">\n<li><p>startThread(void* obj)   -&gt;</p>\n<ol start=\"4\">\n<li><p>ThreadData::runInThread()    -&gt; </p>\n<ol start=\"5\">\n<li>Thread::func_()</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ThreadData</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> muduo::Thread::ThreadFunc ThreadFunc;</span><br><span class=\"line\">    ThreadFunc func_;</span><br><span class=\"line\">    string name_;</span><br><span class=\"line\">    <span class=\"type\">pid_t</span>* tid_;</span><br><span class=\"line\">    CountDownLatch* latch_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">ThreadData</span>(ThreadFunc func,</span><br><span class=\"line\">                <span class=\"type\">const</span> string&amp; name,</span><br><span class=\"line\">                <span class=\"type\">pid_t</span>* tid,</span><br><span class=\"line\">                CountDownLatch* latch)</span><br><span class=\"line\">    : <span class=\"built_in\">func_</span>(std::<span class=\"built_in\">move</span>(func)),</span><br><span class=\"line\">        <span class=\"built_in\">name_</span>(name),</span><br><span class=\"line\">        <span class=\"built_in\">tid_</span>(tid),</span><br><span class=\"line\">        <span class=\"built_in\">latch_</span>(latch)</span><br><span class=\"line\">    &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">runInThread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        *tid_ = muduo::CurrentThread::<span class=\"built_in\">tid</span>();  <span class=\"comment\">// 获取&amp;&amp;缓存tid，并赋值给Thread::tid_对象</span></span><br><span class=\"line\">        tid_ = <span class=\"literal\">NULL</span>;  <span class=\"comment\">// 取消对Thread::tid_的指向，保证安全</span></span><br><span class=\"line\">        latch_-&gt;<span class=\"built_in\">countDown</span>();  <span class=\"comment\">// 倒计数器减为0（初始化为1），通知父线程，子线程启动完毕</span></span><br><span class=\"line\">        latch_ = <span class=\"literal\">NULL</span>;  <span class=\"comment\">// 取消对Thread::latch__的指向，保证安全</span></span><br><span class=\"line\"></span><br><span class=\"line\">        muduo::CurrentThread::t_threadName = name_.<span class=\"built_in\">empty</span>() ? <span class=\"string\">&quot;muduoThread&quot;</span> : name_.<span class=\"built_in\">c_str</span>(); <span class=\"comment\">// 将线程名赋值给线程全局变量</span></span><br><span class=\"line\">        ::<span class=\"built_in\">prctl</span>(PR_SET_NAME, muduo::CurrentThread::t_threadName); <span class=\"comment\">// 设置真正的线程的进程名。</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">func_</span>();  <span class=\"comment\">// 真正开始执行Thread的回调函数</span></span><br><span class=\"line\">            muduo::CurrentThread::t_threadName = <span class=\"string\">&quot;finished&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">catch</span> (...)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 异常处理...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* pthread_create回调函数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span>* <span class=\"title\">startThread</span><span class=\"params\">(<span class=\"type\">void</span>* obj)</span></span>&#123;</span><br><span class=\"line\">    ThreadData* data = <span class=\"built_in\">static_cast</span>&lt;ThreadData*&gt;(obj);</span><br><span class=\"line\">    data-&gt;<span class=\"built_in\">runInThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> data;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Thread::<span class=\"built_in\">Thread</span>(ThreadFunc func, <span class=\"type\">const</span> string&amp; n)</span><br><span class=\"line\">  : <span class=\"built_in\">started_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">joined_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">pthreadId_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">tid_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">func_</span>(std::<span class=\"built_in\">move</span>(func)),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(n),</span><br><span class=\"line\">    <span class=\"built_in\">latch_</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setDefaultName</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Thread::~<span class=\"built_in\">Thread</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * 如果线程启动了并且没有任何线程join过该线程，就调用pthread_detach将该线程分</span></span><br><span class=\"line\"><span class=\"comment\">    * 离，接触父子关系，让该线程自生自灭。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (started_ &amp;&amp; !joined_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">pthread_detach</span>(pthreadId_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Thread::setDefaultName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> num = numCreated_.<span class=\"built_in\">incrementAndGet</span>();  <span class=\"comment\">// 原子自增</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name_.<span class=\"built_in\">empty</span>())&#123;  <span class=\"comment\">// 如果用户没有设置name</span></span><br><span class=\"line\">        <span class=\"type\">char</span> buf[<span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;Thread%d&quot;</span>, num); <span class=\"comment\">// 利用numCreated_构造一个唯一的name</span></span><br><span class=\"line\">        name_ = buf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Thread::start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!started_);</span><br><span class=\"line\">    started_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * ThreadData对象的创建是为了父子线程数据的初始化和传输，比如，Thread对象最开始被创建</span></span><br><span class=\"line\"><span class=\"comment\">    * 在父线程，子线程要执行的回调函数，以及其线程名，而且，Thread对象的一些成员变量还要等</span></span><br><span class=\"line\"><span class=\"comment\">    * 子线程启动后，才能得知，比如tid，此外，父子线程同步也要依附子线程的启动。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> move(func_)</span></span><br><span class=\"line\">    detail::ThreadData* data = <span class=\"keyword\">new</span> detail::<span class=\"built_in\">ThreadData</span>(func_, name_, &amp;tid_, &amp;latch_);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_create</span>(&amp;pthreadId_, <span class=\"literal\">NULL</span>, &amp;detail::startThread, data))&#123;</span><br><span class=\"line\">        started_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> data; <span class=\"comment\">// or no delete?</span></span><br><span class=\"line\">        LOG_SYSFATAL &lt;&lt; <span class=\"string\">&quot;Failed in pthread_create&quot;</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        latch_.<span class=\"built_in\">wait</span>();  <span class=\"comment\">// 父子线程的同步，在子线程启动后，会调用latch_.down()唤醒父线程。</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(tid_ &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  * 简单的调用join即可</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Thread::join</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(started_);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!joined_);</span><br><span class=\"line\">    joined_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">pthread_join</span>(pthreadId_, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"细节明细：\"><a href=\"#细节明细：\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h3><p><strong>疑问：</strong></p>\n<p>Muduo网络库在封装Thread时，为什么不直接向子线程传递Thread对象本身，反而去创建一个ThreadData对象去传递呢？</p>\n<p><strong>解答：</strong></p>\n<p>Muduo网络库在封装Thread时选择创建一个ThreadData对象而不是直接向子线程传递Thread对象本身，有一些合理的设计考虑：</p>\n<ol>\n<li><p>线程安全性： 直接向子线程传递Thread对象可能会引入线程安全的问题。Thread对象的生命周期和线程的执行是相关联的，如果在子线程中直接访问或修改Thread对象，可能导致竞态条件和不确定的行为。通过ThreadData的设计，可以更好地封装线程私有数据，确保线程安全性。</p>\n</li>\n<li><p>封装线程私有数据： ThreadData的存在允许封装线程私有数据，这些数据对于特定线程是独立的。如果直接传递Thread对象，就需要确保Thread对象的成员变量在多线程环境下的正确性和安全性，而通过ThreadData可以更容易实现这一点。</p>\n</li>\n<li><p>用户数据传递： ThreadData允许用户在创建线程时传递额外的用户数据。这使得用户可以通过ThreadData传递一些上下文信息，而不必直接依赖Thread对象。</p>\n</li>\n<li><p>解耦设计： 通过ThreadData的设计，Thread类的内部实现与线程的具体执行逻辑解耦。Thread对象可以专注于线程的管理，而线程的执行逻辑则通过ThreadData实现，提高了代码的模块化和可维护性。</p>\n</li>\n</ol>\n<p><strong>Muduo中，对Posix线程调用fork函数的处理:</strong></p>\n<p><strong>背景：</strong> 我有写过一个deamo，结果表明，posix线程在调用fork后，子进程并不会复制父进程的所有线程，即子进程只有一个线程（也是子线程的主线程），该线程就是父进程调用fork函数的子线程的上下文复制版。</p>\n<p><strong>Muduo中的处理：</strong> Muduo设计了一个ThreadNameInitializer类，该类定义了一个全局对象，在程序创建时，构造函数会调用pthread_atfork函数，设置了chile回调<code>afterFork()</code>，在子进程被创建时，系统会调用<code>afterFork()</code>回调，重新设置子进程中主线程的线程局部变量包括：t_cachedTid、t_threadName等。</p>\n<p>回调代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">afterFork</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    muduo::CurrentThread::t_cachedTid = <span class=\"number\">0</span>;</span><br><span class=\"line\">    muduo::CurrentThread::t_threadName = <span class=\"string\">&quot;main&quot;</span>;</span><br><span class=\"line\">    CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    <span class=\"comment\">// no need to call pthread_atfork(NULL, NULL, &amp;afterFork);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>Muduo设计的线程池，可以直接当模板来使用，设计的非常精妙。不仅线程池的初始化和运行，而且<strong>线程池的析构停止</strong>做的也非常清晰。</p>\n<p><strong>架构图：</strong><br>简单画一下线程池的架构图吧：</p>\n<p><img src=\"/2024/11/02/muduo/ThreadAndThreadPool/photo/ThreadPool.drawio.png\" alt=\"线程池\"></p>\n<p>线程池的每个线程执行的线程回调，都是处于一个while循环中，循环往复的执行：</p>\n<ol>\n<li>到任务队列取回调任务。</li>\n<li>执行回调任务。</li>\n<li>回到1。</li>\n</ol>\n<p>当然，如果线程池停止了，就会跳出循环。</p>\n<p><strong>提供的接口：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPool</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> ()&gt; Task;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadPool</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; nameArg = string(<span class=\"string\">&quot;ThreadPool&quot;</span>))</span></span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">ThreadPool</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Must be called before start().</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setMaxQueueSize</span><span class=\"params\">(<span class=\"type\">int</span> maxSize)</span> </span>&#123; maxQueueSize_ = maxSize; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadInitCallback</span><span class=\"params\">(<span class=\"type\">const</span> Task&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; threadInitCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">queueSize</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Could block if maxQueueSize &gt; 0</span></span><br><span class=\"line\">    <span class=\"comment\">// Call after stop() will return immediately.</span></span><br><span class=\"line\">    <span class=\"comment\">// There is no move-only version of std::function in C++ as of C++14.</span></span><br><span class=\"line\">    <span class=\"comment\">// So we don&#x27;t need to overload a const&amp; and an &amp;&amp; versions</span></span><br><span class=\"line\">    <span class=\"comment\">// as we do in (Bounded)BlockingQueue.</span></span><br><span class=\"line\">    <span class=\"comment\">// https://stackoverflow.com/a/25408989</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">run</span><span class=\"params\">(Task f)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"title\">REQUIRES</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">runInThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Task <span class=\"title\">take</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_;                       <span class=\"comment\">// 线程池全局互斥锁</span></span><br><span class=\"line\">    <span class=\"function\">Condition notEmpty_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;         <span class=\"comment\">// 等待任务队列非空的条件变量</span></span><br><span class=\"line\">    <span class=\"function\">Condition notFull_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;          <span class=\"comment\">// 等待任务队列未满的条件变量</span></span><br><span class=\"line\">    string name_;                                   <span class=\"comment\">//线程池的名，线程名就是依据它来拼接</span></span><br><span class=\"line\">    Task threadInitCallback_;                       <span class=\"comment\">// 线程池中，线程共享的线程初始化的回调</span></span><br><span class=\"line\">    std::vector&lt;std::unique_ptr&lt;muduo::Thread&gt;&gt; threads_; <span class=\"comment\">// 线程池本体，除了调用start时会写，其他时期都是读，可以不受mutex保护</span></span><br><span class=\"line\">    <span class=\"function\">std::deque&lt;Task&gt; queue_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;     <span class=\"comment\">// 任务队列</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> maxQueueSize_;                           <span class=\"comment\">//任务队列中，最多存放任务数，不受互斥锁保护。（原生数据类型在很少去写的情况下（可能不太严格，但是为了性能，也无所谓）看成是原子的）</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> running_;                                  <span class=\"comment\">// 线程池是否正在运行，不受互斥锁保护。（原生数据类型在很少去写的情况下（可能不太严格，但是为了性能，也无所谓）看成是原子的）</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>线程池中，在调用<code>ThreadPool::start()</code>启动线程池之前，必须先调用<code>ThreadPool::setMaxQueueSize</code>来设定任务队列的最大任务数。</p>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPool::<span class=\"built_in\">ThreadPool</span>(<span class=\"type\">const</span> string&amp; nameArg)</span><br><span class=\"line\">  : <span class=\"built_in\">mutex_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">notEmpty_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">notFull_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">maxQueueSize_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">running_</span>(<span class=\"literal\">false</span>)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ThreadPool::~<span class=\"built_in\">ThreadPool</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * 如果线程池在析构时，没有停止，就调用stop()回收。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (running_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 调用start前先设置任务队列的最大任务数。</span></span><br><span class=\"line\"><span class=\"comment\">* 参数：提供创建线程池的线程数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::start</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(threads_.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\">    running_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    threads_.<span class=\"built_in\">reserve</span>(numThreads);   <span class=\"comment\">// 提前预留好内存</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; numThreads; ++i)&#123;   <span class=\"comment\">// 创建numThreads个线程，并起名。</span></span><br><span class=\"line\">        <span class=\"type\">char</span> id[<span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(id, <span class=\"keyword\">sizeof</span> id, <span class=\"string\">&quot;%d&quot;</span>, i<span class=\"number\">+1</span>);</span><br><span class=\"line\">        threads_.<span class=\"built_in\">emplace_back</span>(<span class=\"keyword\">new</span> muduo::<span class=\"built_in\">Thread</span>(</span><br><span class=\"line\">                std::<span class=\"built_in\">bind</span>(&amp;ThreadPool::runInThread, <span class=\"keyword\">this</span>), name_+id));</span><br><span class=\"line\">        threads_[i]-&gt;<span class=\"built_in\">start</span>();   <span class=\"comment\">// 启动</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numThreads == <span class=\"number\">0</span> &amp;&amp; threadInitCallback_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果numThreads为零，就让父线程作为任务执行线程，并调用线程初始化函数。</span></span><br><span class=\"line\">        <span class=\"built_in\">threadInitCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::stop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        running_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">notifyAll</span>();  <span class=\"comment\">// 唤醒所有调用notFull_.wait()的函数</span></span><br><span class=\"line\">        notFull_.<span class=\"built_in\">notifyAll</span>();   <span class=\"comment\">// 唤醒所有调用notEmpty_.wait()的函数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; thr : threads_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 除了调用start时会写，其他时期都是读，可以不受mutex保护</span></span><br><span class=\"line\">        thr-&gt;<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">ThreadPool::queueSize</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue_.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::run</span><span class=\"params\">(Task task)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (threads_.<span class=\"built_in\">empty</span>())&#123;  <span class=\"comment\">// 既然无线程可用，线程就自己执行任务。</span></span><br><span class=\"line\">        <span class=\"built_in\">task</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        MutexLockGuard <span class=\"built_in\">lock</span>(mutex_);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">isFull</span>() &amp;&amp; running_)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// while解决惊群，可能会被take（任务队列未满）或stop（线程池停止）唤醒</span></span><br><span class=\"line\">            notFull_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!running_) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(!<span class=\"built_in\">isFull</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        queue_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(task));  <span class=\"comment\">// 存任务</span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">notify</span>(); <span class=\"comment\">// 任务队列至少有一个任务，所以非空，调用一下notEmpty_.notify();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ThreadPool::Task <span class=\"title\">ThreadPool::take</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">// always use a while-loop, due to spurious wakeup</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue_.<span class=\"built_in\">empty</span>() &amp;&amp; running_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// while解决惊群，可能会被run（任务队列非空）或stop（线程池停止）唤醒</span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Task task;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!queue_.<span class=\"built_in\">empty</span>())&#123;   <span class=\"comment\">// 任务队列为空，就返回空任务，一般是调用stop停止线程池导致。</span></span><br><span class=\"line\">        task = queue_.<span class=\"built_in\">front</span>();  <span class=\"comment\">// 取任务。</span></span><br><span class=\"line\">        queue_.<span class=\"built_in\">pop_front</span>();     <span class=\"comment\">// pop任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxQueueSize_ &gt; <span class=\"number\">0</span>)&#123; </span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * 如果任务太多，达到了上限，如果其他线程还想，加入任务，会阻塞在run函数的</span></span><br><span class=\"line\"><span class=\"comment\">            * notFull_.wait()上。保证任务队列任务数量不超过上限，此时在take函数中占</span></span><br><span class=\"line\"><span class=\"comment\">            * 锁取走了一个任务，任务队列一定未满，所以放心调用notFull_.notify()通知</span></span><br><span class=\"line\"><span class=\"comment\">            * run函数即可。</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            notFull_.<span class=\"built_in\">notify</span>();  </span><br><span class=\"line\">        &#125;<span class=\"comment\">// else 若maxQueueSize_ == 0，说明任务队列大小无限，不存在执行notFull_.wait()分支的线程，无需调用notFull_.notify()。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ThreadPool::isFull</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    mutex_.<span class=\"built_in\">assertLocked</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxQueueSize_ &gt; <span class=\"number\">0</span> &amp;&amp; queue_.<span class=\"built_in\">size</span>() &gt;= maxQueueSize_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::runInThread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (threadInitCallback_)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">threadInitCallback_</span>();  <span class=\"comment\">// 执行一下初始化回调</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (running_)&#123;   <span class=\"comment\">// 就算要停止了，如果任务队列里面还有任务不继续消化任务吗？</span></span><br><span class=\"line\">            <span class=\"function\">Task <span class=\"title\">task</span><span class=\"params\">(take())</span></span>;  <span class=\"comment\">// 取任务</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (task)&#123;  <span class=\"comment\">// 空任务一般发生在线程池停止阶段。</span></span><br><span class=\"line\">                <span class=\"built_in\">task</span>(); <span class=\"comment\">// 执行任务。</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"built_in\">catch</span> (...)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 异常处理...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"细节明细：-1\"><a href=\"#细节明细：-1\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h3><p><strong>疑问：</strong></p>\n<p>Muduo的线程池中为什么要设置一个maxQueueSize_成员来限制任务队列的大小？</p>\n<p><strong>解答：</strong></p>\n<p>在Muduo网络库的线程池中设置maxQueueSize_成员来限制任务队列的大小是为了防止无限制的任务积压，以保护系统的稳定性和资源管理。这样的设计有以下几个原因：</p>\n<ol>\n<li><p>资源控制： 通过设置任务队列的最大大小，可以控制线程池在高负载情况下的资源占用。如果不限制任务队列大小，当任务提交速度远远大于线程池处理速度时，可能会导致任务队列无限增长，消耗大量内存资源，最终导致系统资源耗尽。</p>\n</li>\n<li><p>避免任务积压： 如果任务队列无限制增长，可能导致待处理的任务数量不断累积，进而导致系统的响应时间变长。通过设置最大队列大小，可以避免任务积压，确保系统对任务的响应是有限度的。</p>\n</li>\n<li><p>反馈机制： 当任务队列达到最大大小时，新的任务可能会被拒绝或者触发一些警告机制。这样的反馈机制可以让开发者或者系统管理员及时感知到系统的负载情况，并采取相应的措施，如调整线程池大小、优化任务处理逻辑等。（<strong>尽管在Muduo中，在代码实现上并没有实现这一点</strong>）</p>\n</li>\n</ol>\n<p><strong>疑问：</strong></p>\n<p>在ThreadPool::runInThread函数中，如果线程池要停止了（running_ &#x3D;&#x3D; false），假如任务队列里面还有任务不继续消化任务吗？我看Muduo的实现是，线程池停止，即使任务队列还有任务，ThreadPool::runInThread()也会直接跳出循环。为什么要这样设计？</p>\n<p><strong>解答：</strong></p>\n<p>线程池的停止有两种：</p>\n<ol>\n<li><p>Graceful Shutdown： 线程池的停止过程可能是优雅的，即允许已经在任务队列中的任务执行完毕，但不再接受新的任务。在这种情况下，可以通过设置running_为false来触发线程池停止，但允许已在队列中的任务继续执行。</p>\n</li>\n<li><p>快速停止： 另一种设计考虑是快速停止，即立即停止线程的执行，无论任务队列中是否还有任务。这可能是为了迅速释放线程池占用的资源，例如在应用程序关闭时。在这种情况下，即使有未执行的任务，也可以选择快速停止线程池。</p>\n</li>\n</ol>\n<p>具体选择采用哪种停止方式取决于应用程序的需求和设计目标。如果对任务的完成有严格的要求，可以选择优雅停止，确保所有任务得以执行。如果更注重迅速释放资源，可以选择快速停止。</p>\n<p>在Muduo中的设计选择了快速停止，一旦running_为false，即使任务队列中还有任务，线程也会直接退出。这种设计可能符合Muduo网络库的使用场景和性能需求。</p>\n<p><strong>maxQueueSize_ &#x3D;&#x3D; 0的特殊含义：</strong></p>\n<p>在Muduo网络库中，仔细梳理线程池的源码逻辑可以发现，如果maxQueueSize_的大小被设置为0，表示任务队列的大小没有限制，即队列可以无限增长。ThreadPool::isFull函数会始终返回false，此时在调用ThreadPool::run向任务队列添加任务时，会无条件将任务添加到任务队列，而且ThreadPool::take函数中，由于maxQueueSize_ &#x3D;&#x3D; 0，也不会去调用notFull_.notify()通知阻塞在ThreadPool::run的线程，因为在maxQueueSize_ &#x3D;&#x3D; 0条件下根本不可能有线程会阻塞在ThreadPool::run中。</p>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>闲聊</strong></p>\n<p>Muduo对线程和线程池的封装，涉及得到源码也不多，大概加一起300多行，这部分读者可以好好精读一下。</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>在阅读cpp的源码，分析一个类具体的实现的时候，首先应该看类的.h文件，主要看类的成员变量有哪些，毕竟成员函数，就是对成员变量进行代码层面的操作的。</p>\n<p><strong>提供的接口：</strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Thread</span> : noncopyable &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> ()&gt; ThreadFunc;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Thread</span><span class=\"params\">(ThreadFunc, <span class=\"type\">const</span> string&amp; name = string())</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> make it movable in C++11</span></span><br><span class=\"line\">    ~<span class=\"built_in\">Thread</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">join</span><span class=\"params\">()</span></span>; <span class=\"comment\">// return pthread_join()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">started</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> started_; &#125;</span><br><span class=\"line\">    <span class=\"comment\">// pthread_t pthreadId() const &#123; return pthreadId_; &#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">tid</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> tid_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">numCreated</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> numCreated_.<span class=\"built_in\">get</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setDefaultName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span>       started_;    <span class=\"comment\">// 线程正在运行？</span></span><br><span class=\"line\">    <span class=\"type\">bool</span>       joined_;     <span class=\"comment\">// 有其他线程对该线程join？</span></span><br><span class=\"line\">    <span class=\"type\">pthread_t</span>  pthreadId_;  <span class=\"comment\">// Posix中的线程id</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span>      tid_;        <span class=\"comment\">// 线程真实的id（进程id）</span></span><br><span class=\"line\">    ThreadFunc func_;       <span class=\"comment\">// 线程回调函数</span></span><br><span class=\"line\">    string     name_;       <span class=\"comment\">// 线程名</span></span><br><span class=\"line\">    CountDownLatch latch_;  <span class=\"comment\">// 在父线程继续运行前，确保创建的子线程正在运行</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">static</span> AtomicInt32 numCreated_; <span class=\"comment\">// 对已经创建的线程计个数，所有线程对象共享的变量，线程默认名可能会用到</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>线程启动流程：</strong></p>\n<ol>\n<li><p>Thread::start()  -&gt; </p>\n<ol start=\"2\">\n<li><p>pthread_create(…, &amp;detail::startThread,…)    -&gt; </p>\n<ol start=\"3\">\n<li><p>startThread(void* obj)   -&gt;</p>\n<ol start=\"4\">\n<li><p>ThreadData::runInThread()    -&gt; </p>\n<ol start=\"5\">\n<li>Thread::func_()</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ThreadData</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> muduo::Thread::ThreadFunc ThreadFunc;</span><br><span class=\"line\">    ThreadFunc func_;</span><br><span class=\"line\">    string name_;</span><br><span class=\"line\">    <span class=\"type\">pid_t</span>* tid_;</span><br><span class=\"line\">    CountDownLatch* latch_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">ThreadData</span>(ThreadFunc func,</span><br><span class=\"line\">                <span class=\"type\">const</span> string&amp; name,</span><br><span class=\"line\">                <span class=\"type\">pid_t</span>* tid,</span><br><span class=\"line\">                CountDownLatch* latch)</span><br><span class=\"line\">    : <span class=\"built_in\">func_</span>(std::<span class=\"built_in\">move</span>(func)),</span><br><span class=\"line\">        <span class=\"built_in\">name_</span>(name),</span><br><span class=\"line\">        <span class=\"built_in\">tid_</span>(tid),</span><br><span class=\"line\">        <span class=\"built_in\">latch_</span>(latch)</span><br><span class=\"line\">    &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">runInThread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        *tid_ = muduo::CurrentThread::<span class=\"built_in\">tid</span>();  <span class=\"comment\">// 获取&amp;&amp;缓存tid，并赋值给Thread::tid_对象</span></span><br><span class=\"line\">        tid_ = <span class=\"literal\">NULL</span>;  <span class=\"comment\">// 取消对Thread::tid_的指向，保证安全</span></span><br><span class=\"line\">        latch_-&gt;<span class=\"built_in\">countDown</span>();  <span class=\"comment\">// 倒计数器减为0（初始化为1），通知父线程，子线程启动完毕</span></span><br><span class=\"line\">        latch_ = <span class=\"literal\">NULL</span>;  <span class=\"comment\">// 取消对Thread::latch__的指向，保证安全</span></span><br><span class=\"line\"></span><br><span class=\"line\">        muduo::CurrentThread::t_threadName = name_.<span class=\"built_in\">empty</span>() ? <span class=\"string\">&quot;muduoThread&quot;</span> : name_.<span class=\"built_in\">c_str</span>(); <span class=\"comment\">// 将线程名赋值给线程全局变量</span></span><br><span class=\"line\">        ::<span class=\"built_in\">prctl</span>(PR_SET_NAME, muduo::CurrentThread::t_threadName); <span class=\"comment\">// 设置真正的线程的进程名。</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">func_</span>();  <span class=\"comment\">// 真正开始执行Thread的回调函数</span></span><br><span class=\"line\">            muduo::CurrentThread::t_threadName = <span class=\"string\">&quot;finished&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">catch</span> (...)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 异常处理...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* pthread_create回调函数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span>* <span class=\"title\">startThread</span><span class=\"params\">(<span class=\"type\">void</span>* obj)</span></span>&#123;</span><br><span class=\"line\">    ThreadData* data = <span class=\"built_in\">static_cast</span>&lt;ThreadData*&gt;(obj);</span><br><span class=\"line\">    data-&gt;<span class=\"built_in\">runInThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> data;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Thread::<span class=\"built_in\">Thread</span>(ThreadFunc func, <span class=\"type\">const</span> string&amp; n)</span><br><span class=\"line\">  : <span class=\"built_in\">started_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">joined_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">pthreadId_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">tid_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">func_</span>(std::<span class=\"built_in\">move</span>(func)),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(n),</span><br><span class=\"line\">    <span class=\"built_in\">latch_</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setDefaultName</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Thread::~<span class=\"built_in\">Thread</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * 如果线程启动了并且没有任何线程join过该线程，就调用pthread_detach将该线程分</span></span><br><span class=\"line\"><span class=\"comment\">    * 离，接触父子关系，让该线程自生自灭。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (started_ &amp;&amp; !joined_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">pthread_detach</span>(pthreadId_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Thread::setDefaultName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> num = numCreated_.<span class=\"built_in\">incrementAndGet</span>();  <span class=\"comment\">// 原子自增</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name_.<span class=\"built_in\">empty</span>())&#123;  <span class=\"comment\">// 如果用户没有设置name</span></span><br><span class=\"line\">        <span class=\"type\">char</span> buf[<span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;Thread%d&quot;</span>, num); <span class=\"comment\">// 利用numCreated_构造一个唯一的name</span></span><br><span class=\"line\">        name_ = buf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Thread::start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!started_);</span><br><span class=\"line\">    started_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * ThreadData对象的创建是为了父子线程数据的初始化和传输，比如，Thread对象最开始被创建</span></span><br><span class=\"line\"><span class=\"comment\">    * 在父线程，子线程要执行的回调函数，以及其线程名，而且，Thread对象的一些成员变量还要等</span></span><br><span class=\"line\"><span class=\"comment\">    * 子线程启动后，才能得知，比如tid，此外，父子线程同步也要依附子线程的启动。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> move(func_)</span></span><br><span class=\"line\">    detail::ThreadData* data = <span class=\"keyword\">new</span> detail::<span class=\"built_in\">ThreadData</span>(func_, name_, &amp;tid_, &amp;latch_);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_create</span>(&amp;pthreadId_, <span class=\"literal\">NULL</span>, &amp;detail::startThread, data))&#123;</span><br><span class=\"line\">        started_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> data; <span class=\"comment\">// or no delete?</span></span><br><span class=\"line\">        LOG_SYSFATAL &lt;&lt; <span class=\"string\">&quot;Failed in pthread_create&quot;</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        latch_.<span class=\"built_in\">wait</span>();  <span class=\"comment\">// 父子线程的同步，在子线程启动后，会调用latch_.down()唤醒父线程。</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(tid_ &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  * 简单的调用join即可</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Thread::join</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(started_);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!joined_);</span><br><span class=\"line\">    joined_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">pthread_join</span>(pthreadId_, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"细节明细：\"><a href=\"#细节明细：\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h3><p><strong>疑问：</strong></p>\n<p>Muduo网络库在封装Thread时，为什么不直接向子线程传递Thread对象本身，反而去创建一个ThreadData对象去传递呢？</p>\n<p><strong>解答：</strong></p>\n<p>Muduo网络库在封装Thread时选择创建一个ThreadData对象而不是直接向子线程传递Thread对象本身，有一些合理的设计考虑：</p>\n<ol>\n<li><p>线程安全性： 直接向子线程传递Thread对象可能会引入线程安全的问题。Thread对象的生命周期和线程的执行是相关联的，如果在子线程中直接访问或修改Thread对象，可能导致竞态条件和不确定的行为。通过ThreadData的设计，可以更好地封装线程私有数据，确保线程安全性。</p>\n</li>\n<li><p>封装线程私有数据： ThreadData的存在允许封装线程私有数据，这些数据对于特定线程是独立的。如果直接传递Thread对象，就需要确保Thread对象的成员变量在多线程环境下的正确性和安全性，而通过ThreadData可以更容易实现这一点。</p>\n</li>\n<li><p>用户数据传递： ThreadData允许用户在创建线程时传递额外的用户数据。这使得用户可以通过ThreadData传递一些上下文信息，而不必直接依赖Thread对象。</p>\n</li>\n<li><p>解耦设计： 通过ThreadData的设计，Thread类的内部实现与线程的具体执行逻辑解耦。Thread对象可以专注于线程的管理，而线程的执行逻辑则通过ThreadData实现，提高了代码的模块化和可维护性。</p>\n</li>\n</ol>\n<p><strong>Muduo中，对Posix线程调用fork函数的处理:</strong></p>\n<p><strong>背景：</strong> 我有写过一个deamo，结果表明，posix线程在调用fork后，子进程并不会复制父进程的所有线程，即子进程只有一个线程（也是子线程的主线程），该线程就是父进程调用fork函数的子线程的上下文复制版。</p>\n<p><strong>Muduo中的处理：</strong> Muduo设计了一个ThreadNameInitializer类，该类定义了一个全局对象，在程序创建时，构造函数会调用pthread_atfork函数，设置了chile回调<code>afterFork()</code>，在子进程被创建时，系统会调用<code>afterFork()</code>回调，重新设置子进程中主线程的线程局部变量包括：t_cachedTid、t_threadName等。</p>\n<p>回调代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">afterFork</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    muduo::CurrentThread::t_cachedTid = <span class=\"number\">0</span>;</span><br><span class=\"line\">    muduo::CurrentThread::t_threadName = <span class=\"string\">&quot;main&quot;</span>;</span><br><span class=\"line\">    CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    <span class=\"comment\">// no need to call pthread_atfork(NULL, NULL, &amp;afterFork);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>Muduo设计的线程池，可以直接当模板来使用，设计的非常精妙。不仅线程池的初始化和运行，而且<strong>线程池的析构停止</strong>做的也非常清晰。</p>\n<p><strong>架构图：</strong><br>简单画一下线程池的架构图吧：</p>\n<p><img src=\"/2024/11/02/muduo/ThreadAndThreadPool/photo/ThreadPool.drawio.png\" alt=\"线程池\"></p>\n<p>线程池的每个线程执行的线程回调，都是处于一个while循环中，循环往复的执行：</p>\n<ol>\n<li>到任务队列取回调任务。</li>\n<li>执行回调任务。</li>\n<li>回到1。</li>\n</ol>\n<p>当然，如果线程池停止了，就会跳出循环。</p>\n<p><strong>提供的接口：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPool</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> ()&gt; Task;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadPool</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; nameArg = string(<span class=\"string\">&quot;ThreadPool&quot;</span>))</span></span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">ThreadPool</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Must be called before start().</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setMaxQueueSize</span><span class=\"params\">(<span class=\"type\">int</span> maxSize)</span> </span>&#123; maxQueueSize_ = maxSize; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadInitCallback</span><span class=\"params\">(<span class=\"type\">const</span> Task&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; threadInitCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">queueSize</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Could block if maxQueueSize &gt; 0</span></span><br><span class=\"line\">    <span class=\"comment\">// Call after stop() will return immediately.</span></span><br><span class=\"line\">    <span class=\"comment\">// There is no move-only version of std::function in C++ as of C++14.</span></span><br><span class=\"line\">    <span class=\"comment\">// So we don&#x27;t need to overload a const&amp; and an &amp;&amp; versions</span></span><br><span class=\"line\">    <span class=\"comment\">// as we do in (Bounded)BlockingQueue.</span></span><br><span class=\"line\">    <span class=\"comment\">// https://stackoverflow.com/a/25408989</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">run</span><span class=\"params\">(Task f)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"title\">REQUIRES</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">runInThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Task <span class=\"title\">take</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_;                       <span class=\"comment\">// 线程池全局互斥锁</span></span><br><span class=\"line\">    <span class=\"function\">Condition notEmpty_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;         <span class=\"comment\">// 等待任务队列非空的条件变量</span></span><br><span class=\"line\">    <span class=\"function\">Condition notFull_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;          <span class=\"comment\">// 等待任务队列未满的条件变量</span></span><br><span class=\"line\">    string name_;                                   <span class=\"comment\">//线程池的名，线程名就是依据它来拼接</span></span><br><span class=\"line\">    Task threadInitCallback_;                       <span class=\"comment\">// 线程池中，线程共享的线程初始化的回调</span></span><br><span class=\"line\">    std::vector&lt;std::unique_ptr&lt;muduo::Thread&gt;&gt; threads_; <span class=\"comment\">// 线程池本体，除了调用start时会写，其他时期都是读，可以不受mutex保护</span></span><br><span class=\"line\">    <span class=\"function\">std::deque&lt;Task&gt; queue_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;     <span class=\"comment\">// 任务队列</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> maxQueueSize_;                           <span class=\"comment\">//任务队列中，最多存放任务数，不受互斥锁保护。（原生数据类型在很少去写的情况下（可能不太严格，但是为了性能，也无所谓）看成是原子的）</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> running_;                                  <span class=\"comment\">// 线程池是否正在运行，不受互斥锁保护。（原生数据类型在很少去写的情况下（可能不太严格，但是为了性能，也无所谓）看成是原子的）</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>线程池中，在调用<code>ThreadPool::start()</code>启动线程池之前，必须先调用<code>ThreadPool::setMaxQueueSize</code>来设定任务队列的最大任务数。</p>\n<p><strong>实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPool::<span class=\"built_in\">ThreadPool</span>(<span class=\"type\">const</span> string&amp; nameArg)</span><br><span class=\"line\">  : <span class=\"built_in\">mutex_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">notEmpty_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">notFull_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">maxQueueSize_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">running_</span>(<span class=\"literal\">false</span>)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ThreadPool::~<span class=\"built_in\">ThreadPool</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * 如果线程池在析构时，没有停止，就调用stop()回收。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (running_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 调用start前先设置任务队列的最大任务数。</span></span><br><span class=\"line\"><span class=\"comment\">* 参数：提供创建线程池的线程数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::start</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(threads_.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\">    running_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    threads_.<span class=\"built_in\">reserve</span>(numThreads);   <span class=\"comment\">// 提前预留好内存</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; numThreads; ++i)&#123;   <span class=\"comment\">// 创建numThreads个线程，并起名。</span></span><br><span class=\"line\">        <span class=\"type\">char</span> id[<span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(id, <span class=\"keyword\">sizeof</span> id, <span class=\"string\">&quot;%d&quot;</span>, i<span class=\"number\">+1</span>);</span><br><span class=\"line\">        threads_.<span class=\"built_in\">emplace_back</span>(<span class=\"keyword\">new</span> muduo::<span class=\"built_in\">Thread</span>(</span><br><span class=\"line\">                std::<span class=\"built_in\">bind</span>(&amp;ThreadPool::runInThread, <span class=\"keyword\">this</span>), name_+id));</span><br><span class=\"line\">        threads_[i]-&gt;<span class=\"built_in\">start</span>();   <span class=\"comment\">// 启动</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numThreads == <span class=\"number\">0</span> &amp;&amp; threadInitCallback_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果numThreads为零，就让父线程作为任务执行线程，并调用线程初始化函数。</span></span><br><span class=\"line\">        <span class=\"built_in\">threadInitCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::stop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        running_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">notifyAll</span>();  <span class=\"comment\">// 唤醒所有调用notFull_.wait()的函数</span></span><br><span class=\"line\">        notFull_.<span class=\"built_in\">notifyAll</span>();   <span class=\"comment\">// 唤醒所有调用notEmpty_.wait()的函数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; thr : threads_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 除了调用start时会写，其他时期都是读，可以不受mutex保护</span></span><br><span class=\"line\">        thr-&gt;<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">ThreadPool::queueSize</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue_.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::run</span><span class=\"params\">(Task task)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (threads_.<span class=\"built_in\">empty</span>())&#123;  <span class=\"comment\">// 既然无线程可用，线程就自己执行任务。</span></span><br><span class=\"line\">        <span class=\"built_in\">task</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        MutexLockGuard <span class=\"built_in\">lock</span>(mutex_);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">isFull</span>() &amp;&amp; running_)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// while解决惊群，可能会被take（任务队列未满）或stop（线程池停止）唤醒</span></span><br><span class=\"line\">            notFull_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!running_) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(!<span class=\"built_in\">isFull</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        queue_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(task));  <span class=\"comment\">// 存任务</span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">notify</span>(); <span class=\"comment\">// 任务队列至少有一个任务，所以非空，调用一下notEmpty_.notify();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ThreadPool::Task <span class=\"title\">ThreadPool::take</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">// always use a while-loop, due to spurious wakeup</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue_.<span class=\"built_in\">empty</span>() &amp;&amp; running_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// while解决惊群，可能会被run（任务队列非空）或stop（线程池停止）唤醒</span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Task task;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!queue_.<span class=\"built_in\">empty</span>())&#123;   <span class=\"comment\">// 任务队列为空，就返回空任务，一般是调用stop停止线程池导致。</span></span><br><span class=\"line\">        task = queue_.<span class=\"built_in\">front</span>();  <span class=\"comment\">// 取任务。</span></span><br><span class=\"line\">        queue_.<span class=\"built_in\">pop_front</span>();     <span class=\"comment\">// pop任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxQueueSize_ &gt; <span class=\"number\">0</span>)&#123; </span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * 如果任务太多，达到了上限，如果其他线程还想，加入任务，会阻塞在run函数的</span></span><br><span class=\"line\"><span class=\"comment\">            * notFull_.wait()上。保证任务队列任务数量不超过上限，此时在take函数中占</span></span><br><span class=\"line\"><span class=\"comment\">            * 锁取走了一个任务，任务队列一定未满，所以放心调用notFull_.notify()通知</span></span><br><span class=\"line\"><span class=\"comment\">            * run函数即可。</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            notFull_.<span class=\"built_in\">notify</span>();  </span><br><span class=\"line\">        &#125;<span class=\"comment\">// else 若maxQueueSize_ == 0，说明任务队列大小无限，不存在执行notFull_.wait()分支的线程，无需调用notFull_.notify()。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ThreadPool::isFull</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    mutex_.<span class=\"built_in\">assertLocked</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxQueueSize_ &gt; <span class=\"number\">0</span> &amp;&amp; queue_.<span class=\"built_in\">size</span>() &gt;= maxQueueSize_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::runInThread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (threadInitCallback_)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">threadInitCallback_</span>();  <span class=\"comment\">// 执行一下初始化回调</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (running_)&#123;   <span class=\"comment\">// 就算要停止了，如果任务队列里面还有任务不继续消化任务吗？</span></span><br><span class=\"line\">            <span class=\"function\">Task <span class=\"title\">task</span><span class=\"params\">(take())</span></span>;  <span class=\"comment\">// 取任务</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (task)&#123;  <span class=\"comment\">// 空任务一般发生在线程池停止阶段。</span></span><br><span class=\"line\">                <span class=\"built_in\">task</span>(); <span class=\"comment\">// 执行任务。</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"built_in\">catch</span> (...)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 异常处理...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"细节明细：-1\"><a href=\"#细节明细：-1\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h3><p><strong>疑问：</strong></p>\n<p>Muduo的线程池中为什么要设置一个maxQueueSize_成员来限制任务队列的大小？</p>\n<p><strong>解答：</strong></p>\n<p>在Muduo网络库的线程池中设置maxQueueSize_成员来限制任务队列的大小是为了防止无限制的任务积压，以保护系统的稳定性和资源管理。这样的设计有以下几个原因：</p>\n<ol>\n<li><p>资源控制： 通过设置任务队列的最大大小，可以控制线程池在高负载情况下的资源占用。如果不限制任务队列大小，当任务提交速度远远大于线程池处理速度时，可能会导致任务队列无限增长，消耗大量内存资源，最终导致系统资源耗尽。</p>\n</li>\n<li><p>避免任务积压： 如果任务队列无限制增长，可能导致待处理的任务数量不断累积，进而导致系统的响应时间变长。通过设置最大队列大小，可以避免任务积压，确保系统对任务的响应是有限度的。</p>\n</li>\n<li><p>反馈机制： 当任务队列达到最大大小时，新的任务可能会被拒绝或者触发一些警告机制。这样的反馈机制可以让开发者或者系统管理员及时感知到系统的负载情况，并采取相应的措施，如调整线程池大小、优化任务处理逻辑等。（<strong>尽管在Muduo中，在代码实现上并没有实现这一点</strong>）</p>\n</li>\n</ol>\n<p><strong>疑问：</strong></p>\n<p>在ThreadPool::runInThread函数中，如果线程池要停止了（running_ &#x3D;&#x3D; false），假如任务队列里面还有任务不继续消化任务吗？我看Muduo的实现是，线程池停止，即使任务队列还有任务，ThreadPool::runInThread()也会直接跳出循环。为什么要这样设计？</p>\n<p><strong>解答：</strong></p>\n<p>线程池的停止有两种：</p>\n<ol>\n<li><p>Graceful Shutdown： 线程池的停止过程可能是优雅的，即允许已经在任务队列中的任务执行完毕，但不再接受新的任务。在这种情况下，可以通过设置running_为false来触发线程池停止，但允许已在队列中的任务继续执行。</p>\n</li>\n<li><p>快速停止： 另一种设计考虑是快速停止，即立即停止线程的执行，无论任务队列中是否还有任务。这可能是为了迅速释放线程池占用的资源，例如在应用程序关闭时。在这种情况下，即使有未执行的任务，也可以选择快速停止线程池。</p>\n</li>\n</ol>\n<p>具体选择采用哪种停止方式取决于应用程序的需求和设计目标。如果对任务的完成有严格的要求，可以选择优雅停止，确保所有任务得以执行。如果更注重迅速释放资源，可以选择快速停止。</p>\n<p>在Muduo中的设计选择了快速停止，一旦running_为false，即使任务队列中还有任务，线程也会直接退出。这种设计可能符合Muduo网络库的使用场景和性能需求。</p>\n<p><strong>maxQueueSize_ &#x3D;&#x3D; 0的特殊含义：</strong></p>\n<p>在Muduo网络库中，仔细梳理线程池的源码逻辑可以发现，如果maxQueueSize_的大小被设置为0，表示任务队列的大小没有限制，即队列可以无限增长。ThreadPool::isFull函数会始终返回false，此时在调用ThreadPool::run向任务队列添加任务时，会无条件将任务添加到任务队列，而且ThreadPool::take函数中，由于maxQueueSize_ &#x3D;&#x3D; 0，也不会去调用notFull_.notify()通知阻塞在ThreadPool::run的线程，因为在maxQueueSize_ &#x3D;&#x3D; 0条件下根本不可能有线程会阻塞在ThreadPool::run中。</p>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**闲聊**\n\n首先感慨一句，muduo库对C语言原生的线程安全以及同步的API的封装，真的称得上是教科书式的，非常精妙、规范，很值得学习。\n\n读者在阅读muduo源码的时候，看到类定义的类名称被一些宏定义修饰、以及类的成员变量被一些宏定义修饰时，可以直接忽略，无视这些宏。因为这些东西的存在完全不影响整体的功能。简单来说就是吓唬人的。不仅如此，在看muduo以及其他的源码的时候，我们没必要转牛角尖，死扣细节，对于一个类，如果我们可以猜到他的功能以及怎么实现的，我们可以直接看他在源码中的使用即可，没必要在这细节上面浪费精力，专注整体架构，以及思想，不太过专注细节，才是阅读一份源码的正确套路。\n## 原子操作\n\n提到原子操作，不得不顺便提一下c++ std::atomic的原子操作以及它的内存序，这个知识点，以后的博客再来记录。\n\n这里是muduo对gcc提供的原子操作api的封装：\n\n<!-- more -->\n```cpp\ntemplate<typename T>\nclass AtomicIntegerT : noncopyable\n{\npublic:\n    AtomicIntegerT()\n    : value_(0)\n    {\n    }\n    T get()\n    {\n        return __sync_val_compare_and_swap(&value_, 0, 0);\n    }\n\n    T getAndAdd(T x)\n    {\n        return __sync_fetch_and_add(&value_, x);\n    }\n\n    T addAndGet(T x)\n    {\n        return getAndAdd(x) + x;\n    }\n\n    T incrementAndGet()\n    {\n        return addAndGet(1);\n    }\n\n    T decrementAndGet()\n    {\n        return addAndGet(-1);\n    }\n\n    void add(T x)\n    {\n        getAndAdd(x);\n    }\n\n    void increment()\n    {\n        incrementAndGet();\n    }\n\n    void decrement()\n    {\n        decrementAndGet();\n    }\n\n    T getAndSet(T newValue)\n    {\n        return __sync_lock_test_and_set(&value_, newValue);\n    }\n\nprivate:\n    volatile T value_;\n};\n```\n\n1. 函数原型：`type __sync_val_compare_and_swap(type *ptr, type oldval, type newval, ...)`\n\n    **参数：**\n\n    - type：被操作的数据类型，可以是整数类型、指针等。\n    - ptr：要进行 CAS 操作的地址，通常是一个指针。\n    - oldval：期望的旧值。\n    - newval：新值。\n\n    **描述：**\n\n    该函数的作用是，如果 \\*ptr 的当前值等于 oldval，则将 \\*ptr 的值设置为 newval，并**返回 \\*ptr 之前的值**。如果 \\*ptr 的当前值不等于 oldval，则不进行任何操作，直接**返回 \\*ptr 的当前值**。\n\n    这样的操作是原子的，即在多线程环境下，不会被其他线程中断，确保了操作的一致性。CAS 操作通常用于实现锁、同步原语和非阻塞算法等。\n\n2. 函数原型：`type __sync_fetch_and_add(type *ptr, type value, ...)`\n\n    **参数：**\n\n    - type：被操作的数据类型，可以是整数类型、指针等。\n    - ptr：要进行自增操作的地址，通常是一个指针。\n    - value：要添加到 \\*ptr 的值。\n\n    **描述：**\n\n    该函数的作用是，将 \\*ptr 的值与 value 相加，**并返回 \\*ptr 之前的值**。这个操作是原子的，确保在多线程环境下不会被其他线程中断，从而保证了操作的一致性。自增操作通常用于实现计数器等场景。\n\n3. 函数原型：`type __sync_lock_test_and_set(type *ptr, type value, ...)`\n\n    **参数：**\n\n    - type：被操作的数据类型，可以是整数类型、指针等。\n    - ptr：要进行测试并设置的地址，通常是一个指针。\n    - value：将要设置到 \\*ptr 的值。\n\n    **描述：**\n\n    该函数的作用是，**返回 \\*ptr 之前的值**，并将 \\*ptr 的值设置为 value。这个操作是原子的，确保在多线程环境下不会被其他线程中断，从而保证了操作的一致性。\n\n## 互斥锁\n\n这里对互斥锁本身的科普就简要概括，主要专注muduo对Posix中的互斥锁的封装思想。\n\n互斥量资源的管理：\n```cpp\nclass CAPABILITY(\"mutex\") MutexLock : noncopyable\n{\npublic:\n    MutexLock()\n    : holder_(0)\n    {\n        MCHECK(pthread_mutex_init(&mutex_, NULL));\n    }\n\n    ~MutexLock()\n    {\n        assert(holder_ == 0);\n        MCHECK(pthread_mutex_destroy(&mutex_));\n    }\n\n    // must be called when locked, i.e. for assertion\n    bool isLockedByThisThread() const\n    {\n        return holder_ == CurrentThread::tid();\n    }\n\n    void assertLocked() const ASSERT_CAPABILITY(this)\n    {\n        assert(isLockedByThisThread());\n    }\n\n    // internal usage\n\n    void lock() ACQUIRE()\n    {\n        MCHECK(pthread_mutex_lock(&mutex_));\n        assignHolder();\n    }\n\n    void unlock() RELEASE()\n    {\n        unassignHolder();\n        MCHECK(pthread_mutex_unlock(&mutex_));\n    }\n\n    pthread_mutex_t* getPthreadMutex() /* non-const */\n    {\n        return &mutex_;\n    }\n\nprivate:\n    friend class Condition;\n\n    /*\n    * RAII机制，for条件变量\n    * 条件变量中，有详细解释其作用\n    */\n    class UnassignGuard : noncopyable\n    {\n    public:\n        explicit UnassignGuard(MutexLock& owner)\n            : owner_(owner)\n        {\n            owner_.unassignHolder();\n        }\n\n        ~UnassignGuard()\n        {\n            owner_.assignHolder();\n        }\n\n    private:\n        MutexLock& owner_;\n    };\n\n    void unassignHolder()\n    {\n        holder_ = 0;\n    }\n\n    void assignHolder()\n    {\n        holder_ = CurrentThread::tid();\n    }\n\n    pthread_mutex_t mutex_;\n    pid_t holder_;\n};\n```\n\n互斥锁加锁解锁的管理：\n\n```cpp\n/*\n* RAII机制\n*/\n// Use as a stack variable, eg.\n// int Foo::size() const\n// {\n//   MutexLockGuard lock(mutex_);\n//   return data_.size();\n// }\nclass SCOPED_CAPABILITY MutexLockGuard : noncopyable\n{\npublic:\n    explicit MutexLockGuard(MutexLock& mutex) ACQUIRE(mutex)\n    : mutex_(mutex)\n    {\n        mutex_.lock();\n    }\n\n    ~MutexLockGuard() RELEASE()\n    {\n        mutex_.unlock();\n    }\n\nprivate:\n\n    MutexLock& mutex_;\n};\n```\n\n互斥锁加锁解锁的管理，使用了C++大名顶顶的RAII机制，\n\n**RAII 的核心思想是：** 在对象的构造函数中获取资源，在析构函数中释放资源。这种方法能够确保资源在对象的生命周期内得到正确的管理，从而避免了手动管理资源的繁琐和容易出错的问题。\n\n**关键点：**\n\n1. **资源的获取和释放与对象的生命周期关联：** 资源（如内存、文件句柄、网络连接等）的获取和释放被绑定到了对象的构造和析构过程中，确保资源在对象生命周期内正确地管理。\n\n2. **构造函数中获取资源：** 在对象的构造函数中，资源被获取。这意味着当对象被创建时，相应的资源就被分配或初始化。\n\n3. **析构函数中释放资源：** 在对象的析构函数中，资源被释放。这确保了在对象生命周期结束时，与之相关的资源会被正确释放。\n\n4. **无需手动管理资源：** 由于资源的获取和释放与对象的生命周期关联，程序员无需手动管理资源。当对象超出作用域或者被删除时，其析构函数会自动被调用，从而释放关联的资源。\n\n**其他RAII应用的例子**\n\n智能指针、文件处理类、数据库连接类等。\n\n## 条件变量\n\nmuduo对条件变量本身的封装是没有解决惊群效应的，`pthread_cond_wait`函数没有放在while循环中。但是muduo在其他用到条件变量的地方，其实有利用while循环来解决惊群效应的。比如即将要聊到的`CountDownLatch`类的实现\n\n```cpp\nclass Condition : noncopyable\n{\npublic:\n    explicit Condition(MutexLock& mutex)\n    : mutex_(mutex)\n    {\n        MCHECK(pthread_cond_init(&pcond_, NULL));\n    }\n\n    ~Condition()\n    {\n        MCHECK(pthread_cond_destroy(&pcond_));\n    }\n\n    void wait()\n    {\n        /*\n        * 这里是raii机制的具体应用，因为MutexLock类里面有个成员变量holder_存储获取到\n        * mutex锁的线程id，每次线程对mutex加锁后就会将自己的tid赋值给holder_，而\n        * 在释放mutex锁前，会将holder_清零，以示当前mutex锁被哪个线程持有。而线程在等\n        * 待获取条件变量时，内部会原子加/解锁。所以为遵循holder_存在的意义，muduo为Condition\n        * 实现了UnassignGuard类，利用raii，在等待条件变量解锁前，在构造函数中，\n        * 将holder_清零；在获取到条件变量加锁后，在析构函数中，将holder_赋值为获锁线程\n        * 的tid。以此保证holder_严格随着获取mutex锁的线程变化。\n        */\n        MutexLock::UnassignGuard ug(mutex_);\n        MCHECK(pthread_cond_wait(&pcond_, mutex_.getPthreadMutex()));\n    }\n\n    // returns true if time out, false otherwise.\n    bool waitForSeconds(double seconds);\n\n    void notify()\n    {\n        MCHECK(pthread_cond_signal(&pcond_));\n    }\n\n    void notifyAll()\n    {\n        MCHECK(pthread_cond_broadcast(&pcond_));\n    }\n\nprivate:\n    MutexLock& mutex_;\n    pthread_cond_t pcond_;\n};\n```\n\n**关于条件变量和信号量的使用上的差别，说老实话，就我目前的功力，还没有深刻的感受，这里先mark一下，等哪天领悟到之后，再来聊一聊。**\n\n**补充：**\n\n1. 条件变量可以在条件满足时，一次唤醒所有等待条件的线程，但是信号量则不行，只能post一个信号量（资源），唤醒一个线程。在多个线程等待一个条件的满足时再**继续同时**执行的场景下，适合用条件变量。（好像此时也可以用信号量，无非就是多post几次。只是，信号量不适合该场景，而条件变量更加适合）\n\n## CountDownLatch（倒计数同步类）\n\n**使用场景：**\n\n1. 父线程等待多个子线程启动完毕，再继续执行： 在某些并发场景中，可能需要等待多个子线程都完成某个初始化操作后，父线程才能继续执行。CountDownLatch 可以用来等待这些线程的完成。\n\n2. 多个线程等待一个线程某个操作完毕，再继续执行： 可以使用 CountDownLatch 来协调多个线程的并发操作，确保某个操作在所有线程完成之后再执行。\n\n接口：\n\n```cpp\nclass CountDownLatch : noncopyable\n{\npublic:\n\n    explicit CountDownLatch(int count);\n\n    void wait();\n\n    void countDown();\n\n    int getCount() const;\n\nprivate:\n    mutable MutexLock mutex_;\n    Condition condition_ GUARDED_BY(mutex_);\n    int count_ GUARDED_BY(mutex_);\n};\n```\n\n实现：\n\n```cpp\nCountDownLatch::CountDownLatch(int count)\n  : mutex_(),\n    condition_(mutex_),\n    count_(count)\n{\n}\n\nvoid CountDownLatch::wait()\n{\n    MutexLockGuard lock(mutex_);\n    while (count_ > 0)\n    {   // while中解决了惊群效应\n        condition_.wait();\n    }\n}\n\nvoid CountDownLatch::countDown()\n{\n    MutexLockGuard lock(mutex_);\n    --count_;\n    if (count_ == 0)\n    {\n        // 减为零后，将所有处于条件等待队列的线程，移到枪锁等待队列。\n        condition_.notifyAll();\n    }\n}\n\nint CountDownLatch::getCount() const\n{\n    MutexLockGuard lock(mutex_);\n    return count_;\n}\n```\n\n**注意：**\n我之前用一个demo专门实验过，实验结果表明，线程A调用`pthread_cond_broadcast`唤醒其他所有调用`pthread_cond_wait`阻塞的线程时，所有线程会处于一个枪锁状态（从条件等待队列，移到枪锁队列），线程B抢到锁处理临界资源再释放锁后，其他处于枪锁队列的线程还是处于枪锁状态，并不需要等待条件信号的到来，抢到锁就能处理临界资源。\n\n---\n\n**本章完结**","source":"_posts/muduo/ThreadSafeAndSync.md","raw":"---\ntitle: muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）\ndate: 2024-11-02 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**闲聊**\n\n首先感慨一句，muduo库对C语言原生的线程安全以及同步的API的封装，真的称得上是教科书式的，非常精妙、规范，很值得学习。\n\n读者在阅读muduo源码的时候，看到类定义的类名称被一些宏定义修饰、以及类的成员变量被一些宏定义修饰时，可以直接忽略，无视这些宏。因为这些东西的存在完全不影响整体的功能。简单来说就是吓唬人的。不仅如此，在看muduo以及其他的源码的时候，我们没必要转牛角尖，死扣细节，对于一个类，如果我们可以猜到他的功能以及怎么实现的，我们可以直接看他在源码中的使用即可，没必要在这细节上面浪费精力，专注整体架构，以及思想，不太过专注细节，才是阅读一份源码的正确套路。\n## 原子操作\n\n提到原子操作，不得不顺便提一下c++ std::atomic的原子操作以及它的内存序，这个知识点，以后的博客再来记录。\n\n这里是muduo对gcc提供的原子操作api的封装：\n\n<!-- more -->\n```cpp\ntemplate<typename T>\nclass AtomicIntegerT : noncopyable\n{\npublic:\n    AtomicIntegerT()\n    : value_(0)\n    {\n    }\n    T get()\n    {\n        return __sync_val_compare_and_swap(&value_, 0, 0);\n    }\n\n    T getAndAdd(T x)\n    {\n        return __sync_fetch_and_add(&value_, x);\n    }\n\n    T addAndGet(T x)\n    {\n        return getAndAdd(x) + x;\n    }\n\n    T incrementAndGet()\n    {\n        return addAndGet(1);\n    }\n\n    T decrementAndGet()\n    {\n        return addAndGet(-1);\n    }\n\n    void add(T x)\n    {\n        getAndAdd(x);\n    }\n\n    void increment()\n    {\n        incrementAndGet();\n    }\n\n    void decrement()\n    {\n        decrementAndGet();\n    }\n\n    T getAndSet(T newValue)\n    {\n        return __sync_lock_test_and_set(&value_, newValue);\n    }\n\nprivate:\n    volatile T value_;\n};\n```\n\n1. 函数原型：`type __sync_val_compare_and_swap(type *ptr, type oldval, type newval, ...)`\n\n    **参数：**\n\n    - type：被操作的数据类型，可以是整数类型、指针等。\n    - ptr：要进行 CAS 操作的地址，通常是一个指针。\n    - oldval：期望的旧值。\n    - newval：新值。\n\n    **描述：**\n\n    该函数的作用是，如果 \\*ptr 的当前值等于 oldval，则将 \\*ptr 的值设置为 newval，并**返回 \\*ptr 之前的值**。如果 \\*ptr 的当前值不等于 oldval，则不进行任何操作，直接**返回 \\*ptr 的当前值**。\n\n    这样的操作是原子的，即在多线程环境下，不会被其他线程中断，确保了操作的一致性。CAS 操作通常用于实现锁、同步原语和非阻塞算法等。\n\n2. 函数原型：`type __sync_fetch_and_add(type *ptr, type value, ...)`\n\n    **参数：**\n\n    - type：被操作的数据类型，可以是整数类型、指针等。\n    - ptr：要进行自增操作的地址，通常是一个指针。\n    - value：要添加到 \\*ptr 的值。\n\n    **描述：**\n\n    该函数的作用是，将 \\*ptr 的值与 value 相加，**并返回 \\*ptr 之前的值**。这个操作是原子的，确保在多线程环境下不会被其他线程中断，从而保证了操作的一致性。自增操作通常用于实现计数器等场景。\n\n3. 函数原型：`type __sync_lock_test_and_set(type *ptr, type value, ...)`\n\n    **参数：**\n\n    - type：被操作的数据类型，可以是整数类型、指针等。\n    - ptr：要进行测试并设置的地址，通常是一个指针。\n    - value：将要设置到 \\*ptr 的值。\n\n    **描述：**\n\n    该函数的作用是，**返回 \\*ptr 之前的值**，并将 \\*ptr 的值设置为 value。这个操作是原子的，确保在多线程环境下不会被其他线程中断，从而保证了操作的一致性。\n\n## 互斥锁\n\n这里对互斥锁本身的科普就简要概括，主要专注muduo对Posix中的互斥锁的封装思想。\n\n互斥量资源的管理：\n```cpp\nclass CAPABILITY(\"mutex\") MutexLock : noncopyable\n{\npublic:\n    MutexLock()\n    : holder_(0)\n    {\n        MCHECK(pthread_mutex_init(&mutex_, NULL));\n    }\n\n    ~MutexLock()\n    {\n        assert(holder_ == 0);\n        MCHECK(pthread_mutex_destroy(&mutex_));\n    }\n\n    // must be called when locked, i.e. for assertion\n    bool isLockedByThisThread() const\n    {\n        return holder_ == CurrentThread::tid();\n    }\n\n    void assertLocked() const ASSERT_CAPABILITY(this)\n    {\n        assert(isLockedByThisThread());\n    }\n\n    // internal usage\n\n    void lock() ACQUIRE()\n    {\n        MCHECK(pthread_mutex_lock(&mutex_));\n        assignHolder();\n    }\n\n    void unlock() RELEASE()\n    {\n        unassignHolder();\n        MCHECK(pthread_mutex_unlock(&mutex_));\n    }\n\n    pthread_mutex_t* getPthreadMutex() /* non-const */\n    {\n        return &mutex_;\n    }\n\nprivate:\n    friend class Condition;\n\n    /*\n    * RAII机制，for条件变量\n    * 条件变量中，有详细解释其作用\n    */\n    class UnassignGuard : noncopyable\n    {\n    public:\n        explicit UnassignGuard(MutexLock& owner)\n            : owner_(owner)\n        {\n            owner_.unassignHolder();\n        }\n\n        ~UnassignGuard()\n        {\n            owner_.assignHolder();\n        }\n\n    private:\n        MutexLock& owner_;\n    };\n\n    void unassignHolder()\n    {\n        holder_ = 0;\n    }\n\n    void assignHolder()\n    {\n        holder_ = CurrentThread::tid();\n    }\n\n    pthread_mutex_t mutex_;\n    pid_t holder_;\n};\n```\n\n互斥锁加锁解锁的管理：\n\n```cpp\n/*\n* RAII机制\n*/\n// Use as a stack variable, eg.\n// int Foo::size() const\n// {\n//   MutexLockGuard lock(mutex_);\n//   return data_.size();\n// }\nclass SCOPED_CAPABILITY MutexLockGuard : noncopyable\n{\npublic:\n    explicit MutexLockGuard(MutexLock& mutex) ACQUIRE(mutex)\n    : mutex_(mutex)\n    {\n        mutex_.lock();\n    }\n\n    ~MutexLockGuard() RELEASE()\n    {\n        mutex_.unlock();\n    }\n\nprivate:\n\n    MutexLock& mutex_;\n};\n```\n\n互斥锁加锁解锁的管理，使用了C++大名顶顶的RAII机制，\n\n**RAII 的核心思想是：** 在对象的构造函数中获取资源，在析构函数中释放资源。这种方法能够确保资源在对象的生命周期内得到正确的管理，从而避免了手动管理资源的繁琐和容易出错的问题。\n\n**关键点：**\n\n1. **资源的获取和释放与对象的生命周期关联：** 资源（如内存、文件句柄、网络连接等）的获取和释放被绑定到了对象的构造和析构过程中，确保资源在对象生命周期内正确地管理。\n\n2. **构造函数中获取资源：** 在对象的构造函数中，资源被获取。这意味着当对象被创建时，相应的资源就被分配或初始化。\n\n3. **析构函数中释放资源：** 在对象的析构函数中，资源被释放。这确保了在对象生命周期结束时，与之相关的资源会被正确释放。\n\n4. **无需手动管理资源：** 由于资源的获取和释放与对象的生命周期关联，程序员无需手动管理资源。当对象超出作用域或者被删除时，其析构函数会自动被调用，从而释放关联的资源。\n\n**其他RAII应用的例子**\n\n智能指针、文件处理类、数据库连接类等。\n\n## 条件变量\n\nmuduo对条件变量本身的封装是没有解决惊群效应的，`pthread_cond_wait`函数没有放在while循环中。但是muduo在其他用到条件变量的地方，其实有利用while循环来解决惊群效应的。比如即将要聊到的`CountDownLatch`类的实现\n\n```cpp\nclass Condition : noncopyable\n{\npublic:\n    explicit Condition(MutexLock& mutex)\n    : mutex_(mutex)\n    {\n        MCHECK(pthread_cond_init(&pcond_, NULL));\n    }\n\n    ~Condition()\n    {\n        MCHECK(pthread_cond_destroy(&pcond_));\n    }\n\n    void wait()\n    {\n        /*\n        * 这里是raii机制的具体应用，因为MutexLock类里面有个成员变量holder_存储获取到\n        * mutex锁的线程id，每次线程对mutex加锁后就会将自己的tid赋值给holder_，而\n        * 在释放mutex锁前，会将holder_清零，以示当前mutex锁被哪个线程持有。而线程在等\n        * 待获取条件变量时，内部会原子加/解锁。所以为遵循holder_存在的意义，muduo为Condition\n        * 实现了UnassignGuard类，利用raii，在等待条件变量解锁前，在构造函数中，\n        * 将holder_清零；在获取到条件变量加锁后，在析构函数中，将holder_赋值为获锁线程\n        * 的tid。以此保证holder_严格随着获取mutex锁的线程变化。\n        */\n        MutexLock::UnassignGuard ug(mutex_);\n        MCHECK(pthread_cond_wait(&pcond_, mutex_.getPthreadMutex()));\n    }\n\n    // returns true if time out, false otherwise.\n    bool waitForSeconds(double seconds);\n\n    void notify()\n    {\n        MCHECK(pthread_cond_signal(&pcond_));\n    }\n\n    void notifyAll()\n    {\n        MCHECK(pthread_cond_broadcast(&pcond_));\n    }\n\nprivate:\n    MutexLock& mutex_;\n    pthread_cond_t pcond_;\n};\n```\n\n**关于条件变量和信号量的使用上的差别，说老实话，就我目前的功力，还没有深刻的感受，这里先mark一下，等哪天领悟到之后，再来聊一聊。**\n\n**补充：**\n\n1. 条件变量可以在条件满足时，一次唤醒所有等待条件的线程，但是信号量则不行，只能post一个信号量（资源），唤醒一个线程。在多个线程等待一个条件的满足时再**继续同时**执行的场景下，适合用条件变量。（好像此时也可以用信号量，无非就是多post几次。只是，信号量不适合该场景，而条件变量更加适合）\n\n## CountDownLatch（倒计数同步类）\n\n**使用场景：**\n\n1. 父线程等待多个子线程启动完毕，再继续执行： 在某些并发场景中，可能需要等待多个子线程都完成某个初始化操作后，父线程才能继续执行。CountDownLatch 可以用来等待这些线程的完成。\n\n2. 多个线程等待一个线程某个操作完毕，再继续执行： 可以使用 CountDownLatch 来协调多个线程的并发操作，确保某个操作在所有线程完成之后再执行。\n\n接口：\n\n```cpp\nclass CountDownLatch : noncopyable\n{\npublic:\n\n    explicit CountDownLatch(int count);\n\n    void wait();\n\n    void countDown();\n\n    int getCount() const;\n\nprivate:\n    mutable MutexLock mutex_;\n    Condition condition_ GUARDED_BY(mutex_);\n    int count_ GUARDED_BY(mutex_);\n};\n```\n\n实现：\n\n```cpp\nCountDownLatch::CountDownLatch(int count)\n  : mutex_(),\n    condition_(mutex_),\n    count_(count)\n{\n}\n\nvoid CountDownLatch::wait()\n{\n    MutexLockGuard lock(mutex_);\n    while (count_ > 0)\n    {   // while中解决了惊群效应\n        condition_.wait();\n    }\n}\n\nvoid CountDownLatch::countDown()\n{\n    MutexLockGuard lock(mutex_);\n    --count_;\n    if (count_ == 0)\n    {\n        // 减为零后，将所有处于条件等待队列的线程，移到枪锁等待队列。\n        condition_.notifyAll();\n    }\n}\n\nint CountDownLatch::getCount() const\n{\n    MutexLockGuard lock(mutex_);\n    return count_;\n}\n```\n\n**注意：**\n我之前用一个demo专门实验过，实验结果表明，线程A调用`pthread_cond_broadcast`唤醒其他所有调用`pthread_cond_wait`阻塞的线程时，所有线程会处于一个枪锁状态（从条件等待队列，移到枪锁队列），线程B抢到锁处理临界资源再释放锁后，其他处于枪锁队列的线程还是处于枪锁状态，并不需要等待条件信号的到来，抢到锁就能处理临界资源。\n\n---\n\n**本章完结**","slug":"muduo/ThreadSafeAndSync","published":1,"updated":"2025-09-28T16:06:43.135Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9s000qq8wsfjymfkx3","content":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>闲聊</strong></p>\n<p>首先感慨一句，muduo库对C语言原生的线程安全以及同步的API的封装，真的称得上是教科书式的，非常精妙、规范，很值得学习。</p>\n<p>读者在阅读muduo源码的时候，看到类定义的类名称被一些宏定义修饰、以及类的成员变量被一些宏定义修饰时，可以直接忽略，无视这些宏。因为这些东西的存在完全不影响整体的功能。简单来说就是吓唬人的。不仅如此，在看muduo以及其他的源码的时候，我们没必要转牛角尖，死扣细节，对于一个类，如果我们可以猜到他的功能以及怎么实现的，我们可以直接看他在源码中的使用即可，没必要在这细节上面浪费精力，专注整体架构，以及思想，不太过专注细节，才是阅读一份源码的正确套路。</p>\n<h2 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h2><p>提到原子操作，不得不顺便提一下c++ std::atomic的原子操作以及它的内存序，这个知识点，以后的博客再来记录。</p>\n<p>这里是muduo对gcc提供的原子操作api的封装：</p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AtomicIntegerT</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">AtomicIntegerT</span>()</span><br><span class=\"line\">    : <span class=\"built_in\">value_</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __sync_val_compare_and_swap(&amp;value_, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">getAndAdd</span><span class=\"params\">(T x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __sync_fetch_and_add(&amp;value_, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">addAndGet</span><span class=\"params\">(T x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">getAndAdd</span>(x) + x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">incrementAndGet</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">addAndGet</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">decrementAndGet</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">addAndGet</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(T x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">getAndAdd</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">incrementAndGet</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">decrement</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">decrementAndGet</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">getAndSet</span><span class=\"params\">(T newValue)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __sync_lock_test_and_set(&amp;value_, newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> T value_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>函数原型：<code>type __sync_val_compare_and_swap(type *ptr, type oldval, type newval, ...)</code></p>\n<p> <strong>参数：</strong></p>\n<ul>\n<li>type：被操作的数据类型，可以是整数类型、指针等。</li>\n<li>ptr：要进行 CAS 操作的地址，通常是一个指针。</li>\n<li>oldval：期望的旧值。</li>\n<li>newval：新值。</li>\n</ul>\n<p> <strong>描述：</strong></p>\n<p> 该函数的作用是，如果 *ptr 的当前值等于 oldval，则将 *ptr 的值设置为 newval，并<strong>返回 *ptr 之前的值</strong>。如果 *ptr 的当前值不等于 oldval，则不进行任何操作，直接<strong>返回 *ptr 的当前值</strong>。</p>\n<p> 这样的操作是原子的，即在多线程环境下，不会被其他线程中断，确保了操作的一致性。CAS 操作通常用于实现锁、同步原语和非阻塞算法等。</p>\n</li>\n<li><p>函数原型：<code>type __sync_fetch_and_add(type *ptr, type value, ...)</code></p>\n<p> <strong>参数：</strong></p>\n<ul>\n<li>type：被操作的数据类型，可以是整数类型、指针等。</li>\n<li>ptr：要进行自增操作的地址，通常是一个指针。</li>\n<li>value：要添加到 *ptr 的值。</li>\n</ul>\n<p> <strong>描述：</strong></p>\n<p> 该函数的作用是，将 *ptr 的值与 value 相加，<strong>并返回 *ptr 之前的值</strong>。这个操作是原子的，确保在多线程环境下不会被其他线程中断，从而保证了操作的一致性。自增操作通常用于实现计数器等场景。</p>\n</li>\n<li><p>函数原型：<code>type __sync_lock_test_and_set(type *ptr, type value, ...)</code></p>\n<p> <strong>参数：</strong></p>\n<ul>\n<li>type：被操作的数据类型，可以是整数类型、指针等。</li>\n<li>ptr：要进行测试并设置的地址，通常是一个指针。</li>\n<li>value：将要设置到 *ptr 的值。</li>\n</ul>\n<p> <strong>描述：</strong></p>\n<p> 该函数的作用是，<strong>返回 *ptr 之前的值</strong>，并将 *ptr 的值设置为 value。这个操作是原子的，确保在多线程环境下不会被其他线程中断，从而保证了操作的一致性。</p>\n</li>\n</ol>\n<h2 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h2><p>这里对互斥锁本身的科普就简要概括，主要专注muduo对Posix中的互斥锁的封装思想。</p>\n<p>互斥量资源的管理：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> <span class=\"title\">CAPABILITY</span><span class=\"params\">(<span class=\"string\">&quot;mutex&quot;</span>)</span> MutexLock : noncopyable</span></span><br><span class=\"line\"><span class=\"function\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MutexLock</span>()</span><br><span class=\"line\">    : <span class=\"built_in\">holder_</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_init</span>(&amp;mutex_, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">MutexLock</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(holder_ == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_destroy</span>(&amp;mutex_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// must be called when locked, i.e. for assertion</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isLockedByThisThread</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> holder_ == CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assertLocked</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"title\">ASSERT_CAPABILITY</span><span class=\"params\">(<span class=\"keyword\">this</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">isLockedByThisThread</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// internal usage</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> <span class=\"title\">ACQUIRE</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_lock</span>(&amp;mutex_));</span><br><span class=\"line\">        <span class=\"built_in\">assignHolder</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> <span class=\"title\">RELEASE</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unassignHolder</span>();</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;mutex_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">pthread_mutex_t</span>* <span class=\"title\">getPthreadMutex</span><span class=\"params\">()</span> <span class=\"comment\">/* non-const */</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;mutex_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Condition</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * RAII机制，for条件变量</span></span><br><span class=\"line\"><span class=\"comment\">    * 条件变量中，有详细解释其作用</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">UnassignGuard</span> : noncopyable</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">UnassignGuard</span><span class=\"params\">(MutexLock&amp; owner)</span></span></span><br><span class=\"line\"><span class=\"function\">            : owner_(owner)</span></span><br><span class=\"line\"><span class=\"function\">        &#123;</span></span><br><span class=\"line\">            owner_.<span class=\"built_in\">unassignHolder</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ~<span class=\"built_in\">UnassignGuard</span>()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            owner_.<span class=\"built_in\">assignHolder</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        MutexLock&amp; owner_;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unassignHolder</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        holder_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assignHolder</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        holder_ = CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pthread_mutex_t</span> mutex_;</span><br><span class=\"line\">    <span class=\"type\">pid_t</span> holder_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>互斥锁加锁解锁的管理：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* RAII机制</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// Use as a stack variable, eg.</span></span><br><span class=\"line\"><span class=\"comment\">// int Foo::size() const</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   MutexLockGuard lock(mutex_);</span></span><br><span class=\"line\"><span class=\"comment\">//   return data_.size();</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SCOPED_CAPABILITY</span> MutexLockGuard : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">MutexLockGuard</span><span class=\"params\">(MutexLock&amp; mutex)</span> <span class=\"title\">ACQUIRE</span><span class=\"params\">(mutex)</span></span></span><br><span class=\"line\"><span class=\"function\">    : mutex_(mutex)</span></span><br><span class=\"line\"><span class=\"function\">    &#123;</span></span><br><span class=\"line\">        mutex_.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">MutexLockGuard</span>() <span class=\"built_in\">RELEASE</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        mutex_.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    MutexLock&amp; mutex_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>互斥锁加锁解锁的管理，使用了C++大名顶顶的RAII机制，</p>\n<p><strong>RAII 的核心思想是：</strong> 在对象的构造函数中获取资源，在析构函数中释放资源。这种方法能够确保资源在对象的生命周期内得到正确的管理，从而避免了手动管理资源的繁琐和容易出错的问题。</p>\n<p><strong>关键点：</strong></p>\n<ol>\n<li><p><strong>资源的获取和释放与对象的生命周期关联：</strong> 资源（如内存、文件句柄、网络连接等）的获取和释放被绑定到了对象的构造和析构过程中，确保资源在对象生命周期内正确地管理。</p>\n</li>\n<li><p><strong>构造函数中获取资源：</strong> 在对象的构造函数中，资源被获取。这意味着当对象被创建时，相应的资源就被分配或初始化。</p>\n</li>\n<li><p><strong>析构函数中释放资源：</strong> 在对象的析构函数中，资源被释放。这确保了在对象生命周期结束时，与之相关的资源会被正确释放。</p>\n</li>\n<li><p><strong>无需手动管理资源：</strong> 由于资源的获取和释放与对象的生命周期关联，程序员无需手动管理资源。当对象超出作用域或者被删除时，其析构函数会自动被调用，从而释放关联的资源。</p>\n</li>\n</ol>\n<p><strong>其他RAII应用的例子</strong></p>\n<p>智能指针、文件处理类、数据库连接类等。</p>\n<h2 id=\"条件变量\"><a href=\"#条件变量\" class=\"headerlink\" title=\"条件变量\"></a>条件变量</h2><p>muduo对条件变量本身的封装是没有解决惊群效应的，<code>pthread_cond_wait</code>函数没有放在while循环中。但是muduo在其他用到条件变量的地方，其实有利用while循环来解决惊群效应的。比如即将要聊到的<code>CountDownLatch</code>类的实现</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Condition</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Condition</span><span class=\"params\">(MutexLock&amp; mutex)</span></span></span><br><span class=\"line\"><span class=\"function\">    : mutex_(mutex)</span></span><br><span class=\"line\"><span class=\"function\">    &#123;</span></span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_init</span>(&amp;pcond_, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">Condition</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_destroy</span>(&amp;pcond_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wait</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 这里是raii机制的具体应用，因为MutexLock类里面有个成员变量holder_存储获取到</span></span><br><span class=\"line\"><span class=\"comment\">        * mutex锁的线程id，每次线程对mutex加锁后就会将自己的tid赋值给holder_，而</span></span><br><span class=\"line\"><span class=\"comment\">        * 在释放mutex锁前，会将holder_清零，以示当前mutex锁被哪个线程持有。而线程在等</span></span><br><span class=\"line\"><span class=\"comment\">        * 待获取条件变量时，内部会原子加/解锁。所以为遵循holder_存在的意义，muduo为Condition</span></span><br><span class=\"line\"><span class=\"comment\">        * 实现了UnassignGuard类，利用raii，在等待条件变量解锁前，在构造函数中，</span></span><br><span class=\"line\"><span class=\"comment\">        * 将holder_清零；在获取到条件变量加锁后，在析构函数中，将holder_赋值为获锁线程</span></span><br><span class=\"line\"><span class=\"comment\">        * 的tid。以此保证holder_严格随着获取mutex锁的线程变化。</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"function\">MutexLock::UnassignGuard <span class=\"title\">ug</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_wait</span>(&amp;pcond_, mutex_.<span class=\"built_in\">getPthreadMutex</span>()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// returns true if time out, false otherwise.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">waitForSeconds</span><span class=\"params\">(<span class=\"type\">double</span> seconds)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">notify</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_signal</span>(&amp;pcond_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">notifyAll</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_broadcast</span>(&amp;pcond_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    MutexLock&amp; mutex_;</span><br><span class=\"line\">    <span class=\"type\">pthread_cond_t</span> pcond_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>关于条件变量和信号量的使用上的差别，说老实话，就我目前的功力，还没有深刻的感受，这里先mark一下，等哪天领悟到之后，再来聊一聊。</strong></p>\n<p><strong>补充：</strong></p>\n<ol>\n<li>条件变量可以在条件满足时，一次唤醒所有等待条件的线程，但是信号量则不行，只能post一个信号量（资源），唤醒一个线程。在多个线程等待一个条件的满足时再<strong>继续同时</strong>执行的场景下，适合用条件变量。（好像此时也可以用信号量，无非就是多post几次。只是，信号量不适合该场景，而条件变量更加适合）</li>\n</ol>\n<h2 id=\"CountDownLatch（倒计数同步类）\"><a href=\"#CountDownLatch（倒计数同步类）\" class=\"headerlink\" title=\"CountDownLatch（倒计数同步类）\"></a>CountDownLatch（倒计数同步类）</h2><p><strong>使用场景：</strong></p>\n<ol>\n<li><p>父线程等待多个子线程启动完毕，再继续执行： 在某些并发场景中，可能需要等待多个子线程都完成某个初始化操作后，父线程才能继续执行。CountDownLatch 可以用来等待这些线程的完成。</p>\n</li>\n<li><p>多个线程等待一个线程某个操作完毕，再继续执行： 可以使用 CountDownLatch 来协调多个线程的并发操作，确保某个操作在所有线程完成之后再执行。</p>\n</li>\n</ol>\n<p>接口：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CountDownLatch</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">CountDownLatch</span><span class=\"params\">(<span class=\"type\">int</span> count)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wait</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">countDown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">Condition condition_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> count_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CountDownLatch::<span class=\"built_in\">CountDownLatch</span>(<span class=\"type\">int</span> count)</span><br><span class=\"line\">  : <span class=\"built_in\">mutex_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">condition_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">count_</span>(count)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CountDownLatch::wait</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (count_ &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;   <span class=\"comment\">// while中解决了惊群效应</span></span><br><span class=\"line\">        condition_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CountDownLatch::countDown</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    --count_;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count_ == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 减为零后，将所有处于条件等待队列的线程，移到枪锁等待队列。</span></span><br><span class=\"line\">        condition_.<span class=\"built_in\">notifyAll</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">CountDownLatch::getCount</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong><br>我之前用一个demo专门实验过，实验结果表明，线程A调用<code>pthread_cond_broadcast</code>唤醒其他所有调用<code>pthread_cond_wait</code>阻塞的线程时，所有线程会处于一个枪锁状态（从条件等待队列，移到枪锁队列），线程B抢到锁处理临界资源再释放锁后，其他处于枪锁队列的线程还是处于枪锁状态，并不需要等待条件信号的到来，抢到锁就能处理临界资源。</p>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>闲聊</strong></p>\n<p>首先感慨一句，muduo库对C语言原生的线程安全以及同步的API的封装，真的称得上是教科书式的，非常精妙、规范，很值得学习。</p>\n<p>读者在阅读muduo源码的时候，看到类定义的类名称被一些宏定义修饰、以及类的成员变量被一些宏定义修饰时，可以直接忽略，无视这些宏。因为这些东西的存在完全不影响整体的功能。简单来说就是吓唬人的。不仅如此，在看muduo以及其他的源码的时候，我们没必要转牛角尖，死扣细节，对于一个类，如果我们可以猜到他的功能以及怎么实现的，我们可以直接看他在源码中的使用即可，没必要在这细节上面浪费精力，专注整体架构，以及思想，不太过专注细节，才是阅读一份源码的正确套路。</p>\n<h2 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h2><p>提到原子操作，不得不顺便提一下c++ std::atomic的原子操作以及它的内存序，这个知识点，以后的博客再来记录。</p>\n<p>这里是muduo对gcc提供的原子操作api的封装：</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AtomicIntegerT</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">AtomicIntegerT</span>()</span><br><span class=\"line\">    : <span class=\"built_in\">value_</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __sync_val_compare_and_swap(&amp;value_, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">getAndAdd</span><span class=\"params\">(T x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __sync_fetch_and_add(&amp;value_, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">addAndGet</span><span class=\"params\">(T x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">getAndAdd</span>(x) + x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">incrementAndGet</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">addAndGet</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">decrementAndGet</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">addAndGet</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(T x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">getAndAdd</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">incrementAndGet</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">decrement</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">decrementAndGet</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">getAndSet</span><span class=\"params\">(T newValue)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __sync_lock_test_and_set(&amp;value_, newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> T value_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>函数原型：<code>type __sync_val_compare_and_swap(type *ptr, type oldval, type newval, ...)</code></p>\n<p> <strong>参数：</strong></p>\n<ul>\n<li>type：被操作的数据类型，可以是整数类型、指针等。</li>\n<li>ptr：要进行 CAS 操作的地址，通常是一个指针。</li>\n<li>oldval：期望的旧值。</li>\n<li>newval：新值。</li>\n</ul>\n<p> <strong>描述：</strong></p>\n<p> 该函数的作用是，如果 *ptr 的当前值等于 oldval，则将 *ptr 的值设置为 newval，并<strong>返回 *ptr 之前的值</strong>。如果 *ptr 的当前值不等于 oldval，则不进行任何操作，直接<strong>返回 *ptr 的当前值</strong>。</p>\n<p> 这样的操作是原子的，即在多线程环境下，不会被其他线程中断，确保了操作的一致性。CAS 操作通常用于实现锁、同步原语和非阻塞算法等。</p>\n</li>\n<li><p>函数原型：<code>type __sync_fetch_and_add(type *ptr, type value, ...)</code></p>\n<p> <strong>参数：</strong></p>\n<ul>\n<li>type：被操作的数据类型，可以是整数类型、指针等。</li>\n<li>ptr：要进行自增操作的地址，通常是一个指针。</li>\n<li>value：要添加到 *ptr 的值。</li>\n</ul>\n<p> <strong>描述：</strong></p>\n<p> 该函数的作用是，将 *ptr 的值与 value 相加，<strong>并返回 *ptr 之前的值</strong>。这个操作是原子的，确保在多线程环境下不会被其他线程中断，从而保证了操作的一致性。自增操作通常用于实现计数器等场景。</p>\n</li>\n<li><p>函数原型：<code>type __sync_lock_test_and_set(type *ptr, type value, ...)</code></p>\n<p> <strong>参数：</strong></p>\n<ul>\n<li>type：被操作的数据类型，可以是整数类型、指针等。</li>\n<li>ptr：要进行测试并设置的地址，通常是一个指针。</li>\n<li>value：将要设置到 *ptr 的值。</li>\n</ul>\n<p> <strong>描述：</strong></p>\n<p> 该函数的作用是，<strong>返回 *ptr 之前的值</strong>，并将 *ptr 的值设置为 value。这个操作是原子的，确保在多线程环境下不会被其他线程中断，从而保证了操作的一致性。</p>\n</li>\n</ol>\n<h2 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h2><p>这里对互斥锁本身的科普就简要概括，主要专注muduo对Posix中的互斥锁的封装思想。</p>\n<p>互斥量资源的管理：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> <span class=\"title\">CAPABILITY</span><span class=\"params\">(<span class=\"string\">&quot;mutex&quot;</span>)</span> MutexLock : noncopyable</span></span><br><span class=\"line\"><span class=\"function\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MutexLock</span>()</span><br><span class=\"line\">    : <span class=\"built_in\">holder_</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_init</span>(&amp;mutex_, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">MutexLock</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(holder_ == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_destroy</span>(&amp;mutex_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// must be called when locked, i.e. for assertion</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isLockedByThisThread</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> holder_ == CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assertLocked</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"title\">ASSERT_CAPABILITY</span><span class=\"params\">(<span class=\"keyword\">this</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">isLockedByThisThread</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// internal usage</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> <span class=\"title\">ACQUIRE</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_lock</span>(&amp;mutex_));</span><br><span class=\"line\">        <span class=\"built_in\">assignHolder</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> <span class=\"title\">RELEASE</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unassignHolder</span>();</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;mutex_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">pthread_mutex_t</span>* <span class=\"title\">getPthreadMutex</span><span class=\"params\">()</span> <span class=\"comment\">/* non-const */</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;mutex_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Condition</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * RAII机制，for条件变量</span></span><br><span class=\"line\"><span class=\"comment\">    * 条件变量中，有详细解释其作用</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">UnassignGuard</span> : noncopyable</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">UnassignGuard</span><span class=\"params\">(MutexLock&amp; owner)</span></span></span><br><span class=\"line\"><span class=\"function\">            : owner_(owner)</span></span><br><span class=\"line\"><span class=\"function\">        &#123;</span></span><br><span class=\"line\">            owner_.<span class=\"built_in\">unassignHolder</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ~<span class=\"built_in\">UnassignGuard</span>()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            owner_.<span class=\"built_in\">assignHolder</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        MutexLock&amp; owner_;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unassignHolder</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        holder_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assignHolder</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        holder_ = CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pthread_mutex_t</span> mutex_;</span><br><span class=\"line\">    <span class=\"type\">pid_t</span> holder_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>互斥锁加锁解锁的管理：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* RAII机制</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// Use as a stack variable, eg.</span></span><br><span class=\"line\"><span class=\"comment\">// int Foo::size() const</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   MutexLockGuard lock(mutex_);</span></span><br><span class=\"line\"><span class=\"comment\">//   return data_.size();</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SCOPED_CAPABILITY</span> MutexLockGuard : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">MutexLockGuard</span><span class=\"params\">(MutexLock&amp; mutex)</span> <span class=\"title\">ACQUIRE</span><span class=\"params\">(mutex)</span></span></span><br><span class=\"line\"><span class=\"function\">    : mutex_(mutex)</span></span><br><span class=\"line\"><span class=\"function\">    &#123;</span></span><br><span class=\"line\">        mutex_.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">MutexLockGuard</span>() <span class=\"built_in\">RELEASE</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        mutex_.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    MutexLock&amp; mutex_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>互斥锁加锁解锁的管理，使用了C++大名顶顶的RAII机制，</p>\n<p><strong>RAII 的核心思想是：</strong> 在对象的构造函数中获取资源，在析构函数中释放资源。这种方法能够确保资源在对象的生命周期内得到正确的管理，从而避免了手动管理资源的繁琐和容易出错的问题。</p>\n<p><strong>关键点：</strong></p>\n<ol>\n<li><p><strong>资源的获取和释放与对象的生命周期关联：</strong> 资源（如内存、文件句柄、网络连接等）的获取和释放被绑定到了对象的构造和析构过程中，确保资源在对象生命周期内正确地管理。</p>\n</li>\n<li><p><strong>构造函数中获取资源：</strong> 在对象的构造函数中，资源被获取。这意味着当对象被创建时，相应的资源就被分配或初始化。</p>\n</li>\n<li><p><strong>析构函数中释放资源：</strong> 在对象的析构函数中，资源被释放。这确保了在对象生命周期结束时，与之相关的资源会被正确释放。</p>\n</li>\n<li><p><strong>无需手动管理资源：</strong> 由于资源的获取和释放与对象的生命周期关联，程序员无需手动管理资源。当对象超出作用域或者被删除时，其析构函数会自动被调用，从而释放关联的资源。</p>\n</li>\n</ol>\n<p><strong>其他RAII应用的例子</strong></p>\n<p>智能指针、文件处理类、数据库连接类等。</p>\n<h2 id=\"条件变量\"><a href=\"#条件变量\" class=\"headerlink\" title=\"条件变量\"></a>条件变量</h2><p>muduo对条件变量本身的封装是没有解决惊群效应的，<code>pthread_cond_wait</code>函数没有放在while循环中。但是muduo在其他用到条件变量的地方，其实有利用while循环来解决惊群效应的。比如即将要聊到的<code>CountDownLatch</code>类的实现</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Condition</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Condition</span><span class=\"params\">(MutexLock&amp; mutex)</span></span></span><br><span class=\"line\"><span class=\"function\">    : mutex_(mutex)</span></span><br><span class=\"line\"><span class=\"function\">    &#123;</span></span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_init</span>(&amp;pcond_, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">Condition</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_destroy</span>(&amp;pcond_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wait</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 这里是raii机制的具体应用，因为MutexLock类里面有个成员变量holder_存储获取到</span></span><br><span class=\"line\"><span class=\"comment\">        * mutex锁的线程id，每次线程对mutex加锁后就会将自己的tid赋值给holder_，而</span></span><br><span class=\"line\"><span class=\"comment\">        * 在释放mutex锁前，会将holder_清零，以示当前mutex锁被哪个线程持有。而线程在等</span></span><br><span class=\"line\"><span class=\"comment\">        * 待获取条件变量时，内部会原子加/解锁。所以为遵循holder_存在的意义，muduo为Condition</span></span><br><span class=\"line\"><span class=\"comment\">        * 实现了UnassignGuard类，利用raii，在等待条件变量解锁前，在构造函数中，</span></span><br><span class=\"line\"><span class=\"comment\">        * 将holder_清零；在获取到条件变量加锁后，在析构函数中，将holder_赋值为获锁线程</span></span><br><span class=\"line\"><span class=\"comment\">        * 的tid。以此保证holder_严格随着获取mutex锁的线程变化。</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"function\">MutexLock::UnassignGuard <span class=\"title\">ug</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_wait</span>(&amp;pcond_, mutex_.<span class=\"built_in\">getPthreadMutex</span>()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// returns true if time out, false otherwise.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">waitForSeconds</span><span class=\"params\">(<span class=\"type\">double</span> seconds)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">notify</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_signal</span>(&amp;pcond_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">notifyAll</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_broadcast</span>(&amp;pcond_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    MutexLock&amp; mutex_;</span><br><span class=\"line\">    <span class=\"type\">pthread_cond_t</span> pcond_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>关于条件变量和信号量的使用上的差别，说老实话，就我目前的功力，还没有深刻的感受，这里先mark一下，等哪天领悟到之后，再来聊一聊。</strong></p>\n<p><strong>补充：</strong></p>\n<ol>\n<li>条件变量可以在条件满足时，一次唤醒所有等待条件的线程，但是信号量则不行，只能post一个信号量（资源），唤醒一个线程。在多个线程等待一个条件的满足时再<strong>继续同时</strong>执行的场景下，适合用条件变量。（好像此时也可以用信号量，无非就是多post几次。只是，信号量不适合该场景，而条件变量更加适合）</li>\n</ol>\n<h2 id=\"CountDownLatch（倒计数同步类）\"><a href=\"#CountDownLatch（倒计数同步类）\" class=\"headerlink\" title=\"CountDownLatch（倒计数同步类）\"></a>CountDownLatch（倒计数同步类）</h2><p><strong>使用场景：</strong></p>\n<ol>\n<li><p>父线程等待多个子线程启动完毕，再继续执行： 在某些并发场景中，可能需要等待多个子线程都完成某个初始化操作后，父线程才能继续执行。CountDownLatch 可以用来等待这些线程的完成。</p>\n</li>\n<li><p>多个线程等待一个线程某个操作完毕，再继续执行： 可以使用 CountDownLatch 来协调多个线程的并发操作，确保某个操作在所有线程完成之后再执行。</p>\n</li>\n</ol>\n<p>接口：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CountDownLatch</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">CountDownLatch</span><span class=\"params\">(<span class=\"type\">int</span> count)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wait</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">countDown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">Condition condition_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> count_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CountDownLatch::<span class=\"built_in\">CountDownLatch</span>(<span class=\"type\">int</span> count)</span><br><span class=\"line\">  : <span class=\"built_in\">mutex_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">condition_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">count_</span>(count)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CountDownLatch::wait</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (count_ &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;   <span class=\"comment\">// while中解决了惊群效应</span></span><br><span class=\"line\">        condition_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CountDownLatch::countDown</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    --count_;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count_ == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 减为零后，将所有处于条件等待队列的线程，移到枪锁等待队列。</span></span><br><span class=\"line\">        condition_.<span class=\"built_in\">notifyAll</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">CountDownLatch::getCount</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong><br>我之前用一个demo专门实验过，实验结果表明，线程A调用<code>pthread_cond_broadcast</code>唤醒其他所有调用<code>pthread_cond_wait</code>阻塞的线程时，所有线程会处于一个枪锁状态（从条件等待队列，移到枪锁队列），线程B抢到锁处理临界资源再释放锁后，其他处于枪锁队列的线程还是处于枪锁状态，并不需要等待条件信号的到来，抢到锁就能处理临界资源。</p>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"muduo源码阅读笔记（8、定时器TimerQueue）","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\n为了方便Poller的管理，Muduo定时器是基于文件描述符实现。\n\n## 实现\n\n**定时器提供的接口：**\n\n<!-- more -->\n```cpp\nclass TimerQueue : noncopyable{\npublic:\n    explicit TimerQueue(EventLoop* loop);\n    ~TimerQueue();\n\n    ///\n    /// Schedules the callback to be run at given time,\n    /// repeats if @c interval > 0.0.\n    ///\n    /// Must be thread safe. Usually be called from other threads.\n    TimerId addTimer(TimerCallback cb,\n                    Timestamp when,\n                    double interval);\n\n    void cancel(TimerId timerId);\n\nprivate:\n\n    // FIXME: use unique_ptr<Timer> instead of raw pointers.\n    // This requires heterogeneous comparison lookup (N3465) from C++14\n    // so that we can find an T* in a set<unique_ptr<T>>.\n    typedef std::pair<Timestamp, Timer*> Entry;\n    typedef std::set<Entry> TimerList;\n    typedef std::pair<Timer*, int64_t> ActiveTimer;\n    typedef std::set<ActiveTimer> ActiveTimerSet;\n\n    void addTimerInLoop(Timer* timer);\n    void cancelInLoop(TimerId timerId);\n    // called when timerfd alarms\n    void handleRead();\n    // move out all expired timers\n    std::vector<Entry> getExpired(Timestamp now);\n    void reset(const std::vector<Entry>& expired, Timestamp now);\n\n    bool insert(Timer* timer);\n\n    EventLoop* loop_; // 定时器和哪个EventLoop关联\n    const int timerfd_; // timerfd_\n    Channel timerfdChannel_;  // 基于timerfd_的Channel\n    // Timer list sorted by expiration\n    TimerList timers_;  // 基于set的定时器（Timestamp，Timer*）\n\n    // for cancel()\n    ActiveTimerSet activeTimers_;\n    bool callingExpiredTimers_; /* atomic */\n    ActiveTimerSet cancelingTimers_;  // （Timer*，int64_t）\n};\n```\n**构造函数：**\n\n在每个EventLoop创建时，在自己的构造函数中，创建自己的定时器`TimerQueue`，并将EventLoop的this指针作为TimerQueue构造函数的参数。TimerQueue的构造会创建一个timerfd，并且向EventLoop的Poller注册timerfd。这样，Poller正式开开始管理定时器。后面的Acceptor、TcpConnection使用了类似的手法。\n\n实现如下：\n\n```cpp\n/*\n* @param: EventLoop的this指针\n*/\nTimerQueue::TimerQueue(EventLoop* loop)\n  : loop_(loop),\n    timerfd_(createTimerfd()),\n    timerfdChannel_(loop, timerfd_),\n    timers_(),\n    callingExpiredTimers_(false)\n{\n  timerfdChannel_.setReadCallback(\n      std::bind(&TimerQueue::handleRead, this));\n  // we are always reading the timerfd, we disarm it with timerfd_settime.\n  timerfdChannel_.enableReading();  // 向所在的loop中注册timerfd。\n}\n```\n\n**关于<号的万能性**\n\n将自定义类存入std::set是要求用户实现自定义对象<号重载的。思考一个问题：只重载<的话，如果用户调用find成员函数时，set如何判断两个对象是否相等呢？\n\n其实std::set内部做两次比较即可判断两个对象是否相等。方法：当a < b == false && b < a == false时，说明此时 a == b。读者可以在这里仔细思考一下。Timestamp正是因为实现了<才可以作为std::set的元素类型。\n\n\n一个自定义对象重载<号后，不光可以通过<推导出==，还可以推到出>、>=、<=号。[参考博客](https://blog.csdn.net/huangjh2017/article/details/74357003)\n\n参考boost::less_than_comparable<Timestamp>的实现，如下：\n\n```cpp\n//已知：\nfriend bool operator<(const T& x, const T& y)  { /*...*/}\n\n// |\n// V\n\n//可以推导：\nfriend bool operator>(const T& x, const T& y)  { return y < x; }\nfriend bool operator<=(const T& x, const T& y) { return !static_cast<bool>(y < x); }\nfriend bool operator>=(const T& x, const T& y) { return !static_cast<bool>(x < y); }\n```\n\n**定时器实现的伪代码：**\n\n```cpp\nTimerId TimerQueue::addTimer(TimerCallback cb,\n                             Timestamp when,\n                             double interval){\n    Timer* timer = new Timer(std::move(cb), when, interval);\n    loop_->runInLoop(\n        std::bind(&TimerQueue::addTimerInLoop, this, timer));\n    return TimerId(timer, timer->sequence());\n}\n\nvoid TimerQueue::cancel(TimerId timerId){\n    loop_->runInLoop(\n        std::bind(&TimerQueue::cancelInLoop, this, timerId));\n}\n\nvoid TimerQueue::addTimerInLoop(Timer* timer){\n    loop_->assertInLoopThread();\n    bool earliestChanged = insert(timer); // timer加入最新超时的定时器被更新。\n\n    if (earliestChanged){ \n        // 更新timerfd_的超时时间\n        resetTimerfd(timerfd_, timer->expiration());\n    }\n}\n\nvoid TimerQueue::cancelInLoop(TimerId timerId){\n    loop_->assertInLoopThread();\n    assert(timers_.size() == activeTimers_.size());\n    ActiveTimer timer(timerId.timer_, timerId.sequence_);\n    ActiveTimerSet::iterator it = activeTimers_.find(timer);\n    if (it != activeTimers_.end()){ // 在activeTimers_上\n        // 在timers_上删除timerId\n        delete it->first; // FIXME: no delete please\n        // 在activeTimers_上删除timerId\n    }else if (callingExpiredTimers_){   // 如果正在处理超时定时器，那么timerId是有可能从activeTimers_上移除，而在handleRead::expired中\n        // 所以先将timerId加入cancelingTimers_列表，防止是循环定时器，又被重新加入到activeTimers_。handleRead会调用reset删除被取消的定时器。\n        cancelingTimers_.insert(timer);\n    }\n    assert(timers_.size() == activeTimers_.size());\n}\n\nvoid TimerQueue::handleRead(){ // timerfd_读事件处理回调\n    loop_->assertInLoopThread();\n    Timestamp now(Timestamp::now());\n    readTimerfd(timerfd_, now); // 清空timerfd_上的数据\n\n    std::vector<Entry> expired = getExpired(now);\n\n    callingExpiredTimers_ = true;\n    cancelingTimers_.clear();\n    // safe to callback outside critical section\n    for (const Entry& it : expired){\n        it.second->run();   // 调用过期定时器的回调\n    }\n    callingExpiredTimers_ = false;\n\n    reset(expired, now);    // 看能不能重新安装过期定时器，不能就delete。\n}\n\nstd::vector<TimerQueue::Entry> TimerQueue::getExpired(Timestamp now){\n    assert(timers_.size() == activeTimers_.size());\n    std::vector<Entry> expired;\n\n    // 根据now，在timers_中找过期的定时器，存入expired。\n    // ...\n\n    for (const Entry& it : expired){ \n        // 同步activeTimers_ 和 timers_\n        // ...\n    }\n\n    assert(timers_.size() == activeTimers_.size());\n    return expired;\n}\n\nvoid TimerQueue::reset(const std::vector<Entry>& expired, Timestamp now){\n    Timestamp nextExpire;\n\n    for (const Entry& it : expired){\n        ActiveTimer timer(it.second, it.second->sequence());\n        if (it.second->repeat()\n            && cancelingTimers_.find(timer) == cancelingTimers_.end()){ // 是循环定时器，并且没有被取消。\n            it.second->restart(now);\n            insert(it.second);\n        }else{\n            // FIXME move to a free list\n            delete it.second; // FIXME: no delete please\n        }\n    }\n\n    if (!timers_.empty()){\n        nextExpire = timers_.begin()->second->expiration();\n    }\n\n    if (nextExpire.valid()){\n        resetTimerfd(timerfd_, nextExpire);\n    }\n}\n\nbool TimerQueue::insert(Timer* timer){\n    loop_->assertInLoopThread();\n    assert(timers_.size() == activeTimers_.size());\n    bool earliestChanged = false;\n    Timestamp when = timer->expiration(); // timer超时时间\n    TimerList::iterator it = timers_.begin(); // 原来定时器中最早超时的定时器\n    if (it == timers_.end() || when < it->first){ \n        // 原本timers_就没有定时器 || 要插入的定时器超时时间 比 原来的timers_中第一个定时器 早。\n        // 都代表：插入新定时器后，最早超时时间会发生改变，需要重新设置timeFd。\n        earliestChanged = true;\n    }\n    // 插入timers_\n    // std::set::insert\n\n    // 同步到activeTimers_\n    // std::set::insert\n    return earliestChanged;\n}\n```\n\n## 细节明细：\n\n**疑问**\n\n定时器模块存在的意义？\n\n**解答**\n\n1. 事件触发机制： 定时器在Muduo中被用作一种事件触发机制。通过设置定时器，用户可以在指定的时间间隔内执行相应的操作，例如执行定时任务、发送心跳包等。这种事件触发机制有助于异步编程中的任务调度和协调。\n\n2. 超时处理： 定时器用于处理超时事件，例如连接超时、读写操作超时等。通过设置合适的定时器，Muduo可以及时检测并处理超时情况，确保网络应用的稳定性和可靠性。\n\n3. 可能还不太全，后面再有所感悟再来更新。。。\n\n---\n\n**本章完结**","source":"_posts/muduo/TimerQueue.md","raw":"---\ntitle: muduo源码阅读笔记（8、定时器TimerQueue）\ndate: 2024-11-02 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n**Muduo源码笔记系列：**\n\n[muduo源码阅读笔记（0、下载编译muduo）](./Start.md)\n\n[muduo源码阅读笔记（1、同步日志）](./SynLogging.md)\n\n[muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）](./ThreadSafeAndSync.md)\n\n[muduo源码阅读笔记（3、线程和线程池的封装）](./ThreadAndThreadPool.md)\n\n[muduo源码阅读笔记（4、异步日志）](./AsyncLogging.md)\n\n[muduo源码阅读笔记（5、Channel和Poller）](./ChannelAndPoller.md)\n\n[muduo源码阅读笔记（6、ExevntLoop和Thread）](./EvevntLoopAndThread.md)\n\n[muduo源码阅读笔记（7、EventLoopThreadPool）](./EventLoopThreadPool.md)\n\n[muduo源码阅读笔记（8、定时器TimerQueue）](./TimerQueue.md)\n\n[muduo源码阅读笔记（9、TcpServer）](./TcpServer.md)\n\n[muduo源码阅读笔记（10、TcpConnection）](./TcpConnection.md)\n\n**前言**\n\n为了方便Poller的管理，Muduo定时器是基于文件描述符实现。\n\n## 实现\n\n**定时器提供的接口：**\n\n<!-- more -->\n```cpp\nclass TimerQueue : noncopyable{\npublic:\n    explicit TimerQueue(EventLoop* loop);\n    ~TimerQueue();\n\n    ///\n    /// Schedules the callback to be run at given time,\n    /// repeats if @c interval > 0.0.\n    ///\n    /// Must be thread safe. Usually be called from other threads.\n    TimerId addTimer(TimerCallback cb,\n                    Timestamp when,\n                    double interval);\n\n    void cancel(TimerId timerId);\n\nprivate:\n\n    // FIXME: use unique_ptr<Timer> instead of raw pointers.\n    // This requires heterogeneous comparison lookup (N3465) from C++14\n    // so that we can find an T* in a set<unique_ptr<T>>.\n    typedef std::pair<Timestamp, Timer*> Entry;\n    typedef std::set<Entry> TimerList;\n    typedef std::pair<Timer*, int64_t> ActiveTimer;\n    typedef std::set<ActiveTimer> ActiveTimerSet;\n\n    void addTimerInLoop(Timer* timer);\n    void cancelInLoop(TimerId timerId);\n    // called when timerfd alarms\n    void handleRead();\n    // move out all expired timers\n    std::vector<Entry> getExpired(Timestamp now);\n    void reset(const std::vector<Entry>& expired, Timestamp now);\n\n    bool insert(Timer* timer);\n\n    EventLoop* loop_; // 定时器和哪个EventLoop关联\n    const int timerfd_; // timerfd_\n    Channel timerfdChannel_;  // 基于timerfd_的Channel\n    // Timer list sorted by expiration\n    TimerList timers_;  // 基于set的定时器（Timestamp，Timer*）\n\n    // for cancel()\n    ActiveTimerSet activeTimers_;\n    bool callingExpiredTimers_; /* atomic */\n    ActiveTimerSet cancelingTimers_;  // （Timer*，int64_t）\n};\n```\n**构造函数：**\n\n在每个EventLoop创建时，在自己的构造函数中，创建自己的定时器`TimerQueue`，并将EventLoop的this指针作为TimerQueue构造函数的参数。TimerQueue的构造会创建一个timerfd，并且向EventLoop的Poller注册timerfd。这样，Poller正式开开始管理定时器。后面的Acceptor、TcpConnection使用了类似的手法。\n\n实现如下：\n\n```cpp\n/*\n* @param: EventLoop的this指针\n*/\nTimerQueue::TimerQueue(EventLoop* loop)\n  : loop_(loop),\n    timerfd_(createTimerfd()),\n    timerfdChannel_(loop, timerfd_),\n    timers_(),\n    callingExpiredTimers_(false)\n{\n  timerfdChannel_.setReadCallback(\n      std::bind(&TimerQueue::handleRead, this));\n  // we are always reading the timerfd, we disarm it with timerfd_settime.\n  timerfdChannel_.enableReading();  // 向所在的loop中注册timerfd。\n}\n```\n\n**关于<号的万能性**\n\n将自定义类存入std::set是要求用户实现自定义对象<号重载的。思考一个问题：只重载<的话，如果用户调用find成员函数时，set如何判断两个对象是否相等呢？\n\n其实std::set内部做两次比较即可判断两个对象是否相等。方法：当a < b == false && b < a == false时，说明此时 a == b。读者可以在这里仔细思考一下。Timestamp正是因为实现了<才可以作为std::set的元素类型。\n\n\n一个自定义对象重载<号后，不光可以通过<推导出==，还可以推到出>、>=、<=号。[参考博客](https://blog.csdn.net/huangjh2017/article/details/74357003)\n\n参考boost::less_than_comparable<Timestamp>的实现，如下：\n\n```cpp\n//已知：\nfriend bool operator<(const T& x, const T& y)  { /*...*/}\n\n// |\n// V\n\n//可以推导：\nfriend bool operator>(const T& x, const T& y)  { return y < x; }\nfriend bool operator<=(const T& x, const T& y) { return !static_cast<bool>(y < x); }\nfriend bool operator>=(const T& x, const T& y) { return !static_cast<bool>(x < y); }\n```\n\n**定时器实现的伪代码：**\n\n```cpp\nTimerId TimerQueue::addTimer(TimerCallback cb,\n                             Timestamp when,\n                             double interval){\n    Timer* timer = new Timer(std::move(cb), when, interval);\n    loop_->runInLoop(\n        std::bind(&TimerQueue::addTimerInLoop, this, timer));\n    return TimerId(timer, timer->sequence());\n}\n\nvoid TimerQueue::cancel(TimerId timerId){\n    loop_->runInLoop(\n        std::bind(&TimerQueue::cancelInLoop, this, timerId));\n}\n\nvoid TimerQueue::addTimerInLoop(Timer* timer){\n    loop_->assertInLoopThread();\n    bool earliestChanged = insert(timer); // timer加入最新超时的定时器被更新。\n\n    if (earliestChanged){ \n        // 更新timerfd_的超时时间\n        resetTimerfd(timerfd_, timer->expiration());\n    }\n}\n\nvoid TimerQueue::cancelInLoop(TimerId timerId){\n    loop_->assertInLoopThread();\n    assert(timers_.size() == activeTimers_.size());\n    ActiveTimer timer(timerId.timer_, timerId.sequence_);\n    ActiveTimerSet::iterator it = activeTimers_.find(timer);\n    if (it != activeTimers_.end()){ // 在activeTimers_上\n        // 在timers_上删除timerId\n        delete it->first; // FIXME: no delete please\n        // 在activeTimers_上删除timerId\n    }else if (callingExpiredTimers_){   // 如果正在处理超时定时器，那么timerId是有可能从activeTimers_上移除，而在handleRead::expired中\n        // 所以先将timerId加入cancelingTimers_列表，防止是循环定时器，又被重新加入到activeTimers_。handleRead会调用reset删除被取消的定时器。\n        cancelingTimers_.insert(timer);\n    }\n    assert(timers_.size() == activeTimers_.size());\n}\n\nvoid TimerQueue::handleRead(){ // timerfd_读事件处理回调\n    loop_->assertInLoopThread();\n    Timestamp now(Timestamp::now());\n    readTimerfd(timerfd_, now); // 清空timerfd_上的数据\n\n    std::vector<Entry> expired = getExpired(now);\n\n    callingExpiredTimers_ = true;\n    cancelingTimers_.clear();\n    // safe to callback outside critical section\n    for (const Entry& it : expired){\n        it.second->run();   // 调用过期定时器的回调\n    }\n    callingExpiredTimers_ = false;\n\n    reset(expired, now);    // 看能不能重新安装过期定时器，不能就delete。\n}\n\nstd::vector<TimerQueue::Entry> TimerQueue::getExpired(Timestamp now){\n    assert(timers_.size() == activeTimers_.size());\n    std::vector<Entry> expired;\n\n    // 根据now，在timers_中找过期的定时器，存入expired。\n    // ...\n\n    for (const Entry& it : expired){ \n        // 同步activeTimers_ 和 timers_\n        // ...\n    }\n\n    assert(timers_.size() == activeTimers_.size());\n    return expired;\n}\n\nvoid TimerQueue::reset(const std::vector<Entry>& expired, Timestamp now){\n    Timestamp nextExpire;\n\n    for (const Entry& it : expired){\n        ActiveTimer timer(it.second, it.second->sequence());\n        if (it.second->repeat()\n            && cancelingTimers_.find(timer) == cancelingTimers_.end()){ // 是循环定时器，并且没有被取消。\n            it.second->restart(now);\n            insert(it.second);\n        }else{\n            // FIXME move to a free list\n            delete it.second; // FIXME: no delete please\n        }\n    }\n\n    if (!timers_.empty()){\n        nextExpire = timers_.begin()->second->expiration();\n    }\n\n    if (nextExpire.valid()){\n        resetTimerfd(timerfd_, nextExpire);\n    }\n}\n\nbool TimerQueue::insert(Timer* timer){\n    loop_->assertInLoopThread();\n    assert(timers_.size() == activeTimers_.size());\n    bool earliestChanged = false;\n    Timestamp when = timer->expiration(); // timer超时时间\n    TimerList::iterator it = timers_.begin(); // 原来定时器中最早超时的定时器\n    if (it == timers_.end() || when < it->first){ \n        // 原本timers_就没有定时器 || 要插入的定时器超时时间 比 原来的timers_中第一个定时器 早。\n        // 都代表：插入新定时器后，最早超时时间会发生改变，需要重新设置timeFd。\n        earliestChanged = true;\n    }\n    // 插入timers_\n    // std::set::insert\n\n    // 同步到activeTimers_\n    // std::set::insert\n    return earliestChanged;\n}\n```\n\n## 细节明细：\n\n**疑问**\n\n定时器模块存在的意义？\n\n**解答**\n\n1. 事件触发机制： 定时器在Muduo中被用作一种事件触发机制。通过设置定时器，用户可以在指定的时间间隔内执行相应的操作，例如执行定时任务、发送心跳包等。这种事件触发机制有助于异步编程中的任务调度和协调。\n\n2. 超时处理： 定时器用于处理超时事件，例如连接超时、读写操作超时等。通过设置合适的定时器，Muduo可以及时检测并处理超时情况，确保网络应用的稳定性和可靠性。\n\n3. 可能还不太全，后面再有所感悟再来更新。。。\n\n---\n\n**本章完结**","slug":"muduo/TimerQueue","published":1,"updated":"2025-09-28T16:06:43.135Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9s000sq8ws8wi65amy","content":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>为了方便Poller的管理，Muduo定时器是基于文件描述符实现。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p><strong>定时器提供的接口：</strong></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TimerQueue</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">TimerQueue</span><span class=\"params\">(EventLoop* loop)</span></span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">TimerQueue</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Schedules the callback to be run at given time,</span></span><br><span class=\"line\">    <span class=\"comment\">/// repeats if @c interval &gt; 0.0.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be thread safe. Usually be called from other threads.</span></span><br><span class=\"line\">    <span class=\"function\">TimerId <span class=\"title\">addTimer</span><span class=\"params\">(TimerCallback cb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                    Timestamp when,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                    <span class=\"type\">double</span> interval)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cancel</span><span class=\"params\">(TimerId timerId)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use unique_ptr&lt;Timer&gt; instead of raw pointers.</span></span><br><span class=\"line\">    <span class=\"comment\">// This requires heterogeneous comparison lookup (N3465) from C++14</span></span><br><span class=\"line\">    <span class=\"comment\">// so that we can find an T* in a set&lt;unique_ptr&lt;T&gt;&gt;.</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::pair&lt;Timestamp, Timer*&gt; Entry;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::set&lt;Entry&gt; TimerList;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::pair&lt;Timer*, <span class=\"type\">int64_t</span>&gt; ActiveTimer;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::set&lt;ActiveTimer&gt; ActiveTimerSet;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addTimerInLoop</span><span class=\"params\">(Timer* timer)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cancelInLoop</span><span class=\"params\">(TimerId timerId)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// called when timerfd alarms</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// move out all expired timers</span></span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;Entry&gt; <span class=\"title\">getExpired</span><span class=\"params\">(Timestamp now)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Entry&gt;&amp; expired, Timestamp now)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">insert</span><span class=\"params\">(Timer* timer)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// 定时器和哪个EventLoop关联</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> timerfd_; <span class=\"comment\">// timerfd_</span></span><br><span class=\"line\">    Channel timerfdChannel_;  <span class=\"comment\">// 基于timerfd_的Channel</span></span><br><span class=\"line\">    <span class=\"comment\">// Timer list sorted by expiration</span></span><br><span class=\"line\">    TimerList timers_;  <span class=\"comment\">// 基于set的定时器（Timestamp，Timer*）</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for cancel()</span></span><br><span class=\"line\">    ActiveTimerSet activeTimers_;</span><br><span class=\"line\">    <span class=\"type\">bool</span> callingExpiredTimers_; <span class=\"comment\">/* atomic */</span></span><br><span class=\"line\">    ActiveTimerSet cancelingTimers_;  <span class=\"comment\">// （Timer*，int64_t）</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>构造函数：</strong></p>\n<p>在每个EventLoop创建时，在自己的构造函数中，创建自己的定时器<code>TimerQueue</code>，并将EventLoop的this指针作为TimerQueue构造函数的参数。TimerQueue的构造会创建一个timerfd，并且向EventLoop的Poller注册timerfd。这样，Poller正式开开始管理定时器。后面的Acceptor、TcpConnection使用了类似的手法。</p>\n<p>实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* @param: EventLoop的this指针</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">TimerQueue::<span class=\"built_in\">TimerQueue</span>(EventLoop* loop)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(loop),</span><br><span class=\"line\">    <span class=\"built_in\">timerfd_</span>(<span class=\"built_in\">createTimerfd</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">timerfdChannel_</span>(loop, timerfd_),</span><br><span class=\"line\">    <span class=\"built_in\">timers_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">callingExpiredTimers_</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  timerfdChannel_.<span class=\"built_in\">setReadCallback</span>(</span><br><span class=\"line\">      std::<span class=\"built_in\">bind</span>(&amp;TimerQueue::handleRead, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">  <span class=\"comment\">// we are always reading the timerfd, we disarm it with timerfd_settime.</span></span><br><span class=\"line\">  timerfdChannel_.<span class=\"built_in\">enableReading</span>();  <span class=\"comment\">// 向所在的loop中注册timerfd。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>关于&lt;号的万能性</strong></p>\n<p>将自定义类存入std::set是要求用户实现自定义对象&lt;号重载的。思考一个问题：只重载&lt;的话，如果用户调用find成员函数时，set如何判断两个对象是否相等呢？</p>\n<p>其实std::set内部做两次比较即可判断两个对象是否相等。方法：当a &lt; b &#x3D;&#x3D; false &amp;&amp; b &lt; a &#x3D;&#x3D; false时，说明此时 a &#x3D;&#x3D; b。读者可以在这里仔细思考一下。Timestamp正是因为实现了&lt;才可以作为std::set的元素类型。</p>\n<p>一个自定义对象重载&lt;号后，不光可以通过&lt;推导出&#x3D;&#x3D;，还可以推到出&gt;、&gt;&#x3D;、&lt;&#x3D;号。<a href=\"https://blog.csdn.net/huangjh2017/article/details/74357003\">参考博客</a></p>\n<p>参考boost::less_than_comparable<Timestamp>的实现，如下：</Timestamp></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//已知：</span></span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"built_in\">operator</span>&lt;(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y)  &#123; <span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// |</span></span><br><span class=\"line\"><span class=\"comment\">// V</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可以推导：</span></span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y)  &#123; <span class=\"keyword\">return</span> y &lt; x; &#125;</span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;=(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y) &#123; <span class=\"keyword\">return</span> !<span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">bool</span>&gt;(y &lt; x); &#125;</span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;=(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y) &#123; <span class=\"keyword\">return</span> !<span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">bool</span>&gt;(x &lt; y); &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>定时器实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TimerId <span class=\"title\">TimerQueue::addTimer</span><span class=\"params\">(TimerCallback cb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             Timestamp when,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             <span class=\"type\">double</span> interval)</span></span>&#123;</span><br><span class=\"line\">    Timer* timer = <span class=\"keyword\">new</span> <span class=\"built_in\">Timer</span>(std::<span class=\"built_in\">move</span>(cb), when, interval);</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TimerQueue::addTimerInLoop, <span class=\"keyword\">this</span>, timer));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">TimerId</span>(timer, timer-&gt;<span class=\"built_in\">sequence</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::cancel</span><span class=\"params\">(TimerId timerId)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TimerQueue::cancelInLoop, <span class=\"keyword\">this</span>, timerId));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::addTimerInLoop</span><span class=\"params\">(Timer* timer)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"type\">bool</span> earliestChanged = <span class=\"built_in\">insert</span>(timer); <span class=\"comment\">// timer加入最新超时的定时器被更新。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (earliestChanged)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// 更新timerfd_的超时时间</span></span><br><span class=\"line\">        <span class=\"built_in\">resetTimerfd</span>(timerfd_, timer-&gt;<span class=\"built_in\">expiration</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::cancelInLoop</span><span class=\"params\">(TimerId timerId)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    <span class=\"function\">ActiveTimer <span class=\"title\">timer</span><span class=\"params\">(timerId.timer_, timerId.sequence_)</span></span>;</span><br><span class=\"line\">    ActiveTimerSet::iterator it = activeTimers_.<span class=\"built_in\">find</span>(timer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it != activeTimers_.<span class=\"built_in\">end</span>())&#123; <span class=\"comment\">// 在activeTimers_上</span></span><br><span class=\"line\">        <span class=\"comment\">// 在timers_上删除timerId</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> it-&gt;first; <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> no delete please</span></span><br><span class=\"line\">        <span class=\"comment\">// 在activeTimers_上删除timerId</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (callingExpiredTimers_)&#123;   <span class=\"comment\">// 如果正在处理超时定时器，那么timerId是有可能从activeTimers_上移除，而在handleRead::expired中</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以先将timerId加入cancelingTimers_列表，防止是循环定时器，又被重新加入到activeTimers_。handleRead会调用reset删除被取消的定时器。</span></span><br><span class=\"line\">        cancelingTimers_.<span class=\"built_in\">insert</span>(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::handleRead</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// timerfd_读事件处理回调</span></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"function\">Timestamp <span class=\"title\">now</span><span class=\"params\">(Timestamp::now())</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">readTimerfd</span>(timerfd_, now); <span class=\"comment\">// 清空timerfd_上的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::vector&lt;Entry&gt; expired = <span class=\"built_in\">getExpired</span>(now);</span><br><span class=\"line\"></span><br><span class=\"line\">    callingExpiredTimers_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    cancelingTimers_.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    <span class=\"comment\">// safe to callback outside critical section</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Entry&amp; it : expired)&#123;</span><br><span class=\"line\">        it.second-&gt;<span class=\"built_in\">run</span>();   <span class=\"comment\">// 调用过期定时器的回调</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    callingExpiredTimers_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">reset</span>(expired, now);    <span class=\"comment\">// 看能不能重新安装过期定时器，不能就delete。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;TimerQueue::Entry&gt; <span class=\"title\">TimerQueue::getExpired</span><span class=\"params\">(Timestamp now)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    std::vector&lt;Entry&gt; expired;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据now，在timers_中找过期的定时器，存入expired。</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Entry&amp; it : expired)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// 同步activeTimers_ 和 timers_</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> expired;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::reset</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Entry&gt;&amp; expired, Timestamp now)</span></span>&#123;</span><br><span class=\"line\">    Timestamp nextExpire;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Entry&amp; it : expired)&#123;</span><br><span class=\"line\">        <span class=\"function\">ActiveTimer <span class=\"title\">timer</span><span class=\"params\">(it.second, it.second-&gt;sequence())</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it.second-&gt;<span class=\"built_in\">repeat</span>()</span><br><span class=\"line\">            &amp;&amp; cancelingTimers_.<span class=\"built_in\">find</span>(timer) == cancelingTimers_.<span class=\"built_in\">end</span>())&#123; <span class=\"comment\">// 是循环定时器，并且没有被取消。</span></span><br><span class=\"line\">            it.second-&gt;<span class=\"built_in\">restart</span>(now);</span><br><span class=\"line\">            <span class=\"built_in\">insert</span>(it.second);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// FIXME move to a free list</span></span><br><span class=\"line\">            <span class=\"keyword\">delete</span> it.second; <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> no delete please</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timers_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        nextExpire = timers_.<span class=\"built_in\">begin</span>()-&gt;second-&gt;<span class=\"built_in\">expiration</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextExpire.<span class=\"built_in\">valid</span>())&#123;</span><br><span class=\"line\">        <span class=\"built_in\">resetTimerfd</span>(timerfd_, nextExpire);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TimerQueue::insert</span><span class=\"params\">(Timer* timer)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    <span class=\"type\">bool</span> earliestChanged = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    Timestamp when = timer-&gt;<span class=\"built_in\">expiration</span>(); <span class=\"comment\">// timer超时时间</span></span><br><span class=\"line\">    TimerList::iterator it = timers_.<span class=\"built_in\">begin</span>(); <span class=\"comment\">// 原来定时器中最早超时的定时器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it == timers_.<span class=\"built_in\">end</span>() || when &lt; it-&gt;first)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// 原本timers_就没有定时器 || 要插入的定时器超时时间 比 原来的timers_中第一个定时器 早。</span></span><br><span class=\"line\">        <span class=\"comment\">// 都代表：插入新定时器后，最早超时时间会发生改变，需要重新设置timeFd。</span></span><br><span class=\"line\">        earliestChanged = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 插入timers_</span></span><br><span class=\"line\">    <span class=\"comment\">// std::set::insert</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 同步到activeTimers_</span></span><br><span class=\"line\">    <span class=\"comment\">// std::set::insert</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> earliestChanged;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"细节明细：\"><a href=\"#细节明细：\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h2><p><strong>疑问</strong></p>\n<p>定时器模块存在的意义？</p>\n<p><strong>解答</strong></p>\n<ol>\n<li><p>事件触发机制： 定时器在Muduo中被用作一种事件触发机制。通过设置定时器，用户可以在指定的时间间隔内执行相应的操作，例如执行定时任务、发送心跳包等。这种事件触发机制有助于异步编程中的任务调度和协调。</p>\n</li>\n<li><p>超时处理： 定时器用于处理超时事件，例如连接超时、读写操作超时等。通过设置合适的定时器，Muduo可以及时检测并处理超时情况，确保网络应用的稳定性和可靠性。</p>\n</li>\n<li><p>可能还不太全，后面再有所感悟再来更新。。。</p>\n</li>\n</ol>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<p><strong>Muduo源码笔记系列：</strong></p>\n<p><a href=\"./Start.md\">muduo源码阅读笔记（0、下载编译muduo）</a></p>\n<p><a href=\"./SynLogging.md\">muduo源码阅读笔记（1、同步日志）</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo源码阅读笔记（2、对C语言原生的线程安全以及同步的API的封装）</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo源码阅读笔记（3、线程和线程池的封装）</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo源码阅读笔记（4、异步日志）</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo源码阅读笔记（5、Channel和Poller）</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo源码阅读笔记（6、ExevntLoop和Thread）</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo源码阅读笔记（7、EventLoopThreadPool）</a></p>\n<p><a href=\"./TimerQueue.md\">muduo源码阅读笔记（8、定时器TimerQueue）</a></p>\n<p><a href=\"./TcpServer.md\">muduo源码阅读笔记（9、TcpServer）</a></p>\n<p><a href=\"./TcpConnection.md\">muduo源码阅读笔记（10、TcpConnection）</a></p>\n<p><strong>前言</strong></p>\n<p>为了方便Poller的管理，Muduo定时器是基于文件描述符实现。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p><strong>定时器提供的接口：</strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TimerQueue</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">TimerQueue</span><span class=\"params\">(EventLoop* loop)</span></span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">TimerQueue</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Schedules the callback to be run at given time,</span></span><br><span class=\"line\">    <span class=\"comment\">/// repeats if @c interval &gt; 0.0.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be thread safe. Usually be called from other threads.</span></span><br><span class=\"line\">    <span class=\"function\">TimerId <span class=\"title\">addTimer</span><span class=\"params\">(TimerCallback cb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                    Timestamp when,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                    <span class=\"type\">double</span> interval)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cancel</span><span class=\"params\">(TimerId timerId)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use unique_ptr&lt;Timer&gt; instead of raw pointers.</span></span><br><span class=\"line\">    <span class=\"comment\">// This requires heterogeneous comparison lookup (N3465) from C++14</span></span><br><span class=\"line\">    <span class=\"comment\">// so that we can find an T* in a set&lt;unique_ptr&lt;T&gt;&gt;.</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::pair&lt;Timestamp, Timer*&gt; Entry;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::set&lt;Entry&gt; TimerList;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::pair&lt;Timer*, <span class=\"type\">int64_t</span>&gt; ActiveTimer;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::set&lt;ActiveTimer&gt; ActiveTimerSet;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addTimerInLoop</span><span class=\"params\">(Timer* timer)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cancelInLoop</span><span class=\"params\">(TimerId timerId)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// called when timerfd alarms</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// move out all expired timers</span></span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;Entry&gt; <span class=\"title\">getExpired</span><span class=\"params\">(Timestamp now)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Entry&gt;&amp; expired, Timestamp now)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">insert</span><span class=\"params\">(Timer* timer)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// 定时器和哪个EventLoop关联</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> timerfd_; <span class=\"comment\">// timerfd_</span></span><br><span class=\"line\">    Channel timerfdChannel_;  <span class=\"comment\">// 基于timerfd_的Channel</span></span><br><span class=\"line\">    <span class=\"comment\">// Timer list sorted by expiration</span></span><br><span class=\"line\">    TimerList timers_;  <span class=\"comment\">// 基于set的定时器（Timestamp，Timer*）</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for cancel()</span></span><br><span class=\"line\">    ActiveTimerSet activeTimers_;</span><br><span class=\"line\">    <span class=\"type\">bool</span> callingExpiredTimers_; <span class=\"comment\">/* atomic */</span></span><br><span class=\"line\">    ActiveTimerSet cancelingTimers_;  <span class=\"comment\">// （Timer*，int64_t）</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>构造函数：</strong></p>\n<p>在每个EventLoop创建时，在自己的构造函数中，创建自己的定时器<code>TimerQueue</code>，并将EventLoop的this指针作为TimerQueue构造函数的参数。TimerQueue的构造会创建一个timerfd，并且向EventLoop的Poller注册timerfd。这样，Poller正式开开始管理定时器。后面的Acceptor、TcpConnection使用了类似的手法。</p>\n<p>实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* @param: EventLoop的this指针</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">TimerQueue::<span class=\"built_in\">TimerQueue</span>(EventLoop* loop)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(loop),</span><br><span class=\"line\">    <span class=\"built_in\">timerfd_</span>(<span class=\"built_in\">createTimerfd</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">timerfdChannel_</span>(loop, timerfd_),</span><br><span class=\"line\">    <span class=\"built_in\">timers_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">callingExpiredTimers_</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  timerfdChannel_.<span class=\"built_in\">setReadCallback</span>(</span><br><span class=\"line\">      std::<span class=\"built_in\">bind</span>(&amp;TimerQueue::handleRead, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">  <span class=\"comment\">// we are always reading the timerfd, we disarm it with timerfd_settime.</span></span><br><span class=\"line\">  timerfdChannel_.<span class=\"built_in\">enableReading</span>();  <span class=\"comment\">// 向所在的loop中注册timerfd。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>关于&lt;号的万能性</strong></p>\n<p>将自定义类存入std::set是要求用户实现自定义对象&lt;号重载的。思考一个问题：只重载&lt;的话，如果用户调用find成员函数时，set如何判断两个对象是否相等呢？</p>\n<p>其实std::set内部做两次比较即可判断两个对象是否相等。方法：当a &lt; b &#x3D;&#x3D; false &amp;&amp; b &lt; a &#x3D;&#x3D; false时，说明此时 a &#x3D;&#x3D; b。读者可以在这里仔细思考一下。Timestamp正是因为实现了&lt;才可以作为std::set的元素类型。</p>\n<p>一个自定义对象重载&lt;号后，不光可以通过&lt;推导出&#x3D;&#x3D;，还可以推到出&gt;、&gt;&#x3D;、&lt;&#x3D;号。<a href=\"https://blog.csdn.net/huangjh2017/article/details/74357003\">参考博客</a></p>\n<p>参考boost::less_than_comparable<Timestamp>的实现，如下：</Timestamp></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//已知：</span></span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"built_in\">operator</span>&lt;(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y)  &#123; <span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// |</span></span><br><span class=\"line\"><span class=\"comment\">// V</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可以推导：</span></span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y)  &#123; <span class=\"keyword\">return</span> y &lt; x; &#125;</span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;=(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y) &#123; <span class=\"keyword\">return</span> !<span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">bool</span>&gt;(y &lt; x); &#125;</span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;=(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y) &#123; <span class=\"keyword\">return</span> !<span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">bool</span>&gt;(x &lt; y); &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>定时器实现的伪代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TimerId <span class=\"title\">TimerQueue::addTimer</span><span class=\"params\">(TimerCallback cb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             Timestamp when,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             <span class=\"type\">double</span> interval)</span></span>&#123;</span><br><span class=\"line\">    Timer* timer = <span class=\"keyword\">new</span> <span class=\"built_in\">Timer</span>(std::<span class=\"built_in\">move</span>(cb), when, interval);</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TimerQueue::addTimerInLoop, <span class=\"keyword\">this</span>, timer));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">TimerId</span>(timer, timer-&gt;<span class=\"built_in\">sequence</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::cancel</span><span class=\"params\">(TimerId timerId)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TimerQueue::cancelInLoop, <span class=\"keyword\">this</span>, timerId));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::addTimerInLoop</span><span class=\"params\">(Timer* timer)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"type\">bool</span> earliestChanged = <span class=\"built_in\">insert</span>(timer); <span class=\"comment\">// timer加入最新超时的定时器被更新。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (earliestChanged)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// 更新timerfd_的超时时间</span></span><br><span class=\"line\">        <span class=\"built_in\">resetTimerfd</span>(timerfd_, timer-&gt;<span class=\"built_in\">expiration</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::cancelInLoop</span><span class=\"params\">(TimerId timerId)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    <span class=\"function\">ActiveTimer <span class=\"title\">timer</span><span class=\"params\">(timerId.timer_, timerId.sequence_)</span></span>;</span><br><span class=\"line\">    ActiveTimerSet::iterator it = activeTimers_.<span class=\"built_in\">find</span>(timer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it != activeTimers_.<span class=\"built_in\">end</span>())&#123; <span class=\"comment\">// 在activeTimers_上</span></span><br><span class=\"line\">        <span class=\"comment\">// 在timers_上删除timerId</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> it-&gt;first; <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> no delete please</span></span><br><span class=\"line\">        <span class=\"comment\">// 在activeTimers_上删除timerId</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (callingExpiredTimers_)&#123;   <span class=\"comment\">// 如果正在处理超时定时器，那么timerId是有可能从activeTimers_上移除，而在handleRead::expired中</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以先将timerId加入cancelingTimers_列表，防止是循环定时器，又被重新加入到activeTimers_。handleRead会调用reset删除被取消的定时器。</span></span><br><span class=\"line\">        cancelingTimers_.<span class=\"built_in\">insert</span>(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::handleRead</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// timerfd_读事件处理回调</span></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"function\">Timestamp <span class=\"title\">now</span><span class=\"params\">(Timestamp::now())</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">readTimerfd</span>(timerfd_, now); <span class=\"comment\">// 清空timerfd_上的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::vector&lt;Entry&gt; expired = <span class=\"built_in\">getExpired</span>(now);</span><br><span class=\"line\"></span><br><span class=\"line\">    callingExpiredTimers_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    cancelingTimers_.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    <span class=\"comment\">// safe to callback outside critical section</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Entry&amp; it : expired)&#123;</span><br><span class=\"line\">        it.second-&gt;<span class=\"built_in\">run</span>();   <span class=\"comment\">// 调用过期定时器的回调</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    callingExpiredTimers_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">reset</span>(expired, now);    <span class=\"comment\">// 看能不能重新安装过期定时器，不能就delete。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;TimerQueue::Entry&gt; <span class=\"title\">TimerQueue::getExpired</span><span class=\"params\">(Timestamp now)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    std::vector&lt;Entry&gt; expired;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据now，在timers_中找过期的定时器，存入expired。</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Entry&amp; it : expired)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// 同步activeTimers_ 和 timers_</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> expired;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::reset</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Entry&gt;&amp; expired, Timestamp now)</span></span>&#123;</span><br><span class=\"line\">    Timestamp nextExpire;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Entry&amp; it : expired)&#123;</span><br><span class=\"line\">        <span class=\"function\">ActiveTimer <span class=\"title\">timer</span><span class=\"params\">(it.second, it.second-&gt;sequence())</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it.second-&gt;<span class=\"built_in\">repeat</span>()</span><br><span class=\"line\">            &amp;&amp; cancelingTimers_.<span class=\"built_in\">find</span>(timer) == cancelingTimers_.<span class=\"built_in\">end</span>())&#123; <span class=\"comment\">// 是循环定时器，并且没有被取消。</span></span><br><span class=\"line\">            it.second-&gt;<span class=\"built_in\">restart</span>(now);</span><br><span class=\"line\">            <span class=\"built_in\">insert</span>(it.second);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// FIXME move to a free list</span></span><br><span class=\"line\">            <span class=\"keyword\">delete</span> it.second; <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> no delete please</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timers_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        nextExpire = timers_.<span class=\"built_in\">begin</span>()-&gt;second-&gt;<span class=\"built_in\">expiration</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextExpire.<span class=\"built_in\">valid</span>())&#123;</span><br><span class=\"line\">        <span class=\"built_in\">resetTimerfd</span>(timerfd_, nextExpire);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TimerQueue::insert</span><span class=\"params\">(Timer* timer)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    <span class=\"type\">bool</span> earliestChanged = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    Timestamp when = timer-&gt;<span class=\"built_in\">expiration</span>(); <span class=\"comment\">// timer超时时间</span></span><br><span class=\"line\">    TimerList::iterator it = timers_.<span class=\"built_in\">begin</span>(); <span class=\"comment\">// 原来定时器中最早超时的定时器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it == timers_.<span class=\"built_in\">end</span>() || when &lt; it-&gt;first)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// 原本timers_就没有定时器 || 要插入的定时器超时时间 比 原来的timers_中第一个定时器 早。</span></span><br><span class=\"line\">        <span class=\"comment\">// 都代表：插入新定时器后，最早超时时间会发生改变，需要重新设置timeFd。</span></span><br><span class=\"line\">        earliestChanged = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 插入timers_</span></span><br><span class=\"line\">    <span class=\"comment\">// std::set::insert</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 同步到activeTimers_</span></span><br><span class=\"line\">    <span class=\"comment\">// std::set::insert</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> earliestChanged;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"细节明细：\"><a href=\"#细节明细：\" class=\"headerlink\" title=\"细节明细：\"></a>细节明细：</h2><p><strong>疑问</strong></p>\n<p>定时器模块存在的意义？</p>\n<p><strong>解答</strong></p>\n<ol>\n<li><p>事件触发机制： 定时器在Muduo中被用作一种事件触发机制。通过设置定时器，用户可以在指定的时间间隔内执行相应的操作，例如执行定时任务、发送心跳包等。这种事件触发机制有助于异步编程中的任务调度和协调。</p>\n</li>\n<li><p>超时处理： 定时器用于处理超时事件，例如连接超时、读写操作超时等。通过设置合适的定时器，Muduo可以及时检测并处理超时情况，确保网络应用的稳定性和可靠性。</p>\n</li>\n<li><p>可能还不太全，后面再有所感悟再来更新。。。</p>\n</li>\n</ol>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"WorkFlow源码剖析——Communicator之TCPServer（上）","date":"2024-11-02T04:00:00.000Z","_content":"\n[WorkFlow源码剖析——GO-Task 源码分析](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlow源码剖析——Communicator之TCPServer（上）](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlow源码剖析——Communicator之TCPServer（中）](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlow源码剖析——Communicator之TCPServer（下）](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\n## 前言\n\n上一篇博客已经介绍了一下WorkFlow GO-Task的实现原理。本文会介绍一下WorkFlow Tcp Server端的一些实现细节以及有趣的思想。因为这部分涉及的内容有点多，一些有趣的细节也希望能完整的叙述出来，所以我可能会将TCPServer拆分成上中下三个部分。三个部分分别对应：poller的实现（即对IO对路复用事件池的封装，属于最底层），Communicator的实现（对连接对象生命周期的管理，属于中间层），最后就是TCPServer的实现（利用中间层实现一个TCPServer）。文件异步IO相关的内容，后面抽空会补上。\n\n<!-- more -->\n\n这里声明一下：\n\n关于workflow的线程池，其实最终的目的就是实现一个线程池嘛，知道它是个什么东西，看一下它的接口，其实就差不多了。原理都是一样的，就是实现细节上各有各的特点。workflow的线程池简单描述它的特点就是一种链式的线程池。它所涉及的源码也不多就200多行，如果专门起一篇博客去讲解它，以我的表达能力和理解的深度，估计到时候代码的比例又会占大头。成了纯纯的贴代码的博客是我不愿意看到的。所以如果你对workflow线程池的实现感兴趣，建议你亲自去看看它的源码。我始终认为，如果你想了解一个项目的源码，博客写的再好，也只能作为辅助，它只能在你看源码有疑惑时给你一些指点，或者说作为你在读完源码后，回头巩固的一种手段。最终亲眼看看代码才是正道。\n\n关于消息队列，和线程池紧密相关的就是任务（/消息）队列。我最大的收货就是：我们以往再写线程池任务队列时，读写都是一把锁，而workflow线程的任务队列却有两把锁，**读和写分别持有一把**，巧妙的降低了锁的竞争。具体细节，感兴趣的读者可以自行阅读源码，这里就不过多赘述。\n\nWorkflow其实没有TcpServer的概念，相关的其实就是一个CommService，而CommService其实可以理解为TCPServer，尽管CommService其实也是支持udp等其他非tcp的协议。但是我们重点只关注tcp相关的东西。所以，下文提到的TcpServer都代指CommService。\n\n本文会按照如下顺序讲解TcpServer的实现：\n\npoller相关的数据结构的介绍 -> 事件循环的设计 -> 对poller_node的增删改 -> 对定时器的增删 -> 对IO事件回调函数的流程分析。\n\n## 对IO以及IO多路复用的封装\n\n本节内容主要集中在poller.c文件，主要关注workflow对epoll事件池的设计以及linux原生IO相关api的最底层的封装。这里涉及大量的回调。不得不说workflow对回调理解的是真的透彻。\n\n### 数据结构的分析\n\n首先是数据结构__poller：\n\n```cpp\ntypedef struct __poller poller_t;   // 对外暴露的名称\n\nstruct __poller\n{\n\tsize_t max_open_files;                              // 该epollfd支持的最大fd\n\tvoid (*callback)(struct poller_result *, void *);   // 由Communicator设置，Communicator会根据poller_result.poller_data.operation的类型回调不同的函数。\n\tvoid *context;                                      // 传给callback的参数\n\n\tpthread_t tid;                                      // epollfd监听线程的线程id\n\tint pfd;                                            // epollfd\n\tint timerfd;\n\tint pipe_rd;                                        // 管道读端，通知回收某个/些__poller_node\n\tint pipe_wr;                                        // 管道写端\n\tint stopped;\n\tstruct rb_root timeo_tree;                          // 带超时的__poller_node红黑树，以下三个成员都和[定时器]红黑树相关\n\tstruct rb_node *tree_first;\n\tstruct rb_node *tree_last;\n\tstruct list_head timeo_list;                        // 带超时的__poller_node链表\n\tstruct list_head no_timeo_list;                     // 不带超时的__poller_node链表\n\tstruct __poller_node **nodes;                       // 可根据fd索引每一个__poller_node\n\tpthread_mutex_t mutex;\n\tchar buf[POLLER_BUFSIZE];                           // 共享buffer\n};\n```\n\npoller的数据结构每项成员的定义非常恰到好处，我相信比较难理解的就是为啥为定时器搞了两种结构：链表和红黑树？后面在看到定时器的增删查改时再谈谈我的理解。\n\n这里可以先用定时器类型，简单的对__poller_node进行分类：\n\n1. 带超时的__poller_node：带超时的__poller_node又有两种挂法：\n\n    1. 被挂到红黑树timeo_tree上。\n\n    2. 按递增顺序，被挂到超时链表timeo_list上。\n\n2. 不带超时的__poller_node：被挂到no_timeo_list链表上。\n\n然后就是数据结构__poller_node：\n\n它的定义如下：\n\n```cpp\nstruct __poller_node\n{\n\tint state;                  // __poller_node的状态\n\tint error;\n\tstruct poller_data data;    // 稍后解释\n#pragma pack(1)\n\tunion\n\t{\n\t\tstruct list_head list;  // 如果是在链表上使用该成员作为节点\n\t\tstruct rb_node rb;      // 如果是在红黑树上使用该成员作为节点\n\t};\n#pragma pack()\n\tchar in_rbtree;             // 是在红黑树上吗？\n\tchar removed;               // 被从epoll上移除取消监听（链表/红黑树上也会移除该node）\n\tint event;                  // epoll监听的事件\n\tstruct timespec timeout;    // fd超时时间\n\tstruct __poller_node *res;  // 稍后解释，（PS，我也有点忘了）\n};\n```\n\n如果你看过Muduo的源码，那么__poller + __poller_node可以看作Muduo当中的EPollPoller，而Muduo当中，定时器同样使用的是timerfd_，区别是Muduo当中直接使用了标准库当中的std::set对定时器进行排序，而workflow使用的是自己造的红黑树的轮子。并且workflow额外使用了一个链表来维护带超时的__poller_node。\n\n当然在__poller_node结构体当中，我还没有解释data成员是干啥的，这里既然扯到了Muduo，顺便提一嘴：data成员其实可以等价与Muduo当中的Channel。poller_data当中也是有各种来自（Communicator）上层注册的回调函数。\n\npoller_dataj结构体在workflow当中定义如下：\n\n```cpp\nstruct poller_data\n{\n// poll关心的事件的定义。\n#define PD_OP_TIMER\t\t\t0\n#define PD_OP_READ\t\t\t1\n#define PD_OP_WRITE\t\t\t2\n#define PD_OP_LISTEN\t\t3\n#define PD_OP_CONNECT\t\t4\n#define PD_OP_RECVFROM\t\t5\n/* ... */\n#define PD_OP_EVENT\t\t\t9\n#define PD_OP_NOTIFY\t\t10\n\tshort operation;\n\tunsigned short iovcnt;\n\tint fd;\n\tSSL *ssl;\n\tunion\n\t{\n\t\tpoller_message_t *(*create_message)(void *);    // 钩爪异步读上下文的回调\n\t\tint (*partial_written)(size_t, void *);\n\t\tvoid *(*accept)(const struct sockaddr *, socklen_t, int, void *);\n\t\tvoid *(*recvfrom)(const struct sockaddr *, socklen_t,\n\t\t\t\t\t\t  const void *, size_t, void *);\n\t\tvoid *(*event)(void *);\n\t\tvoid *(*notify)(void *, void *);\n\t};\n\tvoid *context;\n\tunion\n\t{\n\t\tpoller_message_t *message;      // 异步读上下文，由create_message创建\n\t\tstruct iovec *write_iov;        // 异步写缓存\n\t\tvoid *result;\n\t};\n};\n```\n\n|\t回调函数\t\t|\t作用\t|\n|\t:-:\t\t\t\t|\t:-:\t\t|\n|\tcreate_message\t|\t（fd的read事件）利用该回调可以构造一个msg对象，并且每次在fd可读时，将读到的数据交给该msg去处理（解析），解释完成后返回一个大于0的值，然后通poller的callback通知上层（Communicator）|\n|\tpartial_written\t|\t（fd的write事件）在每次fd可写并且**尽力**写入一些数据后会调用该回调，以更新写超时时间\t|\n| accept\t\t\t|\t（fd的read事件）在listen fd接受一条连接并为连接创建一个读写sockfd后，会调用该回调，回调会为该sockfd创建一个CommServiceTarget对象\t|\n|\trecvfrom\t\t|\t（fd的read事件）使用udp协议的读（可以先不管，主要研究tcp，先将workflow的tcp打通）\t|\n|\tevent\t\t\t|\t（fd的read事件）为实现文件fd的异步读写而生，作者暂时还未能去详细了解，在后续有空了再补上，我们重点还是关注网络socket fd的读写事件和回调\t|\n|\tnotify\t|\t同event\t|\n\n\n其次就是poller_result结构体，该结构体其实就是__poller_node最前面三个成员。在poller.c当中，poller_result一般是以指针的形式去使用，并且是将__poller_node类型的变量的地址作为其值，如果你C语言基础足够扎实，结合poller_result和__poller_node定义的成员去看，其实很容易的理解到：**将__poller_node类型的变量的地址作为poller_result*变量的值的用法就是只使用__poller_node的前三个成员。**\n\n```cpp\n\nstruct poller_result\n{\n#define PR_ST_SUCCESS\t\t0\n#define PR_ST_FINISHED\t\t1\n#define PR_ST_ERROR\t\t\t2\n#define PR_ST_DELETED\t\t3\n#define PR_ST_MODIFIED\t\t4\n#define PR_ST_STOPPED\t\t5\n\tint state;\n\tint error;\n\tstruct poller_data data;\n\t/* In callback, spaces of six pointers are available from here. */\n};\n```\n\n在了解了poller当中的数据结构之后，如果你之前有过阅读其他网络库/框架相关源码，其实我们就可以猜测，workflow当中的poller一定会有针对epollfd/超时链表/红黑树进行增删查改的一些函数。\n\n这里吐槽一下workflow，我觉得muduo、sylar这些网络框架层次其实更加分明，epoll池是epoll池、io读写操作是io读写操作、定时器是定时器。而在workflow当中。这三部分完全混合在了一个文件当中去实现。导致我最开始看poller源码时，感觉很混乱。\n\n### 事件循环（Event Loop） --- 主干\n\n凡是网络框架都会使用epoll/poll等IO多路复用机制，不得不说IO多路复用机制也确实挺好用的。而使用了IO多路复用机制的程序肯定避不开事件循环。本小节会逐步讲解从__poller的创建 到 事件循环的启动。\n\n首先是__poller的创建，其实__poller和__mpoller的创建可以放一起去讲解，__mpoller就是一群__poller的集合，可以将__mpoller理解为__poller的manager，一个__poller在创建时会申请一个epollfd，而__mpoller向外部提供的接口是具有负载均衡的功能的，它会将读写socketfd分散的发给__poller，同样的__poller内部就是一群__poller_node的集合（socket fd），你也可以将__poller看作__poller_node的manager。下面来看看__mpoller是如何构造每一个__poller的。\n\n```cpp\nstatic int __mpoller_create(const struct poller_params *params,\n\t\t\t\t\t\t\tmpoller_t *mpoller) {\n\tvoid **nodes_buf = (void **)calloc(params->max_open_files, sizeof (void *));\n\tunsigned int i;\n\n\tif (nodes_buf) {\n\t\tfor (i = 0; i < mpoller->nthreads; i++) {\n\t\t\tmpoller->poller[i] = __poller_create(nodes_buf, params);\n\t\t\tif (!mpoller->poller[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == mpoller->nthreads) {\n\t\t\tmpoller->nodes_buf = nodes_buf;\n\t\t\treturn 0;\n\t\t}\n\t\t// ...\n\t}\n\n\treturn -1;\n}\n```\n\n代码很简单，就是分配一个max_open_files大小的指针数组（nodes_buf），然后调用__poller_create函数，将nodes_buf作为参数构造__poller对象，__poller_create会根据传入的参数对__poller做一些初始化，而__poller的nodes成员被初始化为指向nodes_buf，前面介绍过，nodes成员可根据socket fd索引__poller_node。 **那么问题就来了，多个__poller共用一个nodes_buf，这样不会有问题吗？？？**\n\n（经过深入思考）我可以明确的告诉你，确实不会，而且这种用法还很奇妙。这是因为有 **{nodes成员可根据socket fd索引__poller_node}** 这句话保底，因为在linux当中，一个进程当中的描述符（fd）绝对不可能重复！所以即使你创建的多个__poller对象，多个__poller对象又共用一个nodes_buf，但是分配给它们的socket fd（__poller_node）绝对**互不相同**，又因为__poller_node是根据socket fd索引的，故真实的情况是：**每个__poller会共用一个nodes_buf，但是各自使用nodes_buf的不同entry。**\n\n然后就是__poller的启动，调用mpoller的mpoller_start函数可以启动所有的__poller，对于每个__poller的启动会调用poller_start函数，它的实现如下：\n\n```cpp\nint poller_start(poller_t *poller) {\n\tpthread_t tid;\n\tint ret;\n\n\tpthread_mutex_lock(&poller->mutex);\n\tif (__poller_open_pipe(poller) >= 0) {\n\t\tret = pthread_create(&tid, NULL, __poller_thread_routine, poller);\n\t\tif (ret == 0) {\n\t\t\tpoller->tid = tid;\n\t\t\tpoller->stopped = 0;\n\t\t}\n\t\telse {\n\t\t\terrno = ret;\n\t\t\tclose(poller->pipe_wr);\n\t\t\tclose(poller->pipe_rd);\n\t\t}\n\t}\n\n\tpthread_mutex_unlock(&poller->mutex);\n\treturn -poller->stopped;\n}\n```\n\n主要就干了两件事：\n\n1. 调用__poller_open_pipe函数创建pipfd，将pipfd读端注册到epollfd上，pipfd在__poller当中起到内存回收的作用。具体是什么玩法，后面详细解释。（PS：说实话第一次看到用pipfd做内存回收的用法感觉挺不可思议的。真得感叹一句真是艺高人胆大！）\n\n2. 创建并启动事件循环线程。\n\n总结一下就是和Muduo**很像**的One loop per thread，注意这里的加粗，在看完workflow的__poller源码后，感觉和Muduo的还是有很大差别的，我只能说Muduo的One loop per thread的思想的纯净，Muduo的代码阅读起来也很舒服。而workflow的却不同，它可能夹杂着业务优化的考量，所以并不是那么纯粹的One loop per thread，所以我在源码阅读时比较坎坷。（也可能是我功力不够深厚，没能领悟其奥妙。）针对加锁方面尤为明显，两者每个loop线程都会有自己的互斥锁，Muduo仅在对任务队列操作的时候会加锁，而workflow加锁的范围会稍微大点，凡是对__poller内部数据成员的访问都会加锁。\n\n事件循环的历程函数是__poller_thread_routine，它的实现如下：\n\n```cpp\nstatic void *__poller_thread_routine(void *arg) {\n\tpoller_t *poller = (poller_t *)arg;\n\t__poller_event_t events[POLLER_EVENTS_MAX];\n\tstruct __poller_node time_node;\n\tstruct __poller_node *node;\n\tint has_pipe_event;\n\tint nevents;\n\tint i;\n\n\twhile (1) {\n\t\t// 将最早超时的节点的超时时间作为定时器的超时时间\n\t\t__poller_set_timer(poller);\n\t\t// 等待时间的到来\n\t\tnevents = __poller_wait(events, POLLER_EVENTS_MAX, poller);\n\t\t// 获取当前时间，小于该时间的节点视为超时。\n\t\tclock_gettime(CLOCK_MONOTONIC, &time_node.timeout);\n\t\t// pipfd可读？\n\t\thas_pipe_event = 0;\n\t\tfor (i = 0; i < nevents; i++) {\n\t\t\t// 将private转换为__poller_node*\n\t\t\tnode = (struct __poller_node *)__poller_event_data(&events[i]);\n\t\t\tif (node <= (struct __poller_node *)1) {\t// 是pipfd？\n\t\t\t\tif (node == (struct __poller_node *)1)\n\t\t\t\t\thas_pipe_event = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 根据__poller_node.data的operation调用对应的回调函数。\n\t\t\tswitch (node->data.operation) {\n\t\t\tcase PD_OP_READ:\n\t\t\t\t__poller_handle_read(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_WRITE:\n\t\t\t\t__poller_handle_write(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_LISTEN:\n\t\t\t\t__poller_handle_listen(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_CONNECT:\n\t\t\t\t__poller_handle_connect(node, poller);\n\t\t\t\tbreak;\n\t\t\t/* 省略SSL、UDP相关部分... */\n\t\t\tcase PD_OP_EVENT:\n\t\t\t\t__poller_handle_event(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_NOTIFY:\n\t\t\t\t__poller_handle_notify(node, poller);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (has_pipe_event) {\n\t\t\t// 内存回收\n\t\t\tif (__poller_handle_pipe(poller))\n\t\t\t\tbreak;\n\t\t}\n\t\t// 处理超时的__poller_node\n\t\t__poller_handle_timeout(&time_node, poller);\n\t}\n\n\treturn NULL;\n}\n```\n\n流程事件循环的流程图如下所示：\n\n![](./TCPServer_1/photo/EventLoopFlowChart.drawio.png)\n\n最后改造了一下之前画的Muduo的one loop per thread的架构图。放在下面，读者可以好好品味一下。\n\n![](./TCPServer_1/photo/EventLoopThreadPool.drawio.png)\n\n你可以参考一下[Muduo的one loop per thread的架构图](../muduo/EventLoopThreadPool.md)，以及[xv6最后优化其调度器模型的架构图](../xv6/Scheduler.md)，再来看workflow的__poller的架构图，你一定会吃惊它们是如此的相似！\n\n### 对poller_node的增删改\n\npoller对外暴露的对对poller_node的增删改的接口包括：poller_add、poller_del、poller_mod。\n\n**首先：**\n\n这些接口在sylar、muduo中其实也有类似的。从函数的名称其实就能推测出它们分别代表：\n\n```bash\npoller_add -> 向poller中添加poller_node;\n\npoller_del -> 删除poller_node;\n\npoller_mod -> 修改poller_node;\n```\n\n**进一步的：**\n\n1. poller_add本质上会将poller_node.data.fd连同关心的读/写事件**添加**到epoll当中。如果poller_node.timeout被用户设置过，还会将poller_node挂到超时链表上或者是红黑树上。**适当的时候更新timefd的设置。**\n\n2. poller_del本质会将poller_node.data.fd连同关心的读/写事件从epoll当中**删除**。\n\n3. poller_mod本质上会**修改**被挂到epoll当中的poller_node.data.fd所关心的读/写事件。当然此时如果用户重新设置了poller_node的超时时间，则应该**调整**poller_node在超时链表/红黑树的位置。**适当的时候更新timefd的设置。**\n\n**实际上的：**\n\npoller实际源码也正是这样做的。这里有一些比较意思的实践，这里一一列举一下：\n\n首先是根据poller_node的超时时间，将poller_node挂到超时链表/红黑树上的操作。这个操作在poller_add、poller_mod都有需求。所以在poller当中是实现一个专门的函数__poller_insert_node，该函数功能就是**将poller_node插入到超时链表/红黑树适当位置，并且在poller_node是最早超时的节点时，更新timefd的设置。**\n\npoller_node源码如下：\n\n```cpp\n\nstatic void __poller_insert_node(struct __poller_node *node,\n\t\t\t\t\t\t\t\t poller_t *poller) {\n\tstruct __poller_node *end;\n\n\tend = list_entry(poller->timeo_list.prev, struct __poller_node, list);\n\tif (list_empty(&poller->timeo_list)) {\n\t\tlist_add(&node->list, &poller->timeo_list);\n\t\tend = rb_entry(poller->tree_first, struct __poller_node, rb);\n\t} else if (__timeout_cmp(node, end) >= 0) {\n\t\tlist_add_tail(&node->list, &poller->timeo_list);\n\t\treturn;\n\t} else {\n\t\t__poller_tree_insert(node, poller);\n\t\tif (&node->rb != poller->tree_first)\n\t\t\treturn;\n\n\t\tend = list_entry(poller->timeo_list.next, struct __poller_node, list);\n\t}\n\n\tif (!poller->tree_first || __timeout_cmp(node, end) < 0)\n\t\t__poller_set_timerfd(poller->timerfd, &node->timeout, poller);\n}\n```\n\n第一次看这段代码可能会感觉比较绕，下面我来梳理它的逻辑：\n\n其实主要是三个分支，假设现在要添加名为node的poller_node：\n\n0. 先获取（按升序排列的）超时链表上的最后一个元素。\n\n1. 如果超时链表为空，直接将node加到超时链表尾部，然后获取红黑树第一个poller_node，如果红黑树为空或者说node比红黑树的第一个poller_node还小。那么将timefd的超时时间设置为node的超时时间。\n\n2. 如果node比超时链表最后一个poller_node超时时间还大。那直接将node添加到超时链表末尾即可。timefd不用改。\n\n3. 如果node超时时间小于超时链表最后一个元素超时时间，就将node添加到红黑树上。此时要是node正好作为红黑树的第一个元素（红黑树当中最小的节点），就比较一下node超时时间和超时链表第一个元素的超时时间。如果node比链表第一个元素超时时间小的话，更新timefd为node的超时时间。\n\n仔细梳理一下该函数的逻辑其实也是很清晰的。说白了就是将node添加到链表/红黑树当中，同时当node是作为最小超时时间时，更新一下timefd的超时时间。这里使用两种数据结构的原因是：\n\n1. 利用升序链表追加比红黑树快的优点；\n\n2. 利用红黑树随机插入比升序链表快的优点；\n\n其次就是poller当中内存管理的做法：\n\n对于poller_add、poller_mod其实会调用__poller_new_node（间接调用malloc）分配一个新的地址作为poller_node。\n\n对于poller_del，会将poller_node从超时链表/红黑树上移除。同时**将poller_node的地址作为数据，写到pipe当中。等待pipe读时间处理函数调用poller->callback去回收**。这种将地址写到管道然后异步回收的做法在我最开始看到的时候是为它捏了一把汗的。像我这种普通人肯定写不出这样的代码的。\n\n这里可以欣赏一下poller_del的代码\n\n```cpp\nint poller_del(int fd, poller_t *poller) {\n\tstruct __poller_node *node;\n\tint stopped = 0;\n\n\tpthread_mutex_lock(&poller->mutex);\n\tnode = poller->nodes[fd];\n\tif (node) {\n\t\tpoller->nodes[fd] = NULL;\n\n\t\tif (node->in_rbtree)\n\t\t\t__poller_tree_erase(node, poller);\n\t\telse\n\t\t\t// 要么是被从超时链表上移除，要么是被从非超时链表上删除。统一都可以使用list_del来删除。\n\t\t\tlist_del(&node->list);\n\n\t\t__poller_del_fd(fd, node->event, poller);\n\n\t\tnode->error = 0;\n\t\tnode->state = PR_ST_DELETED;\n\t\tstopped = poller->stopped;\n\t\tif (!stopped) {\n\t\t\tnode->removed = 1;\n\t\t\t// 将地址写到pipe当中，异步让pipe读事件去回收\n\t\t\twrite(poller->pipe_wr, &node, sizeof (void *));\n\t\t}\n\t}\n\telse\n\t\terrno = ENOENT;\n\n\tpthread_mutex_unlock(&poller->mutex);\n\tif (stopped) {\n\t\t// 事件处理线程停止了，就主动去释放了。其实pipe读事件处理函数也是做下面这两步操作\n\t\tfree(node->res);\n\t\tpoller->callback((struct poller_result *)node, poller->context);\n\t}\n\n\treturn -!node;\n}\n```\n\n### 定时器的增删\n\npoller对外暴露的定时器操作的接口包括：poller_add_timer、poller_del_timer，简单来说就是对定时器进行添加和删除。\n\n这里可以需要明确一点，超时事件分为两类：定时器超时 和 读写事件的超时。\n\n- 定时器超时是指：用户需要指定一个回调函数在延迟n ms后才执行。使用场景比如：1分钟向文件写入一条日志，日志内容是系统当前运行状态。\n\n- 读写事件超时是指：在规定的超时时间内必需进行一次io，否则将操作视为超时，进行对应的超时处理。使用场景比如：HTTP的保活（keepalived）。\n\n这两者区别是：定时器超时是**一定会发生**的，而对于读写事件超时，只要规定时间内有io事件发生，则超时**不一定会发生**。\n\npoller当中定时器其实就是fd为（无效）-1的__poller_node，它不会被添加到epoll当中，但是会根据超时时间被挂到超时链表/红黑树上。超时后的处理和IO事件超时的处理一模一样。\n\n这里贴出部分poller_add_timer代码：\n\n```cpp\nint poller_add_timer(const struct timespec *value, void *context, void **timer,\n\t\t\t\t\t poller_t *poller) {\n\tstruct __poller_node *node;\n\n\tnode = (struct __poller_node *)malloc(sizeof (struct __poller_node));\n\tif (node) {\n\t\tnode->data.operation = PD_OP_TIMER;\n\t\tnode->data.fd = -1;\t\t\t\t\t// 标记为无效\n\t\tnode->data.context = context;\n\n\t\t/* ... */\n\t\tclock_gettime(CLOCK_MONOTONIC, &node->timeout);\n\t\tnode->timeout.tv_sec += value->tv_sec;\n\t\tnode->timeout.tv_nsec += value->tv_nsec;\n\t\tif (node->timeout.tv_nsec >= 1000000000) {\n\t\t\tnode->timeout.tv_nsec -= 1000000000;\n\t\t\tnode->timeout.tv_sec++;\n\t\t}\n\n\t\t*timer = node;\n\t\tpthread_mutex_lock(&poller->mutex);\n\t\t__poller_insert_node(node, poller);\t// 将poller_node添加到超时链表/红黑树上。\n\t\tpthread_mutex_unlock(&poller->mutex);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n```\n\n__poller_insert_node函数代码上小结已贴出。poller_del_timer函数实现可以参考poller_del，感兴趣的读者可以直接翻看源码，这里不过多赘述。\n\n### 事件处理函数\n\n下面逐个分析poller当中IO事件的处理函数细节。本文是以workflow的TCPServer为主，这里默认阅读本文的读者是有网络编程的经验的，那么你一定知道一个TCP的服务端最基本的框架如下：\n\n```\n\t+-----------+\n\t|\tsocket\t|\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tbind\t|\t最开始三步由Communicator完成，下一篇博客会细讲。\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tlisten\t|\n\t+-----------+\n\t\t|\t\t\t______________________________________________\n\t\tV\n\t+-----------+\n\t|\taccept\t|\t从这里开始涉及到的所以函数就是接下来讲解的重点。\n\t+-----------+\n\t|\t|\t|\t|\n\tV\tV\tV\tV\n\tfd\tfd\tfd\t...\n\t\t/\\\n\tread  write\n```\n\n本节就以上图所示顺序逐一介绍各个处理函数实现细节。\n\n======================================================\n\n首先是accept事件处理函数————__poller_handle_listen，代码如下：\n\n```cpp\n\nstatic void __poller_handle_listen(struct __poller_node *node,\n\t\t\t\t\t\t\t\t   poller_t *poller) {\n\tstruct __poller_node *res = node->res;\n\t/* ... */\n\twhile (1) {\n\t\taddrlen = sizeof (struct sockaddr_storage);\n\t\tsockfd = accept(node->data.fd, addr, &addrlen);\n\t\tif (sockfd < 0) {\n\t\t\tif (errno == EAGAIN || errno == EMFILE || errno == ENFILE)\n\t\t\t\treturn;\n\t\t\telse if (errno == ECONNABORTED)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tresult = node->data.accept(addr, addrlen, sockfd, node->data.context);\n\t\tif (!result)\n\t\t\tbreak;\n\n\t\tres->data = node->data;\n\t\tres->data.result = result;\n\t\tres->error = 0;\n\t\tres->state = PR_ST_SUCCESS;\n\t\tpoller->callback((struct poller_result *)res, poller->context);\n\n\t\tres = (struct __poller_node *)malloc(sizeof (struct __poller_node));\n\t\tnode->res = res;\n\t\tif (!res)\n\t\t\tbreak;\n\t}\n\n\tif (__poller_remove_node(node, poller))\t// 从epoll当中移除fd\n\t\treturn;\n\n\tnode->error = errno;\n\tnode->state = PR_ST_ERROR;\n\tfree(node->res);\n\tpoller->callback((struct poller_result *)node, poller->context);\t// 一般是server在停止或出错才会走到这里。\t\n}\n```\n\n逻辑是：不断在一个while循环当中执行如下过程：\n\n1. （非阻塞的）调用accept系统调用接受客户端的连接。EAGAIN、EMFILE、ENFILE、ECONNABORTED分别代表没有可用连接、文件描述符达到上限、系统无句柄可用、连接终止（客户端的原因）。这些错误都是网络编程当中很常规的错误。都是可以容忍的。所以该return的return，该continue就continue。\n\n2. 当接收到一条合法的io连接，就将其scoketfd作为参数回调node->data.accept，它会回调 Communicator::accept函数，该函数会为连接构造一个CommServiceTarget对象作为返回值，**这里并没有将sockfd设置为非阻塞**。这里读者可以先不必探究CommServiceTarget是干什么的，在下一章讲解Communicator自然会明了。因为我一开始也不知道CommServiceTarget的作用。可以从它的命名先猜测它其实就是IO连接在服务端的一个对象实体吧。\n\n3. 回调poller->callback，其实在看完后面的read、write等io事件的处理函数之后，就会发现最早都会调用poller->callback，该回调也是在下章讲解Communicator后才发挥重要作用，读者先把它看作黑盒即可。可以预料到它里面一定会将接受的sockfd**设置为非阻塞**，并且最终会将它包装成poller_node加入到poller当中。\n\n======================================================\n\n然后是read事件处理函数————__poller_handle_read，（去除了和SSL相关的代码，剩余的）代码如下：\n\n```cpp\nstatic int __poller_append_message(const void *buf, size_t *n,\n\t\t\t\t\t\t\t\t   struct __poller_node *node,\n\t\t\t\t\t\t\t\t   poller_t *poller) {\n\tpoller_message_t *msg = node->data.message;\n\tstruct __poller_node *res;\n\tint ret;\n\n\tif (!msg) {\t// 为连接的每个请求包分配一个msg\n\t\tres = (struct __poller_node *)malloc(sizeof (struct __poller_node));\n\t\tif (!res)\n\t\t\treturn -1;\n\n\t\tmsg = node->data.create_message(node->data.context);\n\t\tif (!msg) {\n\t\t\tfree(res);\n\t\t\treturn -1;\n\t\t}\n\n\t\tnode->data.message = msg;\n\t\tnode->res = res;\n\t}\n\telse\n\t\tres = node->res;\n\n\tret = msg->append(buf, n, msg);\t// 通过msg解析请求包（PS，注意同一个请求可能会被拆分成多个tcp报文发送，所以函数可能会被多次回调）\n\tif (ret > 0) {\n\t\tres->data = node->data;\n\t\tres->error = 0;\n\t\tres->state = PR_ST_SUCCESS;\n\t\t// 当msg收到完整的请求包且解析完后同样回调一下poller->callback\n\t\tpoller->callback((struct poller_result *)res, poller->context);\n\n\t\tnode->data.message = NULL;\t// 清空，为下一个请求做准备\n\t\tnode->res = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic void __poller_handle_read(struct __poller_node *node,\n\t\t\t\t\t\t\t\t poller_t *poller) {\n\tssize_t nleft;\n\tsize_t n;\n\tchar *p;\n\n\twhile (1) {\n\t\tp = poller->buf;\n\t\tnleft = read(node->data.fd, p, POLLER_BUFSIZE);\n\t\tif (nleft < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (nleft <= 0)\n\t\t\tbreak;\n\n\t\tdo {\n\t\t\tn = nleft;\n\t\t\tif (__poller_append_message(p, &n, node, poller) >= 0) {\n\t\t\t\tnleft -= n;\n\t\t\t\tp += n;\n\t\t\t}\n\t\t\telse\n\t\t\t\tnleft = -1;\n\t\t} while (nleft > 0);\n\n\t\tif (nleft < 0)\n\t\t\tbreak;\n\t}\t// 连接断开或则有错误发生\n\n\tif (__poller_remove_node(node, poller))\n\t\treturn;\n\n\tif (nleft == 0) {\n\t\tnode->error = 0;\n\t\tnode->state = PR_ST_FINISHED;\n\t} else {\n\t\tnode->error = errno;\n\t\tnode->state = PR_ST_ERROR;\n\t}\n\n\tfree(node->res);\n\tpoller->callback((struct poller_result *)node, poller->context);\n}\n```\n\n因为是异步read，所以__poller_handle_read回调多次才能读完一个完整的客户端请求报文。它的逻辑。主要就是两步，（非阻塞的方式）调用原始read系统调用，然后调用__poller_append_message函数去逐步解析收到的数据。当连接断开或则出现错误就跳出循环，回调poller->callback处理错误。**这里我们其实可以大胆猜测__poller_append_message函数当中msg->append函数肯定是一个（HTTP、DNS等）报文解析器。**\n\n这里有一个比较有意思的点是read系统调用所使用的buffer是poller->buf，它是poller的数据成员，这里所有的fd在read的时候使用同一个buffer，难道不会出问题吗？read的数据不会乱吗？\n\n这里简单分析一下，首先考虑线程安全问题，因为前面说过：一个poller对应一个线程。所以在线程处理IO事件的时候，一定是串行的，这就排除并行导致的线程安全问题。\n\n其次，再考虑异步非阻塞的方式读数据，东读一下西读一下会不会存在数据乱掉的问题，如果你仔细分析过__poller_handle_read其实就不会出现这个疑问，因为__poller_handle_read在通过poller->buf接受到数据后，不管这个请求是否完整，都会在__poller_append_message函数里面的msg->append进行**异步解析**。解析完毕后，poller->buf上的数据也就失去了它的意义。所以在处理下一个read事件的时候，放心的随他使用poller->buf吧。\n\n======================================================\n\n最后write事件处理函数————__poller_handle_write，代码如下：\n\n```cpp\nstatic void __poller_handle_write(struct __poller_node *node,\n\t\t\t\t\t\t\t\t  poller_t *poller)\n{\n\tstruct iovec *iov = node->data.write_iov;\n\tsize_t count = 0;\n\tssize_t nleft;\n\tint iovcnt;\n\tint ret;\n\n\twhile (node->data.iovcnt > 0) {\n\t\tiovcnt = node->data.iovcnt;\n\t\tif (iovcnt > IOV_MAX)\n\t\t\tiovcnt = IOV_MAX;\n\n\t\tnleft = writev(node->data.fd, iov, iovcnt);\n\t\tif (nleft < 0) {\n\t\t\tret = errno == EAGAIN ? 0 : -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount += nleft;\n\t\tdo {\t\t\t\t\t\t\t// 修正iov\n\t\t\tif (nleft >= iov->iov_len) {\n\t\t\t\tnleft -= iov->iov_len;\n\t\t\t\tiov->iov_base = (char *)iov->iov_base + iov->iov_len;\n\t\t\t\tiov->iov_len = 0;\n\t\t\t\tiov++;\n\t\t\t\tnode->data.iovcnt--;\n\t\t\t} else {\n\t\t\t\tiov->iov_base = (char *)iov->iov_base + nleft;\n\t\t\t\tiov->iov_len -= nleft;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (node->data.iovcnt > 0);\n\t}\n\n\tnode->data.write_iov = iov;\n\tif (node->data.iovcnt > 0 && ret >= 0) {\n\t\tif (count == 0)\n\t\t\treturn;\n\n\t\tif (node->data.partial_written(count, node->data.context) >= 0)\t// 通知一下已发送的数据量\n\t\t\treturn;\n\t}\n\n\tif (__poller_remove_node(node, poller))\n\t\treturn;\n\n\tif (node->data.iovcnt == 0) {\t// 为零结束\n\t\tnode->error = 0;\n\t\tnode->state = PR_ST_FINISHED;\t\n\t} else {\t\t\t\t\t\t// 否则出错\n\t\tnode->error = errno;\n\t\tnode->state = PR_ST_ERROR;\t\t\n\t}\n\n\tpoller->callback((struct poller_result *)node, poller->context);\n}\n```\n\n同样，因为是异步写数据，一个客户请求的回复报文可能分多次write才能发送完毕。poller向socketfd写数据采用的是writev接口，writev接口可以很方便的将内存不连续的数据发送到网络上。这在需要向网络写入大量的数据时很方便。因为数据量大所以系统无法一次性分配那么大块内存，所以数据可能被放在内存不连续的离散的buffer当中。writev使用元素类型为struct iovec的数组作为数据缓存，数组当中每个元素存放指向一块缓存的首地址的指针和长度。（非阻塞的）writev会返回实际发送的字节数。从代码中可以看到while循环嵌套了一个do while，因为tcp发送缓存区是有限的，do while作用是根据实际发送的字节数抹除已经发生的buffer，重新计算iov数组等待下一轮while循环继续发送。\n\n当发送缓存满，会因为EAGAIN跳出while循环，同时因为还存在没有发送完毕的数据，会调用node->data.partial_written。当数发送完毕，会将poller_node从epoll当中移除（对写事件的监听），最后回调poller->callback。\n\n---\n\n**本章完结**","source":"_posts/workflow/TCPServer_1.md","raw":"---\ntitle: WorkFlow源码剖析——Communicator之TCPServer（上）\ndate: 2024-11-02 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n[WorkFlow源码剖析——GO-Task 源码分析](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlow源码剖析——Communicator之TCPServer（上）](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlow源码剖析——Communicator之TCPServer（中）](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlow源码剖析——Communicator之TCPServer（下）](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\n## 前言\n\n上一篇博客已经介绍了一下WorkFlow GO-Task的实现原理。本文会介绍一下WorkFlow Tcp Server端的一些实现细节以及有趣的思想。因为这部分涉及的内容有点多，一些有趣的细节也希望能完整的叙述出来，所以我可能会将TCPServer拆分成上中下三个部分。三个部分分别对应：poller的实现（即对IO对路复用事件池的封装，属于最底层），Communicator的实现（对连接对象生命周期的管理，属于中间层），最后就是TCPServer的实现（利用中间层实现一个TCPServer）。文件异步IO相关的内容，后面抽空会补上。\n\n<!-- more -->\n\n这里声明一下：\n\n关于workflow的线程池，其实最终的目的就是实现一个线程池嘛，知道它是个什么东西，看一下它的接口，其实就差不多了。原理都是一样的，就是实现细节上各有各的特点。workflow的线程池简单描述它的特点就是一种链式的线程池。它所涉及的源码也不多就200多行，如果专门起一篇博客去讲解它，以我的表达能力和理解的深度，估计到时候代码的比例又会占大头。成了纯纯的贴代码的博客是我不愿意看到的。所以如果你对workflow线程池的实现感兴趣，建议你亲自去看看它的源码。我始终认为，如果你想了解一个项目的源码，博客写的再好，也只能作为辅助，它只能在你看源码有疑惑时给你一些指点，或者说作为你在读完源码后，回头巩固的一种手段。最终亲眼看看代码才是正道。\n\n关于消息队列，和线程池紧密相关的就是任务（/消息）队列。我最大的收货就是：我们以往再写线程池任务队列时，读写都是一把锁，而workflow线程的任务队列却有两把锁，**读和写分别持有一把**，巧妙的降低了锁的竞争。具体细节，感兴趣的读者可以自行阅读源码，这里就不过多赘述。\n\nWorkflow其实没有TcpServer的概念，相关的其实就是一个CommService，而CommService其实可以理解为TCPServer，尽管CommService其实也是支持udp等其他非tcp的协议。但是我们重点只关注tcp相关的东西。所以，下文提到的TcpServer都代指CommService。\n\n本文会按照如下顺序讲解TcpServer的实现：\n\npoller相关的数据结构的介绍 -> 事件循环的设计 -> 对poller_node的增删改 -> 对定时器的增删 -> 对IO事件回调函数的流程分析。\n\n## 对IO以及IO多路复用的封装\n\n本节内容主要集中在poller.c文件，主要关注workflow对epoll事件池的设计以及linux原生IO相关api的最底层的封装。这里涉及大量的回调。不得不说workflow对回调理解的是真的透彻。\n\n### 数据结构的分析\n\n首先是数据结构__poller：\n\n```cpp\ntypedef struct __poller poller_t;   // 对外暴露的名称\n\nstruct __poller\n{\n\tsize_t max_open_files;                              // 该epollfd支持的最大fd\n\tvoid (*callback)(struct poller_result *, void *);   // 由Communicator设置，Communicator会根据poller_result.poller_data.operation的类型回调不同的函数。\n\tvoid *context;                                      // 传给callback的参数\n\n\tpthread_t tid;                                      // epollfd监听线程的线程id\n\tint pfd;                                            // epollfd\n\tint timerfd;\n\tint pipe_rd;                                        // 管道读端，通知回收某个/些__poller_node\n\tint pipe_wr;                                        // 管道写端\n\tint stopped;\n\tstruct rb_root timeo_tree;                          // 带超时的__poller_node红黑树，以下三个成员都和[定时器]红黑树相关\n\tstruct rb_node *tree_first;\n\tstruct rb_node *tree_last;\n\tstruct list_head timeo_list;                        // 带超时的__poller_node链表\n\tstruct list_head no_timeo_list;                     // 不带超时的__poller_node链表\n\tstruct __poller_node **nodes;                       // 可根据fd索引每一个__poller_node\n\tpthread_mutex_t mutex;\n\tchar buf[POLLER_BUFSIZE];                           // 共享buffer\n};\n```\n\npoller的数据结构每项成员的定义非常恰到好处，我相信比较难理解的就是为啥为定时器搞了两种结构：链表和红黑树？后面在看到定时器的增删查改时再谈谈我的理解。\n\n这里可以先用定时器类型，简单的对__poller_node进行分类：\n\n1. 带超时的__poller_node：带超时的__poller_node又有两种挂法：\n\n    1. 被挂到红黑树timeo_tree上。\n\n    2. 按递增顺序，被挂到超时链表timeo_list上。\n\n2. 不带超时的__poller_node：被挂到no_timeo_list链表上。\n\n然后就是数据结构__poller_node：\n\n它的定义如下：\n\n```cpp\nstruct __poller_node\n{\n\tint state;                  // __poller_node的状态\n\tint error;\n\tstruct poller_data data;    // 稍后解释\n#pragma pack(1)\n\tunion\n\t{\n\t\tstruct list_head list;  // 如果是在链表上使用该成员作为节点\n\t\tstruct rb_node rb;      // 如果是在红黑树上使用该成员作为节点\n\t};\n#pragma pack()\n\tchar in_rbtree;             // 是在红黑树上吗？\n\tchar removed;               // 被从epoll上移除取消监听（链表/红黑树上也会移除该node）\n\tint event;                  // epoll监听的事件\n\tstruct timespec timeout;    // fd超时时间\n\tstruct __poller_node *res;  // 稍后解释，（PS，我也有点忘了）\n};\n```\n\n如果你看过Muduo的源码，那么__poller + __poller_node可以看作Muduo当中的EPollPoller，而Muduo当中，定时器同样使用的是timerfd_，区别是Muduo当中直接使用了标准库当中的std::set对定时器进行排序，而workflow使用的是自己造的红黑树的轮子。并且workflow额外使用了一个链表来维护带超时的__poller_node。\n\n当然在__poller_node结构体当中，我还没有解释data成员是干啥的，这里既然扯到了Muduo，顺便提一嘴：data成员其实可以等价与Muduo当中的Channel。poller_data当中也是有各种来自（Communicator）上层注册的回调函数。\n\npoller_dataj结构体在workflow当中定义如下：\n\n```cpp\nstruct poller_data\n{\n// poll关心的事件的定义。\n#define PD_OP_TIMER\t\t\t0\n#define PD_OP_READ\t\t\t1\n#define PD_OP_WRITE\t\t\t2\n#define PD_OP_LISTEN\t\t3\n#define PD_OP_CONNECT\t\t4\n#define PD_OP_RECVFROM\t\t5\n/* ... */\n#define PD_OP_EVENT\t\t\t9\n#define PD_OP_NOTIFY\t\t10\n\tshort operation;\n\tunsigned short iovcnt;\n\tint fd;\n\tSSL *ssl;\n\tunion\n\t{\n\t\tpoller_message_t *(*create_message)(void *);    // 钩爪异步读上下文的回调\n\t\tint (*partial_written)(size_t, void *);\n\t\tvoid *(*accept)(const struct sockaddr *, socklen_t, int, void *);\n\t\tvoid *(*recvfrom)(const struct sockaddr *, socklen_t,\n\t\t\t\t\t\t  const void *, size_t, void *);\n\t\tvoid *(*event)(void *);\n\t\tvoid *(*notify)(void *, void *);\n\t};\n\tvoid *context;\n\tunion\n\t{\n\t\tpoller_message_t *message;      // 异步读上下文，由create_message创建\n\t\tstruct iovec *write_iov;        // 异步写缓存\n\t\tvoid *result;\n\t};\n};\n```\n\n|\t回调函数\t\t|\t作用\t|\n|\t:-:\t\t\t\t|\t:-:\t\t|\n|\tcreate_message\t|\t（fd的read事件）利用该回调可以构造一个msg对象，并且每次在fd可读时，将读到的数据交给该msg去处理（解析），解释完成后返回一个大于0的值，然后通poller的callback通知上层（Communicator）|\n|\tpartial_written\t|\t（fd的write事件）在每次fd可写并且**尽力**写入一些数据后会调用该回调，以更新写超时时间\t|\n| accept\t\t\t|\t（fd的read事件）在listen fd接受一条连接并为连接创建一个读写sockfd后，会调用该回调，回调会为该sockfd创建一个CommServiceTarget对象\t|\n|\trecvfrom\t\t|\t（fd的read事件）使用udp协议的读（可以先不管，主要研究tcp，先将workflow的tcp打通）\t|\n|\tevent\t\t\t|\t（fd的read事件）为实现文件fd的异步读写而生，作者暂时还未能去详细了解，在后续有空了再补上，我们重点还是关注网络socket fd的读写事件和回调\t|\n|\tnotify\t|\t同event\t|\n\n\n其次就是poller_result结构体，该结构体其实就是__poller_node最前面三个成员。在poller.c当中，poller_result一般是以指针的形式去使用，并且是将__poller_node类型的变量的地址作为其值，如果你C语言基础足够扎实，结合poller_result和__poller_node定义的成员去看，其实很容易的理解到：**将__poller_node类型的变量的地址作为poller_result*变量的值的用法就是只使用__poller_node的前三个成员。**\n\n```cpp\n\nstruct poller_result\n{\n#define PR_ST_SUCCESS\t\t0\n#define PR_ST_FINISHED\t\t1\n#define PR_ST_ERROR\t\t\t2\n#define PR_ST_DELETED\t\t3\n#define PR_ST_MODIFIED\t\t4\n#define PR_ST_STOPPED\t\t5\n\tint state;\n\tint error;\n\tstruct poller_data data;\n\t/* In callback, spaces of six pointers are available from here. */\n};\n```\n\n在了解了poller当中的数据结构之后，如果你之前有过阅读其他网络库/框架相关源码，其实我们就可以猜测，workflow当中的poller一定会有针对epollfd/超时链表/红黑树进行增删查改的一些函数。\n\n这里吐槽一下workflow，我觉得muduo、sylar这些网络框架层次其实更加分明，epoll池是epoll池、io读写操作是io读写操作、定时器是定时器。而在workflow当中。这三部分完全混合在了一个文件当中去实现。导致我最开始看poller源码时，感觉很混乱。\n\n### 事件循环（Event Loop） --- 主干\n\n凡是网络框架都会使用epoll/poll等IO多路复用机制，不得不说IO多路复用机制也确实挺好用的。而使用了IO多路复用机制的程序肯定避不开事件循环。本小节会逐步讲解从__poller的创建 到 事件循环的启动。\n\n首先是__poller的创建，其实__poller和__mpoller的创建可以放一起去讲解，__mpoller就是一群__poller的集合，可以将__mpoller理解为__poller的manager，一个__poller在创建时会申请一个epollfd，而__mpoller向外部提供的接口是具有负载均衡的功能的，它会将读写socketfd分散的发给__poller，同样的__poller内部就是一群__poller_node的集合（socket fd），你也可以将__poller看作__poller_node的manager。下面来看看__mpoller是如何构造每一个__poller的。\n\n```cpp\nstatic int __mpoller_create(const struct poller_params *params,\n\t\t\t\t\t\t\tmpoller_t *mpoller) {\n\tvoid **nodes_buf = (void **)calloc(params->max_open_files, sizeof (void *));\n\tunsigned int i;\n\n\tif (nodes_buf) {\n\t\tfor (i = 0; i < mpoller->nthreads; i++) {\n\t\t\tmpoller->poller[i] = __poller_create(nodes_buf, params);\n\t\t\tif (!mpoller->poller[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == mpoller->nthreads) {\n\t\t\tmpoller->nodes_buf = nodes_buf;\n\t\t\treturn 0;\n\t\t}\n\t\t// ...\n\t}\n\n\treturn -1;\n}\n```\n\n代码很简单，就是分配一个max_open_files大小的指针数组（nodes_buf），然后调用__poller_create函数，将nodes_buf作为参数构造__poller对象，__poller_create会根据传入的参数对__poller做一些初始化，而__poller的nodes成员被初始化为指向nodes_buf，前面介绍过，nodes成员可根据socket fd索引__poller_node。 **那么问题就来了，多个__poller共用一个nodes_buf，这样不会有问题吗？？？**\n\n（经过深入思考）我可以明确的告诉你，确实不会，而且这种用法还很奇妙。这是因为有 **{nodes成员可根据socket fd索引__poller_node}** 这句话保底，因为在linux当中，一个进程当中的描述符（fd）绝对不可能重复！所以即使你创建的多个__poller对象，多个__poller对象又共用一个nodes_buf，但是分配给它们的socket fd（__poller_node）绝对**互不相同**，又因为__poller_node是根据socket fd索引的，故真实的情况是：**每个__poller会共用一个nodes_buf，但是各自使用nodes_buf的不同entry。**\n\n然后就是__poller的启动，调用mpoller的mpoller_start函数可以启动所有的__poller，对于每个__poller的启动会调用poller_start函数，它的实现如下：\n\n```cpp\nint poller_start(poller_t *poller) {\n\tpthread_t tid;\n\tint ret;\n\n\tpthread_mutex_lock(&poller->mutex);\n\tif (__poller_open_pipe(poller) >= 0) {\n\t\tret = pthread_create(&tid, NULL, __poller_thread_routine, poller);\n\t\tif (ret == 0) {\n\t\t\tpoller->tid = tid;\n\t\t\tpoller->stopped = 0;\n\t\t}\n\t\telse {\n\t\t\terrno = ret;\n\t\t\tclose(poller->pipe_wr);\n\t\t\tclose(poller->pipe_rd);\n\t\t}\n\t}\n\n\tpthread_mutex_unlock(&poller->mutex);\n\treturn -poller->stopped;\n}\n```\n\n主要就干了两件事：\n\n1. 调用__poller_open_pipe函数创建pipfd，将pipfd读端注册到epollfd上，pipfd在__poller当中起到内存回收的作用。具体是什么玩法，后面详细解释。（PS：说实话第一次看到用pipfd做内存回收的用法感觉挺不可思议的。真得感叹一句真是艺高人胆大！）\n\n2. 创建并启动事件循环线程。\n\n总结一下就是和Muduo**很像**的One loop per thread，注意这里的加粗，在看完workflow的__poller源码后，感觉和Muduo的还是有很大差别的，我只能说Muduo的One loop per thread的思想的纯净，Muduo的代码阅读起来也很舒服。而workflow的却不同，它可能夹杂着业务优化的考量，所以并不是那么纯粹的One loop per thread，所以我在源码阅读时比较坎坷。（也可能是我功力不够深厚，没能领悟其奥妙。）针对加锁方面尤为明显，两者每个loop线程都会有自己的互斥锁，Muduo仅在对任务队列操作的时候会加锁，而workflow加锁的范围会稍微大点，凡是对__poller内部数据成员的访问都会加锁。\n\n事件循环的历程函数是__poller_thread_routine，它的实现如下：\n\n```cpp\nstatic void *__poller_thread_routine(void *arg) {\n\tpoller_t *poller = (poller_t *)arg;\n\t__poller_event_t events[POLLER_EVENTS_MAX];\n\tstruct __poller_node time_node;\n\tstruct __poller_node *node;\n\tint has_pipe_event;\n\tint nevents;\n\tint i;\n\n\twhile (1) {\n\t\t// 将最早超时的节点的超时时间作为定时器的超时时间\n\t\t__poller_set_timer(poller);\n\t\t// 等待时间的到来\n\t\tnevents = __poller_wait(events, POLLER_EVENTS_MAX, poller);\n\t\t// 获取当前时间，小于该时间的节点视为超时。\n\t\tclock_gettime(CLOCK_MONOTONIC, &time_node.timeout);\n\t\t// pipfd可读？\n\t\thas_pipe_event = 0;\n\t\tfor (i = 0; i < nevents; i++) {\n\t\t\t// 将private转换为__poller_node*\n\t\t\tnode = (struct __poller_node *)__poller_event_data(&events[i]);\n\t\t\tif (node <= (struct __poller_node *)1) {\t// 是pipfd？\n\t\t\t\tif (node == (struct __poller_node *)1)\n\t\t\t\t\thas_pipe_event = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 根据__poller_node.data的operation调用对应的回调函数。\n\t\t\tswitch (node->data.operation) {\n\t\t\tcase PD_OP_READ:\n\t\t\t\t__poller_handle_read(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_WRITE:\n\t\t\t\t__poller_handle_write(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_LISTEN:\n\t\t\t\t__poller_handle_listen(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_CONNECT:\n\t\t\t\t__poller_handle_connect(node, poller);\n\t\t\t\tbreak;\n\t\t\t/* 省略SSL、UDP相关部分... */\n\t\t\tcase PD_OP_EVENT:\n\t\t\t\t__poller_handle_event(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_NOTIFY:\n\t\t\t\t__poller_handle_notify(node, poller);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (has_pipe_event) {\n\t\t\t// 内存回收\n\t\t\tif (__poller_handle_pipe(poller))\n\t\t\t\tbreak;\n\t\t}\n\t\t// 处理超时的__poller_node\n\t\t__poller_handle_timeout(&time_node, poller);\n\t}\n\n\treturn NULL;\n}\n```\n\n流程事件循环的流程图如下所示：\n\n![](./TCPServer_1/photo/EventLoopFlowChart.drawio.png)\n\n最后改造了一下之前画的Muduo的one loop per thread的架构图。放在下面，读者可以好好品味一下。\n\n![](./TCPServer_1/photo/EventLoopThreadPool.drawio.png)\n\n你可以参考一下[Muduo的one loop per thread的架构图](../muduo/EventLoopThreadPool.md)，以及[xv6最后优化其调度器模型的架构图](../xv6/Scheduler.md)，再来看workflow的__poller的架构图，你一定会吃惊它们是如此的相似！\n\n### 对poller_node的增删改\n\npoller对外暴露的对对poller_node的增删改的接口包括：poller_add、poller_del、poller_mod。\n\n**首先：**\n\n这些接口在sylar、muduo中其实也有类似的。从函数的名称其实就能推测出它们分别代表：\n\n```bash\npoller_add -> 向poller中添加poller_node;\n\npoller_del -> 删除poller_node;\n\npoller_mod -> 修改poller_node;\n```\n\n**进一步的：**\n\n1. poller_add本质上会将poller_node.data.fd连同关心的读/写事件**添加**到epoll当中。如果poller_node.timeout被用户设置过，还会将poller_node挂到超时链表上或者是红黑树上。**适当的时候更新timefd的设置。**\n\n2. poller_del本质会将poller_node.data.fd连同关心的读/写事件从epoll当中**删除**。\n\n3. poller_mod本质上会**修改**被挂到epoll当中的poller_node.data.fd所关心的读/写事件。当然此时如果用户重新设置了poller_node的超时时间，则应该**调整**poller_node在超时链表/红黑树的位置。**适当的时候更新timefd的设置。**\n\n**实际上的：**\n\npoller实际源码也正是这样做的。这里有一些比较意思的实践，这里一一列举一下：\n\n首先是根据poller_node的超时时间，将poller_node挂到超时链表/红黑树上的操作。这个操作在poller_add、poller_mod都有需求。所以在poller当中是实现一个专门的函数__poller_insert_node，该函数功能就是**将poller_node插入到超时链表/红黑树适当位置，并且在poller_node是最早超时的节点时，更新timefd的设置。**\n\npoller_node源码如下：\n\n```cpp\n\nstatic void __poller_insert_node(struct __poller_node *node,\n\t\t\t\t\t\t\t\t poller_t *poller) {\n\tstruct __poller_node *end;\n\n\tend = list_entry(poller->timeo_list.prev, struct __poller_node, list);\n\tif (list_empty(&poller->timeo_list)) {\n\t\tlist_add(&node->list, &poller->timeo_list);\n\t\tend = rb_entry(poller->tree_first, struct __poller_node, rb);\n\t} else if (__timeout_cmp(node, end) >= 0) {\n\t\tlist_add_tail(&node->list, &poller->timeo_list);\n\t\treturn;\n\t} else {\n\t\t__poller_tree_insert(node, poller);\n\t\tif (&node->rb != poller->tree_first)\n\t\t\treturn;\n\n\t\tend = list_entry(poller->timeo_list.next, struct __poller_node, list);\n\t}\n\n\tif (!poller->tree_first || __timeout_cmp(node, end) < 0)\n\t\t__poller_set_timerfd(poller->timerfd, &node->timeout, poller);\n}\n```\n\n第一次看这段代码可能会感觉比较绕，下面我来梳理它的逻辑：\n\n其实主要是三个分支，假设现在要添加名为node的poller_node：\n\n0. 先获取（按升序排列的）超时链表上的最后一个元素。\n\n1. 如果超时链表为空，直接将node加到超时链表尾部，然后获取红黑树第一个poller_node，如果红黑树为空或者说node比红黑树的第一个poller_node还小。那么将timefd的超时时间设置为node的超时时间。\n\n2. 如果node比超时链表最后一个poller_node超时时间还大。那直接将node添加到超时链表末尾即可。timefd不用改。\n\n3. 如果node超时时间小于超时链表最后一个元素超时时间，就将node添加到红黑树上。此时要是node正好作为红黑树的第一个元素（红黑树当中最小的节点），就比较一下node超时时间和超时链表第一个元素的超时时间。如果node比链表第一个元素超时时间小的话，更新timefd为node的超时时间。\n\n仔细梳理一下该函数的逻辑其实也是很清晰的。说白了就是将node添加到链表/红黑树当中，同时当node是作为最小超时时间时，更新一下timefd的超时时间。这里使用两种数据结构的原因是：\n\n1. 利用升序链表追加比红黑树快的优点；\n\n2. 利用红黑树随机插入比升序链表快的优点；\n\n其次就是poller当中内存管理的做法：\n\n对于poller_add、poller_mod其实会调用__poller_new_node（间接调用malloc）分配一个新的地址作为poller_node。\n\n对于poller_del，会将poller_node从超时链表/红黑树上移除。同时**将poller_node的地址作为数据，写到pipe当中。等待pipe读时间处理函数调用poller->callback去回收**。这种将地址写到管道然后异步回收的做法在我最开始看到的时候是为它捏了一把汗的。像我这种普通人肯定写不出这样的代码的。\n\n这里可以欣赏一下poller_del的代码\n\n```cpp\nint poller_del(int fd, poller_t *poller) {\n\tstruct __poller_node *node;\n\tint stopped = 0;\n\n\tpthread_mutex_lock(&poller->mutex);\n\tnode = poller->nodes[fd];\n\tif (node) {\n\t\tpoller->nodes[fd] = NULL;\n\n\t\tif (node->in_rbtree)\n\t\t\t__poller_tree_erase(node, poller);\n\t\telse\n\t\t\t// 要么是被从超时链表上移除，要么是被从非超时链表上删除。统一都可以使用list_del来删除。\n\t\t\tlist_del(&node->list);\n\n\t\t__poller_del_fd(fd, node->event, poller);\n\n\t\tnode->error = 0;\n\t\tnode->state = PR_ST_DELETED;\n\t\tstopped = poller->stopped;\n\t\tif (!stopped) {\n\t\t\tnode->removed = 1;\n\t\t\t// 将地址写到pipe当中，异步让pipe读事件去回收\n\t\t\twrite(poller->pipe_wr, &node, sizeof (void *));\n\t\t}\n\t}\n\telse\n\t\terrno = ENOENT;\n\n\tpthread_mutex_unlock(&poller->mutex);\n\tif (stopped) {\n\t\t// 事件处理线程停止了，就主动去释放了。其实pipe读事件处理函数也是做下面这两步操作\n\t\tfree(node->res);\n\t\tpoller->callback((struct poller_result *)node, poller->context);\n\t}\n\n\treturn -!node;\n}\n```\n\n### 定时器的增删\n\npoller对外暴露的定时器操作的接口包括：poller_add_timer、poller_del_timer，简单来说就是对定时器进行添加和删除。\n\n这里可以需要明确一点，超时事件分为两类：定时器超时 和 读写事件的超时。\n\n- 定时器超时是指：用户需要指定一个回调函数在延迟n ms后才执行。使用场景比如：1分钟向文件写入一条日志，日志内容是系统当前运行状态。\n\n- 读写事件超时是指：在规定的超时时间内必需进行一次io，否则将操作视为超时，进行对应的超时处理。使用场景比如：HTTP的保活（keepalived）。\n\n这两者区别是：定时器超时是**一定会发生**的，而对于读写事件超时，只要规定时间内有io事件发生，则超时**不一定会发生**。\n\npoller当中定时器其实就是fd为（无效）-1的__poller_node，它不会被添加到epoll当中，但是会根据超时时间被挂到超时链表/红黑树上。超时后的处理和IO事件超时的处理一模一样。\n\n这里贴出部分poller_add_timer代码：\n\n```cpp\nint poller_add_timer(const struct timespec *value, void *context, void **timer,\n\t\t\t\t\t poller_t *poller) {\n\tstruct __poller_node *node;\n\n\tnode = (struct __poller_node *)malloc(sizeof (struct __poller_node));\n\tif (node) {\n\t\tnode->data.operation = PD_OP_TIMER;\n\t\tnode->data.fd = -1;\t\t\t\t\t// 标记为无效\n\t\tnode->data.context = context;\n\n\t\t/* ... */\n\t\tclock_gettime(CLOCK_MONOTONIC, &node->timeout);\n\t\tnode->timeout.tv_sec += value->tv_sec;\n\t\tnode->timeout.tv_nsec += value->tv_nsec;\n\t\tif (node->timeout.tv_nsec >= 1000000000) {\n\t\t\tnode->timeout.tv_nsec -= 1000000000;\n\t\t\tnode->timeout.tv_sec++;\n\t\t}\n\n\t\t*timer = node;\n\t\tpthread_mutex_lock(&poller->mutex);\n\t\t__poller_insert_node(node, poller);\t// 将poller_node添加到超时链表/红黑树上。\n\t\tpthread_mutex_unlock(&poller->mutex);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n```\n\n__poller_insert_node函数代码上小结已贴出。poller_del_timer函数实现可以参考poller_del，感兴趣的读者可以直接翻看源码，这里不过多赘述。\n\n### 事件处理函数\n\n下面逐个分析poller当中IO事件的处理函数细节。本文是以workflow的TCPServer为主，这里默认阅读本文的读者是有网络编程的经验的，那么你一定知道一个TCP的服务端最基本的框架如下：\n\n```\n\t+-----------+\n\t|\tsocket\t|\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tbind\t|\t最开始三步由Communicator完成，下一篇博客会细讲。\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tlisten\t|\n\t+-----------+\n\t\t|\t\t\t______________________________________________\n\t\tV\n\t+-----------+\n\t|\taccept\t|\t从这里开始涉及到的所以函数就是接下来讲解的重点。\n\t+-----------+\n\t|\t|\t|\t|\n\tV\tV\tV\tV\n\tfd\tfd\tfd\t...\n\t\t/\\\n\tread  write\n```\n\n本节就以上图所示顺序逐一介绍各个处理函数实现细节。\n\n======================================================\n\n首先是accept事件处理函数————__poller_handle_listen，代码如下：\n\n```cpp\n\nstatic void __poller_handle_listen(struct __poller_node *node,\n\t\t\t\t\t\t\t\t   poller_t *poller) {\n\tstruct __poller_node *res = node->res;\n\t/* ... */\n\twhile (1) {\n\t\taddrlen = sizeof (struct sockaddr_storage);\n\t\tsockfd = accept(node->data.fd, addr, &addrlen);\n\t\tif (sockfd < 0) {\n\t\t\tif (errno == EAGAIN || errno == EMFILE || errno == ENFILE)\n\t\t\t\treturn;\n\t\t\telse if (errno == ECONNABORTED)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tresult = node->data.accept(addr, addrlen, sockfd, node->data.context);\n\t\tif (!result)\n\t\t\tbreak;\n\n\t\tres->data = node->data;\n\t\tres->data.result = result;\n\t\tres->error = 0;\n\t\tres->state = PR_ST_SUCCESS;\n\t\tpoller->callback((struct poller_result *)res, poller->context);\n\n\t\tres = (struct __poller_node *)malloc(sizeof (struct __poller_node));\n\t\tnode->res = res;\n\t\tif (!res)\n\t\t\tbreak;\n\t}\n\n\tif (__poller_remove_node(node, poller))\t// 从epoll当中移除fd\n\t\treturn;\n\n\tnode->error = errno;\n\tnode->state = PR_ST_ERROR;\n\tfree(node->res);\n\tpoller->callback((struct poller_result *)node, poller->context);\t// 一般是server在停止或出错才会走到这里。\t\n}\n```\n\n逻辑是：不断在一个while循环当中执行如下过程：\n\n1. （非阻塞的）调用accept系统调用接受客户端的连接。EAGAIN、EMFILE、ENFILE、ECONNABORTED分别代表没有可用连接、文件描述符达到上限、系统无句柄可用、连接终止（客户端的原因）。这些错误都是网络编程当中很常规的错误。都是可以容忍的。所以该return的return，该continue就continue。\n\n2. 当接收到一条合法的io连接，就将其scoketfd作为参数回调node->data.accept，它会回调 Communicator::accept函数，该函数会为连接构造一个CommServiceTarget对象作为返回值，**这里并没有将sockfd设置为非阻塞**。这里读者可以先不必探究CommServiceTarget是干什么的，在下一章讲解Communicator自然会明了。因为我一开始也不知道CommServiceTarget的作用。可以从它的命名先猜测它其实就是IO连接在服务端的一个对象实体吧。\n\n3. 回调poller->callback，其实在看完后面的read、write等io事件的处理函数之后，就会发现最早都会调用poller->callback，该回调也是在下章讲解Communicator后才发挥重要作用，读者先把它看作黑盒即可。可以预料到它里面一定会将接受的sockfd**设置为非阻塞**，并且最终会将它包装成poller_node加入到poller当中。\n\n======================================================\n\n然后是read事件处理函数————__poller_handle_read，（去除了和SSL相关的代码，剩余的）代码如下：\n\n```cpp\nstatic int __poller_append_message(const void *buf, size_t *n,\n\t\t\t\t\t\t\t\t   struct __poller_node *node,\n\t\t\t\t\t\t\t\t   poller_t *poller) {\n\tpoller_message_t *msg = node->data.message;\n\tstruct __poller_node *res;\n\tint ret;\n\n\tif (!msg) {\t// 为连接的每个请求包分配一个msg\n\t\tres = (struct __poller_node *)malloc(sizeof (struct __poller_node));\n\t\tif (!res)\n\t\t\treturn -1;\n\n\t\tmsg = node->data.create_message(node->data.context);\n\t\tif (!msg) {\n\t\t\tfree(res);\n\t\t\treturn -1;\n\t\t}\n\n\t\tnode->data.message = msg;\n\t\tnode->res = res;\n\t}\n\telse\n\t\tres = node->res;\n\n\tret = msg->append(buf, n, msg);\t// 通过msg解析请求包（PS，注意同一个请求可能会被拆分成多个tcp报文发送，所以函数可能会被多次回调）\n\tif (ret > 0) {\n\t\tres->data = node->data;\n\t\tres->error = 0;\n\t\tres->state = PR_ST_SUCCESS;\n\t\t// 当msg收到完整的请求包且解析完后同样回调一下poller->callback\n\t\tpoller->callback((struct poller_result *)res, poller->context);\n\n\t\tnode->data.message = NULL;\t// 清空，为下一个请求做准备\n\t\tnode->res = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic void __poller_handle_read(struct __poller_node *node,\n\t\t\t\t\t\t\t\t poller_t *poller) {\n\tssize_t nleft;\n\tsize_t n;\n\tchar *p;\n\n\twhile (1) {\n\t\tp = poller->buf;\n\t\tnleft = read(node->data.fd, p, POLLER_BUFSIZE);\n\t\tif (nleft < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (nleft <= 0)\n\t\t\tbreak;\n\n\t\tdo {\n\t\t\tn = nleft;\n\t\t\tif (__poller_append_message(p, &n, node, poller) >= 0) {\n\t\t\t\tnleft -= n;\n\t\t\t\tp += n;\n\t\t\t}\n\t\t\telse\n\t\t\t\tnleft = -1;\n\t\t} while (nleft > 0);\n\n\t\tif (nleft < 0)\n\t\t\tbreak;\n\t}\t// 连接断开或则有错误发生\n\n\tif (__poller_remove_node(node, poller))\n\t\treturn;\n\n\tif (nleft == 0) {\n\t\tnode->error = 0;\n\t\tnode->state = PR_ST_FINISHED;\n\t} else {\n\t\tnode->error = errno;\n\t\tnode->state = PR_ST_ERROR;\n\t}\n\n\tfree(node->res);\n\tpoller->callback((struct poller_result *)node, poller->context);\n}\n```\n\n因为是异步read，所以__poller_handle_read回调多次才能读完一个完整的客户端请求报文。它的逻辑。主要就是两步，（非阻塞的方式）调用原始read系统调用，然后调用__poller_append_message函数去逐步解析收到的数据。当连接断开或则出现错误就跳出循环，回调poller->callback处理错误。**这里我们其实可以大胆猜测__poller_append_message函数当中msg->append函数肯定是一个（HTTP、DNS等）报文解析器。**\n\n这里有一个比较有意思的点是read系统调用所使用的buffer是poller->buf，它是poller的数据成员，这里所有的fd在read的时候使用同一个buffer，难道不会出问题吗？read的数据不会乱吗？\n\n这里简单分析一下，首先考虑线程安全问题，因为前面说过：一个poller对应一个线程。所以在线程处理IO事件的时候，一定是串行的，这就排除并行导致的线程安全问题。\n\n其次，再考虑异步非阻塞的方式读数据，东读一下西读一下会不会存在数据乱掉的问题，如果你仔细分析过__poller_handle_read其实就不会出现这个疑问，因为__poller_handle_read在通过poller->buf接受到数据后，不管这个请求是否完整，都会在__poller_append_message函数里面的msg->append进行**异步解析**。解析完毕后，poller->buf上的数据也就失去了它的意义。所以在处理下一个read事件的时候，放心的随他使用poller->buf吧。\n\n======================================================\n\n最后write事件处理函数————__poller_handle_write，代码如下：\n\n```cpp\nstatic void __poller_handle_write(struct __poller_node *node,\n\t\t\t\t\t\t\t\t  poller_t *poller)\n{\n\tstruct iovec *iov = node->data.write_iov;\n\tsize_t count = 0;\n\tssize_t nleft;\n\tint iovcnt;\n\tint ret;\n\n\twhile (node->data.iovcnt > 0) {\n\t\tiovcnt = node->data.iovcnt;\n\t\tif (iovcnt > IOV_MAX)\n\t\t\tiovcnt = IOV_MAX;\n\n\t\tnleft = writev(node->data.fd, iov, iovcnt);\n\t\tif (nleft < 0) {\n\t\t\tret = errno == EAGAIN ? 0 : -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount += nleft;\n\t\tdo {\t\t\t\t\t\t\t// 修正iov\n\t\t\tif (nleft >= iov->iov_len) {\n\t\t\t\tnleft -= iov->iov_len;\n\t\t\t\tiov->iov_base = (char *)iov->iov_base + iov->iov_len;\n\t\t\t\tiov->iov_len = 0;\n\t\t\t\tiov++;\n\t\t\t\tnode->data.iovcnt--;\n\t\t\t} else {\n\t\t\t\tiov->iov_base = (char *)iov->iov_base + nleft;\n\t\t\t\tiov->iov_len -= nleft;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (node->data.iovcnt > 0);\n\t}\n\n\tnode->data.write_iov = iov;\n\tif (node->data.iovcnt > 0 && ret >= 0) {\n\t\tif (count == 0)\n\t\t\treturn;\n\n\t\tif (node->data.partial_written(count, node->data.context) >= 0)\t// 通知一下已发送的数据量\n\t\t\treturn;\n\t}\n\n\tif (__poller_remove_node(node, poller))\n\t\treturn;\n\n\tif (node->data.iovcnt == 0) {\t// 为零结束\n\t\tnode->error = 0;\n\t\tnode->state = PR_ST_FINISHED;\t\n\t} else {\t\t\t\t\t\t// 否则出错\n\t\tnode->error = errno;\n\t\tnode->state = PR_ST_ERROR;\t\t\n\t}\n\n\tpoller->callback((struct poller_result *)node, poller->context);\n}\n```\n\n同样，因为是异步写数据，一个客户请求的回复报文可能分多次write才能发送完毕。poller向socketfd写数据采用的是writev接口，writev接口可以很方便的将内存不连续的数据发送到网络上。这在需要向网络写入大量的数据时很方便。因为数据量大所以系统无法一次性分配那么大块内存，所以数据可能被放在内存不连续的离散的buffer当中。writev使用元素类型为struct iovec的数组作为数据缓存，数组当中每个元素存放指向一块缓存的首地址的指针和长度。（非阻塞的）writev会返回实际发送的字节数。从代码中可以看到while循环嵌套了一个do while，因为tcp发送缓存区是有限的，do while作用是根据实际发送的字节数抹除已经发生的buffer，重新计算iov数组等待下一轮while循环继续发送。\n\n当发送缓存满，会因为EAGAIN跳出while循环，同时因为还存在没有发送完毕的数据，会调用node->data.partial_written。当数发送完毕，会将poller_node从epoll当中移除（对写事件的监听），最后回调poller->callback。\n\n---\n\n**本章完结**","slug":"workflow/TCPServer_1","published":1,"updated":"2025-09-28T14:33:27.743Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9s000uq8ws80lh02fu","content":"<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlow源码剖析——GO-Task 源码分析</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlow源码剖析——Communicator之TCPServer（上）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlow源码剖析——Communicator之TCPServer（中）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlow源码剖析——Communicator之TCPServer（下）</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇博客已经介绍了一下WorkFlow GO-Task的实现原理。本文会介绍一下WorkFlow Tcp Server端的一些实现细节以及有趣的思想。因为这部分涉及的内容有点多，一些有趣的细节也希望能完整的叙述出来，所以我可能会将TCPServer拆分成上中下三个部分。三个部分分别对应：poller的实现（即对IO对路复用事件池的封装，属于最底层），Communicator的实现（对连接对象生命周期的管理，属于中间层），最后就是TCPServer的实现（利用中间层实现一个TCPServer）。文件异步IO相关的内容，后面抽空会补上。</p>\n<span id=\"more\"></span>\n\n<p>这里声明一下：</p>\n<p>关于workflow的线程池，其实最终的目的就是实现一个线程池嘛，知道它是个什么东西，看一下它的接口，其实就差不多了。原理都是一样的，就是实现细节上各有各的特点。workflow的线程池简单描述它的特点就是一种链式的线程池。它所涉及的源码也不多就200多行，如果专门起一篇博客去讲解它，以我的表达能力和理解的深度，估计到时候代码的比例又会占大头。成了纯纯的贴代码的博客是我不愿意看到的。所以如果你对workflow线程池的实现感兴趣，建议你亲自去看看它的源码。我始终认为，如果你想了解一个项目的源码，博客写的再好，也只能作为辅助，它只能在你看源码有疑惑时给你一些指点，或者说作为你在读完源码后，回头巩固的一种手段。最终亲眼看看代码才是正道。</p>\n<p>关于消息队列，和线程池紧密相关的就是任务（&#x2F;消息）队列。我最大的收货就是：我们以往再写线程池任务队列时，读写都是一把锁，而workflow线程的任务队列却有两把锁，<strong>读和写分别持有一把</strong>，巧妙的降低了锁的竞争。具体细节，感兴趣的读者可以自行阅读源码，这里就不过多赘述。</p>\n<p>Workflow其实没有TcpServer的概念，相关的其实就是一个CommService，而CommService其实可以理解为TCPServer，尽管CommService其实也是支持udp等其他非tcp的协议。但是我们重点只关注tcp相关的东西。所以，下文提到的TcpServer都代指CommService。</p>\n<p>本文会按照如下顺序讲解TcpServer的实现：</p>\n<p>poller相关的数据结构的介绍 -&gt; 事件循环的设计 -&gt; 对poller_node的增删改 -&gt; 对定时器的增删 -&gt; 对IO事件回调函数的流程分析。</p>\n<h2 id=\"对IO以及IO多路复用的封装\"><a href=\"#对IO以及IO多路复用的封装\" class=\"headerlink\" title=\"对IO以及IO多路复用的封装\"></a>对IO以及IO多路复用的封装</h2><p>本节内容主要集中在poller.c文件，主要关注workflow对epoll事件池的设计以及linux原生IO相关api的最底层的封装。这里涉及大量的回调。不得不说workflow对回调理解的是真的透彻。</p>\n<h3 id=\"数据结构的分析\"><a href=\"#数据结构的分析\" class=\"headerlink\" title=\"数据结构的分析\"></a>数据结构的分析</h3><p>首先是数据结构__poller：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">__poller</span> <span class=\"type\">poller_t</span>;   <span class=\"comment\">// 对外暴露的名称</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">__poller</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> max_open_files;                              <span class=\"comment\">// 该epollfd支持的最大fd</span></span><br><span class=\"line\">\t<span class=\"built_in\">void</span> (*callback)(<span class=\"keyword\">struct</span> poller_result *, <span class=\"type\">void</span> *);   <span class=\"comment\">// 由Communicator设置，Communicator会根据poller_result.poller_data.operation的类型回调不同的函数。</span></span><br><span class=\"line\">\t<span class=\"type\">void</span> *context;                                      <span class=\"comment\">// 传给callback的参数</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">pthread_t</span> tid;                                      <span class=\"comment\">// epollfd监听线程的线程id</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> pfd;                                            <span class=\"comment\">// epollfd</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> timerfd;</span><br><span class=\"line\">\t<span class=\"type\">int</span> pipe_rd;                                        <span class=\"comment\">// 管道读端，通知回收某个/些__poller_node</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> pipe_wr;                                        <span class=\"comment\">// 管道写端</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> stopped;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_root</span> timeo_tree;                          <span class=\"comment\">// 带超时的__poller_node红黑树，以下三个成员都和[定时器]红黑树相关</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_node</span> *tree_first;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_node</span> *tree_last;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> timeo_list;                        <span class=\"comment\">// 带超时的__poller_node链表</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> no_timeo_list;                     <span class=\"comment\">// 不带超时的__poller_node链表</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> **nodes;                       <span class=\"comment\">// 可根据fd索引每一个__poller_node</span></span><br><span class=\"line\">\t<span class=\"type\">pthread_mutex_t</span> mutex;</span><br><span class=\"line\">\t<span class=\"type\">char</span> buf[POLLER_BUFSIZE];                           <span class=\"comment\">// 共享buffer</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>poller的数据结构每项成员的定义非常恰到好处，我相信比较难理解的就是为啥为定时器搞了两种结构：链表和红黑树？后面在看到定时器的增删查改时再谈谈我的理解。</p>\n<p>这里可以先用定时器类型，简单的对__poller_node进行分类：</p>\n<ol>\n<li><p>带超时的__poller_node：带超时的__poller_node又有两种挂法：</p>\n<ol>\n<li><p>被挂到红黑树timeo_tree上。</p>\n</li>\n<li><p>按递增顺序，被挂到超时链表timeo_list上。</p>\n</li>\n</ol>\n</li>\n<li><p>不带超时的__poller_node：被挂到no_timeo_list链表上。</p>\n</li>\n</ol>\n<p>然后就是数据结构__poller_node：</p>\n<p>它的定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> state;                  <span class=\"comment\">// __poller_node的状态</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> error;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span> data;    <span class=\"comment\">// 稍后解释</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack(1)</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> list;  <span class=\"comment\">// 如果是在链表上使用该成员作为节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_node</span> rb;      <span class=\"comment\">// 如果是在红黑树上使用该成员作为节点</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack()</span></span><br><span class=\"line\">\t<span class=\"type\">char</span> in_rbtree;             <span class=\"comment\">// 是在红黑树上吗？</span></span><br><span class=\"line\">\t<span class=\"type\">char</span> removed;               <span class=\"comment\">// 被从epoll上移除取消监听（链表/红黑树上也会移除该node）</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> event;                  <span class=\"comment\">// epoll监听的事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">timespec</span> timeout;    <span class=\"comment\">// fd超时时间</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *res;  <span class=\"comment\">// 稍后解释，（PS，我也有点忘了）</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果你看过Muduo的源码，那么__poller + __poller_node可以看作Muduo当中的EPollPoller，而Muduo当中，定时器同样使用的是timerfd_，区别是Muduo当中直接使用了标准库当中的std::set对定时器进行排序，而workflow使用的是自己造的红黑树的轮子。并且workflow额外使用了一个链表来维护带超时的__poller_node。</p>\n<p>当然在__poller_node结构体当中，我还没有解释data成员是干啥的，这里既然扯到了Muduo，顺便提一嘴：data成员其实可以等价与Muduo当中的Channel。poller_data当中也是有各种来自（Communicator）上层注册的回调函数。</p>\n<p>poller_dataj结构体在workflow当中定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">// poll关心的事件的定义。</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_TIMER\t\t\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_READ\t\t\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_WRITE\t\t\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_LISTEN\t\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_CONNECT\t\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_RECVFROM\t\t5</span></span><br><span class=\"line\"><span class=\"comment\">/* ... */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_EVENT\t\t\t9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_NOTIFY\t\t10</span></span><br><span class=\"line\">\t<span class=\"type\">short</span> operation;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">short</span> iovcnt;</span><br><span class=\"line\">\t<span class=\"type\">int</span> fd;</span><br><span class=\"line\">\tSSL *ssl;</span><br><span class=\"line\">\t<span class=\"keyword\">union</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">poller_message_t</span> *(*create_message)(<span class=\"type\">void</span> *);    <span class=\"comment\">// 钩爪异步读上下文的回调</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">int</span> (*partial_written)(<span class=\"type\">size_t</span>, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*accept)(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *, <span class=\"type\">socklen_t</span>, <span class=\"type\">int</span>, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*recvfrom)(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *, <span class=\"type\">socklen_t</span>,</span><br><span class=\"line\">\t\t\t\t\t\t  <span class=\"type\">const</span> <span class=\"type\">void</span> *, <span class=\"type\">size_t</span>, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*event)(<span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*notify)(<span class=\"type\">void</span> *, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"type\">void</span> *context;</span><br><span class=\"line\">\t<span class=\"keyword\">union</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">poller_message_t</span> *message;      <span class=\"comment\">// 异步读上下文，由create_message创建</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> *write_iov;        <span class=\"comment\">// 异步写缓存</span></span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *result;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>|\t回调函数\t\t|\t作用\t|<br>|\t:-:\t\t\t\t|\t:-:\t\t|<br>|\tcreate_message\t|\t（fd的read事件）利用该回调可以构造一个msg对象，并且每次在fd可读时，将读到的数据交给该msg去处理（解析），解释完成后返回一个大于0的值，然后通poller的callback通知上层（Communicator）|<br>|\tpartial_written\t|\t（fd的write事件）在每次fd可写并且<strong>尽力</strong>写入一些数据后会调用该回调，以更新写超时时间\t|<br>| accept\t\t\t|\t（fd的read事件）在listen fd接受一条连接并为连接创建一个读写sockfd后，会调用该回调，回调会为该sockfd创建一个CommServiceTarget对象\t|<br>|\trecvfrom\t\t|\t（fd的read事件）使用udp协议的读（可以先不管，主要研究tcp，先将workflow的tcp打通）\t|<br>|\tevent\t\t\t|\t（fd的read事件）为实现文件fd的异步读写而生，作者暂时还未能去详细了解，在后续有空了再补上，我们重点还是关注网络socket fd的读写事件和回调\t|<br>|\tnotify\t|\t同event\t|</p>\n<p>其次就是poller_result结构体，该结构体其实就是__poller_node最前面三个成员。在poller.c当中，poller_result一般是以指针的形式去使用，并且是将__poller_node类型的变量的地址作为其值，如果你C语言基础足够扎实，结合poller_result和__poller_node定义的成员去看，其实很容易的理解到：<strong>将__poller_node类型的变量的地址作为poller_result*变量的值的用法就是只使用__poller_node的前三个成员。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">poller_result</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_SUCCESS\t\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_FINISHED\t\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_ERROR\t\t\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_DELETED\t\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_MODIFIED\t\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_STOPPED\t\t5</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> state;</span><br><span class=\"line\">\t<span class=\"type\">int</span> error;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span> data;</span><br><span class=\"line\">\t<span class=\"comment\">/* In callback, spaces of six pointers are available from here. */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在了解了poller当中的数据结构之后，如果你之前有过阅读其他网络库&#x2F;框架相关源码，其实我们就可以猜测，workflow当中的poller一定会有针对epollfd&#x2F;超时链表&#x2F;红黑树进行增删查改的一些函数。</p>\n<p>这里吐槽一下workflow，我觉得muduo、sylar这些网络框架层次其实更加分明，epoll池是epoll池、io读写操作是io读写操作、定时器是定时器。而在workflow当中。这三部分完全混合在了一个文件当中去实现。导致我最开始看poller源码时，感觉很混乱。</p>\n<h3 id=\"事件循环（Event-Loop）-—-主干\"><a href=\"#事件循环（Event-Loop）-—-主干\" class=\"headerlink\" title=\"事件循环（Event Loop） — 主干\"></a>事件循环（Event Loop） — 主干</h3><p>凡是网络框架都会使用epoll&#x2F;poll等IO多路复用机制，不得不说IO多路复用机制也确实挺好用的。而使用了IO多路复用机制的程序肯定避不开事件循环。本小节会逐步讲解从__poller的创建 到 事件循环的启动。</p>\n<p>首先是__poller的创建，其实__poller和__mpoller的创建可以放一起去讲解，__mpoller就是一群__poller的集合，可以将__mpoller理解为__poller的manager，一个__poller在创建时会申请一个epollfd，而__mpoller向外部提供的接口是具有负载均衡的功能的，它会将读写socketfd分散的发给__poller，同样的__poller内部就是一群__poller_node的集合（socket fd），你也可以将__poller看作__poller_node的manager。下面来看看__mpoller是如何构造每一个__poller的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __mpoller_create(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> poller_params *params,</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"type\">mpoller_t</span> *mpoller) &#123;</span><br><span class=\"line\">\t<span class=\"type\">void</span> **nodes_buf = (<span class=\"type\">void</span> **)<span class=\"built_in\">calloc</span>(params-&gt;max_open_files, <span class=\"built_in\">sizeof</span> (<span class=\"type\">void</span> *));</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (nodes_buf) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; mpoller-&gt;nthreads; i++) &#123;</span><br><span class=\"line\">\t\t\tmpoller-&gt;poller[i] = __poller_create(nodes_buf, params);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!mpoller-&gt;poller[i])</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == mpoller-&gt;nthreads) &#123;</span><br><span class=\"line\">\t\t\tmpoller-&gt;nodes_buf = nodes_buf;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很简单，就是分配一个max_open_files大小的指针数组（nodes_buf），然后调用__poller_create函数，将nodes_buf作为参数构造__poller对象，__poller_create会根据传入的参数对__poller做一些初始化，而__poller的nodes成员被初始化为指向nodes_buf，前面介绍过，nodes成员可根据socket fd索引__poller_node。 <strong>那么问题就来了，多个__poller共用一个nodes_buf，这样不会有问题吗？？？</strong></p>\n<p>（经过深入思考）我可以明确的告诉你，确实不会，而且这种用法还很奇妙。这是因为有 <strong>{nodes成员可根据socket fd索引__poller_node}</strong> 这句话保底，因为在linux当中，一个进程当中的描述符（fd）绝对不可能重复！所以即使你创建的多个__poller对象，多个__poller对象又共用一个nodes_buf，但是分配给它们的socket fd（__poller_node）绝对<strong>互不相同</strong>，又因为__poller_node是根据socket fd索引的，故真实的情况是：<strong>每个__poller会共用一个nodes_buf，但是各自使用nodes_buf的不同entry。</strong></p>\n<p>然后就是__poller的启动，调用mpoller的mpoller_start函数可以启动所有的__poller，对于每个__poller的启动会调用poller_start函数，它的实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">poller_start</span><span class=\"params\">(<span class=\"type\">poller_t</span> *poller)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">pthread_t</span> tid;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_open_pipe(poller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tret = <span class=\"built_in\">pthread_create</span>(&amp;tid, <span class=\"literal\">NULL</span>, __poller_thread_routine, poller);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tpoller-&gt;tid = tid;</span><br><span class=\"line\">\t\t\tpoller-&gt;stopped = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\terrno = ret;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(poller-&gt;pipe_wr);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(poller-&gt;pipe_rd);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -poller-&gt;stopped;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要就干了两件事：</p>\n<ol>\n<li><p>调用__poller_open_pipe函数创建pipfd，将pipfd读端注册到epollfd上，pipfd在__poller当中起到内存回收的作用。具体是什么玩法，后面详细解释。（PS：说实话第一次看到用pipfd做内存回收的用法感觉挺不可思议的。真得感叹一句真是艺高人胆大！）</p>\n</li>\n<li><p>创建并启动事件循环线程。</p>\n</li>\n</ol>\n<p>总结一下就是和Muduo<strong>很像</strong>的One loop per thread，注意这里的加粗，在看完workflow的__poller源码后，感觉和Muduo的还是有很大差别的，我只能说Muduo的One loop per thread的思想的纯净，Muduo的代码阅读起来也很舒服。而workflow的却不同，它可能夹杂着业务优化的考量，所以并不是那么纯粹的One loop per thread，所以我在源码阅读时比较坎坷。（也可能是我功力不够深厚，没能领悟其奥妙。）针对加锁方面尤为明显，两者每个loop线程都会有自己的互斥锁，Muduo仅在对任务队列操作的时候会加锁，而workflow加锁的范围会稍微大点，凡是对__poller内部数据成员的访问都会加锁。</p>\n<p>事件循环的历程函数是__poller_thread_routine，它的实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *__poller_thread_routine(<span class=\"type\">void</span> *arg) &#123;</span><br><span class=\"line\">\t<span class=\"type\">poller_t</span> *poller = (<span class=\"type\">poller_t</span> *)arg;</span><br><span class=\"line\">\t<span class=\"type\">__poller_event_t</span> events[POLLER_EVENTS_MAX];</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> time_node;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *node;</span><br><span class=\"line\">\t<span class=\"type\">int</span> has_pipe_event;</span><br><span class=\"line\">\t<span class=\"type\">int</span> nevents;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将最早超时的节点的超时时间作为定时器的超时时间</span></span><br><span class=\"line\">\t\t__poller_set_timer(poller);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 等待时间的到来</span></span><br><span class=\"line\">\t\tnevents = __poller_wait(events, POLLER_EVENTS_MAX, poller);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 获取当前时间，小于该时间的节点视为超时。</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">clock_gettime</span>(CLOCK_MONOTONIC, &amp;time_node.timeout);</span><br><span class=\"line\">\t\t<span class=\"comment\">// pipfd可读？</span></span><br><span class=\"line\">\t\thas_pipe_event = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nevents; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将private转换为__poller_node*</span></span><br><span class=\"line\">\t\t\tnode = (<span class=\"keyword\">struct</span> __poller_node *)__poller_event_data(&amp;events[i]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (node &lt;= (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"number\">1</span>) &#123;\t<span class=\"comment\">// 是pipfd？</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (node == (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t\thas_pipe_event = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 根据__poller_node.data的operation调用对应的回调函数。</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (node-&gt;data.operation) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_READ:</span><br><span class=\"line\">\t\t\t\t__poller_handle_read(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_WRITE:</span><br><span class=\"line\">\t\t\t\t__poller_handle_write(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_LISTEN:</span><br><span class=\"line\">\t\t\t\t__poller_handle_listen(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_CONNECT:</span><br><span class=\"line\">\t\t\t\t__poller_handle_connect(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* 省略SSL、UDP相关部分... */</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_EVENT:</span><br><span class=\"line\">\t\t\t\t__poller_handle_event(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_NOTIFY:</span><br><span class=\"line\">\t\t\t\t__poller_handle_notify(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (has_pipe_event) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 内存回收</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (__poller_handle_pipe(poller))</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 处理超时的__poller_node</span></span><br><span class=\"line\">\t\t__poller_handle_timeout(&amp;time_node, poller);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>流程事件循环的流程图如下所示：</p>\n<p><img src=\"/2024/11/02/workflow/TCPServer_1/photo/EventLoopFlowChart.drawio.png\"></p>\n<p>最后改造了一下之前画的Muduo的one loop per thread的架构图。放在下面，读者可以好好品味一下。</p>\n<p><img src=\"/2024/11/02/workflow/TCPServer_1/photo/EventLoopThreadPool.drawio.png\"></p>\n<p>你可以参考一下<a href=\"../muduo/EventLoopThreadPool.md\">Muduo的one loop per thread的架构图</a>，以及<a href=\"../xv6/Scheduler.md\">xv6最后优化其调度器模型的架构图</a>，再来看workflow的__poller的架构图，你一定会吃惊它们是如此的相似！</p>\n<h3 id=\"对poller-node的增删改\"><a href=\"#对poller-node的增删改\" class=\"headerlink\" title=\"对poller_node的增删改\"></a>对poller_node的增删改</h3><p>poller对外暴露的对对poller_node的增删改的接口包括：poller_add、poller_del、poller_mod。</p>\n<p><strong>首先：</strong></p>\n<p>这些接口在sylar、muduo中其实也有类似的。从函数的名称其实就能推测出它们分别代表：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">poller_add -&gt; 向poller中添加poller_node;</span><br><span class=\"line\"></span><br><span class=\"line\">poller_del -&gt; 删除poller_node;</span><br><span class=\"line\"></span><br><span class=\"line\">poller_mod -&gt; 修改poller_node;</span><br></pre></td></tr></table></figure>\n\n<p><strong>进一步的：</strong></p>\n<ol>\n<li><p>poller_add本质上会将poller_node.data.fd连同关心的读&#x2F;写事件<strong>添加</strong>到epoll当中。如果poller_node.timeout被用户设置过，还会将poller_node挂到超时链表上或者是红黑树上。<strong>适当的时候更新timefd的设置。</strong></p>\n</li>\n<li><p>poller_del本质会将poller_node.data.fd连同关心的读&#x2F;写事件从epoll当中<strong>删除</strong>。</p>\n</li>\n<li><p>poller_mod本质上会<strong>修改</strong>被挂到epoll当中的poller_node.data.fd所关心的读&#x2F;写事件。当然此时如果用户重新设置了poller_node的超时时间，则应该<strong>调整</strong>poller_node在超时链表&#x2F;红黑树的位置。<strong>适当的时候更新timefd的设置。</strong></p>\n</li>\n</ol>\n<p><strong>实际上的：</strong></p>\n<p>poller实际源码也正是这样做的。这里有一些比较意思的实践，这里一一列举一下：</p>\n<p>首先是根据poller_node的超时时间，将poller_node挂到超时链表&#x2F;红黑树上的操作。这个操作在poller_add、poller_mod都有需求。所以在poller当中是实现一个专门的函数__poller_insert_node，该函数功能就是<strong>将poller_node插入到超时链表&#x2F;红黑树适当位置，并且在poller_node是最早超时的节点时，更新timefd的设置。</strong></p>\n<p>poller_node源码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_insert_node(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *end;</span><br><span class=\"line\"></span><br><span class=\"line\">\tend = <span class=\"built_in\">list_entry</span>(poller-&gt;timeo_list.prev, <span class=\"keyword\">struct</span> __poller_node, list);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">list_empty</span>(&amp;poller-&gt;timeo_list)) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_add</span>(&amp;node-&gt;list, &amp;poller-&gt;timeo_list);</span><br><span class=\"line\">\t\tend = <span class=\"built_in\">rb_entry</span>(poller-&gt;tree_first, <span class=\"keyword\">struct</span> __poller_node, rb);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__timeout_cmp(node, end) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_add_tail</span>(&amp;node-&gt;list, &amp;poller-&gt;timeo_list);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t__poller_tree_insert(node, poller);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (&amp;node-&gt;rb != poller-&gt;tree_first)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tend = <span class=\"built_in\">list_entry</span>(poller-&gt;timeo_list.next, <span class=\"keyword\">struct</span> __poller_node, list);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!poller-&gt;tree_first || __timeout_cmp(node, end) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t__poller_set_timerfd(poller-&gt;timerfd, &amp;node-&gt;timeout, poller);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一次看这段代码可能会感觉比较绕，下面我来梳理它的逻辑：</p>\n<p>其实主要是三个分支，假设现在要添加名为node的poller_node：</p>\n<ol start=\"0\">\n<li><p>先获取（按升序排列的）超时链表上的最后一个元素。</p>\n</li>\n<li><p>如果超时链表为空，直接将node加到超时链表尾部，然后获取红黑树第一个poller_node，如果红黑树为空或者说node比红黑树的第一个poller_node还小。那么将timefd的超时时间设置为node的超时时间。</p>\n</li>\n<li><p>如果node比超时链表最后一个poller_node超时时间还大。那直接将node添加到超时链表末尾即可。timefd不用改。</p>\n</li>\n<li><p>如果node超时时间小于超时链表最后一个元素超时时间，就将node添加到红黑树上。此时要是node正好作为红黑树的第一个元素（红黑树当中最小的节点），就比较一下node超时时间和超时链表第一个元素的超时时间。如果node比链表第一个元素超时时间小的话，更新timefd为node的超时时间。</p>\n</li>\n</ol>\n<p>仔细梳理一下该函数的逻辑其实也是很清晰的。说白了就是将node添加到链表&#x2F;红黑树当中，同时当node是作为最小超时时间时，更新一下timefd的超时时间。这里使用两种数据结构的原因是：</p>\n<ol>\n<li><p>利用升序链表追加比红黑树快的优点；</p>\n</li>\n<li><p>利用红黑树随机插入比升序链表快的优点；</p>\n</li>\n</ol>\n<p>其次就是poller当中内存管理的做法：</p>\n<p>对于poller_add、poller_mod其实会调用__poller_new_node（间接调用malloc）分配一个新的地址作为poller_node。</p>\n<p>对于poller_del，会将poller_node从超时链表&#x2F;红黑树上移除。同时<strong>将poller_node的地址作为数据，写到pipe当中。等待pipe读时间处理函数调用poller-&gt;callback去回收</strong>。这种将地址写到管道然后异步回收的做法在我最开始看到的时候是为它捏了一把汗的。像我这种普通人肯定写不出这样的代码的。</p>\n<p>这里可以欣赏一下poller_del的代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">poller_del</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">poller_t</span> *poller)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *node;</span><br><span class=\"line\">\t<span class=\"type\">int</span> stopped = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\tnode = poller-&gt;nodes[fd];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">\t\tpoller-&gt;nodes[fd] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node-&gt;in_rbtree)</span><br><span class=\"line\">\t\t\t__poller_tree_erase(node, poller);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 要么是被从超时链表上移除，要么是被从非超时链表上删除。统一都可以使用list_del来删除。</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">list_del</span>(&amp;node-&gt;list);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t__poller_del_fd(fd, node-&gt;event, poller);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnode-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_DELETED;</span><br><span class=\"line\">\t\tstopped = poller-&gt;stopped;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!stopped) &#123;</span><br><span class=\"line\">\t\t\tnode-&gt;removed = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将地址写到pipe当中，异步让pipe读事件去回收</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">write</span>(poller-&gt;pipe_wr, &amp;node, <span class=\"built_in\">sizeof</span> (<span class=\"type\">void</span> *));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\terrno = ENOENT;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stopped) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 事件处理线程停止了，就主动去释放了。其实pipe读事件处理函数也是做下面这两步操作</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(node-&gt;res);</span><br><span class=\"line\">\t\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -!node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定时器的增删\"><a href=\"#定时器的增删\" class=\"headerlink\" title=\"定时器的增删\"></a>定时器的增删</h3><p>poller对外暴露的定时器操作的接口包括：poller_add_timer、poller_del_timer，简单来说就是对定时器进行添加和删除。</p>\n<p>这里可以需要明确一点，超时事件分为两类：定时器超时 和 读写事件的超时。</p>\n<ul>\n<li><p>定时器超时是指：用户需要指定一个回调函数在延迟n ms后才执行。使用场景比如：1分钟向文件写入一条日志，日志内容是系统当前运行状态。</p>\n</li>\n<li><p>读写事件超时是指：在规定的超时时间内必需进行一次io，否则将操作视为超时，进行对应的超时处理。使用场景比如：HTTP的保活（keepalived）。</p>\n</li>\n</ul>\n<p>这两者区别是：定时器超时是<strong>一定会发生</strong>的，而对于读写事件超时，只要规定时间内有io事件发生，则超时<strong>不一定会发生</strong>。</p>\n<p>poller当中定时器其实就是fd为（无效）-1的__poller_node，它不会被添加到epoll当中，但是会根据超时时间被挂到超时链表&#x2F;红黑树上。超时后的处理和IO事件超时的处理一模一样。</p>\n<p>这里贴出部分poller_add_timer代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">poller_add_timer</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> timespec *value, <span class=\"type\">void</span> *context, <span class=\"type\">void</span> **timer,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t\t <span class=\"type\">poller_t</span> *poller)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *node;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode = (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> __poller_node));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">\t\tnode-&gt;data.operation = PD_OP_TIMER;</span><br><span class=\"line\">\t\tnode-&gt;data.fd = <span class=\"number\">-1</span>;\t\t\t\t\t<span class=\"comment\">// 标记为无效</span></span><br><span class=\"line\">\t\tnode-&gt;data.context = context;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">clock_gettime</span>(CLOCK_MONOTONIC, &amp;node-&gt;timeout);</span><br><span class=\"line\">\t\tnode-&gt;timeout.tv_sec += value-&gt;tv_sec;</span><br><span class=\"line\">\t\tnode-&gt;timeout.tv_nsec += value-&gt;tv_nsec;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node-&gt;timeout.tv_nsec &gt;= <span class=\"number\">1000000000</span>) &#123;</span><br><span class=\"line\">\t\t\tnode-&gt;timeout.tv_nsec -= <span class=\"number\">1000000000</span>;</span><br><span class=\"line\">\t\t\tnode-&gt;timeout.tv_sec++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t*timer = node;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t\t__poller_insert_node(node, poller);\t<span class=\"comment\">// 将poller_node添加到超时链表/红黑树上。</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>__poller_insert_node函数代码上小结已贴出。poller_del_timer函数实现可以参考poller_del，感兴趣的读者可以直接翻看源码，这里不过多赘述。</p>\n<h3 id=\"事件处理函数\"><a href=\"#事件处理函数\" class=\"headerlink\" title=\"事件处理函数\"></a>事件处理函数</h3><p>下面逐个分析poller当中IO事件的处理函数细节。本文是以workflow的TCPServer为主，这里默认阅读本文的读者是有网络编程的经验的，那么你一定知道一个TCP的服务端最基本的框架如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tsocket\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tbind\t|\t最开始三步由Communicator完成，下一篇博客会细讲。</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tlisten\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|\t\t\t______________________________________________</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\taccept\t|\t从这里开始涉及到的所以函数就是接下来讲解的重点。</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\t|\t|\t|</span><br><span class=\"line\">V\tV\tV\tV</span><br><span class=\"line\">fd\tfd\tfd\t...</span><br><span class=\"line\">\t/\\</span><br><span class=\"line\">read  write</span><br></pre></td></tr></table></figure>\n\n<p>本节就以上图所示顺序逐一介绍各个处理函数实现细节。</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>首先是accept事件处理函数————__poller_handle_listen，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_handle_listen(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t   <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *res = node-&gt;res;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\taddrlen = <span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> sockaddr_storage);</span><br><span class=\"line\">\t\tsockfd = <span class=\"built_in\">accept</span>(node-&gt;data.fd, addr, &amp;addrlen);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sockfd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (errno == EAGAIN || errno == EMFILE || errno == ENFILE)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (errno == ECONNABORTED)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tresult = node-&gt;data.<span class=\"built_in\">accept</span>(addr, addrlen, sockfd, node-&gt;data.context);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!result)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tres-&gt;data = node-&gt;data;</span><br><span class=\"line\">\t\tres-&gt;data.result = result;</span><br><span class=\"line\">\t\tres-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tres-&gt;state = PR_ST_SUCCESS;</span><br><span class=\"line\">\t\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)res, poller-&gt;context);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tres = (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> __poller_node));</span><br><span class=\"line\">\t\tnode-&gt;res = res;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!res)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_remove_node(node, poller))\t<span class=\"comment\">// 从epoll当中移除fd</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode-&gt;error = errno;</span><br><span class=\"line\">\tnode-&gt;state = PR_ST_ERROR;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(node-&gt;res);</span><br><span class=\"line\">\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);\t<span class=\"comment\">// 一般是server在停止或出错才会走到这里。\t</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>逻辑是：不断在一个while循环当中执行如下过程：</p>\n<ol>\n<li><p>（非阻塞的）调用accept系统调用接受客户端的连接。EAGAIN、EMFILE、ENFILE、ECONNABORTED分别代表没有可用连接、文件描述符达到上限、系统无句柄可用、连接终止（客户端的原因）。这些错误都是网络编程当中很常规的错误。都是可以容忍的。所以该return的return，该continue就continue。</p>\n</li>\n<li><p>当接收到一条合法的io连接，就将其scoketfd作为参数回调node-&gt;data.accept，它会回调 Communicator::accept函数，该函数会为连接构造一个CommServiceTarget对象作为返回值，<strong>这里并没有将sockfd设置为非阻塞</strong>。这里读者可以先不必探究CommServiceTarget是干什么的，在下一章讲解Communicator自然会明了。因为我一开始也不知道CommServiceTarget的作用。可以从它的命名先猜测它其实就是IO连接在服务端的一个对象实体吧。</p>\n</li>\n<li><p>回调poller-&gt;callback，其实在看完后面的read、write等io事件的处理函数之后，就会发现最早都会调用poller-&gt;callback，该回调也是在下章讲解Communicator后才发挥重要作用，读者先把它看作黑盒即可。可以预料到它里面一定会将接受的sockfd<strong>设置为非阻塞</strong>，并且最终会将它包装成poller_node加入到poller当中。</p>\n</li>\n</ol>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>然后是read事件处理函数————__poller_handle_read，（去除了和SSL相关的代码，剩余的）代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __poller_append_message(<span class=\"type\">const</span> <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> *n,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t   <span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t   <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"type\">poller_message_t</span> *msg = node-&gt;data.message;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *res;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!msg) &#123;\t<span class=\"comment\">// 为连接的每个请求包分配一个msg</span></span><br><span class=\"line\">\t\tres = (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> __poller_node));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!res)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmsg = node-&gt;data.<span class=\"built_in\">create_message</span>(node-&gt;data.context);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!msg) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">free</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnode-&gt;data.message = msg;</span><br><span class=\"line\">\t\tnode-&gt;res = res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tres = node-&gt;res;</span><br><span class=\"line\"></span><br><span class=\"line\">\tret = msg-&gt;<span class=\"built_in\">append</span>(buf, n, msg);\t<span class=\"comment\">// 通过msg解析请求包（PS，注意同一个请求可能会被拆分成多个tcp报文发送，所以函数可能会被多次回调）</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ret &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tres-&gt;data = node-&gt;data;</span><br><span class=\"line\">\t\tres-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tres-&gt;state = PR_ST_SUCCESS;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当msg收到完整的请求包且解析完后同样回调一下poller-&gt;callback</span></span><br><span class=\"line\">\t\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)res, poller-&gt;context);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnode-&gt;data.message = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">// 清空，为下一个请求做准备</span></span><br><span class=\"line\">\t\tnode-&gt;res = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_handle_read(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> nleft;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> n;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *p;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tp = poller-&gt;buf;</span><br><span class=\"line\">\t\tnleft = <span class=\"built_in\">read</span>(node-&gt;data.fd, p, POLLER_BUFSIZE);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (errno == EAGAIN)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\tn = nleft;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (__poller_append_message(p, &amp;n, node, poller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tnleft -= n;</span><br><span class=\"line\">\t\t\t\tp += n;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\tnleft = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> (nleft &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;\t<span class=\"comment\">// 连接断开或则有错误发生</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_remove_node(node, poller))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (nleft == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tnode-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_FINISHED;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tnode-&gt;error = errno;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_ERROR;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(node-&gt;res);</span><br><span class=\"line\">\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为是异步read，所以__poller_handle_read回调多次才能读完一个完整的客户端请求报文。它的逻辑。主要就是两步，（非阻塞的方式）调用原始read系统调用，然后调用__poller_append_message函数去逐步解析收到的数据。当连接断开或则出现错误就跳出循环，回调poller-&gt;callback处理错误。<strong>这里我们其实可以大胆猜测__poller_append_message函数当中msg-&gt;append函数肯定是一个（HTTP、DNS等）报文解析器。</strong></p>\n<p>这里有一个比较有意思的点是read系统调用所使用的buffer是poller-&gt;buf，它是poller的数据成员，这里所有的fd在read的时候使用同一个buffer，难道不会出问题吗？read的数据不会乱吗？</p>\n<p>这里简单分析一下，首先考虑线程安全问题，因为前面说过：一个poller对应一个线程。所以在线程处理IO事件的时候，一定是串行的，这就排除并行导致的线程安全问题。</p>\n<p>其次，再考虑异步非阻塞的方式读数据，东读一下西读一下会不会存在数据乱掉的问题，如果你仔细分析过__poller_handle_read其实就不会出现这个疑问，因为__poller_handle_read在通过poller-&gt;buf接受到数据后，不管这个请求是否完整，都会在__poller_append_message函数里面的msg-&gt;append进行<strong>异步解析</strong>。解析完毕后，poller-&gt;buf上的数据也就失去了它的意义。所以在处理下一个read事件的时候，放心的随他使用poller-&gt;buf吧。</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>最后write事件处理函数————__poller_handle_write，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_handle_write(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t  <span class=\"type\">poller_t</span> *poller)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> *iov = node-&gt;data.write_iov;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> nleft;</span><br><span class=\"line\">\t<span class=\"type\">int</span> iovcnt;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (node-&gt;data.iovcnt &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tiovcnt = node-&gt;data.iovcnt;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (iovcnt &gt; IOV_MAX)</span><br><span class=\"line\">\t\t\tiovcnt = IOV_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnleft = <span class=\"built_in\">writev</span>(node-&gt;data.fd, iov, iovcnt);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tret = errno == EAGAIN ? <span class=\"number\">0</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcount += nleft;</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;\t\t\t\t\t\t\t<span class=\"comment\">// 修正iov</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (nleft &gt;= iov-&gt;iov_len) &#123;</span><br><span class=\"line\">\t\t\t\tnleft -= iov-&gt;iov_len;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_base = (<span class=\"type\">char</span> *)iov-&gt;iov_base + iov-&gt;iov_len;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_len = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\tiov++;</span><br><span class=\"line\">\t\t\t\tnode-&gt;data.iovcnt--;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_base = (<span class=\"type\">char</span> *)iov-&gt;iov_base + nleft;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_len -= nleft;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> (node-&gt;data.iovcnt &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode-&gt;data.write_iov = iov;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node-&gt;data.iovcnt &gt; <span class=\"number\">0</span> &amp;&amp; ret &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node-&gt;data.<span class=\"built_in\">partial_written</span>(count, node-&gt;data.context) &gt;= <span class=\"number\">0</span>)\t<span class=\"comment\">// 通知一下已发送的数据量</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_remove_node(node, poller))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node-&gt;data.iovcnt == <span class=\"number\">0</span>) &#123;\t<span class=\"comment\">// 为零结束</span></span><br><span class=\"line\">\t\tnode-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_FINISHED;\t</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;\t\t\t\t\t\t<span class=\"comment\">// 否则出错</span></span><br><span class=\"line\">\t\tnode-&gt;error = errno;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_ERROR;\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样，因为是异步写数据，一个客户请求的回复报文可能分多次write才能发送完毕。poller向socketfd写数据采用的是writev接口，writev接口可以很方便的将内存不连续的数据发送到网络上。这在需要向网络写入大量的数据时很方便。因为数据量大所以系统无法一次性分配那么大块内存，所以数据可能被放在内存不连续的离散的buffer当中。writev使用元素类型为struct iovec的数组作为数据缓存，数组当中每个元素存放指向一块缓存的首地址的指针和长度。（非阻塞的）writev会返回实际发送的字节数。从代码中可以看到while循环嵌套了一个do while，因为tcp发送缓存区是有限的，do while作用是根据实际发送的字节数抹除已经发生的buffer，重新计算iov数组等待下一轮while循环继续发送。</p>\n<p>当发送缓存满，会因为EAGAIN跳出while循环，同时因为还存在没有发送完毕的数据，会调用node-&gt;data.partial_written。当数发送完毕，会将poller_node从epoll当中移除（对写事件的监听），最后回调poller-&gt;callback。</p>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlow源码剖析——GO-Task 源码分析</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlow源码剖析——Communicator之TCPServer（上）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlow源码剖析——Communicator之TCPServer（中）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlow源码剖析——Communicator之TCPServer（下）</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇博客已经介绍了一下WorkFlow GO-Task的实现原理。本文会介绍一下WorkFlow Tcp Server端的一些实现细节以及有趣的思想。因为这部分涉及的内容有点多，一些有趣的细节也希望能完整的叙述出来，所以我可能会将TCPServer拆分成上中下三个部分。三个部分分别对应：poller的实现（即对IO对路复用事件池的封装，属于最底层），Communicator的实现（对连接对象生命周期的管理，属于中间层），最后就是TCPServer的实现（利用中间层实现一个TCPServer）。文件异步IO相关的内容，后面抽空会补上。</p>","more":"<p>这里声明一下：</p>\n<p>关于workflow的线程池，其实最终的目的就是实现一个线程池嘛，知道它是个什么东西，看一下它的接口，其实就差不多了。原理都是一样的，就是实现细节上各有各的特点。workflow的线程池简单描述它的特点就是一种链式的线程池。它所涉及的源码也不多就200多行，如果专门起一篇博客去讲解它，以我的表达能力和理解的深度，估计到时候代码的比例又会占大头。成了纯纯的贴代码的博客是我不愿意看到的。所以如果你对workflow线程池的实现感兴趣，建议你亲自去看看它的源码。我始终认为，如果你想了解一个项目的源码，博客写的再好，也只能作为辅助，它只能在你看源码有疑惑时给你一些指点，或者说作为你在读完源码后，回头巩固的一种手段。最终亲眼看看代码才是正道。</p>\n<p>关于消息队列，和线程池紧密相关的就是任务（&#x2F;消息）队列。我最大的收货就是：我们以往再写线程池任务队列时，读写都是一把锁，而workflow线程的任务队列却有两把锁，<strong>读和写分别持有一把</strong>，巧妙的降低了锁的竞争。具体细节，感兴趣的读者可以自行阅读源码，这里就不过多赘述。</p>\n<p>Workflow其实没有TcpServer的概念，相关的其实就是一个CommService，而CommService其实可以理解为TCPServer，尽管CommService其实也是支持udp等其他非tcp的协议。但是我们重点只关注tcp相关的东西。所以，下文提到的TcpServer都代指CommService。</p>\n<p>本文会按照如下顺序讲解TcpServer的实现：</p>\n<p>poller相关的数据结构的介绍 -&gt; 事件循环的设计 -&gt; 对poller_node的增删改 -&gt; 对定时器的增删 -&gt; 对IO事件回调函数的流程分析。</p>\n<h2 id=\"对IO以及IO多路复用的封装\"><a href=\"#对IO以及IO多路复用的封装\" class=\"headerlink\" title=\"对IO以及IO多路复用的封装\"></a>对IO以及IO多路复用的封装</h2><p>本节内容主要集中在poller.c文件，主要关注workflow对epoll事件池的设计以及linux原生IO相关api的最底层的封装。这里涉及大量的回调。不得不说workflow对回调理解的是真的透彻。</p>\n<h3 id=\"数据结构的分析\"><a href=\"#数据结构的分析\" class=\"headerlink\" title=\"数据结构的分析\"></a>数据结构的分析</h3><p>首先是数据结构__poller：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">__poller</span> <span class=\"type\">poller_t</span>;   <span class=\"comment\">// 对外暴露的名称</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">__poller</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> max_open_files;                              <span class=\"comment\">// 该epollfd支持的最大fd</span></span><br><span class=\"line\">\t<span class=\"built_in\">void</span> (*callback)(<span class=\"keyword\">struct</span> poller_result *, <span class=\"type\">void</span> *);   <span class=\"comment\">// 由Communicator设置，Communicator会根据poller_result.poller_data.operation的类型回调不同的函数。</span></span><br><span class=\"line\">\t<span class=\"type\">void</span> *context;                                      <span class=\"comment\">// 传给callback的参数</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">pthread_t</span> tid;                                      <span class=\"comment\">// epollfd监听线程的线程id</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> pfd;                                            <span class=\"comment\">// epollfd</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> timerfd;</span><br><span class=\"line\">\t<span class=\"type\">int</span> pipe_rd;                                        <span class=\"comment\">// 管道读端，通知回收某个/些__poller_node</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> pipe_wr;                                        <span class=\"comment\">// 管道写端</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> stopped;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_root</span> timeo_tree;                          <span class=\"comment\">// 带超时的__poller_node红黑树，以下三个成员都和[定时器]红黑树相关</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_node</span> *tree_first;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_node</span> *tree_last;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> timeo_list;                        <span class=\"comment\">// 带超时的__poller_node链表</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> no_timeo_list;                     <span class=\"comment\">// 不带超时的__poller_node链表</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> **nodes;                       <span class=\"comment\">// 可根据fd索引每一个__poller_node</span></span><br><span class=\"line\">\t<span class=\"type\">pthread_mutex_t</span> mutex;</span><br><span class=\"line\">\t<span class=\"type\">char</span> buf[POLLER_BUFSIZE];                           <span class=\"comment\">// 共享buffer</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>poller的数据结构每项成员的定义非常恰到好处，我相信比较难理解的就是为啥为定时器搞了两种结构：链表和红黑树？后面在看到定时器的增删查改时再谈谈我的理解。</p>\n<p>这里可以先用定时器类型，简单的对__poller_node进行分类：</p>\n<ol>\n<li><p>带超时的__poller_node：带超时的__poller_node又有两种挂法：</p>\n<ol>\n<li><p>被挂到红黑树timeo_tree上。</p>\n</li>\n<li><p>按递增顺序，被挂到超时链表timeo_list上。</p>\n</li>\n</ol>\n</li>\n<li><p>不带超时的__poller_node：被挂到no_timeo_list链表上。</p>\n</li>\n</ol>\n<p>然后就是数据结构__poller_node：</p>\n<p>它的定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> state;                  <span class=\"comment\">// __poller_node的状态</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> error;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span> data;    <span class=\"comment\">// 稍后解释</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack(1)</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> list;  <span class=\"comment\">// 如果是在链表上使用该成员作为节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_node</span> rb;      <span class=\"comment\">// 如果是在红黑树上使用该成员作为节点</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack()</span></span><br><span class=\"line\">\t<span class=\"type\">char</span> in_rbtree;             <span class=\"comment\">// 是在红黑树上吗？</span></span><br><span class=\"line\">\t<span class=\"type\">char</span> removed;               <span class=\"comment\">// 被从epoll上移除取消监听（链表/红黑树上也会移除该node）</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> event;                  <span class=\"comment\">// epoll监听的事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">timespec</span> timeout;    <span class=\"comment\">// fd超时时间</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *res;  <span class=\"comment\">// 稍后解释，（PS，我也有点忘了）</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果你看过Muduo的源码，那么__poller + __poller_node可以看作Muduo当中的EPollPoller，而Muduo当中，定时器同样使用的是timerfd_，区别是Muduo当中直接使用了标准库当中的std::set对定时器进行排序，而workflow使用的是自己造的红黑树的轮子。并且workflow额外使用了一个链表来维护带超时的__poller_node。</p>\n<p>当然在__poller_node结构体当中，我还没有解释data成员是干啥的，这里既然扯到了Muduo，顺便提一嘴：data成员其实可以等价与Muduo当中的Channel。poller_data当中也是有各种来自（Communicator）上层注册的回调函数。</p>\n<p>poller_dataj结构体在workflow当中定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">// poll关心的事件的定义。</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_TIMER\t\t\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_READ\t\t\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_WRITE\t\t\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_LISTEN\t\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_CONNECT\t\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_RECVFROM\t\t5</span></span><br><span class=\"line\"><span class=\"comment\">/* ... */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_EVENT\t\t\t9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_NOTIFY\t\t10</span></span><br><span class=\"line\">\t<span class=\"type\">short</span> operation;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">short</span> iovcnt;</span><br><span class=\"line\">\t<span class=\"type\">int</span> fd;</span><br><span class=\"line\">\tSSL *ssl;</span><br><span class=\"line\">\t<span class=\"keyword\">union</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">poller_message_t</span> *(*create_message)(<span class=\"type\">void</span> *);    <span class=\"comment\">// 钩爪异步读上下文的回调</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">int</span> (*partial_written)(<span class=\"type\">size_t</span>, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*accept)(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *, <span class=\"type\">socklen_t</span>, <span class=\"type\">int</span>, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*recvfrom)(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *, <span class=\"type\">socklen_t</span>,</span><br><span class=\"line\">\t\t\t\t\t\t  <span class=\"type\">const</span> <span class=\"type\">void</span> *, <span class=\"type\">size_t</span>, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*event)(<span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*notify)(<span class=\"type\">void</span> *, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"type\">void</span> *context;</span><br><span class=\"line\">\t<span class=\"keyword\">union</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">poller_message_t</span> *message;      <span class=\"comment\">// 异步读上下文，由create_message创建</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> *write_iov;        <span class=\"comment\">// 异步写缓存</span></span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *result;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>|\t回调函数\t\t|\t作用\t|<br>|\t:-:\t\t\t\t|\t:-:\t\t|<br>|\tcreate_message\t|\t（fd的read事件）利用该回调可以构造一个msg对象，并且每次在fd可读时，将读到的数据交给该msg去处理（解析），解释完成后返回一个大于0的值，然后通poller的callback通知上层（Communicator）|<br>|\tpartial_written\t|\t（fd的write事件）在每次fd可写并且<strong>尽力</strong>写入一些数据后会调用该回调，以更新写超时时间\t|<br>| accept\t\t\t|\t（fd的read事件）在listen fd接受一条连接并为连接创建一个读写sockfd后，会调用该回调，回调会为该sockfd创建一个CommServiceTarget对象\t|<br>|\trecvfrom\t\t|\t（fd的read事件）使用udp协议的读（可以先不管，主要研究tcp，先将workflow的tcp打通）\t|<br>|\tevent\t\t\t|\t（fd的read事件）为实现文件fd的异步读写而生，作者暂时还未能去详细了解，在后续有空了再补上，我们重点还是关注网络socket fd的读写事件和回调\t|<br>|\tnotify\t|\t同event\t|</p>\n<p>其次就是poller_result结构体，该结构体其实就是__poller_node最前面三个成员。在poller.c当中，poller_result一般是以指针的形式去使用，并且是将__poller_node类型的变量的地址作为其值，如果你C语言基础足够扎实，结合poller_result和__poller_node定义的成员去看，其实很容易的理解到：<strong>将__poller_node类型的变量的地址作为poller_result*变量的值的用法就是只使用__poller_node的前三个成员。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">poller_result</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_SUCCESS\t\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_FINISHED\t\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_ERROR\t\t\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_DELETED\t\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_MODIFIED\t\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_STOPPED\t\t5</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> state;</span><br><span class=\"line\">\t<span class=\"type\">int</span> error;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span> data;</span><br><span class=\"line\">\t<span class=\"comment\">/* In callback, spaces of six pointers are available from here. */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在了解了poller当中的数据结构之后，如果你之前有过阅读其他网络库&#x2F;框架相关源码，其实我们就可以猜测，workflow当中的poller一定会有针对epollfd&#x2F;超时链表&#x2F;红黑树进行增删查改的一些函数。</p>\n<p>这里吐槽一下workflow，我觉得muduo、sylar这些网络框架层次其实更加分明，epoll池是epoll池、io读写操作是io读写操作、定时器是定时器。而在workflow当中。这三部分完全混合在了一个文件当中去实现。导致我最开始看poller源码时，感觉很混乱。</p>\n<h3 id=\"事件循环（Event-Loop）-—-主干\"><a href=\"#事件循环（Event-Loop）-—-主干\" class=\"headerlink\" title=\"事件循环（Event Loop） — 主干\"></a>事件循环（Event Loop） — 主干</h3><p>凡是网络框架都会使用epoll&#x2F;poll等IO多路复用机制，不得不说IO多路复用机制也确实挺好用的。而使用了IO多路复用机制的程序肯定避不开事件循环。本小节会逐步讲解从__poller的创建 到 事件循环的启动。</p>\n<p>首先是__poller的创建，其实__poller和__mpoller的创建可以放一起去讲解，__mpoller就是一群__poller的集合，可以将__mpoller理解为__poller的manager，一个__poller在创建时会申请一个epollfd，而__mpoller向外部提供的接口是具有负载均衡的功能的，它会将读写socketfd分散的发给__poller，同样的__poller内部就是一群__poller_node的集合（socket fd），你也可以将__poller看作__poller_node的manager。下面来看看__mpoller是如何构造每一个__poller的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __mpoller_create(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> poller_params *params,</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"type\">mpoller_t</span> *mpoller) &#123;</span><br><span class=\"line\">\t<span class=\"type\">void</span> **nodes_buf = (<span class=\"type\">void</span> **)<span class=\"built_in\">calloc</span>(params-&gt;max_open_files, <span class=\"built_in\">sizeof</span> (<span class=\"type\">void</span> *));</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (nodes_buf) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; mpoller-&gt;nthreads; i++) &#123;</span><br><span class=\"line\">\t\t\tmpoller-&gt;poller[i] = __poller_create(nodes_buf, params);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!mpoller-&gt;poller[i])</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == mpoller-&gt;nthreads) &#123;</span><br><span class=\"line\">\t\t\tmpoller-&gt;nodes_buf = nodes_buf;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很简单，就是分配一个max_open_files大小的指针数组（nodes_buf），然后调用__poller_create函数，将nodes_buf作为参数构造__poller对象，__poller_create会根据传入的参数对__poller做一些初始化，而__poller的nodes成员被初始化为指向nodes_buf，前面介绍过，nodes成员可根据socket fd索引__poller_node。 <strong>那么问题就来了，多个__poller共用一个nodes_buf，这样不会有问题吗？？？</strong></p>\n<p>（经过深入思考）我可以明确的告诉你，确实不会，而且这种用法还很奇妙。这是因为有 <strong>{nodes成员可根据socket fd索引__poller_node}</strong> 这句话保底，因为在linux当中，一个进程当中的描述符（fd）绝对不可能重复！所以即使你创建的多个__poller对象，多个__poller对象又共用一个nodes_buf，但是分配给它们的socket fd（__poller_node）绝对<strong>互不相同</strong>，又因为__poller_node是根据socket fd索引的，故真实的情况是：<strong>每个__poller会共用一个nodes_buf，但是各自使用nodes_buf的不同entry。</strong></p>\n<p>然后就是__poller的启动，调用mpoller的mpoller_start函数可以启动所有的__poller，对于每个__poller的启动会调用poller_start函数，它的实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">poller_start</span><span class=\"params\">(<span class=\"type\">poller_t</span> *poller)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">pthread_t</span> tid;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_open_pipe(poller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tret = <span class=\"built_in\">pthread_create</span>(&amp;tid, <span class=\"literal\">NULL</span>, __poller_thread_routine, poller);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tpoller-&gt;tid = tid;</span><br><span class=\"line\">\t\t\tpoller-&gt;stopped = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\terrno = ret;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(poller-&gt;pipe_wr);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(poller-&gt;pipe_rd);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -poller-&gt;stopped;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要就干了两件事：</p>\n<ol>\n<li><p>调用__poller_open_pipe函数创建pipfd，将pipfd读端注册到epollfd上，pipfd在__poller当中起到内存回收的作用。具体是什么玩法，后面详细解释。（PS：说实话第一次看到用pipfd做内存回收的用法感觉挺不可思议的。真得感叹一句真是艺高人胆大！）</p>\n</li>\n<li><p>创建并启动事件循环线程。</p>\n</li>\n</ol>\n<p>总结一下就是和Muduo<strong>很像</strong>的One loop per thread，注意这里的加粗，在看完workflow的__poller源码后，感觉和Muduo的还是有很大差别的，我只能说Muduo的One loop per thread的思想的纯净，Muduo的代码阅读起来也很舒服。而workflow的却不同，它可能夹杂着业务优化的考量，所以并不是那么纯粹的One loop per thread，所以我在源码阅读时比较坎坷。（也可能是我功力不够深厚，没能领悟其奥妙。）针对加锁方面尤为明显，两者每个loop线程都会有自己的互斥锁，Muduo仅在对任务队列操作的时候会加锁，而workflow加锁的范围会稍微大点，凡是对__poller内部数据成员的访问都会加锁。</p>\n<p>事件循环的历程函数是__poller_thread_routine，它的实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *__poller_thread_routine(<span class=\"type\">void</span> *arg) &#123;</span><br><span class=\"line\">\t<span class=\"type\">poller_t</span> *poller = (<span class=\"type\">poller_t</span> *)arg;</span><br><span class=\"line\">\t<span class=\"type\">__poller_event_t</span> events[POLLER_EVENTS_MAX];</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> time_node;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *node;</span><br><span class=\"line\">\t<span class=\"type\">int</span> has_pipe_event;</span><br><span class=\"line\">\t<span class=\"type\">int</span> nevents;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将最早超时的节点的超时时间作为定时器的超时时间</span></span><br><span class=\"line\">\t\t__poller_set_timer(poller);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 等待时间的到来</span></span><br><span class=\"line\">\t\tnevents = __poller_wait(events, POLLER_EVENTS_MAX, poller);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 获取当前时间，小于该时间的节点视为超时。</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">clock_gettime</span>(CLOCK_MONOTONIC, &amp;time_node.timeout);</span><br><span class=\"line\">\t\t<span class=\"comment\">// pipfd可读？</span></span><br><span class=\"line\">\t\thas_pipe_event = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nevents; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将private转换为__poller_node*</span></span><br><span class=\"line\">\t\t\tnode = (<span class=\"keyword\">struct</span> __poller_node *)__poller_event_data(&amp;events[i]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (node &lt;= (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"number\">1</span>) &#123;\t<span class=\"comment\">// 是pipfd？</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (node == (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t\thas_pipe_event = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 根据__poller_node.data的operation调用对应的回调函数。</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (node-&gt;data.operation) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_READ:</span><br><span class=\"line\">\t\t\t\t__poller_handle_read(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_WRITE:</span><br><span class=\"line\">\t\t\t\t__poller_handle_write(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_LISTEN:</span><br><span class=\"line\">\t\t\t\t__poller_handle_listen(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_CONNECT:</span><br><span class=\"line\">\t\t\t\t__poller_handle_connect(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* 省略SSL、UDP相关部分... */</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_EVENT:</span><br><span class=\"line\">\t\t\t\t__poller_handle_event(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_NOTIFY:</span><br><span class=\"line\">\t\t\t\t__poller_handle_notify(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (has_pipe_event) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 内存回收</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (__poller_handle_pipe(poller))</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 处理超时的__poller_node</span></span><br><span class=\"line\">\t\t__poller_handle_timeout(&amp;time_node, poller);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>流程事件循环的流程图如下所示：</p>\n<p><img src=\"/2024/11/02/workflow/TCPServer_1/photo/EventLoopFlowChart.drawio.png\"></p>\n<p>最后改造了一下之前画的Muduo的one loop per thread的架构图。放在下面，读者可以好好品味一下。</p>\n<p><img src=\"/2024/11/02/workflow/TCPServer_1/photo/EventLoopThreadPool.drawio.png\"></p>\n<p>你可以参考一下<a href=\"../muduo/EventLoopThreadPool.md\">Muduo的one loop per thread的架构图</a>，以及<a href=\"../xv6/Scheduler.md\">xv6最后优化其调度器模型的架构图</a>，再来看workflow的__poller的架构图，你一定会吃惊它们是如此的相似！</p>\n<h3 id=\"对poller-node的增删改\"><a href=\"#对poller-node的增删改\" class=\"headerlink\" title=\"对poller_node的增删改\"></a>对poller_node的增删改</h3><p>poller对外暴露的对对poller_node的增删改的接口包括：poller_add、poller_del、poller_mod。</p>\n<p><strong>首先：</strong></p>\n<p>这些接口在sylar、muduo中其实也有类似的。从函数的名称其实就能推测出它们分别代表：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">poller_add -&gt; 向poller中添加poller_node;</span><br><span class=\"line\"></span><br><span class=\"line\">poller_del -&gt; 删除poller_node;</span><br><span class=\"line\"></span><br><span class=\"line\">poller_mod -&gt; 修改poller_node;</span><br></pre></td></tr></table></figure>\n\n<p><strong>进一步的：</strong></p>\n<ol>\n<li><p>poller_add本质上会将poller_node.data.fd连同关心的读&#x2F;写事件<strong>添加</strong>到epoll当中。如果poller_node.timeout被用户设置过，还会将poller_node挂到超时链表上或者是红黑树上。<strong>适当的时候更新timefd的设置。</strong></p>\n</li>\n<li><p>poller_del本质会将poller_node.data.fd连同关心的读&#x2F;写事件从epoll当中<strong>删除</strong>。</p>\n</li>\n<li><p>poller_mod本质上会<strong>修改</strong>被挂到epoll当中的poller_node.data.fd所关心的读&#x2F;写事件。当然此时如果用户重新设置了poller_node的超时时间，则应该<strong>调整</strong>poller_node在超时链表&#x2F;红黑树的位置。<strong>适当的时候更新timefd的设置。</strong></p>\n</li>\n</ol>\n<p><strong>实际上的：</strong></p>\n<p>poller实际源码也正是这样做的。这里有一些比较意思的实践，这里一一列举一下：</p>\n<p>首先是根据poller_node的超时时间，将poller_node挂到超时链表&#x2F;红黑树上的操作。这个操作在poller_add、poller_mod都有需求。所以在poller当中是实现一个专门的函数__poller_insert_node，该函数功能就是<strong>将poller_node插入到超时链表&#x2F;红黑树适当位置，并且在poller_node是最早超时的节点时，更新timefd的设置。</strong></p>\n<p>poller_node源码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_insert_node(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *end;</span><br><span class=\"line\"></span><br><span class=\"line\">\tend = <span class=\"built_in\">list_entry</span>(poller-&gt;timeo_list.prev, <span class=\"keyword\">struct</span> __poller_node, list);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">list_empty</span>(&amp;poller-&gt;timeo_list)) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_add</span>(&amp;node-&gt;list, &amp;poller-&gt;timeo_list);</span><br><span class=\"line\">\t\tend = <span class=\"built_in\">rb_entry</span>(poller-&gt;tree_first, <span class=\"keyword\">struct</span> __poller_node, rb);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__timeout_cmp(node, end) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_add_tail</span>(&amp;node-&gt;list, &amp;poller-&gt;timeo_list);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t__poller_tree_insert(node, poller);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (&amp;node-&gt;rb != poller-&gt;tree_first)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tend = <span class=\"built_in\">list_entry</span>(poller-&gt;timeo_list.next, <span class=\"keyword\">struct</span> __poller_node, list);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!poller-&gt;tree_first || __timeout_cmp(node, end) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t__poller_set_timerfd(poller-&gt;timerfd, &amp;node-&gt;timeout, poller);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一次看这段代码可能会感觉比较绕，下面我来梳理它的逻辑：</p>\n<p>其实主要是三个分支，假设现在要添加名为node的poller_node：</p>\n<ol start=\"0\">\n<li><p>先获取（按升序排列的）超时链表上的最后一个元素。</p>\n</li>\n<li><p>如果超时链表为空，直接将node加到超时链表尾部，然后获取红黑树第一个poller_node，如果红黑树为空或者说node比红黑树的第一个poller_node还小。那么将timefd的超时时间设置为node的超时时间。</p>\n</li>\n<li><p>如果node比超时链表最后一个poller_node超时时间还大。那直接将node添加到超时链表末尾即可。timefd不用改。</p>\n</li>\n<li><p>如果node超时时间小于超时链表最后一个元素超时时间，就将node添加到红黑树上。此时要是node正好作为红黑树的第一个元素（红黑树当中最小的节点），就比较一下node超时时间和超时链表第一个元素的超时时间。如果node比链表第一个元素超时时间小的话，更新timefd为node的超时时间。</p>\n</li>\n</ol>\n<p>仔细梳理一下该函数的逻辑其实也是很清晰的。说白了就是将node添加到链表&#x2F;红黑树当中，同时当node是作为最小超时时间时，更新一下timefd的超时时间。这里使用两种数据结构的原因是：</p>\n<ol>\n<li><p>利用升序链表追加比红黑树快的优点；</p>\n</li>\n<li><p>利用红黑树随机插入比升序链表快的优点；</p>\n</li>\n</ol>\n<p>其次就是poller当中内存管理的做法：</p>\n<p>对于poller_add、poller_mod其实会调用__poller_new_node（间接调用malloc）分配一个新的地址作为poller_node。</p>\n<p>对于poller_del，会将poller_node从超时链表&#x2F;红黑树上移除。同时<strong>将poller_node的地址作为数据，写到pipe当中。等待pipe读时间处理函数调用poller-&gt;callback去回收</strong>。这种将地址写到管道然后异步回收的做法在我最开始看到的时候是为它捏了一把汗的。像我这种普通人肯定写不出这样的代码的。</p>\n<p>这里可以欣赏一下poller_del的代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">poller_del</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">poller_t</span> *poller)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *node;</span><br><span class=\"line\">\t<span class=\"type\">int</span> stopped = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\tnode = poller-&gt;nodes[fd];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">\t\tpoller-&gt;nodes[fd] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node-&gt;in_rbtree)</span><br><span class=\"line\">\t\t\t__poller_tree_erase(node, poller);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 要么是被从超时链表上移除，要么是被从非超时链表上删除。统一都可以使用list_del来删除。</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">list_del</span>(&amp;node-&gt;list);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t__poller_del_fd(fd, node-&gt;event, poller);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnode-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_DELETED;</span><br><span class=\"line\">\t\tstopped = poller-&gt;stopped;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!stopped) &#123;</span><br><span class=\"line\">\t\t\tnode-&gt;removed = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将地址写到pipe当中，异步让pipe读事件去回收</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">write</span>(poller-&gt;pipe_wr, &amp;node, <span class=\"built_in\">sizeof</span> (<span class=\"type\">void</span> *));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\terrno = ENOENT;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stopped) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 事件处理线程停止了，就主动去释放了。其实pipe读事件处理函数也是做下面这两步操作</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(node-&gt;res);</span><br><span class=\"line\">\t\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -!node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定时器的增删\"><a href=\"#定时器的增删\" class=\"headerlink\" title=\"定时器的增删\"></a>定时器的增删</h3><p>poller对外暴露的定时器操作的接口包括：poller_add_timer、poller_del_timer，简单来说就是对定时器进行添加和删除。</p>\n<p>这里可以需要明确一点，超时事件分为两类：定时器超时 和 读写事件的超时。</p>\n<ul>\n<li><p>定时器超时是指：用户需要指定一个回调函数在延迟n ms后才执行。使用场景比如：1分钟向文件写入一条日志，日志内容是系统当前运行状态。</p>\n</li>\n<li><p>读写事件超时是指：在规定的超时时间内必需进行一次io，否则将操作视为超时，进行对应的超时处理。使用场景比如：HTTP的保活（keepalived）。</p>\n</li>\n</ul>\n<p>这两者区别是：定时器超时是<strong>一定会发生</strong>的，而对于读写事件超时，只要规定时间内有io事件发生，则超时<strong>不一定会发生</strong>。</p>\n<p>poller当中定时器其实就是fd为（无效）-1的__poller_node，它不会被添加到epoll当中，但是会根据超时时间被挂到超时链表&#x2F;红黑树上。超时后的处理和IO事件超时的处理一模一样。</p>\n<p>这里贴出部分poller_add_timer代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">poller_add_timer</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> timespec *value, <span class=\"type\">void</span> *context, <span class=\"type\">void</span> **timer,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t\t <span class=\"type\">poller_t</span> *poller)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *node;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode = (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> __poller_node));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">\t\tnode-&gt;data.operation = PD_OP_TIMER;</span><br><span class=\"line\">\t\tnode-&gt;data.fd = <span class=\"number\">-1</span>;\t\t\t\t\t<span class=\"comment\">// 标记为无效</span></span><br><span class=\"line\">\t\tnode-&gt;data.context = context;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">clock_gettime</span>(CLOCK_MONOTONIC, &amp;node-&gt;timeout);</span><br><span class=\"line\">\t\tnode-&gt;timeout.tv_sec += value-&gt;tv_sec;</span><br><span class=\"line\">\t\tnode-&gt;timeout.tv_nsec += value-&gt;tv_nsec;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node-&gt;timeout.tv_nsec &gt;= <span class=\"number\">1000000000</span>) &#123;</span><br><span class=\"line\">\t\t\tnode-&gt;timeout.tv_nsec -= <span class=\"number\">1000000000</span>;</span><br><span class=\"line\">\t\t\tnode-&gt;timeout.tv_sec++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t*timer = node;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t\t__poller_insert_node(node, poller);\t<span class=\"comment\">// 将poller_node添加到超时链表/红黑树上。</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>__poller_insert_node函数代码上小结已贴出。poller_del_timer函数实现可以参考poller_del，感兴趣的读者可以直接翻看源码，这里不过多赘述。</p>\n<h3 id=\"事件处理函数\"><a href=\"#事件处理函数\" class=\"headerlink\" title=\"事件处理函数\"></a>事件处理函数</h3><p>下面逐个分析poller当中IO事件的处理函数细节。本文是以workflow的TCPServer为主，这里默认阅读本文的读者是有网络编程的经验的，那么你一定知道一个TCP的服务端最基本的框架如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tsocket\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tbind\t|\t最开始三步由Communicator完成，下一篇博客会细讲。</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tlisten\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|\t\t\t______________________________________________</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\taccept\t|\t从这里开始涉及到的所以函数就是接下来讲解的重点。</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\t|\t|\t|</span><br><span class=\"line\">V\tV\tV\tV</span><br><span class=\"line\">fd\tfd\tfd\t...</span><br><span class=\"line\">\t/\\</span><br><span class=\"line\">read  write</span><br></pre></td></tr></table></figure>\n\n<p>本节就以上图所示顺序逐一介绍各个处理函数实现细节。</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>首先是accept事件处理函数————__poller_handle_listen，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_handle_listen(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t   <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *res = node-&gt;res;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\taddrlen = <span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> sockaddr_storage);</span><br><span class=\"line\">\t\tsockfd = <span class=\"built_in\">accept</span>(node-&gt;data.fd, addr, &amp;addrlen);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sockfd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (errno == EAGAIN || errno == EMFILE || errno == ENFILE)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (errno == ECONNABORTED)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tresult = node-&gt;data.<span class=\"built_in\">accept</span>(addr, addrlen, sockfd, node-&gt;data.context);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!result)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tres-&gt;data = node-&gt;data;</span><br><span class=\"line\">\t\tres-&gt;data.result = result;</span><br><span class=\"line\">\t\tres-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tres-&gt;state = PR_ST_SUCCESS;</span><br><span class=\"line\">\t\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)res, poller-&gt;context);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tres = (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> __poller_node));</span><br><span class=\"line\">\t\tnode-&gt;res = res;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!res)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_remove_node(node, poller))\t<span class=\"comment\">// 从epoll当中移除fd</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode-&gt;error = errno;</span><br><span class=\"line\">\tnode-&gt;state = PR_ST_ERROR;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(node-&gt;res);</span><br><span class=\"line\">\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);\t<span class=\"comment\">// 一般是server在停止或出错才会走到这里。\t</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>逻辑是：不断在一个while循环当中执行如下过程：</p>\n<ol>\n<li><p>（非阻塞的）调用accept系统调用接受客户端的连接。EAGAIN、EMFILE、ENFILE、ECONNABORTED分别代表没有可用连接、文件描述符达到上限、系统无句柄可用、连接终止（客户端的原因）。这些错误都是网络编程当中很常规的错误。都是可以容忍的。所以该return的return，该continue就continue。</p>\n</li>\n<li><p>当接收到一条合法的io连接，就将其scoketfd作为参数回调node-&gt;data.accept，它会回调 Communicator::accept函数，该函数会为连接构造一个CommServiceTarget对象作为返回值，<strong>这里并没有将sockfd设置为非阻塞</strong>。这里读者可以先不必探究CommServiceTarget是干什么的，在下一章讲解Communicator自然会明了。因为我一开始也不知道CommServiceTarget的作用。可以从它的命名先猜测它其实就是IO连接在服务端的一个对象实体吧。</p>\n</li>\n<li><p>回调poller-&gt;callback，其实在看完后面的read、write等io事件的处理函数之后，就会发现最早都会调用poller-&gt;callback，该回调也是在下章讲解Communicator后才发挥重要作用，读者先把它看作黑盒即可。可以预料到它里面一定会将接受的sockfd<strong>设置为非阻塞</strong>，并且最终会将它包装成poller_node加入到poller当中。</p>\n</li>\n</ol>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>然后是read事件处理函数————__poller_handle_read，（去除了和SSL相关的代码，剩余的）代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __poller_append_message(<span class=\"type\">const</span> <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> *n,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t   <span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t   <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"type\">poller_message_t</span> *msg = node-&gt;data.message;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *res;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!msg) &#123;\t<span class=\"comment\">// 为连接的每个请求包分配一个msg</span></span><br><span class=\"line\">\t\tres = (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> __poller_node));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!res)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmsg = node-&gt;data.<span class=\"built_in\">create_message</span>(node-&gt;data.context);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!msg) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">free</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnode-&gt;data.message = msg;</span><br><span class=\"line\">\t\tnode-&gt;res = res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tres = node-&gt;res;</span><br><span class=\"line\"></span><br><span class=\"line\">\tret = msg-&gt;<span class=\"built_in\">append</span>(buf, n, msg);\t<span class=\"comment\">// 通过msg解析请求包（PS，注意同一个请求可能会被拆分成多个tcp报文发送，所以函数可能会被多次回调）</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ret &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tres-&gt;data = node-&gt;data;</span><br><span class=\"line\">\t\tres-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tres-&gt;state = PR_ST_SUCCESS;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当msg收到完整的请求包且解析完后同样回调一下poller-&gt;callback</span></span><br><span class=\"line\">\t\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)res, poller-&gt;context);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnode-&gt;data.message = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">// 清空，为下一个请求做准备</span></span><br><span class=\"line\">\t\tnode-&gt;res = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_handle_read(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> nleft;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> n;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *p;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tp = poller-&gt;buf;</span><br><span class=\"line\">\t\tnleft = <span class=\"built_in\">read</span>(node-&gt;data.fd, p, POLLER_BUFSIZE);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (errno == EAGAIN)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\tn = nleft;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (__poller_append_message(p, &amp;n, node, poller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tnleft -= n;</span><br><span class=\"line\">\t\t\t\tp += n;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\tnleft = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> (nleft &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;\t<span class=\"comment\">// 连接断开或则有错误发生</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_remove_node(node, poller))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (nleft == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tnode-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_FINISHED;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tnode-&gt;error = errno;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_ERROR;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(node-&gt;res);</span><br><span class=\"line\">\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为是异步read，所以__poller_handle_read回调多次才能读完一个完整的客户端请求报文。它的逻辑。主要就是两步，（非阻塞的方式）调用原始read系统调用，然后调用__poller_append_message函数去逐步解析收到的数据。当连接断开或则出现错误就跳出循环，回调poller-&gt;callback处理错误。<strong>这里我们其实可以大胆猜测__poller_append_message函数当中msg-&gt;append函数肯定是一个（HTTP、DNS等）报文解析器。</strong></p>\n<p>这里有一个比较有意思的点是read系统调用所使用的buffer是poller-&gt;buf，它是poller的数据成员，这里所有的fd在read的时候使用同一个buffer，难道不会出问题吗？read的数据不会乱吗？</p>\n<p>这里简单分析一下，首先考虑线程安全问题，因为前面说过：一个poller对应一个线程。所以在线程处理IO事件的时候，一定是串行的，这就排除并行导致的线程安全问题。</p>\n<p>其次，再考虑异步非阻塞的方式读数据，东读一下西读一下会不会存在数据乱掉的问题，如果你仔细分析过__poller_handle_read其实就不会出现这个疑问，因为__poller_handle_read在通过poller-&gt;buf接受到数据后，不管这个请求是否完整，都会在__poller_append_message函数里面的msg-&gt;append进行<strong>异步解析</strong>。解析完毕后，poller-&gt;buf上的数据也就失去了它的意义。所以在处理下一个read事件的时候，放心的随他使用poller-&gt;buf吧。</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>最后write事件处理函数————__poller_handle_write，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_handle_write(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t  <span class=\"type\">poller_t</span> *poller)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> *iov = node-&gt;data.write_iov;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> nleft;</span><br><span class=\"line\">\t<span class=\"type\">int</span> iovcnt;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (node-&gt;data.iovcnt &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tiovcnt = node-&gt;data.iovcnt;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (iovcnt &gt; IOV_MAX)</span><br><span class=\"line\">\t\t\tiovcnt = IOV_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnleft = <span class=\"built_in\">writev</span>(node-&gt;data.fd, iov, iovcnt);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tret = errno == EAGAIN ? <span class=\"number\">0</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcount += nleft;</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;\t\t\t\t\t\t\t<span class=\"comment\">// 修正iov</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (nleft &gt;= iov-&gt;iov_len) &#123;</span><br><span class=\"line\">\t\t\t\tnleft -= iov-&gt;iov_len;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_base = (<span class=\"type\">char</span> *)iov-&gt;iov_base + iov-&gt;iov_len;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_len = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\tiov++;</span><br><span class=\"line\">\t\t\t\tnode-&gt;data.iovcnt--;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_base = (<span class=\"type\">char</span> *)iov-&gt;iov_base + nleft;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_len -= nleft;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> (node-&gt;data.iovcnt &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode-&gt;data.write_iov = iov;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node-&gt;data.iovcnt &gt; <span class=\"number\">0</span> &amp;&amp; ret &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node-&gt;data.<span class=\"built_in\">partial_written</span>(count, node-&gt;data.context) &gt;= <span class=\"number\">0</span>)\t<span class=\"comment\">// 通知一下已发送的数据量</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_remove_node(node, poller))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node-&gt;data.iovcnt == <span class=\"number\">0</span>) &#123;\t<span class=\"comment\">// 为零结束</span></span><br><span class=\"line\">\t\tnode-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_FINISHED;\t</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;\t\t\t\t\t\t<span class=\"comment\">// 否则出错</span></span><br><span class=\"line\">\t\tnode-&gt;error = errno;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_ERROR;\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样，因为是异步写数据，一个客户请求的回复报文可能分多次write才能发送完毕。poller向socketfd写数据采用的是writev接口，writev接口可以很方便的将内存不连续的数据发送到网络上。这在需要向网络写入大量的数据时很方便。因为数据量大所以系统无法一次性分配那么大块内存，所以数据可能被放在内存不连续的离散的buffer当中。writev使用元素类型为struct iovec的数组作为数据缓存，数组当中每个元素存放指向一块缓存的首地址的指针和长度。（非阻塞的）writev会返回实际发送的字节数。从代码中可以看到while循环嵌套了一个do while，因为tcp发送缓存区是有限的，do while作用是根据实际发送的字节数抹除已经发生的buffer，重新计算iov数组等待下一轮while循环继续发送。</p>\n<p>当发送缓存满，会因为EAGAIN跳出while循环，同时因为还存在没有发送完毕的数据，会调用node-&gt;data.partial_written。当数发送完毕，会将poller_node从epoll当中移除（对写事件的监听），最后回调poller-&gt;callback。</p>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"WorkFlow源码剖析——Communicator之TCPServer（下）","date":"2024-11-07T04:00:00.000Z","_content":"\n## 前言\n\n系列链接如下：\n\n[WorkFlow源码剖析——GO-Task 源码分析](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlow源码剖析——Communicator之TCPServer（上）](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlow源码剖析——Communicator之TCPServer（中）](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlow源码剖析——Communicator之TCPServer（下）](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\n终于来到TCPServer最后一部分，前面两篇博客已经深入分析了WorkFlow底层poller和Communicator的实现细节，本篇博客将会从整体视角，整合前面所讲的poller以及Communicator形成最终的TCPServer。\n\n同样放上workflow开源项目的Github地址：[https://github.com/sogou/workflow](https://github.com/sogou/workflow)\n\n和GO-Task的实现类似，尤其需要注意对基类SubTask、CommSession虚函数的重写。如果你看过GO-Task的实现，本文最终所讲的TCPServer任务其实差不多。因为TCPServer的继承树和GO-Task的继承树不能说相似，只能说一模一样。对称性对框架的设计真的很重要，我认为对称思想（也可以说成抽象思想）是优雅的象征。并且对称性可以帮我们减少出BUG的风险。如果你刷过的LeetCode，你一定会发现，在解答那些对边界条件要求很高的题目时，如果你能给各种情况抽象出一套统一的逻辑说词，大概率就不会wa。\n\n<!-- more -->\n\n重申一下，本系列暂时集中分析workflow的TCPServer端的架构。对于客户端，后面有时间了会另起一个系列进行讲解。像CommSchedGroup、CommSchedTarget、CommSchedObject等属于客户端独有功能。CommSchedGroup主要功能是对客户端的连接按负载（引用数量）进行一个堆排序管理。读者可先忽略掉这些内容。并且因为有些类的设计是同时兼顾客户端和服务端的（如：CommRequest、等），这点在阅读源码的时候需要有自己的判断能力。不要被绕进去了！\n\n## 正文\n\n我们就顺从[WorkFlow GO-Task 源码分析](https://blog.csdn.net/m0_52566365/article/details/142903964)的方式，以workflow给的http_echo_server的示例作为本文的切入点：\n\n### 用法\n\ngo-task的用法示例如下：\n\n```cpp\n#include <stdio.h>\n#include <utility>\n#include \"workflow/HttpMessage.h\"\n#include \"workflow/HttpUtil.h\"\n#include \"workflow/WFServer.h\"\n#include \"workflow/WFHttpServer.h\"\n#include \"workflow/WFFacilities.h\"\n\nvoid process(WFHttpTask *server_task) {\n\tprotocol::HttpRequest *req = server_task->get_req();\n\tprotocol::HttpResponse *resp = server_task->get_resp();\n\n    /* 根据http请求进行一些业务处理，然后构造出回复报文。 */\n    /* ... */\n}\n\nint main(int argc, char *argv[]) {\n\tunsigned short port;\n\n\tif (argc != 2) {\n\t\tfprintf(stderr, \"USAGE: %s <port>\\n\", argv[0]);\n\t\texit(1);\n\t}\n\n\tsignal(SIGINT, sig_handler);\n\n\tWFHttpServer server(process);\n\tport = atoi(argv[1]);\n\tif (server.start(port) == 0) {\n\t\twait_group.wait();\n\t\tserver.stop();\n\t} else {\n\t\tperror(\"Cannot start server\");\n\t\texit(1);\n\t}\n\n\treturn 0;\n}\n```\n\n从workflow的httpserver的使用demo当中可以了解到，核心框架有三步：\n\n1. 将http处理回调函数作为参数，构造一个server对象。\n\n2. 调用start接口，启动server。\n\n3. wait_group.wait()阻塞，等待服务的结束。\n\n看到这三步流程，我们其实应该是一脸蒙的，根本无法猜到它底层是如何起服务的；当连接来到时又是如何回调上面的处理函数的。别着急我们先结合前面两篇博客，尽力而为的猜：\n\n1. 看到了process回调函数当中开头定义的两个**指针变量**req和resp都是来自server_task。结合tcp服务端在读取来自客户端的请求报文并解析前会调用Communicator::create_request函数创建一个in对象作为报文解析器，而in又是由session创建，**而在服务端session又是由CommService创建**。同时Communicator::reply接口是以session作为参数，最终tcpserver在发送回复时会取出session当中的out并发送给客户端，很明显的是：out显然是服务端对客户端请求的回复报文。所以种种迹象都表明server_task当中req、resp和session的in和out有着紧密联系。\n\n2. server.start接口一定会调用创建socket，绑定socket、监听sokcet。而这些流程在Communicator当中有提供接口，对应：Communicator::bind。Communicator::bind函数只有一个唯一的参数：CommService，但综合CommService头文件的定义来看，因为它里面有一个纯虚函数：new_session，显然CommService是一个虚基类，这意味着它无法实例化对象。所以一定有继承CommService的子类。\n\n综上，1、2两点都指向了一个关键词————CommService。\n\n### 探究WFHttpServer\n\n根据上小节得到的线索，我们深入跟到WFHttpServer当中去，它的继承树如下：\n\n```\n{ WFHttpServer == WFServer<protocol::HttpRequest, protocol::HttpResponse> } -> WFServerBase -> CommService\n```\n\n所以，WFHttpServer实际上是**模板类WFServer**的一个**成员函数全特化**实现。下面集中分析一下WFServer和WFServerBase：\n\n首先是WFServer模板类：\n\n```cpp\ntemplate<class REQ, class RESP>\nclass WFServer : public WFServerBase {\npublic:\n\tWFServer(const struct WFServerParams *params,\n\t\t\t std::function<void (WFNetworkTask<REQ, RESP> *)> proc) :\n\t\tWFServerBase(params),\n\t\tprocess(std::move(proc)) {  }\n\n\tWFServer(std::function<void (WFNetworkTask<REQ, RESP> *)> proc) :\n\t\tWFServerBase(&SERVER_PARAMS_DEFAULT),\n\t\tprocess(std::move(proc)) {  }\n\nprotected:\n\tvirtual CommSession *new_session(long long seq, CommConnection *conn);\n\nprotected:\n\tstd::function<void (WFNetworkTask<REQ, RESP> *)> process;\n};\n\ntemplate<class REQ, class RESP>\nCommSession *WFServer<REQ, RESP>::new_session(long long seq, CommConnection *conn) {\n\tusing factory = WFNetworkTaskFactory<REQ, RESP>;\n\tWFNetworkTask<REQ, RESP> *task;\n\n\ttask = factory::create_server_task(this, this->process);\n\ttask->set_keep_alive(this->params.keep_alive_timeout);\n\ttask->set_receive_timeout(this->params.receive_timeout);\n\ttask->get_req()->set_size_limit(this->params.request_size_limit);\n\n\treturn task;\n}\n```\n\n（PS，代码量很少，读者表示狂喜。）\n\n如代码所写的那样，WFServer就是继承了一下WFServerBase，并重写了new_session函数。究其根本这里的new_session实际上重写的是CommService当中所定义的纯虚函数。如果你认为应该仔细去阅读这里重写的虚函数，那你就错了，实际上WFHttpServer**又将new_session函数进行全特化实现**。所以WFServer的new_session看看就好。无需深入理解。\n\nWFServer重点就是将示例在创建server时传入的process回调，保存到了成员变量当中，**以供new_session时将任务回调传给Task**。下面重点研究一下WFServerBase。\n\n从上面的分析了解到WFServerBase继承自CommService。WFServerBase实现如下：\n\n```cpp\nclass WFServerBase : protected CommService {\npublic:\n\tWFServerBase(const struct WFServerParams *params) :\n\t\tconn_count(0) {\n\t\tthis->params = *params;\n\t\tthis->unbind_finish = false;\n\t\tthis->listen_fd = -1;\n\t}\n\npublic:\n\t/* To start a TCP server */\n\t/* ... */\n\t/* Start with binding address. The only necessary start function. */\n\tint start(const struct sockaddr *bind_addr, socklen_t addrlen);\n\n\t/* stop() is a blocking operation. */\n\tvoid stop() {\n\t\tthis->shutdown();\n\t\tthis->wait_finish();\n\t}\n\n\t/* Nonblocking terminating the server. For stopping multiple servers.\n\t * Typically, call shutdown() and then wait_finish().\n\t * But indeed wait_finish() can be called before shutdown(), even before\n\t * start() in another thread. */\n\tvoid shutdown();\n\tvoid wait_finish();\n\npublic:\n\tsize_t get_conn_count() const { return this->conn_count; }\n\nprotected:\n\tWFServerParams params;\n\nprotected:\n\tvirtual int create_listen_fd();\n\tvirtual WFConnection *new_connection(int accept_fd);\n\tvoid delete_connection(WFConnection *conn);\n\nprivate:\n\tint init(const struct sockaddr *bind_addr, socklen_t addrlen);\n\tvirtual void handle_unbound();\n\nprotected:\n\tstd::atomic<size_t> conn_count;\n\nprivate:\n\tint listen_fd;\n\tbool unbind_finish;\n\n\tstd::mutex mutex;\n\tstd::condition_variable cond;\n\n\tclass CommScheduler *scheduler;\n};\n```\n\n首先，我们看到WFServerBase当中有一个类型为CommScheduler的成员变量scheduler。我们应该感到惊喜，因为CommScheduler不就是对Communicator做了一层浅浅的封装吗？这里出现的scheduler不就意味着WFServerBase和Communicator联系起来了吗？那server的启动必定是调用了Communicator::bind接口来创建、绑定、监听listen socket。下面重点研究一下start函数的函数的实现：\n\n```cpp\nint WFServerBase::start(const struct sockaddr *bind_addr, socklen_t addrlen) {\n\tif (this->init(bind_addr, addrlen) >= 0) {\n\t\tif (this->scheduler->bind(this) >= 0)\n\t\t\treturn 0;\n\n\t\tthis->deinit();\n\t}\n\n\tthis->listen_fd = -1;\n\treturn -1;\n}\n```\n\ninit函数伪代码如下：\n\n```cpp\nint WFServerBase::init(const struct sockaddr *bind_addr, socklen_t addrlen) {\n\t/* ... */\n\tif (this->CommService::init(bind_addr, addrlen, -1, timeout) < 0)\t// 调用基类CommService的初始化函数，就是将listen fd所绑定的地址拷贝一份到基类。\n\t\treturn -1;\n\n\tthis->scheduler = WFGlobal::get_scheduler();\t\t\t\t\t\t// 全局的单例CommScheduler对象。\n\treturn 0;\n}\n```\n\n主要干了两件事：调用基类的init，将绑定的地址拷贝一份到基类的成员变量当中。然后通过__CommManager获取全局的单例CommScheduler对象。\n\n特别的是，**这里有个重要的时间点**，在__CommManager被构造时，会**初始化CommScheduler对象**，如果你看过上一篇博客，你一定知道为什么这个时刻重要。因为CommScheduler::init函数会**启动workflow底层的事件池和状态迁移池**。具体的架构模型图可以参考：[WorkFlow源码剖析——Communicator之TCPServer（中）](https://blog.csdn.net/m0_52566365/article/details/143493066)。\n\n在WFServerBase::start实现中，调用init函数过后，立马调用CommScheduler::bind（实际上就是Communicator::bind），该函数里面会做网络编程三部曲：创建、绑定、监听。至此我们的TCPServer服务器就在这里启动，等待客户端的连接。\n\n关于WFServerBase其实还有两个有趣的知识点：new_connection 和 服务停止。\n\n- new_connection：该函数和WFServerBase::conn_count强相关。new_connection所创建的对象共用WFServerBase::conn_count。每当有客户端连接到来，都会创建一个CommConnection对象，同时会使WFServerBase::conn_count自增一。每当连接断开，Communicator当中就会调用__release_conn释放连接上下文，并且CommConnection对象也随之释放，其构造函数当中，会将WFServerBase::conn_count变量自减一。所以说，每次在连接到来创建的CommConnection对象可以视为连接计数器。（PS，因为目前只了解workflow的部分源码，所以连接计数器存在的具体意义，我目前还未能领悟。后面有时间的话，再去深究吧。）\n\n- 服务停止：如代码注释那样，WFServerBase所提供的stop接口是阻塞的，它其实连续调用了两个函数：shutdown、wait_finish。其中shutdown会调用Communicator::unbind函数，它会直接将listen fd从mpoller当中删除。当调用shutdown函数时，整体**停止的链路是这样的**：\n\n```\nWFServerBase::shutdown -> \n\nCommScheduler::unbind -> \n\nCommunicator::unbind -> \n\nmpoller_del(listen_fd) - - -> \n\nCommunicator::handle_listen_result -> \n\nCommunicator::shutdown_service -> \n\nwhile (直到CommService的ref减为0) { CommService::decref() } -> \n\nWFServerBase::handle_unbound\n```\n\nCommunicator::shutdown_service代码如下：\n\n```cpp\nvoid Communicator::shutdown_service(CommService *service) {\n\tclose(service->listen_fd);\n\tservice->listen_fd = -1;\n\tservice->drain(-1);\n\tservice->decref();\n}\n```\n\n这里的service->drain(-1)会将server端目前所有的连接都从mpoller当中移除。然后等待所有连接上下文回调CommServiceTarget::decref将server对象的引用计数减为0后，调用WFServerBase::handle_unbound函数\n\n```cpp\ninline void CommService::decref() {\n\tif (__sync_sub_and_fetch(&this->ref, 1) == 0)\n\t\tthis->handle_unbound();\t\t\t\t\t\t// 最终被重写成：WFServerBase::handle_unbound\n}\n```\n\nWFServerBase::stop的注释说明了该函数是阻塞的，其阻塞主要原因就在wait_finish，它会等待所有的连接被释放然后释放WFServerBase的引用计数后才会跳出等待条件变量的循环。\n\n```cpp\nvoid WFServerBase::handle_unbound() {\n\tthis->mutex.lock();\n\tthis->unbind_finish = true;\n\tthis->cond.notify_one();\n\tthis->mutex.unlock();\n}\n\nvoid WFServerBase::wait_finish() {\n\tstd::unique_lock<std::mutex> lock(this->mutex);\n\n\twhile (!this->unbind_finish)\n\t\tthis->cond.wait(lock);\n\n\tthis->deinit();\n\tthis->unbind_finish = false;\n\tlock.unlock();\n}\n```\n\n### 探究WFHttpServerTask\n\n好了，tcpserver的启动流程基本流程已经分析完毕，下面我们重点看看WFHttpServer::new_session的实现。该函数在每轮读取客户端请求时会被调用一次。返回值是类型为CommSession的对象。\n\n```cpp\ntemplate<> inline\nCommSession *WFHttpServer::new_session(long long seq, CommConnection *conn) {\n\tWFHttpTask *task;\n\n\ttask = WFServerTaskFactory::create_http_task(this, this->process);\n\ttask->set_keep_alive(this->params.keep_alive_timeout);\n\ttask->set_receive_timeout(this->params.receive_timeout);\n\ttask->get_req()->set_size_limit(this->params.request_size_limit);\n\n\treturn task;\n}\n```\n\n可以看到出现了一个新的类——WFHttpTask，我可以明确告诉你，WFHttpTask只是一个基类，我们应该从final类开始深入分析。\n\n对于WFHttpTask，它的定义如下：\n\n```cpp\nusing WFHttpTask = WFNetworkTask<protocol::HttpRequest,\n\t\t\t\t\t\t\t\t protocol::HttpResponse>;\n```\n\n那么WFNetworkTask是啥呢？先别急，后面再来揭晓它的源码。通过WFServerTaskFactory::create_http_task我们可以找到我们所需要的final类——WFHttpServerTask它的定义如下：\n\n```cpp\nclass WFHttpServerTask : public WFServerTask<protocol::HttpRequest,\n\t\t\t\t\t\t\t\t\t\t\t protocol::HttpResponse> {\nprivate:\n\tusing TASK = WFNetworkTask<protocol::HttpRequest, protocol::HttpResponse>;\n\npublic:\n\tWFHttpServerTask(CommService *service, std::function<void (TASK *)>& proc) :\n\t\tWFServerTask(service, WFGlobal::get_scheduler(), proc),\n\t\treq_is_alive_(false),\n\t\treq_has_keep_alive_header_(false) {  }\n\nprotected:\n\tvirtual void handle(int state, int error);\n\tvirtual CommMessageOut *message_out();\n\nprotected:\n\tbool req_is_alive_;\n\tbool req_has_keep_alive_header_;\n\tstd::string req_keep_alive_;\n};\n```\n\n从构造函数当可以看到，再一次对全局单例的CommScheduler的引用。类的成员函数包括hanlde、message_out最终实现，我们重点关注handle的实现：\n\n```cpp\nvoid WFHttpServerTask::handle(int state, int error) {\n\tif (state == WFT_STATE_TOREPLY) {\n\t\t/* 设置fianl类的成员变量... */\n\t}\n\n\tthis->WFServerTask::handle(state, error);\n}\n\n```\n\n在服务端收完并解析完客户端发来的请求报文之后（在Communicator::handle_incoming_request函数当中）会进入该函数，从WFT_STATE_TOREPLY宏的命名也可以推测到，它代表准备回复的状态。在做完final类一些设置后，最终会调用父类的handle，所以下面深入看看WFServerTask模板类的实现。\n\n**tcpserver任务部分最烧脑的就在WFServerTask模板类的实现**，对于WFNetworkTask模板类，它本身的成员函数对我们理解tcpserver本身来说并不重要。但需要注意的是WFNetworkTask继承自CommRequest。\n\n简单用字符画了一下WFHttpServerTask的继承树。如下：\n\n```\n\tSubTask\t\tCommSession\n\t\t\t\\/\n\t\tCommRequest\n\t\t\t|\n\t\t\tV\n\tWFNetworkTask<REQ, RESP>\t# 该类的实现在对我们理解tcpserver不是特别重要，读者可以跳过该类。\n\t\t\t|\n\t\t\tV\n\tWFServerTask<REQ, RESP>\n\t\t\t|\n\t\t\tV\n\tWFHttpServerTask\n```\n\n在正式讲解WFServerTask前，**先学习几个关键知识点：**\n\n首先回顾一下，SubTask::subtask_done函数实现：\n\n```cpp\nvoid SubTask::subtask_done() {\n\tSubTask *cur = this;\n\n\tcur = cur->done();\n\tif (cur) {\n\t\tcur->dispatch();\t\t// 下一个任务的dispatch\n\t}\n\treturn;\n}\n```\n\n更简单点描述，调done后调dispatch触发任务队列的下一个任务。**（关键点一：）其中done函数实现最后都会调用`series_of(this)->pop()`，这行代码是获取SeriesWork串行队列的下一个任务，当队列中（没有任何任务了）山穷水尽了会返回nullptr，并且SeriesWork会delete this（SeriesWork对象本身）。**\n\n然后了解一下两个WFServerTask当中的内嵌类的定义：\n\n```cpp\nclass Processor : public SubTask {\npublic:\n\tProcessor(WFServerTask<REQ, RESP> *task,\n\t\t\t\tstd::function<void (WFNetworkTask<REQ, RESP> *)>& proc) :\n\t\tprocess(proc) {\n\t\tthis->task = task;\n\t}\n\n\tvirtual void dispatch() {\n\t\tthis->process(this->task);\t\t// 调用\n\t\tthis->task = NULL;\t/* As a flag. get_conneciton() disabled. */\n\t\tthis->subtask_done();\n\t}\n\n\tvirtual SubTask *done() {\n\t\treturn series_of(this)->pop();\t// 获取串行队列下一个任务\n\t}\n\n\tstd::function<void (WFNetworkTask<REQ, RESP> *)>& process;\n\tWFServerTask<REQ, RESP> *task;\n} processor;\n\nclass Series : public SeriesWork {\npublic:\n\tSeries(WFServerTask<REQ, RESP> *task) :\n\t\tSeriesWork(&task->processor, nullptr) {\n\t\tthis->set_last_task(task);\n\t\tthis->task = task;\n\t}\n\n\tvirtual ~Series() {\n\t\tdelete this->task;\n\t}\n\n\tWFServerTask<REQ, RESP> *task;\n};\n```\n\n- Processor::dispatch函数首先调用了一下构造传进来的回调函数process，然后调用subtask_done，结合上面的分析，它会调用串行队列当中的下一个任务的dispatch函数。\n\n- 对于Series，只有析构和构造函数，从构造函数当中可以看出来，它本质上就是 **（关键点二）只有两个任务的串行队列。并且在该串行队列被delete时，顺带会在析构函数当中delete掉二号任务。**此外，**（关键点三）在每个任务被加到串行队列当中时，会将任务的SubTask::pointer指针指向串行队列对象。**\n\n好了，下面从WFServerTask<REQ, RESP>::handle函数开始分析其中的奥妙。源代码如下：\n\n```cpp\ntemplate<class REQ, class RESP>\nvoid WFServerTask<REQ, RESP>::handle(int state, int error) {\n\tif (state == WFT_STATE_TOREPLY) {\n\t\tthis->state = WFT_STATE_TOREPLY;\n\t\tthis->target = this->get_target();\n\t\tnew Series(this);\n\t\tthis->processor.dispatch();\n\t}\n\telse if (this->state == WFT_STATE_TOREPLY) {\n\t\tthis->state = state;\n\t\tthis->error = error;\n\t\tif (error == ETIMEDOUT)\n\t\t\tthis->timeout_reason = TOR_TRANSMIT_TIMEOUT;\n\n\t\tthis->subtask_done();\n\t}\n\telse\n\t\tdelete this;\n}\n```\n\n因为WFServerTask顶层的基类包括：SubTask + **CommSession**，对这里着重强调CommSession，因为CommSession当中的handle最终被重写成如上所示的代码。服务端在每次读完（并解析完）客户端发来的数据后，状态迁移池都会回调Communicator::handle_incoming_request函数，在每次写完客户端请求的回复后，状态迁移池都会回调Communicator::handle_reply_result函数。这两函数当最后都会调用session->handle，所不同的是每次传入的state参数有所不同。**正常情况下，在读完后回调session->handle传入的state为CS_STATE_TOREPLY，而在写完后回调的session->handle传入的state为CS_STATE_SUCCESS。**\n\n- 所以在解析完客户端请求后所调用的handle会进入第一个if分支，从代码当中可以看到，它先是将WFServerTask::state数据成员设置成了WFT_STATE_TOREPLY，这为发送完回复再次回到handle进入第二个if分支做准备。然后最关键的是`new Series(this);`这行代码，如果你第一次看workflow的源码这样的写法一定会让你蒙。**什么鬼？new的成员没用什么变量去接？这不典型内存泄漏了吗？**，但是深入研究下去，这样写好像也没问题。结合上面Series的定义，所以最终new的Series串行队列当中第一个任务是WFServerTask::processor，第二个任务是WFServerTask本身。继续分析第一个if分支的代码，接下来调用了`this->processor.dispatch();`函数这也是整个业务代码的起始点。深入分析Processor::dispatch实现可知，它首先调用process回调，我可以直接告诉你此回调正是我们在示例当中创建server时传进来的process函数。在调用process处理完业务代码，然后调用了`this->subtask_done();`函数，根据前面提到的**关键点一**，我们可以知道这将返回串行队列的第二个任务即WFServerTask。我想这里一定会有读者有疑惑，怎么就返回第二个任务了？不是应该返回第一个任务吗？如果你有这样的疑惑，我建议你仔细阅读一下SeriesWork这部分的源码，所谓的两个任务实际上首个任务是不会入队列的，需要人手动触发，而在WFServerTask<REQ, RESP>::handle当中其实已经手动触发了一号任务————Processor，所以第一次调用subtask_done实际上返回的是第二个任务。好了回到正题，进入二号任务的dispatch（`WFServerTask::dispatch`），因为我们在前面已经将WFServerTask::state设置成了WFT_STATE_TOREPLY所以，进入if分支，这里应该开个香槟了，因为这里调用了`this->scheduler->reply`，这意味着服务端向客户端发送回复了！！！正常情况下会返回大于零的值，然后直接返回。这里罗列一下调用和返回流程：\n\n\t首先是调用流程：\n\n\t```\n\tWFServerTask<REQ, RESP>::handle ->\n\tProcessor::dispatch -> \n\tProcessor::subtask_done -> \n\tWFServerTask::dispatch\n\t```\n\n\t然后是返回流程：\n\t\n\t```\n\t从第二个任务的WFServerTask的：dispatch函数当中 返回到 -> \n\t第一个任务Processor的基类函数：subtask_done -> \n\t返回到第一个任务Processor的dispatch函数 -> \n\t返回到WFServerTask<REQ, RESP>::handle函数。\n\t```\n\n\t我这里想表达的是：**WFServerTask<REQ, RESP>::handle第一个if分支的一次dispatch实际上嵌套执行了两个任务。**，注意是**嵌套**，这点很重要！\n\n- 然后在写完回复后，会再次回到WFServerTask<REQ, RESP>::handle，此时会进入第二个if分支，并且根据**关键点一**，**因为此时第一个if分支new的串行队列已经为空，所以WFServerTask::subtask_done操作会将第一个if分支new的串行队列给释放掉，同时因为Series的释放，它的析构函数又会将WFServerTask给释放掉！**\n\n下面贴出WFServerTask关键的代码：\n\n```cpp\ntemplate<class REQ, class RESP>\nclass WFServerTask : public WFNetworkTask<REQ, RESP> {\nprotected:\n\tvirtual CommMessageOut *message_out() { return &this->resp; }\n\tvirtual CommMessageIn *message_in() { return &this->req; }\n\tvirtual void handle(int state, int error);\n\nprotected:\n\tvirtual void dispatch() {\n\t\tif (this->state == WFT_STATE_TOREPLY) {\n\t\t\t/* Enable get_connection() again if the reply() call is success. */\n\t\t\tthis->processor.task = this;\n\t\t\tif (this->scheduler->reply(this) >= 0)\t// 发生回复\n\t\t\t\treturn;\n\n\t\t\tthis->state = WFT_STATE_SYS_ERROR;\n\t\t\tthis->error = errno;\n\t\t\tthis->processor.task = NULL;\n\t\t}\n\t\telse\n\t\t\tthis->scheduler->shutdown(this);\n\n\t\tthis->subtask_done();\n\t}\n\n\tvirtual SubTask *done() {\n\t\tSeriesWork *series = series_of(this);\n\n\t\tif (this->callback)\n\t\t\tthis->callback(this);\n\n\t\t/* Defer deleting the task. */\n\t\treturn series->pop();\n\t}\n\npublic:\n\tWFServerTask(CommService *service, CommScheduler *scheduler,\n\t\t\t\t std::function<void (WFNetworkTask<REQ, RESP> *)>& proc) :\n\t\tWFNetworkTask<REQ, RESP>(NULL, scheduler, nullptr),\n\t\tprocessor(this, proc)\n\t{ }\n};\n```\n\n好了基本的HTTPServer端处理客户端请求的流程已经梳理完毕，最后贴出我在看源码的过程当中，所梳理流程笔记，可以给读者提供一些思路。同时也作为我个人的备忘笔记：\n\n```\n# Workflow服务端处理连接流程分析\n\nserver:\n\n    entry: \n        accept_conn: CONN_STATE_CONNECTED -> \n            create_request: CONN_STATE_RECEIVING ->                             // tag1\n                append_message: 当http请求接受完毕时：CONN_STATE_SUCCESS ->\n                    handle_incoming_request: \n                        ==>     CONN_STATE_IDLE && entry被追加到target->idle_list上;\n                        ==>    session->passive = 2;\n                        ==>    state = CS_STATE_TOREPLY\n\n    |   |   |\n    V   V   V\n    WFHttpServerTask::handle ->\n        WFServerTask<REQ, RESP>::handle ->\n            ```cpp\n                template<class REQ, class RESP>\n                void WFServerTask<REQ, RESP>::handle(int state, int error)\n                {\n                    if (state == WFT_STATE_TOREPLY)         // √\n                    {\n                        this->state = WFT_STATE_TOREPLY;\n                        this->target = this->get_target();\n                        new Series(this);\n                        this->processor.dispatch();\n                    }\n                    else if (this->state == WFT_STATE_TOREPLY)\n                    {\n                        this->state = state;\n                        this->error = error;\n                        if (error == ETIMEDOUT)\n                            this->timeout_reason = TOR_TRANSMIT_TIMEOUT;\n\n                        this->subtask_done();\n                    }\n                    else\n                        delete this;\n                }\n            ```\n\n        WFServerTask<REQ, RESP>::dispatch ->\n            this->scheduler->reply(this) -> 以写方式将entry添加到epoll上\n                session->passive = 3;\n\n    |   |   |       \n    V   V   V\n    handle_reply_result ->\n        ===> entry->state = CONN_STATE_KEEPALIVE && entry 被追加到service->alive_list && 以读方式将entry添加到epoll上（如果保活的话）\n        ===> state = CS_STATE_SUCCESS\n\n    |   |   |\n    V   V   V\n    WFHttpServerTask::handle ->\n        WFServerTask<REQ, RESP>::handle ->\n            ```cpp\n                template<class REQ, class RESP>\n                void WFServerTask<REQ, RESP>::handle(int state, int error)\n                {\n                    if (state == WFT_STATE_TOREPLY)\n                    {\n                        this->state = WFT_STATE_TOREPLY;\n                        this->target = this->get_target();\n                        new Series(this);\n                        this->processor.dispatch();\n                    }\n                    else if (this->state == WFT_STATE_TOREPLY)  // √\n                    {\n                        this->state = state;\n                        this->error = error;\n                        if (error == ETIMEDOUT)\n                            this->timeout_reason = TOR_TRANSMIT_TIMEOUT;\n\n                        this->subtask_done();       // will delete Series for first 'if' branch malloc\n                    }\n                    else\n                        delete this;\n                }\n            ```\n\n    |   |   |\n    V   V   V\n    go to tag1.\n```\n\n---\n\n**本章完结**","source":"_posts/workflow/TCPServer_3.md","raw":"---\ntitle: WorkFlow源码剖析——Communicator之TCPServer（下）\ndate: 2024-11-07 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n## 前言\n\n系列链接如下：\n\n[WorkFlow源码剖析——GO-Task 源码分析](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlow源码剖析——Communicator之TCPServer（上）](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlow源码剖析——Communicator之TCPServer（中）](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlow源码剖析——Communicator之TCPServer（下）](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\n终于来到TCPServer最后一部分，前面两篇博客已经深入分析了WorkFlow底层poller和Communicator的实现细节，本篇博客将会从整体视角，整合前面所讲的poller以及Communicator形成最终的TCPServer。\n\n同样放上workflow开源项目的Github地址：[https://github.com/sogou/workflow](https://github.com/sogou/workflow)\n\n和GO-Task的实现类似，尤其需要注意对基类SubTask、CommSession虚函数的重写。如果你看过GO-Task的实现，本文最终所讲的TCPServer任务其实差不多。因为TCPServer的继承树和GO-Task的继承树不能说相似，只能说一模一样。对称性对框架的设计真的很重要，我认为对称思想（也可以说成抽象思想）是优雅的象征。并且对称性可以帮我们减少出BUG的风险。如果你刷过的LeetCode，你一定会发现，在解答那些对边界条件要求很高的题目时，如果你能给各种情况抽象出一套统一的逻辑说词，大概率就不会wa。\n\n<!-- more -->\n\n重申一下，本系列暂时集中分析workflow的TCPServer端的架构。对于客户端，后面有时间了会另起一个系列进行讲解。像CommSchedGroup、CommSchedTarget、CommSchedObject等属于客户端独有功能。CommSchedGroup主要功能是对客户端的连接按负载（引用数量）进行一个堆排序管理。读者可先忽略掉这些内容。并且因为有些类的设计是同时兼顾客户端和服务端的（如：CommRequest、等），这点在阅读源码的时候需要有自己的判断能力。不要被绕进去了！\n\n## 正文\n\n我们就顺从[WorkFlow GO-Task 源码分析](https://blog.csdn.net/m0_52566365/article/details/142903964)的方式，以workflow给的http_echo_server的示例作为本文的切入点：\n\n### 用法\n\ngo-task的用法示例如下：\n\n```cpp\n#include <stdio.h>\n#include <utility>\n#include \"workflow/HttpMessage.h\"\n#include \"workflow/HttpUtil.h\"\n#include \"workflow/WFServer.h\"\n#include \"workflow/WFHttpServer.h\"\n#include \"workflow/WFFacilities.h\"\n\nvoid process(WFHttpTask *server_task) {\n\tprotocol::HttpRequest *req = server_task->get_req();\n\tprotocol::HttpResponse *resp = server_task->get_resp();\n\n    /* 根据http请求进行一些业务处理，然后构造出回复报文。 */\n    /* ... */\n}\n\nint main(int argc, char *argv[]) {\n\tunsigned short port;\n\n\tif (argc != 2) {\n\t\tfprintf(stderr, \"USAGE: %s <port>\\n\", argv[0]);\n\t\texit(1);\n\t}\n\n\tsignal(SIGINT, sig_handler);\n\n\tWFHttpServer server(process);\n\tport = atoi(argv[1]);\n\tif (server.start(port) == 0) {\n\t\twait_group.wait();\n\t\tserver.stop();\n\t} else {\n\t\tperror(\"Cannot start server\");\n\t\texit(1);\n\t}\n\n\treturn 0;\n}\n```\n\n从workflow的httpserver的使用demo当中可以了解到，核心框架有三步：\n\n1. 将http处理回调函数作为参数，构造一个server对象。\n\n2. 调用start接口，启动server。\n\n3. wait_group.wait()阻塞，等待服务的结束。\n\n看到这三步流程，我们其实应该是一脸蒙的，根本无法猜到它底层是如何起服务的；当连接来到时又是如何回调上面的处理函数的。别着急我们先结合前面两篇博客，尽力而为的猜：\n\n1. 看到了process回调函数当中开头定义的两个**指针变量**req和resp都是来自server_task。结合tcp服务端在读取来自客户端的请求报文并解析前会调用Communicator::create_request函数创建一个in对象作为报文解析器，而in又是由session创建，**而在服务端session又是由CommService创建**。同时Communicator::reply接口是以session作为参数，最终tcpserver在发送回复时会取出session当中的out并发送给客户端，很明显的是：out显然是服务端对客户端请求的回复报文。所以种种迹象都表明server_task当中req、resp和session的in和out有着紧密联系。\n\n2. server.start接口一定会调用创建socket，绑定socket、监听sokcet。而这些流程在Communicator当中有提供接口，对应：Communicator::bind。Communicator::bind函数只有一个唯一的参数：CommService，但综合CommService头文件的定义来看，因为它里面有一个纯虚函数：new_session，显然CommService是一个虚基类，这意味着它无法实例化对象。所以一定有继承CommService的子类。\n\n综上，1、2两点都指向了一个关键词————CommService。\n\n### 探究WFHttpServer\n\n根据上小节得到的线索，我们深入跟到WFHttpServer当中去，它的继承树如下：\n\n```\n{ WFHttpServer == WFServer<protocol::HttpRequest, protocol::HttpResponse> } -> WFServerBase -> CommService\n```\n\n所以，WFHttpServer实际上是**模板类WFServer**的一个**成员函数全特化**实现。下面集中分析一下WFServer和WFServerBase：\n\n首先是WFServer模板类：\n\n```cpp\ntemplate<class REQ, class RESP>\nclass WFServer : public WFServerBase {\npublic:\n\tWFServer(const struct WFServerParams *params,\n\t\t\t std::function<void (WFNetworkTask<REQ, RESP> *)> proc) :\n\t\tWFServerBase(params),\n\t\tprocess(std::move(proc)) {  }\n\n\tWFServer(std::function<void (WFNetworkTask<REQ, RESP> *)> proc) :\n\t\tWFServerBase(&SERVER_PARAMS_DEFAULT),\n\t\tprocess(std::move(proc)) {  }\n\nprotected:\n\tvirtual CommSession *new_session(long long seq, CommConnection *conn);\n\nprotected:\n\tstd::function<void (WFNetworkTask<REQ, RESP> *)> process;\n};\n\ntemplate<class REQ, class RESP>\nCommSession *WFServer<REQ, RESP>::new_session(long long seq, CommConnection *conn) {\n\tusing factory = WFNetworkTaskFactory<REQ, RESP>;\n\tWFNetworkTask<REQ, RESP> *task;\n\n\ttask = factory::create_server_task(this, this->process);\n\ttask->set_keep_alive(this->params.keep_alive_timeout);\n\ttask->set_receive_timeout(this->params.receive_timeout);\n\ttask->get_req()->set_size_limit(this->params.request_size_limit);\n\n\treturn task;\n}\n```\n\n（PS，代码量很少，读者表示狂喜。）\n\n如代码所写的那样，WFServer就是继承了一下WFServerBase，并重写了new_session函数。究其根本这里的new_session实际上重写的是CommService当中所定义的纯虚函数。如果你认为应该仔细去阅读这里重写的虚函数，那你就错了，实际上WFHttpServer**又将new_session函数进行全特化实现**。所以WFServer的new_session看看就好。无需深入理解。\n\nWFServer重点就是将示例在创建server时传入的process回调，保存到了成员变量当中，**以供new_session时将任务回调传给Task**。下面重点研究一下WFServerBase。\n\n从上面的分析了解到WFServerBase继承自CommService。WFServerBase实现如下：\n\n```cpp\nclass WFServerBase : protected CommService {\npublic:\n\tWFServerBase(const struct WFServerParams *params) :\n\t\tconn_count(0) {\n\t\tthis->params = *params;\n\t\tthis->unbind_finish = false;\n\t\tthis->listen_fd = -1;\n\t}\n\npublic:\n\t/* To start a TCP server */\n\t/* ... */\n\t/* Start with binding address. The only necessary start function. */\n\tint start(const struct sockaddr *bind_addr, socklen_t addrlen);\n\n\t/* stop() is a blocking operation. */\n\tvoid stop() {\n\t\tthis->shutdown();\n\t\tthis->wait_finish();\n\t}\n\n\t/* Nonblocking terminating the server. For stopping multiple servers.\n\t * Typically, call shutdown() and then wait_finish().\n\t * But indeed wait_finish() can be called before shutdown(), even before\n\t * start() in another thread. */\n\tvoid shutdown();\n\tvoid wait_finish();\n\npublic:\n\tsize_t get_conn_count() const { return this->conn_count; }\n\nprotected:\n\tWFServerParams params;\n\nprotected:\n\tvirtual int create_listen_fd();\n\tvirtual WFConnection *new_connection(int accept_fd);\n\tvoid delete_connection(WFConnection *conn);\n\nprivate:\n\tint init(const struct sockaddr *bind_addr, socklen_t addrlen);\n\tvirtual void handle_unbound();\n\nprotected:\n\tstd::atomic<size_t> conn_count;\n\nprivate:\n\tint listen_fd;\n\tbool unbind_finish;\n\n\tstd::mutex mutex;\n\tstd::condition_variable cond;\n\n\tclass CommScheduler *scheduler;\n};\n```\n\n首先，我们看到WFServerBase当中有一个类型为CommScheduler的成员变量scheduler。我们应该感到惊喜，因为CommScheduler不就是对Communicator做了一层浅浅的封装吗？这里出现的scheduler不就意味着WFServerBase和Communicator联系起来了吗？那server的启动必定是调用了Communicator::bind接口来创建、绑定、监听listen socket。下面重点研究一下start函数的函数的实现：\n\n```cpp\nint WFServerBase::start(const struct sockaddr *bind_addr, socklen_t addrlen) {\n\tif (this->init(bind_addr, addrlen) >= 0) {\n\t\tif (this->scheduler->bind(this) >= 0)\n\t\t\treturn 0;\n\n\t\tthis->deinit();\n\t}\n\n\tthis->listen_fd = -1;\n\treturn -1;\n}\n```\n\ninit函数伪代码如下：\n\n```cpp\nint WFServerBase::init(const struct sockaddr *bind_addr, socklen_t addrlen) {\n\t/* ... */\n\tif (this->CommService::init(bind_addr, addrlen, -1, timeout) < 0)\t// 调用基类CommService的初始化函数，就是将listen fd所绑定的地址拷贝一份到基类。\n\t\treturn -1;\n\n\tthis->scheduler = WFGlobal::get_scheduler();\t\t\t\t\t\t// 全局的单例CommScheduler对象。\n\treturn 0;\n}\n```\n\n主要干了两件事：调用基类的init，将绑定的地址拷贝一份到基类的成员变量当中。然后通过__CommManager获取全局的单例CommScheduler对象。\n\n特别的是，**这里有个重要的时间点**，在__CommManager被构造时，会**初始化CommScheduler对象**，如果你看过上一篇博客，你一定知道为什么这个时刻重要。因为CommScheduler::init函数会**启动workflow底层的事件池和状态迁移池**。具体的架构模型图可以参考：[WorkFlow源码剖析——Communicator之TCPServer（中）](https://blog.csdn.net/m0_52566365/article/details/143493066)。\n\n在WFServerBase::start实现中，调用init函数过后，立马调用CommScheduler::bind（实际上就是Communicator::bind），该函数里面会做网络编程三部曲：创建、绑定、监听。至此我们的TCPServer服务器就在这里启动，等待客户端的连接。\n\n关于WFServerBase其实还有两个有趣的知识点：new_connection 和 服务停止。\n\n- new_connection：该函数和WFServerBase::conn_count强相关。new_connection所创建的对象共用WFServerBase::conn_count。每当有客户端连接到来，都会创建一个CommConnection对象，同时会使WFServerBase::conn_count自增一。每当连接断开，Communicator当中就会调用__release_conn释放连接上下文，并且CommConnection对象也随之释放，其构造函数当中，会将WFServerBase::conn_count变量自减一。所以说，每次在连接到来创建的CommConnection对象可以视为连接计数器。（PS，因为目前只了解workflow的部分源码，所以连接计数器存在的具体意义，我目前还未能领悟。后面有时间的话，再去深究吧。）\n\n- 服务停止：如代码注释那样，WFServerBase所提供的stop接口是阻塞的，它其实连续调用了两个函数：shutdown、wait_finish。其中shutdown会调用Communicator::unbind函数，它会直接将listen fd从mpoller当中删除。当调用shutdown函数时，整体**停止的链路是这样的**：\n\n```\nWFServerBase::shutdown -> \n\nCommScheduler::unbind -> \n\nCommunicator::unbind -> \n\nmpoller_del(listen_fd) - - -> \n\nCommunicator::handle_listen_result -> \n\nCommunicator::shutdown_service -> \n\nwhile (直到CommService的ref减为0) { CommService::decref() } -> \n\nWFServerBase::handle_unbound\n```\n\nCommunicator::shutdown_service代码如下：\n\n```cpp\nvoid Communicator::shutdown_service(CommService *service) {\n\tclose(service->listen_fd);\n\tservice->listen_fd = -1;\n\tservice->drain(-1);\n\tservice->decref();\n}\n```\n\n这里的service->drain(-1)会将server端目前所有的连接都从mpoller当中移除。然后等待所有连接上下文回调CommServiceTarget::decref将server对象的引用计数减为0后，调用WFServerBase::handle_unbound函数\n\n```cpp\ninline void CommService::decref() {\n\tif (__sync_sub_and_fetch(&this->ref, 1) == 0)\n\t\tthis->handle_unbound();\t\t\t\t\t\t// 最终被重写成：WFServerBase::handle_unbound\n}\n```\n\nWFServerBase::stop的注释说明了该函数是阻塞的，其阻塞主要原因就在wait_finish，它会等待所有的连接被释放然后释放WFServerBase的引用计数后才会跳出等待条件变量的循环。\n\n```cpp\nvoid WFServerBase::handle_unbound() {\n\tthis->mutex.lock();\n\tthis->unbind_finish = true;\n\tthis->cond.notify_one();\n\tthis->mutex.unlock();\n}\n\nvoid WFServerBase::wait_finish() {\n\tstd::unique_lock<std::mutex> lock(this->mutex);\n\n\twhile (!this->unbind_finish)\n\t\tthis->cond.wait(lock);\n\n\tthis->deinit();\n\tthis->unbind_finish = false;\n\tlock.unlock();\n}\n```\n\n### 探究WFHttpServerTask\n\n好了，tcpserver的启动流程基本流程已经分析完毕，下面我们重点看看WFHttpServer::new_session的实现。该函数在每轮读取客户端请求时会被调用一次。返回值是类型为CommSession的对象。\n\n```cpp\ntemplate<> inline\nCommSession *WFHttpServer::new_session(long long seq, CommConnection *conn) {\n\tWFHttpTask *task;\n\n\ttask = WFServerTaskFactory::create_http_task(this, this->process);\n\ttask->set_keep_alive(this->params.keep_alive_timeout);\n\ttask->set_receive_timeout(this->params.receive_timeout);\n\ttask->get_req()->set_size_limit(this->params.request_size_limit);\n\n\treturn task;\n}\n```\n\n可以看到出现了一个新的类——WFHttpTask，我可以明确告诉你，WFHttpTask只是一个基类，我们应该从final类开始深入分析。\n\n对于WFHttpTask，它的定义如下：\n\n```cpp\nusing WFHttpTask = WFNetworkTask<protocol::HttpRequest,\n\t\t\t\t\t\t\t\t protocol::HttpResponse>;\n```\n\n那么WFNetworkTask是啥呢？先别急，后面再来揭晓它的源码。通过WFServerTaskFactory::create_http_task我们可以找到我们所需要的final类——WFHttpServerTask它的定义如下：\n\n```cpp\nclass WFHttpServerTask : public WFServerTask<protocol::HttpRequest,\n\t\t\t\t\t\t\t\t\t\t\t protocol::HttpResponse> {\nprivate:\n\tusing TASK = WFNetworkTask<protocol::HttpRequest, protocol::HttpResponse>;\n\npublic:\n\tWFHttpServerTask(CommService *service, std::function<void (TASK *)>& proc) :\n\t\tWFServerTask(service, WFGlobal::get_scheduler(), proc),\n\t\treq_is_alive_(false),\n\t\treq_has_keep_alive_header_(false) {  }\n\nprotected:\n\tvirtual void handle(int state, int error);\n\tvirtual CommMessageOut *message_out();\n\nprotected:\n\tbool req_is_alive_;\n\tbool req_has_keep_alive_header_;\n\tstd::string req_keep_alive_;\n};\n```\n\n从构造函数当可以看到，再一次对全局单例的CommScheduler的引用。类的成员函数包括hanlde、message_out最终实现，我们重点关注handle的实现：\n\n```cpp\nvoid WFHttpServerTask::handle(int state, int error) {\n\tif (state == WFT_STATE_TOREPLY) {\n\t\t/* 设置fianl类的成员变量... */\n\t}\n\n\tthis->WFServerTask::handle(state, error);\n}\n\n```\n\n在服务端收完并解析完客户端发来的请求报文之后（在Communicator::handle_incoming_request函数当中）会进入该函数，从WFT_STATE_TOREPLY宏的命名也可以推测到，它代表准备回复的状态。在做完final类一些设置后，最终会调用父类的handle，所以下面深入看看WFServerTask模板类的实现。\n\n**tcpserver任务部分最烧脑的就在WFServerTask模板类的实现**，对于WFNetworkTask模板类，它本身的成员函数对我们理解tcpserver本身来说并不重要。但需要注意的是WFNetworkTask继承自CommRequest。\n\n简单用字符画了一下WFHttpServerTask的继承树。如下：\n\n```\n\tSubTask\t\tCommSession\n\t\t\t\\/\n\t\tCommRequest\n\t\t\t|\n\t\t\tV\n\tWFNetworkTask<REQ, RESP>\t# 该类的实现在对我们理解tcpserver不是特别重要，读者可以跳过该类。\n\t\t\t|\n\t\t\tV\n\tWFServerTask<REQ, RESP>\n\t\t\t|\n\t\t\tV\n\tWFHttpServerTask\n```\n\n在正式讲解WFServerTask前，**先学习几个关键知识点：**\n\n首先回顾一下，SubTask::subtask_done函数实现：\n\n```cpp\nvoid SubTask::subtask_done() {\n\tSubTask *cur = this;\n\n\tcur = cur->done();\n\tif (cur) {\n\t\tcur->dispatch();\t\t// 下一个任务的dispatch\n\t}\n\treturn;\n}\n```\n\n更简单点描述，调done后调dispatch触发任务队列的下一个任务。**（关键点一：）其中done函数实现最后都会调用`series_of(this)->pop()`，这行代码是获取SeriesWork串行队列的下一个任务，当队列中（没有任何任务了）山穷水尽了会返回nullptr，并且SeriesWork会delete this（SeriesWork对象本身）。**\n\n然后了解一下两个WFServerTask当中的内嵌类的定义：\n\n```cpp\nclass Processor : public SubTask {\npublic:\n\tProcessor(WFServerTask<REQ, RESP> *task,\n\t\t\t\tstd::function<void (WFNetworkTask<REQ, RESP> *)>& proc) :\n\t\tprocess(proc) {\n\t\tthis->task = task;\n\t}\n\n\tvirtual void dispatch() {\n\t\tthis->process(this->task);\t\t// 调用\n\t\tthis->task = NULL;\t/* As a flag. get_conneciton() disabled. */\n\t\tthis->subtask_done();\n\t}\n\n\tvirtual SubTask *done() {\n\t\treturn series_of(this)->pop();\t// 获取串行队列下一个任务\n\t}\n\n\tstd::function<void (WFNetworkTask<REQ, RESP> *)>& process;\n\tWFServerTask<REQ, RESP> *task;\n} processor;\n\nclass Series : public SeriesWork {\npublic:\n\tSeries(WFServerTask<REQ, RESP> *task) :\n\t\tSeriesWork(&task->processor, nullptr) {\n\t\tthis->set_last_task(task);\n\t\tthis->task = task;\n\t}\n\n\tvirtual ~Series() {\n\t\tdelete this->task;\n\t}\n\n\tWFServerTask<REQ, RESP> *task;\n};\n```\n\n- Processor::dispatch函数首先调用了一下构造传进来的回调函数process，然后调用subtask_done，结合上面的分析，它会调用串行队列当中的下一个任务的dispatch函数。\n\n- 对于Series，只有析构和构造函数，从构造函数当中可以看出来，它本质上就是 **（关键点二）只有两个任务的串行队列。并且在该串行队列被delete时，顺带会在析构函数当中delete掉二号任务。**此外，**（关键点三）在每个任务被加到串行队列当中时，会将任务的SubTask::pointer指针指向串行队列对象。**\n\n好了，下面从WFServerTask<REQ, RESP>::handle函数开始分析其中的奥妙。源代码如下：\n\n```cpp\ntemplate<class REQ, class RESP>\nvoid WFServerTask<REQ, RESP>::handle(int state, int error) {\n\tif (state == WFT_STATE_TOREPLY) {\n\t\tthis->state = WFT_STATE_TOREPLY;\n\t\tthis->target = this->get_target();\n\t\tnew Series(this);\n\t\tthis->processor.dispatch();\n\t}\n\telse if (this->state == WFT_STATE_TOREPLY) {\n\t\tthis->state = state;\n\t\tthis->error = error;\n\t\tif (error == ETIMEDOUT)\n\t\t\tthis->timeout_reason = TOR_TRANSMIT_TIMEOUT;\n\n\t\tthis->subtask_done();\n\t}\n\telse\n\t\tdelete this;\n}\n```\n\n因为WFServerTask顶层的基类包括：SubTask + **CommSession**，对这里着重强调CommSession，因为CommSession当中的handle最终被重写成如上所示的代码。服务端在每次读完（并解析完）客户端发来的数据后，状态迁移池都会回调Communicator::handle_incoming_request函数，在每次写完客户端请求的回复后，状态迁移池都会回调Communicator::handle_reply_result函数。这两函数当最后都会调用session->handle，所不同的是每次传入的state参数有所不同。**正常情况下，在读完后回调session->handle传入的state为CS_STATE_TOREPLY，而在写完后回调的session->handle传入的state为CS_STATE_SUCCESS。**\n\n- 所以在解析完客户端请求后所调用的handle会进入第一个if分支，从代码当中可以看到，它先是将WFServerTask::state数据成员设置成了WFT_STATE_TOREPLY，这为发送完回复再次回到handle进入第二个if分支做准备。然后最关键的是`new Series(this);`这行代码，如果你第一次看workflow的源码这样的写法一定会让你蒙。**什么鬼？new的成员没用什么变量去接？这不典型内存泄漏了吗？**，但是深入研究下去，这样写好像也没问题。结合上面Series的定义，所以最终new的Series串行队列当中第一个任务是WFServerTask::processor，第二个任务是WFServerTask本身。继续分析第一个if分支的代码，接下来调用了`this->processor.dispatch();`函数这也是整个业务代码的起始点。深入分析Processor::dispatch实现可知，它首先调用process回调，我可以直接告诉你此回调正是我们在示例当中创建server时传进来的process函数。在调用process处理完业务代码，然后调用了`this->subtask_done();`函数，根据前面提到的**关键点一**，我们可以知道这将返回串行队列的第二个任务即WFServerTask。我想这里一定会有读者有疑惑，怎么就返回第二个任务了？不是应该返回第一个任务吗？如果你有这样的疑惑，我建议你仔细阅读一下SeriesWork这部分的源码，所谓的两个任务实际上首个任务是不会入队列的，需要人手动触发，而在WFServerTask<REQ, RESP>::handle当中其实已经手动触发了一号任务————Processor，所以第一次调用subtask_done实际上返回的是第二个任务。好了回到正题，进入二号任务的dispatch（`WFServerTask::dispatch`），因为我们在前面已经将WFServerTask::state设置成了WFT_STATE_TOREPLY所以，进入if分支，这里应该开个香槟了，因为这里调用了`this->scheduler->reply`，这意味着服务端向客户端发送回复了！！！正常情况下会返回大于零的值，然后直接返回。这里罗列一下调用和返回流程：\n\n\t首先是调用流程：\n\n\t```\n\tWFServerTask<REQ, RESP>::handle ->\n\tProcessor::dispatch -> \n\tProcessor::subtask_done -> \n\tWFServerTask::dispatch\n\t```\n\n\t然后是返回流程：\n\t\n\t```\n\t从第二个任务的WFServerTask的：dispatch函数当中 返回到 -> \n\t第一个任务Processor的基类函数：subtask_done -> \n\t返回到第一个任务Processor的dispatch函数 -> \n\t返回到WFServerTask<REQ, RESP>::handle函数。\n\t```\n\n\t我这里想表达的是：**WFServerTask<REQ, RESP>::handle第一个if分支的一次dispatch实际上嵌套执行了两个任务。**，注意是**嵌套**，这点很重要！\n\n- 然后在写完回复后，会再次回到WFServerTask<REQ, RESP>::handle，此时会进入第二个if分支，并且根据**关键点一**，**因为此时第一个if分支new的串行队列已经为空，所以WFServerTask::subtask_done操作会将第一个if分支new的串行队列给释放掉，同时因为Series的释放，它的析构函数又会将WFServerTask给释放掉！**\n\n下面贴出WFServerTask关键的代码：\n\n```cpp\ntemplate<class REQ, class RESP>\nclass WFServerTask : public WFNetworkTask<REQ, RESP> {\nprotected:\n\tvirtual CommMessageOut *message_out() { return &this->resp; }\n\tvirtual CommMessageIn *message_in() { return &this->req; }\n\tvirtual void handle(int state, int error);\n\nprotected:\n\tvirtual void dispatch() {\n\t\tif (this->state == WFT_STATE_TOREPLY) {\n\t\t\t/* Enable get_connection() again if the reply() call is success. */\n\t\t\tthis->processor.task = this;\n\t\t\tif (this->scheduler->reply(this) >= 0)\t// 发生回复\n\t\t\t\treturn;\n\n\t\t\tthis->state = WFT_STATE_SYS_ERROR;\n\t\t\tthis->error = errno;\n\t\t\tthis->processor.task = NULL;\n\t\t}\n\t\telse\n\t\t\tthis->scheduler->shutdown(this);\n\n\t\tthis->subtask_done();\n\t}\n\n\tvirtual SubTask *done() {\n\t\tSeriesWork *series = series_of(this);\n\n\t\tif (this->callback)\n\t\t\tthis->callback(this);\n\n\t\t/* Defer deleting the task. */\n\t\treturn series->pop();\n\t}\n\npublic:\n\tWFServerTask(CommService *service, CommScheduler *scheduler,\n\t\t\t\t std::function<void (WFNetworkTask<REQ, RESP> *)>& proc) :\n\t\tWFNetworkTask<REQ, RESP>(NULL, scheduler, nullptr),\n\t\tprocessor(this, proc)\n\t{ }\n};\n```\n\n好了基本的HTTPServer端处理客户端请求的流程已经梳理完毕，最后贴出我在看源码的过程当中，所梳理流程笔记，可以给读者提供一些思路。同时也作为我个人的备忘笔记：\n\n```\n# Workflow服务端处理连接流程分析\n\nserver:\n\n    entry: \n        accept_conn: CONN_STATE_CONNECTED -> \n            create_request: CONN_STATE_RECEIVING ->                             // tag1\n                append_message: 当http请求接受完毕时：CONN_STATE_SUCCESS ->\n                    handle_incoming_request: \n                        ==>     CONN_STATE_IDLE && entry被追加到target->idle_list上;\n                        ==>    session->passive = 2;\n                        ==>    state = CS_STATE_TOREPLY\n\n    |   |   |\n    V   V   V\n    WFHttpServerTask::handle ->\n        WFServerTask<REQ, RESP>::handle ->\n            ```cpp\n                template<class REQ, class RESP>\n                void WFServerTask<REQ, RESP>::handle(int state, int error)\n                {\n                    if (state == WFT_STATE_TOREPLY)         // √\n                    {\n                        this->state = WFT_STATE_TOREPLY;\n                        this->target = this->get_target();\n                        new Series(this);\n                        this->processor.dispatch();\n                    }\n                    else if (this->state == WFT_STATE_TOREPLY)\n                    {\n                        this->state = state;\n                        this->error = error;\n                        if (error == ETIMEDOUT)\n                            this->timeout_reason = TOR_TRANSMIT_TIMEOUT;\n\n                        this->subtask_done();\n                    }\n                    else\n                        delete this;\n                }\n            ```\n\n        WFServerTask<REQ, RESP>::dispatch ->\n            this->scheduler->reply(this) -> 以写方式将entry添加到epoll上\n                session->passive = 3;\n\n    |   |   |       \n    V   V   V\n    handle_reply_result ->\n        ===> entry->state = CONN_STATE_KEEPALIVE && entry 被追加到service->alive_list && 以读方式将entry添加到epoll上（如果保活的话）\n        ===> state = CS_STATE_SUCCESS\n\n    |   |   |\n    V   V   V\n    WFHttpServerTask::handle ->\n        WFServerTask<REQ, RESP>::handle ->\n            ```cpp\n                template<class REQ, class RESP>\n                void WFServerTask<REQ, RESP>::handle(int state, int error)\n                {\n                    if (state == WFT_STATE_TOREPLY)\n                    {\n                        this->state = WFT_STATE_TOREPLY;\n                        this->target = this->get_target();\n                        new Series(this);\n                        this->processor.dispatch();\n                    }\n                    else if (this->state == WFT_STATE_TOREPLY)  // √\n                    {\n                        this->state = state;\n                        this->error = error;\n                        if (error == ETIMEDOUT)\n                            this->timeout_reason = TOR_TRANSMIT_TIMEOUT;\n\n                        this->subtask_done();       // will delete Series for first 'if' branch malloc\n                    }\n                    else\n                        delete this;\n                }\n            ```\n\n    |   |   |\n    V   V   V\n    go to tag1.\n```\n\n---\n\n**本章完结**","slug":"workflow/TCPServer_3","published":1,"updated":"2025-09-28T14:34:33.264Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9t000wq8ws64du4jnn","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>系列链接如下：</p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlow源码剖析——GO-Task 源码分析</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlow源码剖析——Communicator之TCPServer（上）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlow源码剖析——Communicator之TCPServer（中）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlow源码剖析——Communicator之TCPServer（下）</a></p>\n<p>终于来到TCPServer最后一部分，前面两篇博客已经深入分析了WorkFlow底层poller和Communicator的实现细节，本篇博客将会从整体视角，整合前面所讲的poller以及Communicator形成最终的TCPServer。</p>\n<p>同样放上workflow开源项目的Github地址：<a href=\"https://github.com/sogou/workflow\">https://github.com/sogou/workflow</a></p>\n<p>和GO-Task的实现类似，尤其需要注意对基类SubTask、CommSession虚函数的重写。如果你看过GO-Task的实现，本文最终所讲的TCPServer任务其实差不多。因为TCPServer的继承树和GO-Task的继承树不能说相似，只能说一模一样。对称性对框架的设计真的很重要，我认为对称思想（也可以说成抽象思想）是优雅的象征。并且对称性可以帮我们减少出BUG的风险。如果你刷过的LeetCode，你一定会发现，在解答那些对边界条件要求很高的题目时，如果你能给各种情况抽象出一套统一的逻辑说词，大概率就不会wa。</p>\n<span id=\"more\"></span>\n\n<p>重申一下，本系列暂时集中分析workflow的TCPServer端的架构。对于客户端，后面有时间了会另起一个系列进行讲解。像CommSchedGroup、CommSchedTarget、CommSchedObject等属于客户端独有功能。CommSchedGroup主要功能是对客户端的连接按负载（引用数量）进行一个堆排序管理。读者可先忽略掉这些内容。并且因为有些类的设计是同时兼顾客户端和服务端的（如：CommRequest、等），这点在阅读源码的时候需要有自己的判断能力。不要被绕进去了！</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>我们就顺从<a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlow GO-Task 源码分析</a>的方式，以workflow给的http_echo_server的示例作为本文的切入点：</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>go-task的用法示例如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/HttpMessage.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/HttpUtil.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFServer.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFHttpServer.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFFacilities.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process</span><span class=\"params\">(WFHttpTask *server_task)</span> </span>&#123;</span><br><span class=\"line\">\tprotocol::HttpRequest *req = server_task-&gt;<span class=\"built_in\">get_req</span>();</span><br><span class=\"line\">\tprotocol::HttpResponse *resp = server_task-&gt;<span class=\"built_in\">get_resp</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 根据http请求进行一些业务处理，然后构造出回复报文。 */</span></span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">short</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;USAGE: %s &lt;port&gt;\\n&quot;</span>, argv[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">signal</span>(SIGINT, sig_handler);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">WFHttpServer <span class=\"title\">server</span><span class=\"params\">(process)</span></span>;</span><br><span class=\"line\">\tport = <span class=\"built_in\">atoi</span>(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (server.<span class=\"built_in\">start</span>(port) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\twait_group.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">\t\tserver.<span class=\"built_in\">stop</span>();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">perror</span>(<span class=\"string\">&quot;Cannot start server&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从workflow的httpserver的使用demo当中可以了解到，核心框架有三步：</p>\n<ol>\n<li><p>将http处理回调函数作为参数，构造一个server对象。</p>\n</li>\n<li><p>调用start接口，启动server。</p>\n</li>\n<li><p>wait_group.wait()阻塞，等待服务的结束。</p>\n</li>\n</ol>\n<p>看到这三步流程，我们其实应该是一脸蒙的，根本无法猜到它底层是如何起服务的；当连接来到时又是如何回调上面的处理函数的。别着急我们先结合前面两篇博客，尽力而为的猜：</p>\n<ol>\n<li><p>看到了process回调函数当中开头定义的两个<strong>指针变量</strong>req和resp都是来自server_task。结合tcp服务端在读取来自客户端的请求报文并解析前会调用Communicator::create_request函数创建一个in对象作为报文解析器，而in又是由session创建，<strong>而在服务端session又是由CommService创建</strong>。同时Communicator::reply接口是以session作为参数，最终tcpserver在发送回复时会取出session当中的out并发送给客户端，很明显的是：out显然是服务端对客户端请求的回复报文。所以种种迹象都表明server_task当中req、resp和session的in和out有着紧密联系。</p>\n</li>\n<li><p>server.start接口一定会调用创建socket，绑定socket、监听sokcet。而这些流程在Communicator当中有提供接口，对应：Communicator::bind。Communicator::bind函数只有一个唯一的参数：CommService，但综合CommService头文件的定义来看，因为它里面有一个纯虚函数：new_session，显然CommService是一个虚基类，这意味着它无法实例化对象。所以一定有继承CommService的子类。</p>\n</li>\n</ol>\n<p>综上，1、2两点都指向了一个关键词————CommService。</p>\n<h3 id=\"探究WFHttpServer\"><a href=\"#探究WFHttpServer\" class=\"headerlink\" title=\"探究WFHttpServer\"></a>探究WFHttpServer</h3><p>根据上小节得到的线索，我们深入跟到WFHttpServer当中去，它的继承树如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; WFHttpServer == WFServer&lt;protocol::HttpRequest, protocol::HttpResponse&gt; &#125; -&gt; WFServerBase -&gt; CommService</span><br></pre></td></tr></table></figure>\n\n<p>所以，WFHttpServer实际上是<strong>模板类WFServer</strong>的一个<strong>成员函数全特化</strong>实现。下面集中分析一下WFServer和WFServerBase：</p>\n<p>首先是WFServer模板类：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFServer</span> : <span class=\"keyword\">public</span> WFServerBase &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFServer</span>(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> WFServerParams *params,</span><br><span class=\"line\">\t\t\t std::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFServerBase</span>(params),</span><br><span class=\"line\">\t\t<span class=\"built_in\">process</span>(std::<span class=\"built_in\">move</span>(proc)) &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">WFServer</span>(std::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFServerBase</span>(&amp;SERVER_PARAMS_DEFAULT),</span><br><span class=\"line\">\t\t<span class=\"built_in\">process</span>(std::<span class=\"built_in\">move</span>(proc)) &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommSession *<span class=\"title\">new_session</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> seq, CommConnection *conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt; process;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\">CommSession *WFServer&lt;REQ, RESP&gt;::<span class=\"built_in\">new_session</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> seq, CommConnection *conn) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">using</span> factory = WFNetworkTaskFactory&lt;REQ, RESP&gt;;</span><br><span class=\"line\">\tWFNetworkTask&lt;REQ, RESP&gt; *task;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttask = factory::<span class=\"built_in\">create_server_task</span>(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>-&gt;process);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_keep_alive</span>(<span class=\"keyword\">this</span>-&gt;params.keep_alive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_receive_timeout</span>(<span class=\"keyword\">this</span>-&gt;params.receive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">get_req</span>()-&gt;<span class=\"built_in\">set_size_limit</span>(<span class=\"keyword\">this</span>-&gt;params.request_size_limit);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（PS，代码量很少，读者表示狂喜。）</p>\n<p>如代码所写的那样，WFServer就是继承了一下WFServerBase，并重写了new_session函数。究其根本这里的new_session实际上重写的是CommService当中所定义的纯虚函数。如果你认为应该仔细去阅读这里重写的虚函数，那你就错了，实际上WFHttpServer<strong>又将new_session函数进行全特化实现</strong>。所以WFServer的new_session看看就好。无需深入理解。</p>\n<p>WFServer重点就是将示例在创建server时传入的process回调，保存到了成员变量当中，<strong>以供new_session时将任务回调传给Task</strong>。下面重点研究一下WFServerBase。</p>\n<p>从上面的分析了解到WFServerBase继承自CommService。WFServerBase实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFServerBase</span> : <span class=\"keyword\">protected</span> CommService &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFServerBase</span>(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> WFServerParams *params) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">conn_count</span>(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;params = *params;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;unbind_finish = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;listen_fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">/* To start a TCP server */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* Start with binding address. The only necessary start function. */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* stop() is a blocking operation. */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">shutdown</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">wait_finish</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Nonblocking terminating the server. For stopping multiple servers.</span></span><br><span class=\"line\"><span class=\"comment\">\t * Typically, call shutdown() and then wait_finish().</span></span><br><span class=\"line\"><span class=\"comment\">\t * But indeed wait_finish() can be called before shutdown(), even before</span></span><br><span class=\"line\"><span class=\"comment\">\t * start() in another thread. */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wait_finish</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">get_conn_count</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;conn_count; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tWFServerParams params;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">create_listen_fd</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> WFConnection *<span class=\"title\">new_connection</span><span class=\"params\">(<span class=\"type\">int</span> accept_fd)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_connection</span><span class=\"params\">(WFConnection *conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle_unbound</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::atomic&lt;<span class=\"type\">size_t</span>&gt; conn_count;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> listen_fd;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> unbind_finish;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::mutex mutex;</span><br><span class=\"line\">\tstd::condition_variable cond;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">CommScheduler</span> *scheduler;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>首先，我们看到WFServerBase当中有一个类型为CommScheduler的成员变量scheduler。我们应该感到惊喜，因为CommScheduler不就是对Communicator做了一层浅浅的封装吗？这里出现的scheduler不就意味着WFServerBase和Communicator联系起来了吗？那server的启动必定是调用了Communicator::bind接口来创建、绑定、监听listen socket。下面重点研究一下start函数的函数的实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">WFServerBase::start</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">init</span>(bind_addr, addrlen) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;scheduler-&gt;<span class=\"built_in\">bind</span>(<span class=\"keyword\">this</span>) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">deinit</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;listen_fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>init函数伪代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">WFServerBase::init</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;CommService::<span class=\"built_in\">init</span>(bind_addr, addrlen, <span class=\"number\">-1</span>, timeout) &lt; <span class=\"number\">0</span>)\t<span class=\"comment\">// 调用基类CommService的初始化函数，就是将listen fd所绑定的地址拷贝一份到基类。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;scheduler = WFGlobal::<span class=\"built_in\">get_scheduler</span>();\t\t\t\t\t\t<span class=\"comment\">// 全局的单例CommScheduler对象。</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要干了两件事：调用基类的init，将绑定的地址拷贝一份到基类的成员变量当中。然后通过__CommManager获取全局的单例CommScheduler对象。</p>\n<p>特别的是，<strong>这里有个重要的时间点</strong>，在__CommManager被构造时，会<strong>初始化CommScheduler对象</strong>，如果你看过上一篇博客，你一定知道为什么这个时刻重要。因为CommScheduler::init函数会<strong>启动workflow底层的事件池和状态迁移池</strong>。具体的架构模型图可以参考：<a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlow源码剖析——Communicator之TCPServer（中）</a>。</p>\n<p>在WFServerBase::start实现中，调用init函数过后，立马调用CommScheduler::bind（实际上就是Communicator::bind），该函数里面会做网络编程三部曲：创建、绑定、监听。至此我们的TCPServer服务器就在这里启动，等待客户端的连接。</p>\n<p>关于WFServerBase其实还有两个有趣的知识点：new_connection 和 服务停止。</p>\n<ul>\n<li><p>new_connection：该函数和WFServerBase::conn_count强相关。new_connection所创建的对象共用WFServerBase::conn_count。每当有客户端连接到来，都会创建一个CommConnection对象，同时会使WFServerBase::conn_count自增一。每当连接断开，Communicator当中就会调用__release_conn释放连接上下文，并且CommConnection对象也随之释放，其构造函数当中，会将WFServerBase::conn_count变量自减一。所以说，每次在连接到来创建的CommConnection对象可以视为连接计数器。（PS，因为目前只了解workflow的部分源码，所以连接计数器存在的具体意义，我目前还未能领悟。后面有时间的话，再去深究吧。）</p>\n</li>\n<li><p>服务停止：如代码注释那样，WFServerBase所提供的stop接口是阻塞的，它其实连续调用了两个函数：shutdown、wait_finish。其中shutdown会调用Communicator::unbind函数，它会直接将listen fd从mpoller当中删除。当调用shutdown函数时，整体<strong>停止的链路是这样的</strong>：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WFServerBase::shutdown -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">CommScheduler::unbind -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">Communicator::unbind -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">mpoller_del(listen_fd) - - -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">Communicator::handle_listen_result -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">Communicator::shutdown_service -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">while (直到CommService的ref减为0) &#123; CommService::decref() &#125; -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">WFServerBase::handle_unbound</span><br></pre></td></tr></table></figure>\n\n<p>Communicator::shutdown_service代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::shutdown_service</span><span class=\"params\">(CommService *service)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(service-&gt;listen_fd);</span><br><span class=\"line\">\tservice-&gt;listen_fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tservice-&gt;<span class=\"built_in\">drain</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tservice-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的service-&gt;drain(-1)会将server端目前所有的连接都从mpoller当中移除。然后等待所有连接上下文回调CommServiceTarget::decref将server对象的引用计数减为0后，调用WFServerBase::handle_unbound函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">CommService::decref</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__sync_sub_and_fetch(&amp;<span class=\"keyword\">this</span>-&gt;ref, <span class=\"number\">1</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">handle_unbound</span>();\t\t\t\t\t\t<span class=\"comment\">// 最终被重写成：WFServerBase::handle_unbound</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>WFServerBase::stop的注释说明了该函数是阻塞的，其阻塞主要原因就在wait_finish，它会等待所有的连接被释放然后释放WFServerBase的引用计数后才会跳出等待条件变量的循环。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WFServerBase::handle_unbound</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;mutex.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;unbind_finish = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;cond.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;mutex.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WFServerBase::wait_finish</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(<span class=\"keyword\">this</span>-&gt;mutex)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>-&gt;unbind_finish)</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;cond.<span class=\"built_in\">wait</span>(lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">deinit</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;unbind_finish = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tlock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"探究WFHttpServerTask\"><a href=\"#探究WFHttpServerTask\" class=\"headerlink\" title=\"探究WFHttpServerTask\"></a>探究WFHttpServerTask</h3><p>好了，tcpserver的启动流程基本流程已经分析完毕，下面我们重点看看WFHttpServer::new_session的实现。该函数在每轮读取客户端请求时会被调用一次。返回值是类型为CommSession的对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt; <span class=\"function\"><span class=\"keyword\">inline</span></span></span><br><span class=\"line\"><span class=\"function\">CommSession *<span class=\"title\">WFHttpServer::new_session</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> seq, CommConnection *conn)</span> </span>&#123;</span><br><span class=\"line\">\tWFHttpTask *task;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttask = WFServerTaskFactory::<span class=\"built_in\">create_http_task</span>(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>-&gt;process);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_keep_alive</span>(<span class=\"keyword\">this</span>-&gt;params.keep_alive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_receive_timeout</span>(<span class=\"keyword\">this</span>-&gt;params.receive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">get_req</span>()-&gt;<span class=\"built_in\">set_size_limit</span>(<span class=\"keyword\">this</span>-&gt;params.request_size_limit);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到出现了一个新的类——WFHttpTask，我可以明确告诉你，WFHttpTask只是一个基类，我们应该从final类开始深入分析。</p>\n<p>对于WFHttpTask，它的定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> WFHttpTask = WFNetworkTask&lt;protocol::HttpRequest,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t protocol::HttpResponse&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>那么WFNetworkTask是啥呢？先别急，后面再来揭晓它的源码。通过WFServerTaskFactory::create_http_task我们可以找到我们所需要的final类——WFHttpServerTask它的定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFHttpServerTask</span> : <span class=\"keyword\">public</span> WFServerTask&lt;protocol::HttpRequest,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t protocol::HttpResponse&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">using</span> TASK = WFNetworkTask&lt;protocol::HttpRequest, protocol::HttpResponse&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFHttpServerTask</span>(CommService *service, std::function&lt;<span class=\"built_in\">void</span> (TASK *)&gt;&amp; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFServerTask</span>(service, WFGlobal::<span class=\"built_in\">get_scheduler</span>(), proc),</span><br><span class=\"line\">\t\t<span class=\"built_in\">req_is_alive_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">\t\t<span class=\"built_in\">req_has_keep_alive_header_</span>(<span class=\"literal\">false</span>) &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommMessageOut *<span class=\"title\">message_out</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">bool</span> req_is_alive_;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> req_has_keep_alive_header_;</span><br><span class=\"line\">\tstd::string req_keep_alive_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>从构造函数当可以看到，再一次对全局单例的CommScheduler的引用。类的成员函数包括hanlde、message_out最终实现，我们重点关注handle的实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WFHttpServerTask::handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* 设置fianl类的成员变量... */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;WFServerTask::<span class=\"built_in\">handle</span>(state, error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在服务端收完并解析完客户端发来的请求报文之后（在Communicator::handle_incoming_request函数当中）会进入该函数，从WFT_STATE_TOREPLY宏的命名也可以推测到，它代表准备回复的状态。在做完final类一些设置后，最终会调用父类的handle，所以下面深入看看WFServerTask模板类的实现。</p>\n<p><strong>tcpserver任务部分最烧脑的就在WFServerTask模板类的实现</strong>，对于WFNetworkTask模板类，它本身的成员函数对我们理解tcpserver本身来说并不重要。但需要注意的是WFNetworkTask继承自CommRequest。</p>\n<p>简单用字符画了一下WFHttpServerTask的继承树。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SubTask\t\tCommSession</span><br><span class=\"line\">\t\t\\/</span><br><span class=\"line\">\tCommRequest</span><br><span class=\"line\">\t\t|</span><br><span class=\"line\">\t\tV</span><br><span class=\"line\">WFNetworkTask&lt;REQ, RESP&gt;\t# 该类的实现在对我们理解tcpserver不是特别重要，读者可以跳过该类。</span><br><span class=\"line\">\t\t|</span><br><span class=\"line\">\t\tV</span><br><span class=\"line\">WFServerTask&lt;REQ, RESP&gt;</span><br><span class=\"line\">\t\t|</span><br><span class=\"line\">\t\tV</span><br><span class=\"line\">WFHttpServerTask</span><br></pre></td></tr></table></figure>\n\n<p>在正式讲解WFServerTask前，<strong>先学习几个关键知识点：</strong></p>\n<p>首先回顾一下，SubTask::subtask_done函数实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SubTask::subtask_done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tSubTask *cur = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcur = cur-&gt;<span class=\"built_in\">done</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cur) &#123;</span><br><span class=\"line\">\t\tcur-&gt;<span class=\"built_in\">dispatch</span>();\t\t<span class=\"comment\">// 下一个任务的dispatch</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更简单点描述，调done后调dispatch触发任务队列的下一个任务。<strong>（关键点一：）其中done函数实现最后都会调用<code>series_of(this)-&gt;pop()</code>，这行代码是获取SeriesWork串行队列的下一个任务，当队列中（没有任何任务了）山穷水尽了会返回nullptr，并且SeriesWork会delete this（SeriesWork对象本身）。</strong></p>\n<p>然后了解一下两个WFServerTask当中的内嵌类的定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Processor</span> : <span class=\"keyword\">public</span> SubTask &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Processor</span>(WFServerTask&lt;REQ, RESP&gt; *task,</span><br><span class=\"line\">\t\t\t\tstd::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt;&amp; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">process</span>(proc) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;task = task;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">process</span>(<span class=\"keyword\">this</span>-&gt;task);\t\t<span class=\"comment\">// 调用</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;task = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">/* As a flag. get_conneciton() disabled. */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> SubTask *<span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>)-&gt;<span class=\"built_in\">pop</span>();\t<span class=\"comment\">// 获取串行队列下一个任务</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt;&amp; process;</span><br><span class=\"line\">\tWFServerTask&lt;REQ, RESP&gt; *task;</span><br><span class=\"line\">&#125; processor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Series</span> : <span class=\"keyword\">public</span> SeriesWork &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Series</span>(WFServerTask&lt;REQ, RESP&gt; *task) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">SeriesWork</span>(&amp;task-&gt;processor, <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">set_last_task</span>(task);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;task = task;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Series</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>-&gt;task;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tWFServerTask&lt;REQ, RESP&gt; *task;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Processor::dispatch函数首先调用了一下构造传进来的回调函数process，然后调用subtask_done，结合上面的分析，它会调用串行队列当中的下一个任务的dispatch函数。</p>\n</li>\n<li><p>对于Series，只有析构和构造函数，从构造函数当中可以看出来，它本质上就是 <strong>（关键点二）只有两个任务的串行队列。并且在该串行队列被delete时，顺带会在析构函数当中delete掉二号任务。</strong>此外，<strong>（关键点三）在每个任务被加到串行队列当中时，会将任务的SubTask::pointer指针指向串行队列对象。</strong></p>\n</li>\n</ul>\n<p>好了，下面从WFServerTask&lt;REQ, RESP&gt;::handle函数开始分析其中的奥妙。源代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> WFServerTask&lt;REQ, RESP&gt;::<span class=\"built_in\">handle</span>(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;state = WFT_STATE_TOREPLY;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;target = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">get_target</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> <span class=\"built_in\">Series</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;processor.<span class=\"built_in\">dispatch</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;state = state;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;error = error;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (error == ETIMEDOUT)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;timeout_reason = TOR_TRANSMIT_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为WFServerTask顶层的基类包括：SubTask + <strong>CommSession</strong>，对这里着重强调CommSession，因为CommSession当中的handle最终被重写成如上所示的代码。服务端在每次读完（并解析完）客户端发来的数据后，状态迁移池都会回调Communicator::handle_incoming_request函数，在每次写完客户端请求的回复后，状态迁移池都会回调Communicator::handle_reply_result函数。这两函数当最后都会调用session-&gt;handle，所不同的是每次传入的state参数有所不同。<strong>正常情况下，在读完后回调session-&gt;handle传入的state为CS_STATE_TOREPLY，而在写完后回调的session-&gt;handle传入的state为CS_STATE_SUCCESS。</strong></p>\n<ul>\n<li><p>所以在解析完客户端请求后所调用的handle会进入第一个if分支，从代码当中可以看到，它先是将WFServerTask::state数据成员设置成了WFT_STATE_TOREPLY，这为发送完回复再次回到handle进入第二个if分支做准备。然后最关键的是<code>new Series(this);</code>这行代码，如果你第一次看workflow的源码这样的写法一定会让你蒙。<strong>什么鬼？new的成员没用什么变量去接？这不典型内存泄漏了吗？</strong>，但是深入研究下去，这样写好像也没问题。结合上面Series的定义，所以最终new的Series串行队列当中第一个任务是WFServerTask::processor，第二个任务是WFServerTask本身。继续分析第一个if分支的代码，接下来调用了<code>this-&gt;processor.dispatch();</code>函数这也是整个业务代码的起始点。深入分析Processor::dispatch实现可知，它首先调用process回调，我可以直接告诉你此回调正是我们在示例当中创建server时传进来的process函数。在调用process处理完业务代码，然后调用了<code>this-&gt;subtask_done();</code>函数，根据前面提到的<strong>关键点一</strong>，我们可以知道这将返回串行队列的第二个任务即WFServerTask。我想这里一定会有读者有疑惑，怎么就返回第二个任务了？不是应该返回第一个任务吗？如果你有这样的疑惑，我建议你仔细阅读一下SeriesWork这部分的源码，所谓的两个任务实际上首个任务是不会入队列的，需要人手动触发，而在WFServerTask&lt;REQ, RESP&gt;::handle当中其实已经手动触发了一号任务————Processor，所以第一次调用subtask_done实际上返回的是第二个任务。好了回到正题，进入二号任务的dispatch（<code>WFServerTask::dispatch</code>），因为我们在前面已经将WFServerTask::state设置成了WFT_STATE_TOREPLY所以，进入if分支，这里应该开个香槟了，因为这里调用了<code>this-&gt;scheduler-&gt;reply</code>，这意味着服务端向客户端发送回复了！！！正常情况下会返回大于零的值，然后直接返回。这里罗列一下调用和返回流程：</p>\n<p>  首先是调用流程：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WFServerTask&lt;REQ, RESP&gt;::handle -&gt;</span><br><span class=\"line\">Processor::dispatch -&gt; </span><br><span class=\"line\">Processor::subtask_done -&gt; </span><br><span class=\"line\">WFServerTask::dispatch</span><br></pre></td></tr></table></figure>\n\n<p>  然后是返回流程：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从第二个任务的WFServerTask的：dispatch函数当中 返回到 -&gt; </span><br><span class=\"line\">第一个任务Processor的基类函数：subtask_done -&gt; </span><br><span class=\"line\">返回到第一个任务Processor的dispatch函数 -&gt; </span><br><span class=\"line\">返回到WFServerTask&lt;REQ, RESP&gt;::handle函数。</span><br></pre></td></tr></table></figure>\n\n<p>  我这里想表达的是：<strong>WFServerTask&lt;REQ, RESP&gt;::handle第一个if分支的一次dispatch实际上嵌套执行了两个任务。</strong>，注意是<strong>嵌套</strong>，这点很重要！</p>\n</li>\n<li><p>然后在写完回复后，会再次回到WFServerTask&lt;REQ, RESP&gt;::handle，此时会进入第二个if分支，并且根据<strong>关键点一</strong>，<strong>因为此时第一个if分支new的串行队列已经为空，所以WFServerTask::subtask_done操作会将第一个if分支new的串行队列给释放掉，同时因为Series的释放，它的析构函数又会将WFServerTask给释放掉！</strong></p>\n</li>\n</ul>\n<p>下面贴出WFServerTask关键的代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFServerTask</span> : <span class=\"keyword\">public</span> WFNetworkTask&lt;REQ, RESP&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommMessageOut *<span class=\"title\">message_out</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> &amp;<span class=\"keyword\">this</span>-&gt;resp; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommMessageIn *<span class=\"title\">message_in</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> &amp;<span class=\"keyword\">this</span>-&gt;req; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* Enable get_connection() again if the reply() call is success. */</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;processor.task = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;scheduler-&gt;<span class=\"built_in\">reply</span>(<span class=\"keyword\">this</span>) &gt;= <span class=\"number\">0</span>)\t<span class=\"comment\">// 发生回复</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;state = WFT_STATE_SYS_ERROR;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;error = errno;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;processor.task = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;scheduler-&gt;<span class=\"built_in\">shutdown</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> SubTask *<span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSeriesWork *series = <span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;callback)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">callback</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* Defer deleting the task. */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> series-&gt;<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFServerTask</span>(CommService *service, CommScheduler *scheduler,</span><br><span class=\"line\">\t\t\t\t std::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt;&amp; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFNetworkTask</span>&lt;REQ, RESP&gt;(<span class=\"literal\">NULL</span>, scheduler, <span class=\"literal\">nullptr</span>),</span><br><span class=\"line\">\t\t<span class=\"built_in\">processor</span>(<span class=\"keyword\">this</span>, proc)</span><br><span class=\"line\">\t&#123; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>好了基本的HTTPServer端处理客户端请求的流程已经梳理完毕，最后贴出我在看源码的过程当中，所梳理流程笔记，可以给读者提供一些思路。同时也作为我个人的备忘笔记：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Workflow服务端处理连接流程分析</span><br><span class=\"line\"></span><br><span class=\"line\">server:</span><br><span class=\"line\"></span><br><span class=\"line\">    entry: </span><br><span class=\"line\">        accept_conn: CONN_STATE_CONNECTED -&gt; </span><br><span class=\"line\">            create_request: CONN_STATE_RECEIVING -&gt;                             // tag1</span><br><span class=\"line\">                append_message: 当http请求接受完毕时：CONN_STATE_SUCCESS -&gt;</span><br><span class=\"line\">                    handle_incoming_request: </span><br><span class=\"line\">                        ==&gt;     CONN_STATE_IDLE &amp;&amp; entry被追加到target-&gt;idle_list上;</span><br><span class=\"line\">                        ==&gt;    session-&gt;passive = 2;</span><br><span class=\"line\">                        ==&gt;    state = CS_STATE_TOREPLY</span><br><span class=\"line\"></span><br><span class=\"line\">    |   |   |</span><br><span class=\"line\">    V   V   V</span><br><span class=\"line\">    WFHttpServerTask::handle -&gt;</span><br><span class=\"line\">        WFServerTask&lt;REQ, RESP&gt;::handle -&gt;</span><br><span class=\"line\">            ```cpp</span><br><span class=\"line\">                template&lt;class REQ, class RESP&gt;</span><br><span class=\"line\">                void WFServerTask&lt;REQ, RESP&gt;::handle(int state, int error)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    if (state == WFT_STATE_TOREPLY)         // √</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        this-&gt;state = WFT_STATE_TOREPLY;</span><br><span class=\"line\">                        this-&gt;target = this-&gt;get_target();</span><br><span class=\"line\">                        new Series(this);</span><br><span class=\"line\">                        this-&gt;processor.dispatch();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else if (this-&gt;state == WFT_STATE_TOREPLY)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        this-&gt;state = state;</span><br><span class=\"line\">                        this-&gt;error = error;</span><br><span class=\"line\">                        if (error == ETIMEDOUT)</span><br><span class=\"line\">                            this-&gt;timeout_reason = TOR_TRANSMIT_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">                        this-&gt;subtask_done();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else</span><br><span class=\"line\">                        delete this;</span><br><span class=\"line\">                &#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    WFServerTask&lt;REQ, RESP&gt;::dispatch -&gt;\n        this-&gt;scheduler-&gt;reply(this) -&gt; 以写方式将entry添加到epoll上\n            session-&gt;passive = 3;\n\n|   |   |       \nV   V   V\nhandle_reply_result -&gt;\n    ===&gt; entry-&gt;state = CONN_STATE_KEEPALIVE &amp;&amp; entry 被追加到service-&gt;alive_list &amp;&amp; 以读方式将entry添加到epoll上（如果保活的话）\n    ===&gt; state = CS_STATE_SUCCESS\n\n|   |   |\nV   V   V\nWFHttpServerTask::handle -&gt;\n    WFServerTask&lt;REQ, RESP&gt;::handle -&gt;\n        <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> WFServerTask&lt;REQ, RESP&gt;::<span class=\"built_in\">handle</span>(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state == WFT_STATE_TOREPLY)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;state = WFT_STATE_TOREPLY;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;target = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">get_target</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"built_in\">Series</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;processor.<span class=\"built_in\">dispatch</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;state == WFT_STATE_TOREPLY)  <span class=\"comment\">// √</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;state = state;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;error = error;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error == ETIMEDOUT)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;timeout_reason = TOR_TRANSMIT_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();       <span class=\"comment\">// will delete Series for first &#x27;if&#x27; branch malloc</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n|   |   |\nV   V   V\ngo to tag1.\n</code></pre>\n<pre><code>\n---\n\n**本章完结**\n</code></pre>\n","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>系列链接如下：</p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlow源码剖析——GO-Task 源码分析</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlow源码剖析——Communicator之TCPServer（上）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlow源码剖析——Communicator之TCPServer（中）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlow源码剖析——Communicator之TCPServer（下）</a></p>\n<p>终于来到TCPServer最后一部分，前面两篇博客已经深入分析了WorkFlow底层poller和Communicator的实现细节，本篇博客将会从整体视角，整合前面所讲的poller以及Communicator形成最终的TCPServer。</p>\n<p>同样放上workflow开源项目的Github地址：<a href=\"https://github.com/sogou/workflow\">https://github.com/sogou/workflow</a></p>\n<p>和GO-Task的实现类似，尤其需要注意对基类SubTask、CommSession虚函数的重写。如果你看过GO-Task的实现，本文最终所讲的TCPServer任务其实差不多。因为TCPServer的继承树和GO-Task的继承树不能说相似，只能说一模一样。对称性对框架的设计真的很重要，我认为对称思想（也可以说成抽象思想）是优雅的象征。并且对称性可以帮我们减少出BUG的风险。如果你刷过的LeetCode，你一定会发现，在解答那些对边界条件要求很高的题目时，如果你能给各种情况抽象出一套统一的逻辑说词，大概率就不会wa。</p>","more":"<p>重申一下，本系列暂时集中分析workflow的TCPServer端的架构。对于客户端，后面有时间了会另起一个系列进行讲解。像CommSchedGroup、CommSchedTarget、CommSchedObject等属于客户端独有功能。CommSchedGroup主要功能是对客户端的连接按负载（引用数量）进行一个堆排序管理。读者可先忽略掉这些内容。并且因为有些类的设计是同时兼顾客户端和服务端的（如：CommRequest、等），这点在阅读源码的时候需要有自己的判断能力。不要被绕进去了！</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>我们就顺从<a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlow GO-Task 源码分析</a>的方式，以workflow给的http_echo_server的示例作为本文的切入点：</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>go-task的用法示例如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/HttpMessage.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/HttpUtil.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFServer.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFHttpServer.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFFacilities.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process</span><span class=\"params\">(WFHttpTask *server_task)</span> </span>&#123;</span><br><span class=\"line\">\tprotocol::HttpRequest *req = server_task-&gt;<span class=\"built_in\">get_req</span>();</span><br><span class=\"line\">\tprotocol::HttpResponse *resp = server_task-&gt;<span class=\"built_in\">get_resp</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 根据http请求进行一些业务处理，然后构造出回复报文。 */</span></span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">short</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;USAGE: %s &lt;port&gt;\\n&quot;</span>, argv[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">signal</span>(SIGINT, sig_handler);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">WFHttpServer <span class=\"title\">server</span><span class=\"params\">(process)</span></span>;</span><br><span class=\"line\">\tport = <span class=\"built_in\">atoi</span>(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (server.<span class=\"built_in\">start</span>(port) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\twait_group.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">\t\tserver.<span class=\"built_in\">stop</span>();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">perror</span>(<span class=\"string\">&quot;Cannot start server&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从workflow的httpserver的使用demo当中可以了解到，核心框架有三步：</p>\n<ol>\n<li><p>将http处理回调函数作为参数，构造一个server对象。</p>\n</li>\n<li><p>调用start接口，启动server。</p>\n</li>\n<li><p>wait_group.wait()阻塞，等待服务的结束。</p>\n</li>\n</ol>\n<p>看到这三步流程，我们其实应该是一脸蒙的，根本无法猜到它底层是如何起服务的；当连接来到时又是如何回调上面的处理函数的。别着急我们先结合前面两篇博客，尽力而为的猜：</p>\n<ol>\n<li><p>看到了process回调函数当中开头定义的两个<strong>指针变量</strong>req和resp都是来自server_task。结合tcp服务端在读取来自客户端的请求报文并解析前会调用Communicator::create_request函数创建一个in对象作为报文解析器，而in又是由session创建，<strong>而在服务端session又是由CommService创建</strong>。同时Communicator::reply接口是以session作为参数，最终tcpserver在发送回复时会取出session当中的out并发送给客户端，很明显的是：out显然是服务端对客户端请求的回复报文。所以种种迹象都表明server_task当中req、resp和session的in和out有着紧密联系。</p>\n</li>\n<li><p>server.start接口一定会调用创建socket，绑定socket、监听sokcet。而这些流程在Communicator当中有提供接口，对应：Communicator::bind。Communicator::bind函数只有一个唯一的参数：CommService，但综合CommService头文件的定义来看，因为它里面有一个纯虚函数：new_session，显然CommService是一个虚基类，这意味着它无法实例化对象。所以一定有继承CommService的子类。</p>\n</li>\n</ol>\n<p>综上，1、2两点都指向了一个关键词————CommService。</p>\n<h3 id=\"探究WFHttpServer\"><a href=\"#探究WFHttpServer\" class=\"headerlink\" title=\"探究WFHttpServer\"></a>探究WFHttpServer</h3><p>根据上小节得到的线索，我们深入跟到WFHttpServer当中去，它的继承树如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; WFHttpServer == WFServer&lt;protocol::HttpRequest, protocol::HttpResponse&gt; &#125; -&gt; WFServerBase -&gt; CommService</span><br></pre></td></tr></table></figure>\n\n<p>所以，WFHttpServer实际上是<strong>模板类WFServer</strong>的一个<strong>成员函数全特化</strong>实现。下面集中分析一下WFServer和WFServerBase：</p>\n<p>首先是WFServer模板类：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFServer</span> : <span class=\"keyword\">public</span> WFServerBase &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFServer</span>(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> WFServerParams *params,</span><br><span class=\"line\">\t\t\t std::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFServerBase</span>(params),</span><br><span class=\"line\">\t\t<span class=\"built_in\">process</span>(std::<span class=\"built_in\">move</span>(proc)) &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">WFServer</span>(std::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFServerBase</span>(&amp;SERVER_PARAMS_DEFAULT),</span><br><span class=\"line\">\t\t<span class=\"built_in\">process</span>(std::<span class=\"built_in\">move</span>(proc)) &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommSession *<span class=\"title\">new_session</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> seq, CommConnection *conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt; process;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\">CommSession *WFServer&lt;REQ, RESP&gt;::<span class=\"built_in\">new_session</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> seq, CommConnection *conn) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">using</span> factory = WFNetworkTaskFactory&lt;REQ, RESP&gt;;</span><br><span class=\"line\">\tWFNetworkTask&lt;REQ, RESP&gt; *task;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttask = factory::<span class=\"built_in\">create_server_task</span>(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>-&gt;process);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_keep_alive</span>(<span class=\"keyword\">this</span>-&gt;params.keep_alive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_receive_timeout</span>(<span class=\"keyword\">this</span>-&gt;params.receive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">get_req</span>()-&gt;<span class=\"built_in\">set_size_limit</span>(<span class=\"keyword\">this</span>-&gt;params.request_size_limit);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（PS，代码量很少，读者表示狂喜。）</p>\n<p>如代码所写的那样，WFServer就是继承了一下WFServerBase，并重写了new_session函数。究其根本这里的new_session实际上重写的是CommService当中所定义的纯虚函数。如果你认为应该仔细去阅读这里重写的虚函数，那你就错了，实际上WFHttpServer<strong>又将new_session函数进行全特化实现</strong>。所以WFServer的new_session看看就好。无需深入理解。</p>\n<p>WFServer重点就是将示例在创建server时传入的process回调，保存到了成员变量当中，<strong>以供new_session时将任务回调传给Task</strong>。下面重点研究一下WFServerBase。</p>\n<p>从上面的分析了解到WFServerBase继承自CommService。WFServerBase实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFServerBase</span> : <span class=\"keyword\">protected</span> CommService &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFServerBase</span>(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> WFServerParams *params) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">conn_count</span>(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;params = *params;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;unbind_finish = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;listen_fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">/* To start a TCP server */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* Start with binding address. The only necessary start function. */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* stop() is a blocking operation. */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">shutdown</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">wait_finish</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Nonblocking terminating the server. For stopping multiple servers.</span></span><br><span class=\"line\"><span class=\"comment\">\t * Typically, call shutdown() and then wait_finish().</span></span><br><span class=\"line\"><span class=\"comment\">\t * But indeed wait_finish() can be called before shutdown(), even before</span></span><br><span class=\"line\"><span class=\"comment\">\t * start() in another thread. */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wait_finish</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">get_conn_count</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;conn_count; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tWFServerParams params;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">create_listen_fd</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> WFConnection *<span class=\"title\">new_connection</span><span class=\"params\">(<span class=\"type\">int</span> accept_fd)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_connection</span><span class=\"params\">(WFConnection *conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle_unbound</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::atomic&lt;<span class=\"type\">size_t</span>&gt; conn_count;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> listen_fd;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> unbind_finish;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::mutex mutex;</span><br><span class=\"line\">\tstd::condition_variable cond;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">CommScheduler</span> *scheduler;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>首先，我们看到WFServerBase当中有一个类型为CommScheduler的成员变量scheduler。我们应该感到惊喜，因为CommScheduler不就是对Communicator做了一层浅浅的封装吗？这里出现的scheduler不就意味着WFServerBase和Communicator联系起来了吗？那server的启动必定是调用了Communicator::bind接口来创建、绑定、监听listen socket。下面重点研究一下start函数的函数的实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">WFServerBase::start</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">init</span>(bind_addr, addrlen) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;scheduler-&gt;<span class=\"built_in\">bind</span>(<span class=\"keyword\">this</span>) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">deinit</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;listen_fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>init函数伪代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">WFServerBase::init</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;CommService::<span class=\"built_in\">init</span>(bind_addr, addrlen, <span class=\"number\">-1</span>, timeout) &lt; <span class=\"number\">0</span>)\t<span class=\"comment\">// 调用基类CommService的初始化函数，就是将listen fd所绑定的地址拷贝一份到基类。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;scheduler = WFGlobal::<span class=\"built_in\">get_scheduler</span>();\t\t\t\t\t\t<span class=\"comment\">// 全局的单例CommScheduler对象。</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要干了两件事：调用基类的init，将绑定的地址拷贝一份到基类的成员变量当中。然后通过__CommManager获取全局的单例CommScheduler对象。</p>\n<p>特别的是，<strong>这里有个重要的时间点</strong>，在__CommManager被构造时，会<strong>初始化CommScheduler对象</strong>，如果你看过上一篇博客，你一定知道为什么这个时刻重要。因为CommScheduler::init函数会<strong>启动workflow底层的事件池和状态迁移池</strong>。具体的架构模型图可以参考：<a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlow源码剖析——Communicator之TCPServer（中）</a>。</p>\n<p>在WFServerBase::start实现中，调用init函数过后，立马调用CommScheduler::bind（实际上就是Communicator::bind），该函数里面会做网络编程三部曲：创建、绑定、监听。至此我们的TCPServer服务器就在这里启动，等待客户端的连接。</p>\n<p>关于WFServerBase其实还有两个有趣的知识点：new_connection 和 服务停止。</p>\n<ul>\n<li><p>new_connection：该函数和WFServerBase::conn_count强相关。new_connection所创建的对象共用WFServerBase::conn_count。每当有客户端连接到来，都会创建一个CommConnection对象，同时会使WFServerBase::conn_count自增一。每当连接断开，Communicator当中就会调用__release_conn释放连接上下文，并且CommConnection对象也随之释放，其构造函数当中，会将WFServerBase::conn_count变量自减一。所以说，每次在连接到来创建的CommConnection对象可以视为连接计数器。（PS，因为目前只了解workflow的部分源码，所以连接计数器存在的具体意义，我目前还未能领悟。后面有时间的话，再去深究吧。）</p>\n</li>\n<li><p>服务停止：如代码注释那样，WFServerBase所提供的stop接口是阻塞的，它其实连续调用了两个函数：shutdown、wait_finish。其中shutdown会调用Communicator::unbind函数，它会直接将listen fd从mpoller当中删除。当调用shutdown函数时，整体<strong>停止的链路是这样的</strong>：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WFServerBase::shutdown -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">CommScheduler::unbind -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">Communicator::unbind -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">mpoller_del(listen_fd) - - -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">Communicator::handle_listen_result -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">Communicator::shutdown_service -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">while (直到CommService的ref减为0) &#123; CommService::decref() &#125; -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">WFServerBase::handle_unbound</span><br></pre></td></tr></table></figure>\n\n<p>Communicator::shutdown_service代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::shutdown_service</span><span class=\"params\">(CommService *service)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(service-&gt;listen_fd);</span><br><span class=\"line\">\tservice-&gt;listen_fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tservice-&gt;<span class=\"built_in\">drain</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tservice-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的service-&gt;drain(-1)会将server端目前所有的连接都从mpoller当中移除。然后等待所有连接上下文回调CommServiceTarget::decref将server对象的引用计数减为0后，调用WFServerBase::handle_unbound函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">CommService::decref</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__sync_sub_and_fetch(&amp;<span class=\"keyword\">this</span>-&gt;ref, <span class=\"number\">1</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">handle_unbound</span>();\t\t\t\t\t\t<span class=\"comment\">// 最终被重写成：WFServerBase::handle_unbound</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>WFServerBase::stop的注释说明了该函数是阻塞的，其阻塞主要原因就在wait_finish，它会等待所有的连接被释放然后释放WFServerBase的引用计数后才会跳出等待条件变量的循环。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WFServerBase::handle_unbound</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;mutex.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;unbind_finish = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;cond.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;mutex.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WFServerBase::wait_finish</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(<span class=\"keyword\">this</span>-&gt;mutex)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>-&gt;unbind_finish)</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;cond.<span class=\"built_in\">wait</span>(lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">deinit</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;unbind_finish = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tlock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"探究WFHttpServerTask\"><a href=\"#探究WFHttpServerTask\" class=\"headerlink\" title=\"探究WFHttpServerTask\"></a>探究WFHttpServerTask</h3><p>好了，tcpserver的启动流程基本流程已经分析完毕，下面我们重点看看WFHttpServer::new_session的实现。该函数在每轮读取客户端请求时会被调用一次。返回值是类型为CommSession的对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt; <span class=\"function\"><span class=\"keyword\">inline</span></span></span><br><span class=\"line\"><span class=\"function\">CommSession *<span class=\"title\">WFHttpServer::new_session</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> seq, CommConnection *conn)</span> </span>&#123;</span><br><span class=\"line\">\tWFHttpTask *task;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttask = WFServerTaskFactory::<span class=\"built_in\">create_http_task</span>(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>-&gt;process);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_keep_alive</span>(<span class=\"keyword\">this</span>-&gt;params.keep_alive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_receive_timeout</span>(<span class=\"keyword\">this</span>-&gt;params.receive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">get_req</span>()-&gt;<span class=\"built_in\">set_size_limit</span>(<span class=\"keyword\">this</span>-&gt;params.request_size_limit);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到出现了一个新的类——WFHttpTask，我可以明确告诉你，WFHttpTask只是一个基类，我们应该从final类开始深入分析。</p>\n<p>对于WFHttpTask，它的定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> WFHttpTask = WFNetworkTask&lt;protocol::HttpRequest,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t protocol::HttpResponse&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>那么WFNetworkTask是啥呢？先别急，后面再来揭晓它的源码。通过WFServerTaskFactory::create_http_task我们可以找到我们所需要的final类——WFHttpServerTask它的定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFHttpServerTask</span> : <span class=\"keyword\">public</span> WFServerTask&lt;protocol::HttpRequest,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t protocol::HttpResponse&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">using</span> TASK = WFNetworkTask&lt;protocol::HttpRequest, protocol::HttpResponse&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFHttpServerTask</span>(CommService *service, std::function&lt;<span class=\"built_in\">void</span> (TASK *)&gt;&amp; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFServerTask</span>(service, WFGlobal::<span class=\"built_in\">get_scheduler</span>(), proc),</span><br><span class=\"line\">\t\t<span class=\"built_in\">req_is_alive_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">\t\t<span class=\"built_in\">req_has_keep_alive_header_</span>(<span class=\"literal\">false</span>) &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommMessageOut *<span class=\"title\">message_out</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">bool</span> req_is_alive_;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> req_has_keep_alive_header_;</span><br><span class=\"line\">\tstd::string req_keep_alive_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>从构造函数当可以看到，再一次对全局单例的CommScheduler的引用。类的成员函数包括hanlde、message_out最终实现，我们重点关注handle的实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WFHttpServerTask::handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* 设置fianl类的成员变量... */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;WFServerTask::<span class=\"built_in\">handle</span>(state, error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在服务端收完并解析完客户端发来的请求报文之后（在Communicator::handle_incoming_request函数当中）会进入该函数，从WFT_STATE_TOREPLY宏的命名也可以推测到，它代表准备回复的状态。在做完final类一些设置后，最终会调用父类的handle，所以下面深入看看WFServerTask模板类的实现。</p>\n<p><strong>tcpserver任务部分最烧脑的就在WFServerTask模板类的实现</strong>，对于WFNetworkTask模板类，它本身的成员函数对我们理解tcpserver本身来说并不重要。但需要注意的是WFNetworkTask继承自CommRequest。</p>\n<p>简单用字符画了一下WFHttpServerTask的继承树。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SubTask\t\tCommSession</span><br><span class=\"line\">\t\t\\/</span><br><span class=\"line\">\tCommRequest</span><br><span class=\"line\">\t\t|</span><br><span class=\"line\">\t\tV</span><br><span class=\"line\">WFNetworkTask&lt;REQ, RESP&gt;\t# 该类的实现在对我们理解tcpserver不是特别重要，读者可以跳过该类。</span><br><span class=\"line\">\t\t|</span><br><span class=\"line\">\t\tV</span><br><span class=\"line\">WFServerTask&lt;REQ, RESP&gt;</span><br><span class=\"line\">\t\t|</span><br><span class=\"line\">\t\tV</span><br><span class=\"line\">WFHttpServerTask</span><br></pre></td></tr></table></figure>\n\n<p>在正式讲解WFServerTask前，<strong>先学习几个关键知识点：</strong></p>\n<p>首先回顾一下，SubTask::subtask_done函数实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SubTask::subtask_done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tSubTask *cur = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcur = cur-&gt;<span class=\"built_in\">done</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cur) &#123;</span><br><span class=\"line\">\t\tcur-&gt;<span class=\"built_in\">dispatch</span>();\t\t<span class=\"comment\">// 下一个任务的dispatch</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更简单点描述，调done后调dispatch触发任务队列的下一个任务。<strong>（关键点一：）其中done函数实现最后都会调用<code>series_of(this)-&gt;pop()</code>，这行代码是获取SeriesWork串行队列的下一个任务，当队列中（没有任何任务了）山穷水尽了会返回nullptr，并且SeriesWork会delete this（SeriesWork对象本身）。</strong></p>\n<p>然后了解一下两个WFServerTask当中的内嵌类的定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Processor</span> : <span class=\"keyword\">public</span> SubTask &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Processor</span>(WFServerTask&lt;REQ, RESP&gt; *task,</span><br><span class=\"line\">\t\t\t\tstd::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt;&amp; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">process</span>(proc) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;task = task;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">process</span>(<span class=\"keyword\">this</span>-&gt;task);\t\t<span class=\"comment\">// 调用</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;task = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">/* As a flag. get_conneciton() disabled. */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> SubTask *<span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>)-&gt;<span class=\"built_in\">pop</span>();\t<span class=\"comment\">// 获取串行队列下一个任务</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt;&amp; process;</span><br><span class=\"line\">\tWFServerTask&lt;REQ, RESP&gt; *task;</span><br><span class=\"line\">&#125; processor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Series</span> : <span class=\"keyword\">public</span> SeriesWork &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Series</span>(WFServerTask&lt;REQ, RESP&gt; *task) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">SeriesWork</span>(&amp;task-&gt;processor, <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">set_last_task</span>(task);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;task = task;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Series</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>-&gt;task;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tWFServerTask&lt;REQ, RESP&gt; *task;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Processor::dispatch函数首先调用了一下构造传进来的回调函数process，然后调用subtask_done，结合上面的分析，它会调用串行队列当中的下一个任务的dispatch函数。</p>\n</li>\n<li><p>对于Series，只有析构和构造函数，从构造函数当中可以看出来，它本质上就是 <strong>（关键点二）只有两个任务的串行队列。并且在该串行队列被delete时，顺带会在析构函数当中delete掉二号任务。</strong>此外，<strong>（关键点三）在每个任务被加到串行队列当中时，会将任务的SubTask::pointer指针指向串行队列对象。</strong></p>\n</li>\n</ul>\n<p>好了，下面从WFServerTask&lt;REQ, RESP&gt;::handle函数开始分析其中的奥妙。源代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> WFServerTask&lt;REQ, RESP&gt;::<span class=\"built_in\">handle</span>(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;state = WFT_STATE_TOREPLY;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;target = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">get_target</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> <span class=\"built_in\">Series</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;processor.<span class=\"built_in\">dispatch</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;state = state;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;error = error;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (error == ETIMEDOUT)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;timeout_reason = TOR_TRANSMIT_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为WFServerTask顶层的基类包括：SubTask + <strong>CommSession</strong>，对这里着重强调CommSession，因为CommSession当中的handle最终被重写成如上所示的代码。服务端在每次读完（并解析完）客户端发来的数据后，状态迁移池都会回调Communicator::handle_incoming_request函数，在每次写完客户端请求的回复后，状态迁移池都会回调Communicator::handle_reply_result函数。这两函数当最后都会调用session-&gt;handle，所不同的是每次传入的state参数有所不同。<strong>正常情况下，在读完后回调session-&gt;handle传入的state为CS_STATE_TOREPLY，而在写完后回调的session-&gt;handle传入的state为CS_STATE_SUCCESS。</strong></p>\n<ul>\n<li><p>所以在解析完客户端请求后所调用的handle会进入第一个if分支，从代码当中可以看到，它先是将WFServerTask::state数据成员设置成了WFT_STATE_TOREPLY，这为发送完回复再次回到handle进入第二个if分支做准备。然后最关键的是<code>new Series(this);</code>这行代码，如果你第一次看workflow的源码这样的写法一定会让你蒙。<strong>什么鬼？new的成员没用什么变量去接？这不典型内存泄漏了吗？</strong>，但是深入研究下去，这样写好像也没问题。结合上面Series的定义，所以最终new的Series串行队列当中第一个任务是WFServerTask::processor，第二个任务是WFServerTask本身。继续分析第一个if分支的代码，接下来调用了<code>this-&gt;processor.dispatch();</code>函数这也是整个业务代码的起始点。深入分析Processor::dispatch实现可知，它首先调用process回调，我可以直接告诉你此回调正是我们在示例当中创建server时传进来的process函数。在调用process处理完业务代码，然后调用了<code>this-&gt;subtask_done();</code>函数，根据前面提到的<strong>关键点一</strong>，我们可以知道这将返回串行队列的第二个任务即WFServerTask。我想这里一定会有读者有疑惑，怎么就返回第二个任务了？不是应该返回第一个任务吗？如果你有这样的疑惑，我建议你仔细阅读一下SeriesWork这部分的源码，所谓的两个任务实际上首个任务是不会入队列的，需要人手动触发，而在WFServerTask&lt;REQ, RESP&gt;::handle当中其实已经手动触发了一号任务————Processor，所以第一次调用subtask_done实际上返回的是第二个任务。好了回到正题，进入二号任务的dispatch（<code>WFServerTask::dispatch</code>），因为我们在前面已经将WFServerTask::state设置成了WFT_STATE_TOREPLY所以，进入if分支，这里应该开个香槟了，因为这里调用了<code>this-&gt;scheduler-&gt;reply</code>，这意味着服务端向客户端发送回复了！！！正常情况下会返回大于零的值，然后直接返回。这里罗列一下调用和返回流程：</p>\n<p>  首先是调用流程：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WFServerTask&lt;REQ, RESP&gt;::handle -&gt;</span><br><span class=\"line\">Processor::dispatch -&gt; </span><br><span class=\"line\">Processor::subtask_done -&gt; </span><br><span class=\"line\">WFServerTask::dispatch</span><br></pre></td></tr></table></figure>\n\n<p>  然后是返回流程：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从第二个任务的WFServerTask的：dispatch函数当中 返回到 -&gt; </span><br><span class=\"line\">第一个任务Processor的基类函数：subtask_done -&gt; </span><br><span class=\"line\">返回到第一个任务Processor的dispatch函数 -&gt; </span><br><span class=\"line\">返回到WFServerTask&lt;REQ, RESP&gt;::handle函数。</span><br></pre></td></tr></table></figure>\n\n<p>  我这里想表达的是：<strong>WFServerTask&lt;REQ, RESP&gt;::handle第一个if分支的一次dispatch实际上嵌套执行了两个任务。</strong>，注意是<strong>嵌套</strong>，这点很重要！</p>\n</li>\n<li><p>然后在写完回复后，会再次回到WFServerTask&lt;REQ, RESP&gt;::handle，此时会进入第二个if分支，并且根据<strong>关键点一</strong>，<strong>因为此时第一个if分支new的串行队列已经为空，所以WFServerTask::subtask_done操作会将第一个if分支new的串行队列给释放掉，同时因为Series的释放，它的析构函数又会将WFServerTask给释放掉！</strong></p>\n</li>\n</ul>\n<p>下面贴出WFServerTask关键的代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFServerTask</span> : <span class=\"keyword\">public</span> WFNetworkTask&lt;REQ, RESP&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommMessageOut *<span class=\"title\">message_out</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> &amp;<span class=\"keyword\">this</span>-&gt;resp; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommMessageIn *<span class=\"title\">message_in</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> &amp;<span class=\"keyword\">this</span>-&gt;req; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* Enable get_connection() again if the reply() call is success. */</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;processor.task = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;scheduler-&gt;<span class=\"built_in\">reply</span>(<span class=\"keyword\">this</span>) &gt;= <span class=\"number\">0</span>)\t<span class=\"comment\">// 发生回复</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;state = WFT_STATE_SYS_ERROR;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;error = errno;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;processor.task = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;scheduler-&gt;<span class=\"built_in\">shutdown</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> SubTask *<span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSeriesWork *series = <span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;callback)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">callback</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* Defer deleting the task. */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> series-&gt;<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFServerTask</span>(CommService *service, CommScheduler *scheduler,</span><br><span class=\"line\">\t\t\t\t std::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt;&amp; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFNetworkTask</span>&lt;REQ, RESP&gt;(<span class=\"literal\">NULL</span>, scheduler, <span class=\"literal\">nullptr</span>),</span><br><span class=\"line\">\t\t<span class=\"built_in\">processor</span>(<span class=\"keyword\">this</span>, proc)</span><br><span class=\"line\">\t&#123; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>好了基本的HTTPServer端处理客户端请求的流程已经梳理完毕，最后贴出我在看源码的过程当中，所梳理流程笔记，可以给读者提供一些思路。同时也作为我个人的备忘笔记：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Workflow服务端处理连接流程分析</span><br><span class=\"line\"></span><br><span class=\"line\">server:</span><br><span class=\"line\"></span><br><span class=\"line\">    entry: </span><br><span class=\"line\">        accept_conn: CONN_STATE_CONNECTED -&gt; </span><br><span class=\"line\">            create_request: CONN_STATE_RECEIVING -&gt;                             // tag1</span><br><span class=\"line\">                append_message: 当http请求接受完毕时：CONN_STATE_SUCCESS -&gt;</span><br><span class=\"line\">                    handle_incoming_request: </span><br><span class=\"line\">                        ==&gt;     CONN_STATE_IDLE &amp;&amp; entry被追加到target-&gt;idle_list上;</span><br><span class=\"line\">                        ==&gt;    session-&gt;passive = 2;</span><br><span class=\"line\">                        ==&gt;    state = CS_STATE_TOREPLY</span><br><span class=\"line\"></span><br><span class=\"line\">    |   |   |</span><br><span class=\"line\">    V   V   V</span><br><span class=\"line\">    WFHttpServerTask::handle -&gt;</span><br><span class=\"line\">        WFServerTask&lt;REQ, RESP&gt;::handle -&gt;</span><br><span class=\"line\">            ```cpp</span><br><span class=\"line\">                template&lt;class REQ, class RESP&gt;</span><br><span class=\"line\">                void WFServerTask&lt;REQ, RESP&gt;::handle(int state, int error)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    if (state == WFT_STATE_TOREPLY)         // √</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        this-&gt;state = WFT_STATE_TOREPLY;</span><br><span class=\"line\">                        this-&gt;target = this-&gt;get_target();</span><br><span class=\"line\">                        new Series(this);</span><br><span class=\"line\">                        this-&gt;processor.dispatch();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else if (this-&gt;state == WFT_STATE_TOREPLY)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        this-&gt;state = state;</span><br><span class=\"line\">                        this-&gt;error = error;</span><br><span class=\"line\">                        if (error == ETIMEDOUT)</span><br><span class=\"line\">                            this-&gt;timeout_reason = TOR_TRANSMIT_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">                        this-&gt;subtask_done();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else</span><br><span class=\"line\">                        delete this;</span><br><span class=\"line\">                &#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    WFServerTask&lt;REQ, RESP&gt;::dispatch -&gt;\n        this-&gt;scheduler-&gt;reply(this) -&gt; 以写方式将entry添加到epoll上\n            session-&gt;passive = 3;\n\n|   |   |       \nV   V   V\nhandle_reply_result -&gt;\n    ===&gt; entry-&gt;state = CONN_STATE_KEEPALIVE &amp;&amp; entry 被追加到service-&gt;alive_list &amp;&amp; 以读方式将entry添加到epoll上（如果保活的话）\n    ===&gt; state = CS_STATE_SUCCESS\n\n|   |   |\nV   V   V\nWFHttpServerTask::handle -&gt;\n    WFServerTask&lt;REQ, RESP&gt;::handle -&gt;\n        <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> WFServerTask&lt;REQ, RESP&gt;::<span class=\"built_in\">handle</span>(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state == WFT_STATE_TOREPLY)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;state = WFT_STATE_TOREPLY;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;target = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">get_target</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"built_in\">Series</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;processor.<span class=\"built_in\">dispatch</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;state == WFT_STATE_TOREPLY)  <span class=\"comment\">// √</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;state = state;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;error = error;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error == ETIMEDOUT)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;timeout_reason = TOR_TRANSMIT_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();       <span class=\"comment\">// will delete Series for first &#x27;if&#x27; branch malloc</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n|   |   |\nV   V   V\ngo to tag1.\n</code></pre>\n<pre><code>\n---\n\n**本章完结**\n</code></pre>"},{"title":"WorkFlow GO-Task 源码分析","date":"2024-10-13T04:00:00.000Z","_content":"\n[WorkFlow GO-Task 源码分析](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlow源码剖析——Communicator之TCPServer（上）](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlow源码剖析——Communicator之TCPServer（中）](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlow源码剖析——Communicator之TCPServer（下）](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\n## 前言\n\n任何好的框架的设计都是围绕着一个核心思想去展开，sylar的一切皆协程、muduo的one loop per thread等。一切皆是任务流就是workflow的精髓。（PS，目前作者功力尚浅，许多设计细节还未能悟透其用意，目前也只能尽力将我的理解呈现出来，有错误非常欢迎指出。\n\n也是尝试着阅读过许多开源优秀的代码，这里记录一下我个人在阅读一份源码时的习惯：**适可而止的自低向上**。因为我在阅读一份完全不了解的源码时，迫不及待的想去知道每个每个模块、每个函数的实现细节，我也曾尝试以自顶向下去阅读一份源码，但是无法克制自己钻牛角尖的心，并且在经验尚浅，完全不了解设计背景的境况下，自顶向下去阅读一份源码，某一个函数的实现你只能去猜，由于经验尚浅，你大概率猜的也是错误的。所以，兜兜转转，我还是遵循我个人的习惯，自低向上去阅读一份源码。当然，应该：**适可而止的自低向上**，一些你完全知道起什么作用的模块其实就不必去深究了，比如：链表、红黑树、编码器等。深入细节的同时，也不要忘了我们的初心：框架的设计思想。\n\n<!-- more -->\n\n网络框架（包括库）的模块设计其实有很多相似的地方，比如都会有的：线程池、对epoll的封装、对io接口的封装、对tcpserver以及tcpclient的封装等。在阅读网络并发相关的源码时可以以这些方面入手。\n\n在深入阅读workflow的源码之后，特别是在kernel文件夹下对一些基础模块的封装中感受到了对c++的克制使用。因为kernel下基础模块的实现大多都是以c语言为主。这点大家要有一个心理准备。\n\n这里建议读者在阅读workflow，go-task源码时，以如下顺序阅读：\n\nExecQueue -> ExecSession -> Executor-> ExecRequest -> SubTask -> __ExecManager -> __WFGoTask -> WFGoTask -> SeriesWork\n\n## 正文\n\n下面直接以workflow给的gotask的示例作为本文的切入点：\n\n### 用法\n\ngo-task的用法示例如下：\n\n```cpp\n#include <stdio.h>\n#include <utility>\n#include \"workflow/WFTaskFactory.h\"\n#include \"workflow/WFFacilities.h\"\n\nvoid add(int a, int b, int& res) {\n    res = a + b;\n}\n\nint main(void) {\n    WFFacilities::WaitGroup wait_group(1);\n    int a = 1;\n    int b = 1;\n    int res;\n\n    WFGoTask *task = WFTaskFactory::create_go_task(\"test\", add, a, b, std::ref(res));   // cb1\n    task->set_callback([&](WFGoTask *task) {    // cb2\n        printf(\"%d + %d = %d\\n\", a, b, res);\n        wait_group.done();\n    });\n \n    task->start();\n    wait_group.wait();\n    return 0;\n}\n```\n\n如果你有一定网络编程的基础，应该很容易看懂这段小daemo。我们可以这段代码猜测：\n\n第一行声明了一个WaitGroup变量，从后面的代码可以知道wait_group的作用是：阻塞主线程等待计算完成。在创建wait_group后，将计算过程add函数封装在一个回调函数（cb1）当中，cb1作为一个参数再来构造一个任务--WFGoTask，然后调用WFGoTask::set_callback函数又设置了一个回调函数（cb2），从代码上可以看到，该cb2的作用是：打印计算结果并通知主线程计算完毕。\n\n所以经过上面的分析，我们可以知道：\n\n1. WaitGroup的实现一定是基于条件变量/信号量。\n\n2. 作为WFGoTask构造参数cb1，一定某一时刻被线程池里面的某个线程给调用了，并且该线程在调用add函数返回之后，一定是**直接或者间接**调用了一下cb2。\n\n### 源码简析\n\n示例代码中create_go_task的第一个参数其实是kernel目录下的ExecQueue队列对应的队列名。ExecQueue具体的用法以及作用稍后讲解，只需知道它是一个队列即可。\n\ncreate_go_task实现很简单，它里面就是依赖一个全局的单例__ExecManager，通过这个单例拿到队列名对应的队列指针以及Executor对象。然后将队列和Executor对象作为__WFGoTask的构造参数，创建出了继承自WFGoTask的__WFGoTask对象。\n\n这里备注一下：__ExecManager单例管理从队列名到队列指针的映射。并且在__ExecManager初始化时，会创建一个Executor对象。\n\n目前为止，出现了几个新的类：ExecQueue、Executor、__WFGoTask。\n\n对于ExecQueue从kernel目录下可以看到它的源码，单纯就是一个链表，使用的还是linux原生链表。它的每一个节点都是ExecSessionEntry类型，如下定义：\n\n```cpp\nstruct ExecSessionEntry {\n\tstruct list_head list;\n\tExecSession *session;\n\tthrdpool_t *thrdpool;\n};\n```\n\n单独看ExecQueue、ExecSession、ExecSessionEntry的源码一定会蒙（我就是），所以这里直接讲解Executor的实现，前面的三个类就是被它所使用。\n\n```cpp\nvoid Executor::executor_thread_routine(void *context) {\n\tExecQueue *queue = (ExecQueue *)context;\n\tstruct ExecSessionEntry *entry;\n\tExecSession *session;\n\tint empty;\n\n\tentry = list_entry(queue->session_list.next, struct ExecSessionEntry, list);\n\tpthread_mutex_lock(&queue->mutex);\n\tlist_del(&entry->list);\n\tempty = list_empty(&queue->session_list);\n\tpthread_mutex_unlock(&queue->mutex);\n\n\tsession = entry->session;\n\tif (!empty) {\n\t\tstruct thrdpool_task task = {\n\t\t\t.routine\t=\tExecutor::executor_thread_routine,\n\t\t\t.context\t=\tqueue\n\t\t};\n\t\t__thrdpool_schedule(&task, entry, entry->thrdpool);\n\t}\n\telse\n\t\tfree(entry);\n\n\tsession->execute();\n\tsession->handle(ES_STATE_FINISHED, 0);\n}\n```\n\n流程如下：\n\n1. 从队列中取ExecSessionEntry。\n\n2. 队列非空的话，将ExecSessionEntry中的session包装成thrdpool_task，并且将ExecSessionEntry的地址复用成线程池的__thrdpool_task_entry（PS：线程池在拿到__thrdpool_task_entry时用完后会自动free掉）。\n\n3. 队列为非空的话，直接free掉ExecSessionEntry。\n\n4. 最后执行ExecSession的execute、handle。\n\n这里的execute函数其实暗示着会调用cb1，handle其实就暗示里面会调用cb2。这下前后不就连起来了？（恍然大悟！）别着急，我们继续去剖析源码。\n\n细心的读者应该会发现这句代码没被放在锁里面：\n\n```cpp\nentry = list_entry(queue->session_list.next, struct ExecSessionEntry, list);\n```\n\n为什么可以不放在锁里面？如果线程2，在线程1执行完list_del之前，拿到了同一个entry，这样不会有野指针的问题吗？\n\n这里放出我的猜测：Executor::executor_thread_routine本身就已经保证了一个时刻只会有一个线程访问队列头部。这个函数的执行逻辑是这样的：当前Executor::executor_thread_routine的回调是靠上一个Executor::executor_thread_routine回调访问完链表头部之后触发的，**也即下一个队列头部访问的回调还得靠上一个回调来封装**。这里其实有点并行任务串行化的味道了。\n\n```cpp\nstruct thrdpool_task task = {\n    .routine\t=\tExecutor::executor_thread_routine,\n    .context\t=\tqueue\n};\n__thrdpool_schedule(&task, entry, entry->thrdpool);\n```\n\n最后是ExecQueue队列的start点，如下：\n\n```cpp\nint Executor::request(ExecSession *session, ExecQueue *queue) {\n\tstruct ExecSessionEntry *entry;\n\n\tsession->queue = queue;\n\tentry = (struct ExecSessionEntry *)malloc(sizeof (struct ExecSessionEntry));\n\tif (entry) {\n\t\tentry->session = session;\n\t\tentry->thrdpool = this->thrdpool;\n\t\tpthread_mutex_lock(&queue->mutex);\n\t\tlist_add_tail(&entry->list, &queue->session_list);\n\t\tif (queue->session_list.next == &entry->list) {\n\t\t\tstruct thrdpool_task task = {\n\t\t\t\t.routine\t=\tExecutor::executor_thread_routine,\n\t\t\t\t.context\t=\tqueue\n\t\t\t};\n\t\t\tif (thrdpool_schedule(&task, this->thrdpool) < 0) {\n\t\t\t\tlist_del(&entry->list);\n\t\t\t\tfree(entry);\n\t\t\t\tentry = NULL;\n\t\t\t}\n\t\t}\n\n\t\tpthread_mutex_unlock(&queue->mutex);\n\t}\n\n\treturn -!entry;\n}\n```\n\n从源码中可以看到，就是使用malloc分配一块内存，将session封装成ExecSessionEntry，然后将其添加到队列尾部，如果队列原来为空（意味着ExecQueue没有开始执行），就启动第一个Executor::executor_thread_routine，这样它会**自动链式触发**执行队列当中的每一个任务的回调。\n\n这里malloc分配的ExecSessionEntry由两个地方去释放：\n\n1. **这里malloc分配的ExecSessionEntry会被复用为线程池的__thrdpool_task_entry，最后被线程池调用free释放掉。**\n\n2. **在函数Executor::executor_thread_routine中，由ExecQueue最后一个任务调用free释放。**\n\n从这里可以看到，workflow针对内存的释放也是极其晦涩（反正我在阅读源码时就是这样感觉）。为了性能，根本没使用智能指针，完全靠malloc和free。内存池也没有，这点我是无法理解的。\n\n经过上面的分析我们了解了ExecSession、ExecQueue、Executor的作用，接下来我们分析一下，__WFGoTask是怎么使用这些类的。\n\n从本段开头了解到ExecQueue、Executor是作为__WFGoTask的构造参数，所以下面我们以__WFGoTask为主去看看它是怎么实现的\n\n```cpp\nclass __WFGoTask : public WFGoTask {\n    // ...\nprotected:\n\tvirtual void execute() {\n\t\tthis->go();\n\t}\n\nprotected:\n\tstd::function<void ()> go;\n\npublic:\n\t__WFGoTask(ExecQueue *queue, Executor *executor,\n\t\t\t   std::function<void ()>&& func) :\n\t\tWFGoTask(queue, executor),\n\t\tgo(std::move(func)) { /* ... */ }\n};\n```\n\n**使用了virtual关键字声明的execute函数！**，并且调用了go也即cb1！（衔接起来了！）\n\n继续看它基类的实现：\n\n```cpp\nclass WFGoTask : public ExecRequest {\npublic:\n\tvoid start() {\n\t\tassert(!series_of(this));\n\t\tWorkflow::start_series_work(this, nullptr);\n\t}\n\npublic:\n\tvoid *user_data;\n\npublic:\n\tvoid set_callback(std::function<void (WFGoTask *)> cb) {\n\t\tthis->callback = std::move(cb);\n\t}\n\nprotected:\n\tvirtual SubTask *done() {\n\t\tSeriesWork *series = series_of(this);\n\n\t\tif (this->callback)\n\t\t\tthis->callback(this);\n\n\t\tdelete this;\n\t\treturn series->pop();\n\t}\n\nprotected:\n\tstd::function<void (WFGoTask *)> callback;\n\npublic:\n\tWFGoTask(ExecQueue *queue, Executor *executor) :\n\t\tExecRequest(queue, executor) { /* ... */ }\n};\n```\n\nWFGoTask::start()正是示例当中调用的start函数，set_callback正是设置的cb2回调。我可以明确的说，start_series_work会创建一个SeriesWork对象，并且将SeriesWork对象的指针赋值给WFGoTask祖父类SubTask的user_data成员，并且SeriesWork其实也是一个队列，它是串行队列，队列当中的任务是有先后执行顺序的。这里串行队列的设计是为特定的有先后依赖顺序的计算场景所设计的。\n\n深入查看ExecRequest的实现：\n\n```cpp\nclass ExecRequest : public SubTask, public ExecSession {\npublic:\n\tExecRequest(ExecQueue *queue, Executor *executor) { /* ... */ }\n\npublic:\n\tvirtual void dispatch() {\n\t\tif (this->executor->request(this, this->queue) < 0)\n\t\t\tthis->handle(ES_STATE_ERROR, errno);\n\t}\n\nprotected:\n\tExecQueue *queue;\n\tExecutor *executor;\n\nprotected:\n\tvirtual void handle(int state, int error) {\n\t\tthis->state = state;\n\t\tthis->error = error;\n\t\tthis->subtask_done();\n\t}\n};\n```\n\nSubTask类和ExecSession类非常简单，由于篇幅有限这只列出我们关心的函数。\n\nSubTask有三个关键函数：\n\n虚函数：dispatch、done\n\n普通成员函数：subtask_done。\n\n而\n\nSubTask::dispatch 最终被重写为：ExecRequest::dispatch\n\nSubTask::done 最终被重写为：WFGoTask::done\n\n其中subtask_done实现如下：\n\n```cpp\nvoid SubTask::subtask_done() {\n\tSubTask *cur = this;\n\n\twhile (1) {\n\t\tcur = cur->done();\n\t\tif (cur) {\n\t\t\tcur->dispatch();\n\t\t}\n        /* ... */\n\n\t\tbreak;\n\t}\n}\n```\n\ndone的实现落实到了WFGoTask::done上，作用是销毁当前的task对象并且返回串行队列当中的下一个task，然后由subtask_done调用ExecRequest::dispatch将task挂到ExecQueue的链表上等待线程池的消费。\n\nExecSession有两个我们比较关心的纯虚函数：execute、handle。这两函数一路继承体系下来最终分别被重写为__WFGoTask::execute和ExecRequest::handle。\n\n所以在Executor::executor_thread_routine函数中调用的execute、handle函数最终被重写为：__WFGoTask::execute、ExecRequest::handle()。\n\n最后总结一下go-task执行的流程：\n\n1. 构造一个go-task对象 && 调用start函数。\n\n2. start函数会new一个first为go-task，last为nullptr的SeriesWork对象 && 调用first的dispatch也即ExecRequest::dispatch。\n\n3. executor的request函数，将go-task挂到ExecQueue链表的尾部上，由线程池去消费。当然，如果ExecQueue原来是为空的，就创建第一个Executor::executor_thread_routine。\n\n4. Executor::executor_thread_routine会**链式**触发让线程池处理ExecQueue每一个任务。\n\n5. 调用任务的__WFGoTask::execute。\n\n6. 调用任务的ExecRequest::handle。\n\n7. 调用SubTask::subtask_done && （如果存在的话）调用SeriesWork对象的下一个task的dispatch（PS，可能不是ExecRequest::dispatch这个重载函数）\n\n8. 调用WFGoTask::done。删除当前task对象并且返回串行队列的下一个串行任务。\n\n**最后要还要提醒的一句是：Executor::executor_thread_routine在向ExecQueue的链表取任务时是保证非并发的，但是在执行任务的execute时，是有可能是并发执行的！** 有人可能会注意到那为什么在向链表取任务时要加锁？因为这把锁可能防止Executor::executor_thread_routine和Executor::request之间的竞争问题，而Executor::executor_thread_routine和Executor::executor_thread_routine之间并不存在竞争问题。\n\n---\n\n**本章完结**","source":"_posts/workflow/go_task.md","raw":"---\ntitle: WorkFlow GO-Task 源码分析\ndate: 2024-10-13 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n[WorkFlow GO-Task 源码分析](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlow源码剖析——Communicator之TCPServer（上）](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlow源码剖析——Communicator之TCPServer（中）](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlow源码剖析——Communicator之TCPServer（下）](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\n## 前言\n\n任何好的框架的设计都是围绕着一个核心思想去展开，sylar的一切皆协程、muduo的one loop per thread等。一切皆是任务流就是workflow的精髓。（PS，目前作者功力尚浅，许多设计细节还未能悟透其用意，目前也只能尽力将我的理解呈现出来，有错误非常欢迎指出。\n\n也是尝试着阅读过许多开源优秀的代码，这里记录一下我个人在阅读一份源码时的习惯：**适可而止的自低向上**。因为我在阅读一份完全不了解的源码时，迫不及待的想去知道每个每个模块、每个函数的实现细节，我也曾尝试以自顶向下去阅读一份源码，但是无法克制自己钻牛角尖的心，并且在经验尚浅，完全不了解设计背景的境况下，自顶向下去阅读一份源码，某一个函数的实现你只能去猜，由于经验尚浅，你大概率猜的也是错误的。所以，兜兜转转，我还是遵循我个人的习惯，自低向上去阅读一份源码。当然，应该：**适可而止的自低向上**，一些你完全知道起什么作用的模块其实就不必去深究了，比如：链表、红黑树、编码器等。深入细节的同时，也不要忘了我们的初心：框架的设计思想。\n\n<!-- more -->\n\n网络框架（包括库）的模块设计其实有很多相似的地方，比如都会有的：线程池、对epoll的封装、对io接口的封装、对tcpserver以及tcpclient的封装等。在阅读网络并发相关的源码时可以以这些方面入手。\n\n在深入阅读workflow的源码之后，特别是在kernel文件夹下对一些基础模块的封装中感受到了对c++的克制使用。因为kernel下基础模块的实现大多都是以c语言为主。这点大家要有一个心理准备。\n\n这里建议读者在阅读workflow，go-task源码时，以如下顺序阅读：\n\nExecQueue -> ExecSession -> Executor-> ExecRequest -> SubTask -> __ExecManager -> __WFGoTask -> WFGoTask -> SeriesWork\n\n## 正文\n\n下面直接以workflow给的gotask的示例作为本文的切入点：\n\n### 用法\n\ngo-task的用法示例如下：\n\n```cpp\n#include <stdio.h>\n#include <utility>\n#include \"workflow/WFTaskFactory.h\"\n#include \"workflow/WFFacilities.h\"\n\nvoid add(int a, int b, int& res) {\n    res = a + b;\n}\n\nint main(void) {\n    WFFacilities::WaitGroup wait_group(1);\n    int a = 1;\n    int b = 1;\n    int res;\n\n    WFGoTask *task = WFTaskFactory::create_go_task(\"test\", add, a, b, std::ref(res));   // cb1\n    task->set_callback([&](WFGoTask *task) {    // cb2\n        printf(\"%d + %d = %d\\n\", a, b, res);\n        wait_group.done();\n    });\n \n    task->start();\n    wait_group.wait();\n    return 0;\n}\n```\n\n如果你有一定网络编程的基础，应该很容易看懂这段小daemo。我们可以这段代码猜测：\n\n第一行声明了一个WaitGroup变量，从后面的代码可以知道wait_group的作用是：阻塞主线程等待计算完成。在创建wait_group后，将计算过程add函数封装在一个回调函数（cb1）当中，cb1作为一个参数再来构造一个任务--WFGoTask，然后调用WFGoTask::set_callback函数又设置了一个回调函数（cb2），从代码上可以看到，该cb2的作用是：打印计算结果并通知主线程计算完毕。\n\n所以经过上面的分析，我们可以知道：\n\n1. WaitGroup的实现一定是基于条件变量/信号量。\n\n2. 作为WFGoTask构造参数cb1，一定某一时刻被线程池里面的某个线程给调用了，并且该线程在调用add函数返回之后，一定是**直接或者间接**调用了一下cb2。\n\n### 源码简析\n\n示例代码中create_go_task的第一个参数其实是kernel目录下的ExecQueue队列对应的队列名。ExecQueue具体的用法以及作用稍后讲解，只需知道它是一个队列即可。\n\ncreate_go_task实现很简单，它里面就是依赖一个全局的单例__ExecManager，通过这个单例拿到队列名对应的队列指针以及Executor对象。然后将队列和Executor对象作为__WFGoTask的构造参数，创建出了继承自WFGoTask的__WFGoTask对象。\n\n这里备注一下：__ExecManager单例管理从队列名到队列指针的映射。并且在__ExecManager初始化时，会创建一个Executor对象。\n\n目前为止，出现了几个新的类：ExecQueue、Executor、__WFGoTask。\n\n对于ExecQueue从kernel目录下可以看到它的源码，单纯就是一个链表，使用的还是linux原生链表。它的每一个节点都是ExecSessionEntry类型，如下定义：\n\n```cpp\nstruct ExecSessionEntry {\n\tstruct list_head list;\n\tExecSession *session;\n\tthrdpool_t *thrdpool;\n};\n```\n\n单独看ExecQueue、ExecSession、ExecSessionEntry的源码一定会蒙（我就是），所以这里直接讲解Executor的实现，前面的三个类就是被它所使用。\n\n```cpp\nvoid Executor::executor_thread_routine(void *context) {\n\tExecQueue *queue = (ExecQueue *)context;\n\tstruct ExecSessionEntry *entry;\n\tExecSession *session;\n\tint empty;\n\n\tentry = list_entry(queue->session_list.next, struct ExecSessionEntry, list);\n\tpthread_mutex_lock(&queue->mutex);\n\tlist_del(&entry->list);\n\tempty = list_empty(&queue->session_list);\n\tpthread_mutex_unlock(&queue->mutex);\n\n\tsession = entry->session;\n\tif (!empty) {\n\t\tstruct thrdpool_task task = {\n\t\t\t.routine\t=\tExecutor::executor_thread_routine,\n\t\t\t.context\t=\tqueue\n\t\t};\n\t\t__thrdpool_schedule(&task, entry, entry->thrdpool);\n\t}\n\telse\n\t\tfree(entry);\n\n\tsession->execute();\n\tsession->handle(ES_STATE_FINISHED, 0);\n}\n```\n\n流程如下：\n\n1. 从队列中取ExecSessionEntry。\n\n2. 队列非空的话，将ExecSessionEntry中的session包装成thrdpool_task，并且将ExecSessionEntry的地址复用成线程池的__thrdpool_task_entry（PS：线程池在拿到__thrdpool_task_entry时用完后会自动free掉）。\n\n3. 队列为非空的话，直接free掉ExecSessionEntry。\n\n4. 最后执行ExecSession的execute、handle。\n\n这里的execute函数其实暗示着会调用cb1，handle其实就暗示里面会调用cb2。这下前后不就连起来了？（恍然大悟！）别着急，我们继续去剖析源码。\n\n细心的读者应该会发现这句代码没被放在锁里面：\n\n```cpp\nentry = list_entry(queue->session_list.next, struct ExecSessionEntry, list);\n```\n\n为什么可以不放在锁里面？如果线程2，在线程1执行完list_del之前，拿到了同一个entry，这样不会有野指针的问题吗？\n\n这里放出我的猜测：Executor::executor_thread_routine本身就已经保证了一个时刻只会有一个线程访问队列头部。这个函数的执行逻辑是这样的：当前Executor::executor_thread_routine的回调是靠上一个Executor::executor_thread_routine回调访问完链表头部之后触发的，**也即下一个队列头部访问的回调还得靠上一个回调来封装**。这里其实有点并行任务串行化的味道了。\n\n```cpp\nstruct thrdpool_task task = {\n    .routine\t=\tExecutor::executor_thread_routine,\n    .context\t=\tqueue\n};\n__thrdpool_schedule(&task, entry, entry->thrdpool);\n```\n\n最后是ExecQueue队列的start点，如下：\n\n```cpp\nint Executor::request(ExecSession *session, ExecQueue *queue) {\n\tstruct ExecSessionEntry *entry;\n\n\tsession->queue = queue;\n\tentry = (struct ExecSessionEntry *)malloc(sizeof (struct ExecSessionEntry));\n\tif (entry) {\n\t\tentry->session = session;\n\t\tentry->thrdpool = this->thrdpool;\n\t\tpthread_mutex_lock(&queue->mutex);\n\t\tlist_add_tail(&entry->list, &queue->session_list);\n\t\tif (queue->session_list.next == &entry->list) {\n\t\t\tstruct thrdpool_task task = {\n\t\t\t\t.routine\t=\tExecutor::executor_thread_routine,\n\t\t\t\t.context\t=\tqueue\n\t\t\t};\n\t\t\tif (thrdpool_schedule(&task, this->thrdpool) < 0) {\n\t\t\t\tlist_del(&entry->list);\n\t\t\t\tfree(entry);\n\t\t\t\tentry = NULL;\n\t\t\t}\n\t\t}\n\n\t\tpthread_mutex_unlock(&queue->mutex);\n\t}\n\n\treturn -!entry;\n}\n```\n\n从源码中可以看到，就是使用malloc分配一块内存，将session封装成ExecSessionEntry，然后将其添加到队列尾部，如果队列原来为空（意味着ExecQueue没有开始执行），就启动第一个Executor::executor_thread_routine，这样它会**自动链式触发**执行队列当中的每一个任务的回调。\n\n这里malloc分配的ExecSessionEntry由两个地方去释放：\n\n1. **这里malloc分配的ExecSessionEntry会被复用为线程池的__thrdpool_task_entry，最后被线程池调用free释放掉。**\n\n2. **在函数Executor::executor_thread_routine中，由ExecQueue最后一个任务调用free释放。**\n\n从这里可以看到，workflow针对内存的释放也是极其晦涩（反正我在阅读源码时就是这样感觉）。为了性能，根本没使用智能指针，完全靠malloc和free。内存池也没有，这点我是无法理解的。\n\n经过上面的分析我们了解了ExecSession、ExecQueue、Executor的作用，接下来我们分析一下，__WFGoTask是怎么使用这些类的。\n\n从本段开头了解到ExecQueue、Executor是作为__WFGoTask的构造参数，所以下面我们以__WFGoTask为主去看看它是怎么实现的\n\n```cpp\nclass __WFGoTask : public WFGoTask {\n    // ...\nprotected:\n\tvirtual void execute() {\n\t\tthis->go();\n\t}\n\nprotected:\n\tstd::function<void ()> go;\n\npublic:\n\t__WFGoTask(ExecQueue *queue, Executor *executor,\n\t\t\t   std::function<void ()>&& func) :\n\t\tWFGoTask(queue, executor),\n\t\tgo(std::move(func)) { /* ... */ }\n};\n```\n\n**使用了virtual关键字声明的execute函数！**，并且调用了go也即cb1！（衔接起来了！）\n\n继续看它基类的实现：\n\n```cpp\nclass WFGoTask : public ExecRequest {\npublic:\n\tvoid start() {\n\t\tassert(!series_of(this));\n\t\tWorkflow::start_series_work(this, nullptr);\n\t}\n\npublic:\n\tvoid *user_data;\n\npublic:\n\tvoid set_callback(std::function<void (WFGoTask *)> cb) {\n\t\tthis->callback = std::move(cb);\n\t}\n\nprotected:\n\tvirtual SubTask *done() {\n\t\tSeriesWork *series = series_of(this);\n\n\t\tif (this->callback)\n\t\t\tthis->callback(this);\n\n\t\tdelete this;\n\t\treturn series->pop();\n\t}\n\nprotected:\n\tstd::function<void (WFGoTask *)> callback;\n\npublic:\n\tWFGoTask(ExecQueue *queue, Executor *executor) :\n\t\tExecRequest(queue, executor) { /* ... */ }\n};\n```\n\nWFGoTask::start()正是示例当中调用的start函数，set_callback正是设置的cb2回调。我可以明确的说，start_series_work会创建一个SeriesWork对象，并且将SeriesWork对象的指针赋值给WFGoTask祖父类SubTask的user_data成员，并且SeriesWork其实也是一个队列，它是串行队列，队列当中的任务是有先后执行顺序的。这里串行队列的设计是为特定的有先后依赖顺序的计算场景所设计的。\n\n深入查看ExecRequest的实现：\n\n```cpp\nclass ExecRequest : public SubTask, public ExecSession {\npublic:\n\tExecRequest(ExecQueue *queue, Executor *executor) { /* ... */ }\n\npublic:\n\tvirtual void dispatch() {\n\t\tif (this->executor->request(this, this->queue) < 0)\n\t\t\tthis->handle(ES_STATE_ERROR, errno);\n\t}\n\nprotected:\n\tExecQueue *queue;\n\tExecutor *executor;\n\nprotected:\n\tvirtual void handle(int state, int error) {\n\t\tthis->state = state;\n\t\tthis->error = error;\n\t\tthis->subtask_done();\n\t}\n};\n```\n\nSubTask类和ExecSession类非常简单，由于篇幅有限这只列出我们关心的函数。\n\nSubTask有三个关键函数：\n\n虚函数：dispatch、done\n\n普通成员函数：subtask_done。\n\n而\n\nSubTask::dispatch 最终被重写为：ExecRequest::dispatch\n\nSubTask::done 最终被重写为：WFGoTask::done\n\n其中subtask_done实现如下：\n\n```cpp\nvoid SubTask::subtask_done() {\n\tSubTask *cur = this;\n\n\twhile (1) {\n\t\tcur = cur->done();\n\t\tif (cur) {\n\t\t\tcur->dispatch();\n\t\t}\n        /* ... */\n\n\t\tbreak;\n\t}\n}\n```\n\ndone的实现落实到了WFGoTask::done上，作用是销毁当前的task对象并且返回串行队列当中的下一个task，然后由subtask_done调用ExecRequest::dispatch将task挂到ExecQueue的链表上等待线程池的消费。\n\nExecSession有两个我们比较关心的纯虚函数：execute、handle。这两函数一路继承体系下来最终分别被重写为__WFGoTask::execute和ExecRequest::handle。\n\n所以在Executor::executor_thread_routine函数中调用的execute、handle函数最终被重写为：__WFGoTask::execute、ExecRequest::handle()。\n\n最后总结一下go-task执行的流程：\n\n1. 构造一个go-task对象 && 调用start函数。\n\n2. start函数会new一个first为go-task，last为nullptr的SeriesWork对象 && 调用first的dispatch也即ExecRequest::dispatch。\n\n3. executor的request函数，将go-task挂到ExecQueue链表的尾部上，由线程池去消费。当然，如果ExecQueue原来是为空的，就创建第一个Executor::executor_thread_routine。\n\n4. Executor::executor_thread_routine会**链式**触发让线程池处理ExecQueue每一个任务。\n\n5. 调用任务的__WFGoTask::execute。\n\n6. 调用任务的ExecRequest::handle。\n\n7. 调用SubTask::subtask_done && （如果存在的话）调用SeriesWork对象的下一个task的dispatch（PS，可能不是ExecRequest::dispatch这个重载函数）\n\n8. 调用WFGoTask::done。删除当前task对象并且返回串行队列的下一个串行任务。\n\n**最后要还要提醒的一句是：Executor::executor_thread_routine在向ExecQueue的链表取任务时是保证非并发的，但是在执行任务的execute时，是有可能是并发执行的！** 有人可能会注意到那为什么在向链表取任务时要加锁？因为这把锁可能防止Executor::executor_thread_routine和Executor::request之间的竞争问题，而Executor::executor_thread_routine和Executor::executor_thread_routine之间并不存在竞争问题。\n\n---\n\n**本章完结**","slug":"workflow/go_task","published":1,"updated":"2025-09-28T14:32:17.118Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9t000yq8ws5v75f0jg","content":"<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlow GO-Task 源码分析</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlow源码剖析——Communicator之TCPServer（上）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlow源码剖析——Communicator之TCPServer（中）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlow源码剖析——Communicator之TCPServer（下）</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>任何好的框架的设计都是围绕着一个核心思想去展开，sylar的一切皆协程、muduo的one loop per thread等。一切皆是任务流就是workflow的精髓。（PS，目前作者功力尚浅，许多设计细节还未能悟透其用意，目前也只能尽力将我的理解呈现出来，有错误非常欢迎指出。</p>\n<p>也是尝试着阅读过许多开源优秀的代码，这里记录一下我个人在阅读一份源码时的习惯：<strong>适可而止的自低向上</strong>。因为我在阅读一份完全不了解的源码时，迫不及待的想去知道每个每个模块、每个函数的实现细节，我也曾尝试以自顶向下去阅读一份源码，但是无法克制自己钻牛角尖的心，并且在经验尚浅，完全不了解设计背景的境况下，自顶向下去阅读一份源码，某一个函数的实现你只能去猜，由于经验尚浅，你大概率猜的也是错误的。所以，兜兜转转，我还是遵循我个人的习惯，自低向上去阅读一份源码。当然，应该：<strong>适可而止的自低向上</strong>，一些你完全知道起什么作用的模块其实就不必去深究了，比如：链表、红黑树、编码器等。深入细节的同时，也不要忘了我们的初心：框架的设计思想。</p>\n<span id=\"more\"></span>\n\n<p>网络框架（包括库）的模块设计其实有很多相似的地方，比如都会有的：线程池、对epoll的封装、对io接口的封装、对tcpserver以及tcpclient的封装等。在阅读网络并发相关的源码时可以以这些方面入手。</p>\n<p>在深入阅读workflow的源码之后，特别是在kernel文件夹下对一些基础模块的封装中感受到了对c++的克制使用。因为kernel下基础模块的实现大多都是以c语言为主。这点大家要有一个心理准备。</p>\n<p>这里建议读者在阅读workflow，go-task源码时，以如下顺序阅读：</p>\n<p>ExecQueue -&gt; ExecSession -&gt; Executor-&gt; ExecRequest -&gt; SubTask -&gt; __ExecManager -&gt; __WFGoTask -&gt; WFGoTask -&gt; SeriesWork</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>下面直接以workflow给的gotask的示例作为本文的切入点：</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>go-task的用法示例如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFTaskFactory.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFFacilities.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span>&amp; res)</span> </span>&#123;</span><br><span class=\"line\">    res = a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">WFFacilities::WaitGroup <span class=\"title\">wait_group</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    WFGoTask *task = WFTaskFactory::<span class=\"built_in\">create_go_task</span>(<span class=\"string\">&quot;test&quot;</span>, add, a, b, std::<span class=\"built_in\">ref</span>(res));   <span class=\"comment\">// cb1</span></span><br><span class=\"line\">    task-&gt;<span class=\"built_in\">set_callback</span>([&amp;](WFGoTask *task) &#123;    <span class=\"comment\">// cb2</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d + %d = %d\\n&quot;</span>, a, b, res);</span><br><span class=\"line\">        wait_group.<span class=\"built_in\">done</span>();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">    task-&gt;<span class=\"built_in\">start</span>();</span><br><span class=\"line\">    wait_group.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你有一定网络编程的基础，应该很容易看懂这段小daemo。我们可以这段代码猜测：</p>\n<p>第一行声明了一个WaitGroup变量，从后面的代码可以知道wait_group的作用是：阻塞主线程等待计算完成。在创建wait_group后，将计算过程add函数封装在一个回调函数（cb1）当中，cb1作为一个参数再来构造一个任务–WFGoTask，然后调用WFGoTask::set_callback函数又设置了一个回调函数（cb2），从代码上可以看到，该cb2的作用是：打印计算结果并通知主线程计算完毕。</p>\n<p>所以经过上面的分析，我们可以知道：</p>\n<ol>\n<li><p>WaitGroup的实现一定是基于条件变量&#x2F;信号量。</p>\n</li>\n<li><p>作为WFGoTask构造参数cb1，一定某一时刻被线程池里面的某个线程给调用了，并且该线程在调用add函数返回之后，一定是<strong>直接或者间接</strong>调用了一下cb2。</p>\n</li>\n</ol>\n<h3 id=\"源码简析\"><a href=\"#源码简析\" class=\"headerlink\" title=\"源码简析\"></a>源码简析</h3><p>示例代码中create_go_task的第一个参数其实是kernel目录下的ExecQueue队列对应的队列名。ExecQueue具体的用法以及作用稍后讲解，只需知道它是一个队列即可。</p>\n<p>create_go_task实现很简单，它里面就是依赖一个全局的单例__ExecManager，通过这个单例拿到队列名对应的队列指针以及Executor对象。然后将队列和Executor对象作为__WFGoTask的构造参数，创建出了继承自WFGoTask的__WFGoTask对象。</p>\n<p>这里备注一下：__ExecManager单例管理从队列名到队列指针的映射。并且在__ExecManager初始化时，会创建一个Executor对象。</p>\n<p>目前为止，出现了几个新的类：ExecQueue、Executor、__WFGoTask。</p>\n<p>对于ExecQueue从kernel目录下可以看到它的源码，单纯就是一个链表，使用的还是linux原生链表。它的每一个节点都是ExecSessionEntry类型，如下定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ExecSessionEntry</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> list;</span><br><span class=\"line\">\tExecSession *session;</span><br><span class=\"line\">\t<span class=\"type\">thrdpool_t</span> *thrdpool;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>单独看ExecQueue、ExecSession、ExecSessionEntry的源码一定会蒙（我就是），所以这里直接讲解Executor的实现，前面的三个类就是被它所使用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Executor::executor_thread_routine</span><span class=\"params\">(<span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">\tExecQueue *queue = (ExecQueue *)context;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">ExecSessionEntry</span> *entry;</span><br><span class=\"line\">\tExecSession *session;</span><br><span class=\"line\">\t<span class=\"type\">int</span> empty;</span><br><span class=\"line\"></span><br><span class=\"line\">\tentry = <span class=\"built_in\">list_entry</span>(queue-&gt;session_list.next, <span class=\"keyword\">struct</span> ExecSessionEntry, list);</span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"built_in\">list_del</span>(&amp;entry-&gt;list);</span><br><span class=\"line\">\tempty = <span class=\"built_in\">list_empty</span>(&amp;queue-&gt;session_list);</span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">\tsession = entry-&gt;session;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!empty) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">thrdpool_task</span> task = &#123;</span><br><span class=\"line\">\t\t\t.routine\t=\tExecutor::executor_thread_routine,</span><br><span class=\"line\">\t\t\t.context\t=\tqueue</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t__thrdpool_schedule(&amp;task, entry, entry-&gt;thrdpool);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(entry);</span><br><span class=\"line\"></span><br><span class=\"line\">\tsession-&gt;<span class=\"built_in\">execute</span>();</span><br><span class=\"line\">\tsession-&gt;<span class=\"built_in\">handle</span>(ES_STATE_FINISHED, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>流程如下：</p>\n<ol>\n<li><p>从队列中取ExecSessionEntry。</p>\n</li>\n<li><p>队列非空的话，将ExecSessionEntry中的session包装成thrdpool_task，并且将ExecSessionEntry的地址复用成线程池的__thrdpool_task_entry（PS：线程池在拿到__thrdpool_task_entry时用完后会自动free掉）。</p>\n</li>\n<li><p>队列为非空的话，直接free掉ExecSessionEntry。</p>\n</li>\n<li><p>最后执行ExecSession的execute、handle。</p>\n</li>\n</ol>\n<p>这里的execute函数其实暗示着会调用cb1，handle其实就暗示里面会调用cb2。这下前后不就连起来了？（恍然大悟！）别着急，我们继续去剖析源码。</p>\n<p>细心的读者应该会发现这句代码没被放在锁里面：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry = <span class=\"built_in\">list_entry</span>(queue-&gt;session_list.next, <span class=\"keyword\">struct</span> ExecSessionEntry, list);</span><br></pre></td></tr></table></figure>\n\n<p>为什么可以不放在锁里面？如果线程2，在线程1执行完list_del之前，拿到了同一个entry，这样不会有野指针的问题吗？</p>\n<p>这里放出我的猜测：Executor::executor_thread_routine本身就已经保证了一个时刻只会有一个线程访问队列头部。这个函数的执行逻辑是这样的：当前Executor::executor_thread_routine的回调是靠上一个Executor::executor_thread_routine回调访问完链表头部之后触发的，<strong>也即下一个队列头部访问的回调还得靠上一个回调来封装</strong>。这里其实有点并行任务串行化的味道了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">thrdpool_task</span> task = &#123;</span><br><span class=\"line\">    .routine\t=\tExecutor::executor_thread_routine,</span><br><span class=\"line\">    .context\t=\tqueue</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">__thrdpool_schedule(&amp;task, entry, entry-&gt;thrdpool);</span><br></pre></td></tr></table></figure>\n\n<p>最后是ExecQueue队列的start点，如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Executor::request</span><span class=\"params\">(ExecSession *session, ExecQueue *queue)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">ExecSessionEntry</span> *entry;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsession-&gt;queue = queue;</span><br><span class=\"line\">\tentry = (<span class=\"keyword\">struct</span> ExecSessionEntry *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> ExecSessionEntry));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (entry) &#123;</span><br><span class=\"line\">\t\tentry-&gt;session = session;</span><br><span class=\"line\">\t\tentry-&gt;thrdpool = <span class=\"keyword\">this</span>-&gt;thrdpool;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_add_tail</span>(&amp;entry-&gt;list, &amp;queue-&gt;session_list);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (queue-&gt;session_list.next == &amp;entry-&gt;list) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">thrdpool_task</span> task = &#123;</span><br><span class=\"line\">\t\t\t\t.routine\t=\tExecutor::executor_thread_routine,</span><br><span class=\"line\">\t\t\t\t.context\t=\tqueue</span><br><span class=\"line\">\t\t\t&#125;;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">thrdpool_schedule</span>(&amp;task, <span class=\"keyword\">this</span>-&gt;thrdpool) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">list_del</span>(&amp;entry-&gt;list);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">free</span>(entry);</span><br><span class=\"line\">\t\t\t\tentry = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -!entry;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从源码中可以看到，就是使用malloc分配一块内存，将session封装成ExecSessionEntry，然后将其添加到队列尾部，如果队列原来为空（意味着ExecQueue没有开始执行），就启动第一个Executor::executor_thread_routine，这样它会<strong>自动链式触发</strong>执行队列当中的每一个任务的回调。</p>\n<p>这里malloc分配的ExecSessionEntry由两个地方去释放：</p>\n<ol>\n<li><p><strong>这里malloc分配的ExecSessionEntry会被复用为线程池的__thrdpool_task_entry，最后被线程池调用free释放掉。</strong></p>\n</li>\n<li><p><strong>在函数Executor::executor_thread_routine中，由ExecQueue最后一个任务调用free释放。</strong></p>\n</li>\n</ol>\n<p>从这里可以看到，workflow针对内存的释放也是极其晦涩（反正我在阅读源码时就是这样感觉）。为了性能，根本没使用智能指针，完全靠malloc和free。内存池也没有，这点我是无法理解的。</p>\n<p>经过上面的分析我们了解了ExecSession、ExecQueue、Executor的作用，接下来我们分析一下，__WFGoTask是怎么使用这些类的。</p>\n<p>从本段开头了解到ExecQueue、Executor是作为__WFGoTask的构造参数，所以下面我们以__WFGoTask为主去看看它是怎么实现的</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">__WFGoTask</span> : <span class=\"keyword\">public</span> WFGoTask &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">go</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> ()&gt; go;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t__WFGoTask(ExecQueue *queue, Executor *executor,</span><br><span class=\"line\">\t\t\t   std::function&lt;<span class=\"built_in\">void</span> ()&gt;&amp;&amp; func) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFGoTask</span>(queue, executor),</span><br><span class=\"line\">\t\t<span class=\"built_in\">go</span>(std::<span class=\"built_in\">move</span>(func)) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用了virtual关键字声明的execute函数！</strong>，并且调用了go也即cb1！（衔接起来了！）</p>\n<p>继续看它基类的实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFGoTask</span> : <span class=\"keyword\">public</span> ExecRequest &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">assert</span>(!<span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">\t\tWorkflow::<span class=\"built_in\">start_series_work</span>(<span class=\"keyword\">this</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">void</span> *user_data;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_callback</span><span class=\"params\">(std::function&lt;<span class=\"type\">void</span> (WFGoTask *)&gt; cb)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;callback = std::<span class=\"built_in\">move</span>(cb);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> SubTask *<span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSeriesWork *series = <span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;callback)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">callback</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> series-&gt;<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> (WFGoTask *)&gt; callback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFGoTask</span>(ExecQueue *queue, Executor *executor) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">ExecRequest</span>(queue, executor) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>WFGoTask::start()正是示例当中调用的start函数，set_callback正是设置的cb2回调。我可以明确的说，start_series_work会创建一个SeriesWork对象，并且将SeriesWork对象的指针赋值给WFGoTask祖父类SubTask的user_data成员，并且SeriesWork其实也是一个队列，它是串行队列，队列当中的任务是有先后执行顺序的。这里串行队列的设计是为特定的有先后依赖顺序的计算场景所设计的。</p>\n<p>深入查看ExecRequest的实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExecRequest</span> : <span class=\"keyword\">public</span> SubTask, <span class=\"keyword\">public</span> ExecSession &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">ExecRequest</span>(ExecQueue *queue, Executor *executor) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;executor-&gt;<span class=\"built_in\">request</span>(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>-&gt;queue) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">handle</span>(ES_STATE_ERROR, errno);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tExecQueue *queue;</span><br><span class=\"line\">\tExecutor *executor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;state = state;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;error = error;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>SubTask类和ExecSession类非常简单，由于篇幅有限这只列出我们关心的函数。</p>\n<p>SubTask有三个关键函数：</p>\n<p>虚函数：dispatch、done</p>\n<p>普通成员函数：subtask_done。</p>\n<p>而</p>\n<p>SubTask::dispatch 最终被重写为：ExecRequest::dispatch</p>\n<p>SubTask::done 最终被重写为：WFGoTask::done</p>\n<p>其中subtask_done实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SubTask::subtask_done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tSubTask *cur = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tcur = cur-&gt;<span class=\"built_in\">done</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur) &#123;</span><br><span class=\"line\">\t\t\tcur-&gt;<span class=\"built_in\">dispatch</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">/* ... */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>done的实现落实到了WFGoTask::done上，作用是销毁当前的task对象并且返回串行队列当中的下一个task，然后由subtask_done调用ExecRequest::dispatch将task挂到ExecQueue的链表上等待线程池的消费。</p>\n<p>ExecSession有两个我们比较关心的纯虚函数：execute、handle。这两函数一路继承体系下来最终分别被重写为__WFGoTask::execute和ExecRequest::handle。</p>\n<p>所以在Executor::executor_thread_routine函数中调用的execute、handle函数最终被重写为：__WFGoTask::execute、ExecRequest::handle()。</p>\n<p>最后总结一下go-task执行的流程：</p>\n<ol>\n<li><p>构造一个go-task对象 &amp;&amp; 调用start函数。</p>\n</li>\n<li><p>start函数会new一个first为go-task，last为nullptr的SeriesWork对象 &amp;&amp; 调用first的dispatch也即ExecRequest::dispatch。</p>\n</li>\n<li><p>executor的request函数，将go-task挂到ExecQueue链表的尾部上，由线程池去消费。当然，如果ExecQueue原来是为空的，就创建第一个Executor::executor_thread_routine。</p>\n</li>\n<li><p>Executor::executor_thread_routine会<strong>链式</strong>触发让线程池处理ExecQueue每一个任务。</p>\n</li>\n<li><p>调用任务的__WFGoTask::execute。</p>\n</li>\n<li><p>调用任务的ExecRequest::handle。</p>\n</li>\n<li><p>调用SubTask::subtask_done &amp;&amp; （如果存在的话）调用SeriesWork对象的下一个task的dispatch（PS，可能不是ExecRequest::dispatch这个重载函数）</p>\n</li>\n<li><p>调用WFGoTask::done。删除当前task对象并且返回串行队列的下一个串行任务。</p>\n</li>\n</ol>\n<p><strong>最后要还要提醒的一句是：Executor::executor_thread_routine在向ExecQueue的链表取任务时是保证非并发的，但是在执行任务的execute时，是有可能是并发执行的！</strong> 有人可能会注意到那为什么在向链表取任务时要加锁？因为这把锁可能防止Executor::executor_thread_routine和Executor::request之间的竞争问题，而Executor::executor_thread_routine和Executor::executor_thread_routine之间并不存在竞争问题。</p>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlow GO-Task 源码分析</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlow源码剖析——Communicator之TCPServer（上）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlow源码剖析——Communicator之TCPServer（中）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlow源码剖析——Communicator之TCPServer（下）</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>任何好的框架的设计都是围绕着一个核心思想去展开，sylar的一切皆协程、muduo的one loop per thread等。一切皆是任务流就是workflow的精髓。（PS，目前作者功力尚浅，许多设计细节还未能悟透其用意，目前也只能尽力将我的理解呈现出来，有错误非常欢迎指出。</p>\n<p>也是尝试着阅读过许多开源优秀的代码，这里记录一下我个人在阅读一份源码时的习惯：<strong>适可而止的自低向上</strong>。因为我在阅读一份完全不了解的源码时，迫不及待的想去知道每个每个模块、每个函数的实现细节，我也曾尝试以自顶向下去阅读一份源码，但是无法克制自己钻牛角尖的心，并且在经验尚浅，完全不了解设计背景的境况下，自顶向下去阅读一份源码，某一个函数的实现你只能去猜，由于经验尚浅，你大概率猜的也是错误的。所以，兜兜转转，我还是遵循我个人的习惯，自低向上去阅读一份源码。当然，应该：<strong>适可而止的自低向上</strong>，一些你完全知道起什么作用的模块其实就不必去深究了，比如：链表、红黑树、编码器等。深入细节的同时，也不要忘了我们的初心：框架的设计思想。</p>","more":"<p>网络框架（包括库）的模块设计其实有很多相似的地方，比如都会有的：线程池、对epoll的封装、对io接口的封装、对tcpserver以及tcpclient的封装等。在阅读网络并发相关的源码时可以以这些方面入手。</p>\n<p>在深入阅读workflow的源码之后，特别是在kernel文件夹下对一些基础模块的封装中感受到了对c++的克制使用。因为kernel下基础模块的实现大多都是以c语言为主。这点大家要有一个心理准备。</p>\n<p>这里建议读者在阅读workflow，go-task源码时，以如下顺序阅读：</p>\n<p>ExecQueue -&gt; ExecSession -&gt; Executor-&gt; ExecRequest -&gt; SubTask -&gt; __ExecManager -&gt; __WFGoTask -&gt; WFGoTask -&gt; SeriesWork</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>下面直接以workflow给的gotask的示例作为本文的切入点：</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>go-task的用法示例如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFTaskFactory.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFFacilities.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span>&amp; res)</span> </span>&#123;</span><br><span class=\"line\">    res = a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">WFFacilities::WaitGroup <span class=\"title\">wait_group</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    WFGoTask *task = WFTaskFactory::<span class=\"built_in\">create_go_task</span>(<span class=\"string\">&quot;test&quot;</span>, add, a, b, std::<span class=\"built_in\">ref</span>(res));   <span class=\"comment\">// cb1</span></span><br><span class=\"line\">    task-&gt;<span class=\"built_in\">set_callback</span>([&amp;](WFGoTask *task) &#123;    <span class=\"comment\">// cb2</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d + %d = %d\\n&quot;</span>, a, b, res);</span><br><span class=\"line\">        wait_group.<span class=\"built_in\">done</span>();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">    task-&gt;<span class=\"built_in\">start</span>();</span><br><span class=\"line\">    wait_group.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你有一定网络编程的基础，应该很容易看懂这段小daemo。我们可以这段代码猜测：</p>\n<p>第一行声明了一个WaitGroup变量，从后面的代码可以知道wait_group的作用是：阻塞主线程等待计算完成。在创建wait_group后，将计算过程add函数封装在一个回调函数（cb1）当中，cb1作为一个参数再来构造一个任务–WFGoTask，然后调用WFGoTask::set_callback函数又设置了一个回调函数（cb2），从代码上可以看到，该cb2的作用是：打印计算结果并通知主线程计算完毕。</p>\n<p>所以经过上面的分析，我们可以知道：</p>\n<ol>\n<li><p>WaitGroup的实现一定是基于条件变量&#x2F;信号量。</p>\n</li>\n<li><p>作为WFGoTask构造参数cb1，一定某一时刻被线程池里面的某个线程给调用了，并且该线程在调用add函数返回之后，一定是<strong>直接或者间接</strong>调用了一下cb2。</p>\n</li>\n</ol>\n<h3 id=\"源码简析\"><a href=\"#源码简析\" class=\"headerlink\" title=\"源码简析\"></a>源码简析</h3><p>示例代码中create_go_task的第一个参数其实是kernel目录下的ExecQueue队列对应的队列名。ExecQueue具体的用法以及作用稍后讲解，只需知道它是一个队列即可。</p>\n<p>create_go_task实现很简单，它里面就是依赖一个全局的单例__ExecManager，通过这个单例拿到队列名对应的队列指针以及Executor对象。然后将队列和Executor对象作为__WFGoTask的构造参数，创建出了继承自WFGoTask的__WFGoTask对象。</p>\n<p>这里备注一下：__ExecManager单例管理从队列名到队列指针的映射。并且在__ExecManager初始化时，会创建一个Executor对象。</p>\n<p>目前为止，出现了几个新的类：ExecQueue、Executor、__WFGoTask。</p>\n<p>对于ExecQueue从kernel目录下可以看到它的源码，单纯就是一个链表，使用的还是linux原生链表。它的每一个节点都是ExecSessionEntry类型，如下定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ExecSessionEntry</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> list;</span><br><span class=\"line\">\tExecSession *session;</span><br><span class=\"line\">\t<span class=\"type\">thrdpool_t</span> *thrdpool;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>单独看ExecQueue、ExecSession、ExecSessionEntry的源码一定会蒙（我就是），所以这里直接讲解Executor的实现，前面的三个类就是被它所使用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Executor::executor_thread_routine</span><span class=\"params\">(<span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">\tExecQueue *queue = (ExecQueue *)context;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">ExecSessionEntry</span> *entry;</span><br><span class=\"line\">\tExecSession *session;</span><br><span class=\"line\">\t<span class=\"type\">int</span> empty;</span><br><span class=\"line\"></span><br><span class=\"line\">\tentry = <span class=\"built_in\">list_entry</span>(queue-&gt;session_list.next, <span class=\"keyword\">struct</span> ExecSessionEntry, list);</span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"built_in\">list_del</span>(&amp;entry-&gt;list);</span><br><span class=\"line\">\tempty = <span class=\"built_in\">list_empty</span>(&amp;queue-&gt;session_list);</span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">\tsession = entry-&gt;session;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!empty) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">thrdpool_task</span> task = &#123;</span><br><span class=\"line\">\t\t\t.routine\t=\tExecutor::executor_thread_routine,</span><br><span class=\"line\">\t\t\t.context\t=\tqueue</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t__thrdpool_schedule(&amp;task, entry, entry-&gt;thrdpool);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(entry);</span><br><span class=\"line\"></span><br><span class=\"line\">\tsession-&gt;<span class=\"built_in\">execute</span>();</span><br><span class=\"line\">\tsession-&gt;<span class=\"built_in\">handle</span>(ES_STATE_FINISHED, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>流程如下：</p>\n<ol>\n<li><p>从队列中取ExecSessionEntry。</p>\n</li>\n<li><p>队列非空的话，将ExecSessionEntry中的session包装成thrdpool_task，并且将ExecSessionEntry的地址复用成线程池的__thrdpool_task_entry（PS：线程池在拿到__thrdpool_task_entry时用完后会自动free掉）。</p>\n</li>\n<li><p>队列为非空的话，直接free掉ExecSessionEntry。</p>\n</li>\n<li><p>最后执行ExecSession的execute、handle。</p>\n</li>\n</ol>\n<p>这里的execute函数其实暗示着会调用cb1，handle其实就暗示里面会调用cb2。这下前后不就连起来了？（恍然大悟！）别着急，我们继续去剖析源码。</p>\n<p>细心的读者应该会发现这句代码没被放在锁里面：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry = <span class=\"built_in\">list_entry</span>(queue-&gt;session_list.next, <span class=\"keyword\">struct</span> ExecSessionEntry, list);</span><br></pre></td></tr></table></figure>\n\n<p>为什么可以不放在锁里面？如果线程2，在线程1执行完list_del之前，拿到了同一个entry，这样不会有野指针的问题吗？</p>\n<p>这里放出我的猜测：Executor::executor_thread_routine本身就已经保证了一个时刻只会有一个线程访问队列头部。这个函数的执行逻辑是这样的：当前Executor::executor_thread_routine的回调是靠上一个Executor::executor_thread_routine回调访问完链表头部之后触发的，<strong>也即下一个队列头部访问的回调还得靠上一个回调来封装</strong>。这里其实有点并行任务串行化的味道了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">thrdpool_task</span> task = &#123;</span><br><span class=\"line\">    .routine\t=\tExecutor::executor_thread_routine,</span><br><span class=\"line\">    .context\t=\tqueue</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">__thrdpool_schedule(&amp;task, entry, entry-&gt;thrdpool);</span><br></pre></td></tr></table></figure>\n\n<p>最后是ExecQueue队列的start点，如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Executor::request</span><span class=\"params\">(ExecSession *session, ExecQueue *queue)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">ExecSessionEntry</span> *entry;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsession-&gt;queue = queue;</span><br><span class=\"line\">\tentry = (<span class=\"keyword\">struct</span> ExecSessionEntry *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> ExecSessionEntry));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (entry) &#123;</span><br><span class=\"line\">\t\tentry-&gt;session = session;</span><br><span class=\"line\">\t\tentry-&gt;thrdpool = <span class=\"keyword\">this</span>-&gt;thrdpool;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_add_tail</span>(&amp;entry-&gt;list, &amp;queue-&gt;session_list);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (queue-&gt;session_list.next == &amp;entry-&gt;list) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">thrdpool_task</span> task = &#123;</span><br><span class=\"line\">\t\t\t\t.routine\t=\tExecutor::executor_thread_routine,</span><br><span class=\"line\">\t\t\t\t.context\t=\tqueue</span><br><span class=\"line\">\t\t\t&#125;;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">thrdpool_schedule</span>(&amp;task, <span class=\"keyword\">this</span>-&gt;thrdpool) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">list_del</span>(&amp;entry-&gt;list);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">free</span>(entry);</span><br><span class=\"line\">\t\t\t\tentry = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -!entry;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从源码中可以看到，就是使用malloc分配一块内存，将session封装成ExecSessionEntry，然后将其添加到队列尾部，如果队列原来为空（意味着ExecQueue没有开始执行），就启动第一个Executor::executor_thread_routine，这样它会<strong>自动链式触发</strong>执行队列当中的每一个任务的回调。</p>\n<p>这里malloc分配的ExecSessionEntry由两个地方去释放：</p>\n<ol>\n<li><p><strong>这里malloc分配的ExecSessionEntry会被复用为线程池的__thrdpool_task_entry，最后被线程池调用free释放掉。</strong></p>\n</li>\n<li><p><strong>在函数Executor::executor_thread_routine中，由ExecQueue最后一个任务调用free释放。</strong></p>\n</li>\n</ol>\n<p>从这里可以看到，workflow针对内存的释放也是极其晦涩（反正我在阅读源码时就是这样感觉）。为了性能，根本没使用智能指针，完全靠malloc和free。内存池也没有，这点我是无法理解的。</p>\n<p>经过上面的分析我们了解了ExecSession、ExecQueue、Executor的作用，接下来我们分析一下，__WFGoTask是怎么使用这些类的。</p>\n<p>从本段开头了解到ExecQueue、Executor是作为__WFGoTask的构造参数，所以下面我们以__WFGoTask为主去看看它是怎么实现的</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">__WFGoTask</span> : <span class=\"keyword\">public</span> WFGoTask &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">go</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> ()&gt; go;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t__WFGoTask(ExecQueue *queue, Executor *executor,</span><br><span class=\"line\">\t\t\t   std::function&lt;<span class=\"built_in\">void</span> ()&gt;&amp;&amp; func) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFGoTask</span>(queue, executor),</span><br><span class=\"line\">\t\t<span class=\"built_in\">go</span>(std::<span class=\"built_in\">move</span>(func)) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用了virtual关键字声明的execute函数！</strong>，并且调用了go也即cb1！（衔接起来了！）</p>\n<p>继续看它基类的实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFGoTask</span> : <span class=\"keyword\">public</span> ExecRequest &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">assert</span>(!<span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">\t\tWorkflow::<span class=\"built_in\">start_series_work</span>(<span class=\"keyword\">this</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">void</span> *user_data;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_callback</span><span class=\"params\">(std::function&lt;<span class=\"type\">void</span> (WFGoTask *)&gt; cb)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;callback = std::<span class=\"built_in\">move</span>(cb);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> SubTask *<span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSeriesWork *series = <span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;callback)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">callback</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> series-&gt;<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> (WFGoTask *)&gt; callback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFGoTask</span>(ExecQueue *queue, Executor *executor) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">ExecRequest</span>(queue, executor) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>WFGoTask::start()正是示例当中调用的start函数，set_callback正是设置的cb2回调。我可以明确的说，start_series_work会创建一个SeriesWork对象，并且将SeriesWork对象的指针赋值给WFGoTask祖父类SubTask的user_data成员，并且SeriesWork其实也是一个队列，它是串行队列，队列当中的任务是有先后执行顺序的。这里串行队列的设计是为特定的有先后依赖顺序的计算场景所设计的。</p>\n<p>深入查看ExecRequest的实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExecRequest</span> : <span class=\"keyword\">public</span> SubTask, <span class=\"keyword\">public</span> ExecSession &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">ExecRequest</span>(ExecQueue *queue, Executor *executor) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;executor-&gt;<span class=\"built_in\">request</span>(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>-&gt;queue) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">handle</span>(ES_STATE_ERROR, errno);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tExecQueue *queue;</span><br><span class=\"line\">\tExecutor *executor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;state = state;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;error = error;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>SubTask类和ExecSession类非常简单，由于篇幅有限这只列出我们关心的函数。</p>\n<p>SubTask有三个关键函数：</p>\n<p>虚函数：dispatch、done</p>\n<p>普通成员函数：subtask_done。</p>\n<p>而</p>\n<p>SubTask::dispatch 最终被重写为：ExecRequest::dispatch</p>\n<p>SubTask::done 最终被重写为：WFGoTask::done</p>\n<p>其中subtask_done实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SubTask::subtask_done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tSubTask *cur = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tcur = cur-&gt;<span class=\"built_in\">done</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur) &#123;</span><br><span class=\"line\">\t\t\tcur-&gt;<span class=\"built_in\">dispatch</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">/* ... */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>done的实现落实到了WFGoTask::done上，作用是销毁当前的task对象并且返回串行队列当中的下一个task，然后由subtask_done调用ExecRequest::dispatch将task挂到ExecQueue的链表上等待线程池的消费。</p>\n<p>ExecSession有两个我们比较关心的纯虚函数：execute、handle。这两函数一路继承体系下来最终分别被重写为__WFGoTask::execute和ExecRequest::handle。</p>\n<p>所以在Executor::executor_thread_routine函数中调用的execute、handle函数最终被重写为：__WFGoTask::execute、ExecRequest::handle()。</p>\n<p>最后总结一下go-task执行的流程：</p>\n<ol>\n<li><p>构造一个go-task对象 &amp;&amp; 调用start函数。</p>\n</li>\n<li><p>start函数会new一个first为go-task，last为nullptr的SeriesWork对象 &amp;&amp; 调用first的dispatch也即ExecRequest::dispatch。</p>\n</li>\n<li><p>executor的request函数，将go-task挂到ExecQueue链表的尾部上，由线程池去消费。当然，如果ExecQueue原来是为空的，就创建第一个Executor::executor_thread_routine。</p>\n</li>\n<li><p>Executor::executor_thread_routine会<strong>链式</strong>触发让线程池处理ExecQueue每一个任务。</p>\n</li>\n<li><p>调用任务的__WFGoTask::execute。</p>\n</li>\n<li><p>调用任务的ExecRequest::handle。</p>\n</li>\n<li><p>调用SubTask::subtask_done &amp;&amp; （如果存在的话）调用SeriesWork对象的下一个task的dispatch（PS，可能不是ExecRequest::dispatch这个重载函数）</p>\n</li>\n<li><p>调用WFGoTask::done。删除当前task对象并且返回串行队列的下一个串行任务。</p>\n</li>\n</ol>\n<p><strong>最后要还要提醒的一句是：Executor::executor_thread_routine在向ExecQueue的链表取任务时是保证非并发的，但是在执行任务的execute时，是有可能是并发执行的！</strong> 有人可能会注意到那为什么在向链表取任务时要加锁？因为这把锁可能防止Executor::executor_thread_routine和Executor::request之间的竞争问题，而Executor::executor_thread_routine和Executor::executor_thread_routine之间并不存在竞争问题。</p>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"WorkFlow源码剖析——Communicator之TCPServer（中）","date":"2024-11-04T04:00:00.000Z","_content":"\n[WorkFlow源码剖析——GO-Task 源码分析](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlow源码剖析——Communicator之TCPServer（上）](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlow源码剖析——Communicator之TCPServer（中）](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlow源码剖析——Communicator之TCPServer（下）](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\n## 前言\n\n上节博客已经详细介绍了workflow的poller的实现，这节我们来看看Communicator是如何利用poller的，对连接对象生命周期的管理。（PS：与其说Communicator利用的是poller，其实Communicator使用的是mpoller，上节在介绍poller时也提到过mpoller，现场帮读者回忆一下：mpoller是poller的manager类，管理多个poller事件池，对外提供的接口负责将各种poller_node负载均衡的分散给不同的poller。）\n\n上节在介绍poller时，出现了各种回调，比如poller->callback()、node->data.accept()、node->data.partial_written()、node->data.create_message()等，当时我们总是一笔带过，没有去深入分析这些回调会做什么？并且每次在IO事件结束都会回调poller->callback()为什么要这样做？在poller当中，只看到了针对poller_node的malloc函数，而没有看到对应的free函数，哪里调用了free函数去释放poller_node？\n\n<!-- more -->\n\n别着急，本节的源码分析会逐步揭晓这些疑问。\n\n同样的，注意里还是放在TCPServer上，对于SSL和UDP相关的内容直接忽略。先把TCP给模清楚。\n\n## 管理连接对象的实现\n\n### 连接上下文数据结构的分析\n\n既然谈到对连接对象的管理，那Communicator必然有一个数据结构来表示一个连接上下文对象，它就是CommConnEntry，代码如下：\n\n```cpp\nstruct CommConnEntry\n{\n\tstruct list_head list;          // 链表节点，\n\tCommConnection *conn;           // 下一章介绍TCPServer的时候会用到，本文可忽略。\n\tlong long seq;                  // seq的作用其实可以理解为：一条连接 请求-回复 的轮次。一条连接的服务端和客户端理论上讲seq值是同时递增的，并且一定是保持相同的。\n\tint sockfd;                     // 连接的句柄\n#define CONN_STATE_CONNECTING\t0\n#define CONN_STATE_CONNECTED\t1\n#define CONN_STATE_RECEIVING\t2\n#define CONN_STATE_SUCCESS\t\t3\n#define CONN_STATE_IDLE\t\t\t4\n#define CONN_STATE_KEEPALIVE\t5\n#define CONN_STATE_CLOSING\t\t6\n#define CONN_STATE_ERROR\t\t7\n\tint state;                      // 连接状态\n\tint error;\n\tint ref;                        // 对对象的引用计数\n\tstruct iovec *write_iov;        // 异步写缓存\n\tCommSession *session;           // 含义同go-task，每次读写完毕或则出错了都会调用该对象的hanle函数\n\tCommTarget *target;             // 连接目的地。对于客户端，该成员是服务器的地址；对于服务端，该成员是客户端的地址。\n\tCommService *service;           // 该成员仅服务端有意义\n\tmpoller_t *mpoller;\n\t/* Connection entry's mutex is for client session only. */\n\tpthread_mutex_t mutex;\n};\n```\n\nworkflow将客户端、服务端、tcp、udp、ssl的实现都混杂在一个文件当中。在第一次阅读它的源码时有点双眼摸瞎的感觉。如果你有足够丰富的网络编程的经验可能还好。\n\n需要注意一点的是：该连接上下文在客户端和服务端所使用成员可能是不同的，客户端不会使用service成员，服务端不会使用seq成员。\n\n对于CommConnEntry::list成员，其实有两种用途：\n\n- 一是被挂在服务端的CommService::alive_list上。可以理解为服务端的http保活池。\n\n- 二是被挂在客户端的CommTarget::idle_list上。可以理解为客户端的（对同一个ipaddr:port的）http连接池。\n\n广义上讲，服务端的CommServiceTarget::idle_list也是http连接池。只是服务端的idle_list上只可能会有一个连接。\n\n然后可以预见的是：\n\n1. 随着tcp连接状态的变化，state成员所记录的状态也会随之更新。\n\n2. 当ref成员减为零，CommConnEntry对象将会被free掉。\n\n根据以往的经验能大胆猜测到的就是这些信息。\n\n### 状态迁移池\n\n状态迁移池——没错，类似于事件池，状态迁移池也有一个循环，它的任务是不断根据IO的结果，转换连接上下文的状态，并且根据IO的结果去回调必要的处理函数，最为代表的是：session->handle，session的概念在go-task源码剖析一节中也是存在。它存在的意义在下一章讲解workflow对TCPServer的时候才适合透露。我们重点集中在communicator如何管理连接上下文的状态的。\n\n这里其实就引入了一个问题，连接上下文为什么存在状态的迁移？别急，让我一步步道来。\n\n======================================================\n\n首先是状态池的启动————Communicator::init\n\n代码如下：\n\n```cpp\nint Communicator::init(size_t poller_threads, size_t handler_threads) {\n    /* ... */\n\n\tif (this->create_poller(poller_threads) >= 0)\n\t{\n\t\tif (this->create_handler_threads(handler_threads) >= 0)\n\t\t{\n\t\t\tthis->stop_flag = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmpoller_stop(this->mpoller);\n\t\tmpoller_destroy(this->mpoller);\n\t\tmsgqueue_destroy(this->msgqueue);\n\t}\n\n\treturn -1;\n}\n```\n\n涉及的代码过多，这里仅挑重点。\n\n1. Communicator::init首先会启动mpoller，也就是上章我们所讲的事件池。上节的poller->callback函数以及它的参数poller->context，在poller初始化时就是由struct poller_params提供。而该结构体的够着在Communicator::create_poller当中是这样被赋值的：\n\n    ```cpp\n    void Communicator::callback(struct poller_result *res, void *context) {\n        msgqueue_t *msgqueue = (msgqueue_t *)context;\n        msgqueue_put(res, msgqueue);\n    }\n\n    int Communicator::create_poller(size_t poller_threads) {\n        struct poller_params params = {\n            .max_open_files\t\t=\t(size_t)sysconf(_SC_OPEN_MAX),\n            .callback\t\t\t=\tCommunicator::callback,\n        };\n\n        this->msgqueue = msgqueue_create(16 * 1024, sizeof (struct poller_result));\n        if (this->msgqueue) {\n            params.context = this->msgqueue;\n            /* ... */\n        }\n\n        return -1;\n    }\n    ```\n\n    所以，可以看到，上章的poller->callback回调，会将传进来的poller_result追加到Communicator的状态迁移池的队列当中。\n\n2. Communicator::init然后会启动状态迁移池。状态迁移池使用的就是workflow自己造了链式线程池轮子。特别的是，在线程池的每个线程都运行**一个**routine：Communicator::handler_thread_routine，该函数是一个死循环。在每个线程都分配到一个Communicator::handler_thread_routine后，**线程池的队列**其实就失去了它的意义。每个Communicator::handler_thread_routine会使用1当中分配的队列。\n\n转到Communicator::handler_thread_routine，它的实现如下：\n\n```cpp\nvoid Communicator::handler_thread_routine(void *context) {\n\tCommunicator *comm = (Communicator *)context;\n\tstruct poller_result *res;\n\n\twhile (1) {\n\t\tres = (struct poller_result *)msgqueue_get(comm->msgqueue);\n\t\tif (!res)\n\t\t\tbreak;\n\n\t\tswitch (res->data.operation) {\n\t\tcase PD_OP_TIMER:\n\t\t\tcomm->handle_sleep_result(res);\n\t\t\tbreak;\n\t\tcase PD_OP_READ:\n\t\t\tcomm->handle_read_result(res);\n\t\t\tbreak;\n\t\tcase PD_OP_WRITE:\n\t\t\tcomm->handle_write_result(res);\n\t\t\tbreak;\n\t\tcase PD_OP_LISTEN:\n\t\t\tcomm->handle_listen_result(res);\n\t\t\tbreak;\n        /* ... */\n\t\t}\n\n\t\tfree(res);\n\t}\n\n\tif (!comm->thrdpool) {\n\t\tmpoller_destroy(comm->mpoller);\n\t\tmsgqueue_destroy(comm->msgqueue);\n\t}\n}\n```\n\n阅读过上面的代码后，我们应该惊喜，因为我们看到了free！这里我可以自信的回答这个问题：上节poller当中，只看到了针对poller_node的malloc函数，而没有看到对应的free函数，哪里调用了free函数去释放poller_node？\n\n**没错，poller_node就是在这里释放的。**\n\npoller_node生命周期是这样的链路：\n\n```\n__poller_new_node { malloc } -> write(addr) -> pipe -> __poller_handle_pipe { addr = read() } -> poller->callback(addr) -> handler_thread_routine { free }\n```\n\n\n最终在状态迁移池启动完毕后，结合poller的事件池，Communicator最终的系统架构如下图：\n\n![](./TCPServer_2/photo/StateTranslateThreadPool.drawio.png)\n\n### IO结果的处理\n\n还是贴出上章所讲解的基本tcp服务框架示例：\n\n```\n\t+-----------+\n\t|\tsocket\t|\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tbind\t|\t这三步就是由本节的Communicator执行\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tlisten\t|\n\t+-----------+\n\t\t|\t\t\t______________________________________________\n\t\tV\n\t+-----------+\n\t|\taccept\t|\t从这里开始涉及到的所有函数是poller负责。\n\t+-----------+\n\t|\t|\t|\t|\n\tV\tV\tV\tV\n\tfd\tfd\tfd\t...\n\t\t/\\\n\tread  write\n```\n\n当然Communicator会使用mpoller暴露的api对sockfd设置所关心的IO事件。间接调用了IO系统调用接口。下面从listen fd入手，逐步揭开communicator的真面目。\n\n======================================================\n\n创建绑定监听三部曲————Communicator::bind\n\n函数如下：\n\n```cpp\nint Communicator::bind(CommService *service) {\n\tstruct poller_data data;\n\tint errno_bak = errno;\n\tint sockfd;\n\n\tsockfd = this->nonblock_listen(service);\n\tif (sockfd >= 0) {\n\t\tdata.fd = sockfd;\n\t\tdata.context = service;\n\t\t/* ... */\n\t\tdata.operation = PD_OP_LISTEN;\n\t\tdata.accept = Communicator::accept;\n\t\t// 开始接收客户端连接\n\t\tif (mpoller_add(&data, service->listen_timeout, this->mpoller) >= 0) {\n\t\t\terrno = errno_bak;\n\t\t\treturn 0;\n\t\t}\n\n\t\tclose(sockfd);\n\t}\n\n\treturn -1;\n}\n```\n\n注意到，listen套接字被分配了一个Communicator::accept回调，上一章介绍poller时每当listen套接字接收到一个客户端的连接，都会将IO socket作为参数回调一下accept函数，此处代表Communicator::accept，它实际上会为IO socket创建一个CommServiceTarget对象。\n\n三部曲核心在nonblock_listen，如下：\n\n```cpp\nint Communicator::nonblock_listen(CommService *service) {\n\tint sockfd = service->create_listen_fd();\t\t\t\t// scoket()\n\tint ret;\n\n\tif (sockfd >= 0) {\n\t\tif (__set_fd_nonblock(sockfd) >= 0)\t{\t\t\t\t// 设置为非阻塞\n\t\t\tif (__bind_sockaddr(sockfd, service->bind_addr,\n\t\t\t\t\t\t\t\tservice->addrlen) >= 0)\t{ \t// 监听socket和addr绑定\n\t\t\t\tret = listen(sockfd, SOMAXCONN);\t\t\t// 开始监听\n\t\t\t\tif (ret >= 0 || errno == EOPNOTSUPP) {\n\t\t\t\t\tservice->reliable = (ret >= 0);\n\t\t\t\t\treturn sockfd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tclose(sockfd);\n\t}\n\n\treturn -1;\n}\n```\n\n所以Communicator::bind绑定并启动一个tcpserver的流程是：\n\n1. 初始化一个监听套接字。\n\n2. 将监听套接字添加到mpoller事件池当中。开始接受来自客户端的连接。\n\n======================================================\n\n接收客户端连接————Communicator::handle_listen_result\n\n了解了前面状态迁移池和bind的流程，结合上一章poller的源码分析，一旦poller的accept接收到一条连接会回调一下Communicator::accept，然后再调用poller->callback，并将IOsocket填到res，然后res被传回Communicator队列当中。状态迁移线程会从队列当中取res，然后根据res->data.operation，会去回调Communicator::handle_listen_result，它的实现如下：\n\n```cpp\nvoid Communicator::handle_listen_result(struct poller_result *res) {\n\tCommService *service = (CommService *)res->data.context;\n\tstruct CommConnEntry *entry;\n\tCommServiceTarget *target;\n\tint timeout;\n\n\tswitch (res->state) {\n\tcase PR_ST_SUCCESS:\n\t\ttarget = (CommServiceTarget *)res->data.result;\t\t// Communicator::accept的返回值\n\t\tentry = Communicator::accept_conn(target, service);\n\t\tif (entry) {\n\t\t\tentry->mpoller = this->mpoller;\n\t\t\tres->data.operation = PD_OP_READ;\n\t\t\tres->data.fd = entry->sockfd;\n\t\t\tres->data.create_message = Communicator::create_request;\n\t\t\tres->data.context = entry;\n\t\t\tres->data.message = NULL;\n\t\t\ttimeout = target->response_timeout;\n\t\t\tif (mpoller_add(&res->data, timeout, this->mpoller) >= 0) {\n\t\t\t\tif (this->stop_flag)\n\t\t\t\t\tmpoller_del(res->data.fd, this->mpoller);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t__release_conn(entry);\n\t\t}\n\t\telse\n\t\t\tclose(target->sockfd);\n\n\t\ttarget->decref();\n\t\tbreak;\n\t}\n}\n```\n\nCommunicator::accept_conn函数根据res创建出IOsocket的连接上下文CommConnEntry，并且该连接上下文初始的state为CONN_STATE_CONNECTED。然后将该对象加入到mpoller事件池当中开启对IOsocket的读事件进行监听。\n\n======================================================\n\n边接收边解析————Communicator::create_request + Communicator::append_message\n\n客户端请求报文解析完毕，状态转移————Communicator::handle_read_result\n\n因为这两部分涉及的代码过于庞大，详细讲解的话避免不了要贴大量的代码，作者表达水平有限。还是觉得使用图解的方式去呈现比较省事。所以，为避免文章代码比例过高，下一小节将会以图画的形式向读者剖析这部分的源码。\n\n### 状态迁移总结\n\n服务端监听套接字的绑定就不说了，下面使用一张图来讲解：从服务端接收客户端连接 到 读客户端请求报文（边读边解析），最后向客户端发送回复的一个流程。\n\n======================================================\n\n接收客户端连接并读取解析客户端发来的报文流程————异步状态机之美\n\n![](./TCPServer_2/photo/ReadStatusTranslate.drawio.png)\n\n第一步，是poller当中的__poller_handle_listen回调函数：\n\n1. 服务端在接收到一个客户端连接后首先会为其创建一个CommServiceTarget对象。\n\n2. 然后将IO socketfd通过回调poller->callback（放到队列当中）传回给Communicator。\n\n第二步，是Communicator的Communicator::handle_listen_result函数：\n\n1. 状态变迁池拿到res对像后，得知operation为PD_OP_LISTEN的res，所以调用Communicator::handle_listen_result函数来处理res。\n\n2. 在Communicator::handle_listen_result函数当中，首先会构造一个连接上下文entry，它的状态被初始化为CONN_STATE_CONNECTED。\n\n3. 构造一个operation为READ的poller_node。并且data成员的create_message回调填为Communicator::create_request。\n\n4. 将poller_node加入到mpoller，开始对其度事件进行监听。\n\n第三步，是poller当中的读事件处理回调__poller_handle_read：\n\n1. 读数据。\n\n2. __poller_append_message，它里面会创建一个poller_message_t对象（如果不存在的话，一般在一轮请求的最开始会构造一个msg对象）。利用poller_message_t对象对读到的数据进行解析。这是一个边读边解析的过程，中间可能会调用数次。当msg->append返回值大于0时，说明请求报文读并且解析完了。此时将msg封装在res当中，并**回调poller->callback**。create_message和append两个回调分别对应Communicator::create_request和Communicator::append_message。这两个函数核心代码已经在上图③号虚框当中显示，读者可以仔细阅读一下。这里其实涉及到连接上下文entry的两次状态变换。在create_message时，entry->state会变更为CONN_STATE_RECEIVING，而在数据解析完毕，Communicator::append_message当中的in->append返回大于0进入到下面的if分支又会将entry->state变更为CONN_STATE_SUCCESS。\n\n第四步，也是读流程的最后一步，Communicator::handle_read_result当中的Communicator::handle_incoming_request函数：\n\n1. 状态变迁池拿到res对像后，得知operation为PD_OP_READ的res，所以调用Communicator::handle_read_result函数来处理res。因为是服务端所以Communicator::handle_read_result函数会调用Communicator::handle_incoming_request函数。\n\n2. 这里会将session的state设置成CS_STATE_TOREPLY。\n\n3. 如果entry->state == CONN_STATE_SUCCESS，则将entry挂到target的idle链表上、entry->ref++，同时entry->state修改成CONN_STATE_IDLE。session->passive 必须赋值为 2。\n\n4. 回调session->handle，然后entry->ref--，当entry->ref为0时，调用__release_conn将连接关闭，并free掉entry连接上下文。\n\n所以entry状态变化顺序为：\n\n```\n[CONN_STATE_CONNECTED] -> [CONN_STATE_RECEIVING] -> [CONN_STATE_SUCCESS] -> [CONN_STATE_IDLE]\n```\n\n======================================================\n\n向客户端发送回复报文————先尽力而为的写，然后再异步写。\n\n当服务端需要发送一个回复报文时会调用Communicator::reply接口，它的代码如下：\n\n```cpp\nint Communicator::reply(CommSession *session) {\n\tstruct CommConnEntry *entry;\n\tCommServiceTarget *target;\n\tint errno_bak;\n\tint ret;\n\n\tif (session->passive != 2) {\t// 处在读完毕的状态\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\terrno_bak = errno;\n\tsession->passive = 3;\t\t\t// 写状态\n\ttarget = (CommServiceTarget *)session->target;\n\tret = this->reply_reliable(session, target);\n\n\n\tif (ret == 0) {\t\t\t\t\t// 这里是同步写已经将所有数据发完了。无需异步写\n\t\tentry = session->in->entry;\n\t\tsession->handle(CS_STATE_SUCCESS, 0);\t// 再次回调session的handle\n\t\tif (__sync_sub_and_fetch(&entry->ref, 1) == 0) {\n\t\t\t__release_conn(entry);\n\t\t\ttarget->decref();\n\t\t}\n\t} else if (ret < 0)\n\t\treturn -1;\n\n\terrno = errno_bak;\n\treturn 0;\n}\n\nint Communicator::reply_reliable(CommSession *session, CommTarget *target) {\n\tstruct CommConnEntry *entry;\n\tstruct list_head *pos;\n\tint ret = -1;\n\n\tpthread_mutex_lock(&target->mutex);\n\tif (!list_empty(&target->idle_list)) {\t// 处于CONN_STATE_IDLE状态\n\t\tpos = target->idle_list.next;\n\t\tentry = list_entry(pos, struct CommConnEntry, list);\n\t\tlist_del(pos);\n\n\t\tsession->out = session->message_out();\n\t\tif (session->out)\n\t\t\tret = this->send_message(entry);\n\n\n\t} else\n\t\terrno = ENOENT;\n\n\tpthread_mutex_unlock(&target->mutex);\n\treturn ret;\n}\n\nint Communicator::send_message(struct CommConnEntry *entry) {\n\t/* ... */\n\tend = vectors + cnt;\n\tcnt = this->send_message_sync(vectors, cnt, entry);\t\t// 先尽力而为的同步写\n\tif (cnt <= 0)\n\t\treturn cnt;\n\n\treturn this->send_message_async(end - cnt, cnt, entry);\t// 写缓存满了，需要异步写\n}\n```\n\n写的设计思路和Muduo的很像[muduo源码阅读笔记（10、TcpConnection）](https://blog.csdn.net/m0_52566365/article/details/135720278)。这里不过多赘述，只讲一下差别。还是以全面的情况为例子，假设现在需要发送一批（回复）数据，并且同步写无法将所有的数据发送完。那么在同步写一部分我们的数据之后，肯定会触发异步写。\n\n而异步写呢，就得靠poller层的__poller_handle_write函数。只要tcp的发送缓存区非满，poller_node就会收到通知，然后尽力向发送缓存区写一些数据，这可能也需要花几轮的功夫去写数据。在这期间，每写一部分数据__poller_handle_write函数就会回调node->data.partial_written，从Communicator::send_message_async函数在构造WRITE类型的poller_node时我们可以得知partial_written就是Communicator::partial_written，而它的实现如下：\n\n```cpp\nint Communicator::partial_written(size_t n, void *context) {\n\tstruct CommConnEntry *entry = (struct CommConnEntry *)context;\n\tCommSession *session = entry->session;\n\tint timeout;\n\n\ttimeout = Communicator::next_timeout(session);\n\tmpoller_set_timeout(entry->sockfd, timeout, entry->mpoller);\n\treturn 0;\n}\n```\n\n在写完部分数据后，为什么需要回调一下partial_written呢？这里其实就得到了合理的解释，既然在规定的写超时时间内，我能向发送缓存写一些数据，那就说明网没断，只是网络状况可能不好。所以，按理来说，在规定的时间内发送了部分数据就应该更新一下发送的超时时间，避免没有必要的超时。\n\n一旦异步写完成了，和__poller_handle_read不同，**__poller_handle_write会自动将poller_node从epoll上移除**，然后回调poller->callback。（PS，如果你忘了poller的实现，建议回顾一下[WorkFlow源码剖析——Communicator之TCPServer（上）](./TcpServer_1.md)）\n\n然后同读完成类似，在Communicator当中写完成会被Communicator::handle_write_result处理，因为是服务断，所以会调用Communicator::handle_reply_result。该函数逻辑如下：\n\n```cpp\nvoid Communicator::handle_reply_result(struct poller_result *res) {\n\tstruct CommConnEntry *entry = (struct CommConnEntry *)res->data.context;\n\tCommService *service = entry->service;\n\tCommSession *session = entry->session;\n\tCommTarget *target = entry->target;\n\tint timeout;\n\tint state;\n\n\tswitch (res->state) {\n\tcase PR_ST_FINISHED:\n\t\ttimeout = session->keep_alive_timeout();\n\t\tif (timeout != 0) {\n\t\t\t__sync_add_and_fetch(&entry->ref, 1);\t\t\t\t\t\t\t// 避免被释放\n\t\t\tres->data.operation = PD_OP_READ;\n\t\t\tres->data.create_message = Communicator::create_request;\n\t\t\tres->data.message = NULL;\n\t\t\tpthread_mutex_lock(&target->mutex);\n\t\t\tif (mpoller_add(&res->data, timeout, this->mpoller) >= 0) {\t\t// 以读的方式添加到mpoller当中\n\t\t\t\tpthread_mutex_lock(&service->mutex);\n\t\t\t\tif (!this->stop_flag && service->listen_fd >= 0) {\n\t\t\t\t\tentry->state = CONN_STATE_KEEPALIVE;\t\t\t\t\t// entry->state修改成CONN_STATE_KEEPALIVE\n\t\t\t\t\tlist_add_tail(&entry->list, &service->alive_list);\t\t// 追加到保活链表\n\t\t\t\t} else {\n\t\t\t\t\tmpoller_del(res->data.fd, this->mpoller);\n\t\t\t\t\tentry->state = CONN_STATE_CLOSING;\n\t\t\t\t}\n\n\t\t\t\tpthread_mutex_unlock(&service->mutex);\n\t\t\t}\n\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 出错，该释放了\n\t\t\t\t__sync_sub_and_fetch(&entry->ref, 1);\t\t\n\n\t\t\tpthread_mutex_unlock(&target->mutex);\n\t\t}\n\n\t\tif (1)\n\t\t\tstate = CS_STATE_SUCCESS;\n\n\t\tsession->handle(state, res->error);\t\t\t\t\t\t\t\t\t// 第二次回调session->handle\n\t\tif (__sync_sub_and_fetch(&entry->ref, 1) == 0) {\n\t\t\t__release_conn(entry);\n\t\t\t((CommServiceTarget *)target)->decref();\n\t\t}\n\n\t\tbreak;\n\t}\n}\n```\n\n逻辑分成三部分：\n\n1. 将entry->ref自增一 && 以读的方式将poller_node加回到mpoller当中继续监听客户端的读请求 && 将entry->state修改成CONN_STATE_KEEPALIVE并且加到CommService的保活链表当中。\n\n2. 将session的state设置成CS_STATE_SUCCESS，再回调session->handle。\n\n3. entry->ref自减一，为零就释放连接以及上下文。\n\n所以在经过Communicator::handle_reply_result函数后，entry->state状态被修改为CONN_STATE_KEEPALIVE。然后再处理下一轮客户端请求。\n\n最后备忘一下：\n\n1. **对于session->passive的变化，在（create_request）创建msg（请求报文解析器）session->passive被置为1，在读取并解析完毕请求报文后，Communicator::handle_incoming_request函数回将session->passive置为2，在调用Communicator::reply向网络发送回复时session->passive会被置为3。**\n\n2. Communicator::send_message_async当中在吧poller_node以WRITE方式加入到mpoller时会走到mpoller_mod分支。\n\n3. 在Communicator当中，TCPServer端的session是个啥？有的人可能会联想可能是HTTPServer当中的Session？我刚开始看源码也是这样认为的，但是实际上并非如此，Communicator当中的session的定义其实和workflow里面的go-task定义很像。HTTPServer当中的Session生命周期同整个HTTP连接一样。而Communicator当中它的生命周期更像仅仅只有**一轮（请求-回复）**，在一轮 请求-回复 过后**自动**被销毁。而翻阅Communicator源码发现，session会在Communicator::create_request函数中通过service->new_session接口进行分配，而释放却并不在Communicator当中。结合之前go-task的实现来看，我们可以大胆猜想：Communicator所出现的session对象一定会派生一个子类，然后session对象的释放由子类对象 delete自身而被释放了。\n\n到了这里其实就能回答这个问题：连接上下文为什么存在状态的迁移？\n\n首先一条tcp连接在服务端必定纯在两种状态：接收、发送。而因为追求性能，我们不得不采用异步的方式将socketfd设置成非阻塞的。并且网络传输（不管是否阻塞）会引来一些问题：读不可能一次性读完、写不可能一次性写完，所以读的过程当中和写的过程当中都存在一种中间的状态。所以状态迁移是必然的。\n\n最后，在了解了workflow的底层架构之后，其实就能感觉到**异步编程就是在实现一个状体机的过程**。\n\n---\n\n**本章完结**","source":"_posts/workflow/TCPServer_2.md","raw":"---\ntitle: WorkFlow源码剖析——Communicator之TCPServer（中）\ndate: 2024-11-04 12:00:00\ntags:\n  - 高性能服务器框架\n---\n\n[WorkFlow源码剖析——GO-Task 源码分析](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlow源码剖析——Communicator之TCPServer（上）](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlow源码剖析——Communicator之TCPServer（中）](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlow源码剖析——Communicator之TCPServer（下）](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\n## 前言\n\n上节博客已经详细介绍了workflow的poller的实现，这节我们来看看Communicator是如何利用poller的，对连接对象生命周期的管理。（PS：与其说Communicator利用的是poller，其实Communicator使用的是mpoller，上节在介绍poller时也提到过mpoller，现场帮读者回忆一下：mpoller是poller的manager类，管理多个poller事件池，对外提供的接口负责将各种poller_node负载均衡的分散给不同的poller。）\n\n上节在介绍poller时，出现了各种回调，比如poller->callback()、node->data.accept()、node->data.partial_written()、node->data.create_message()等，当时我们总是一笔带过，没有去深入分析这些回调会做什么？并且每次在IO事件结束都会回调poller->callback()为什么要这样做？在poller当中，只看到了针对poller_node的malloc函数，而没有看到对应的free函数，哪里调用了free函数去释放poller_node？\n\n<!-- more -->\n\n别着急，本节的源码分析会逐步揭晓这些疑问。\n\n同样的，注意里还是放在TCPServer上，对于SSL和UDP相关的内容直接忽略。先把TCP给模清楚。\n\n## 管理连接对象的实现\n\n### 连接上下文数据结构的分析\n\n既然谈到对连接对象的管理，那Communicator必然有一个数据结构来表示一个连接上下文对象，它就是CommConnEntry，代码如下：\n\n```cpp\nstruct CommConnEntry\n{\n\tstruct list_head list;          // 链表节点，\n\tCommConnection *conn;           // 下一章介绍TCPServer的时候会用到，本文可忽略。\n\tlong long seq;                  // seq的作用其实可以理解为：一条连接 请求-回复 的轮次。一条连接的服务端和客户端理论上讲seq值是同时递增的，并且一定是保持相同的。\n\tint sockfd;                     // 连接的句柄\n#define CONN_STATE_CONNECTING\t0\n#define CONN_STATE_CONNECTED\t1\n#define CONN_STATE_RECEIVING\t2\n#define CONN_STATE_SUCCESS\t\t3\n#define CONN_STATE_IDLE\t\t\t4\n#define CONN_STATE_KEEPALIVE\t5\n#define CONN_STATE_CLOSING\t\t6\n#define CONN_STATE_ERROR\t\t7\n\tint state;                      // 连接状态\n\tint error;\n\tint ref;                        // 对对象的引用计数\n\tstruct iovec *write_iov;        // 异步写缓存\n\tCommSession *session;           // 含义同go-task，每次读写完毕或则出错了都会调用该对象的hanle函数\n\tCommTarget *target;             // 连接目的地。对于客户端，该成员是服务器的地址；对于服务端，该成员是客户端的地址。\n\tCommService *service;           // 该成员仅服务端有意义\n\tmpoller_t *mpoller;\n\t/* Connection entry's mutex is for client session only. */\n\tpthread_mutex_t mutex;\n};\n```\n\nworkflow将客户端、服务端、tcp、udp、ssl的实现都混杂在一个文件当中。在第一次阅读它的源码时有点双眼摸瞎的感觉。如果你有足够丰富的网络编程的经验可能还好。\n\n需要注意一点的是：该连接上下文在客户端和服务端所使用成员可能是不同的，客户端不会使用service成员，服务端不会使用seq成员。\n\n对于CommConnEntry::list成员，其实有两种用途：\n\n- 一是被挂在服务端的CommService::alive_list上。可以理解为服务端的http保活池。\n\n- 二是被挂在客户端的CommTarget::idle_list上。可以理解为客户端的（对同一个ipaddr:port的）http连接池。\n\n广义上讲，服务端的CommServiceTarget::idle_list也是http连接池。只是服务端的idle_list上只可能会有一个连接。\n\n然后可以预见的是：\n\n1. 随着tcp连接状态的变化，state成员所记录的状态也会随之更新。\n\n2. 当ref成员减为零，CommConnEntry对象将会被free掉。\n\n根据以往的经验能大胆猜测到的就是这些信息。\n\n### 状态迁移池\n\n状态迁移池——没错，类似于事件池，状态迁移池也有一个循环，它的任务是不断根据IO的结果，转换连接上下文的状态，并且根据IO的结果去回调必要的处理函数，最为代表的是：session->handle，session的概念在go-task源码剖析一节中也是存在。它存在的意义在下一章讲解workflow对TCPServer的时候才适合透露。我们重点集中在communicator如何管理连接上下文的状态的。\n\n这里其实就引入了一个问题，连接上下文为什么存在状态的迁移？别急，让我一步步道来。\n\n======================================================\n\n首先是状态池的启动————Communicator::init\n\n代码如下：\n\n```cpp\nint Communicator::init(size_t poller_threads, size_t handler_threads) {\n    /* ... */\n\n\tif (this->create_poller(poller_threads) >= 0)\n\t{\n\t\tif (this->create_handler_threads(handler_threads) >= 0)\n\t\t{\n\t\t\tthis->stop_flag = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmpoller_stop(this->mpoller);\n\t\tmpoller_destroy(this->mpoller);\n\t\tmsgqueue_destroy(this->msgqueue);\n\t}\n\n\treturn -1;\n}\n```\n\n涉及的代码过多，这里仅挑重点。\n\n1. Communicator::init首先会启动mpoller，也就是上章我们所讲的事件池。上节的poller->callback函数以及它的参数poller->context，在poller初始化时就是由struct poller_params提供。而该结构体的够着在Communicator::create_poller当中是这样被赋值的：\n\n    ```cpp\n    void Communicator::callback(struct poller_result *res, void *context) {\n        msgqueue_t *msgqueue = (msgqueue_t *)context;\n        msgqueue_put(res, msgqueue);\n    }\n\n    int Communicator::create_poller(size_t poller_threads) {\n        struct poller_params params = {\n            .max_open_files\t\t=\t(size_t)sysconf(_SC_OPEN_MAX),\n            .callback\t\t\t=\tCommunicator::callback,\n        };\n\n        this->msgqueue = msgqueue_create(16 * 1024, sizeof (struct poller_result));\n        if (this->msgqueue) {\n            params.context = this->msgqueue;\n            /* ... */\n        }\n\n        return -1;\n    }\n    ```\n\n    所以，可以看到，上章的poller->callback回调，会将传进来的poller_result追加到Communicator的状态迁移池的队列当中。\n\n2. Communicator::init然后会启动状态迁移池。状态迁移池使用的就是workflow自己造了链式线程池轮子。特别的是，在线程池的每个线程都运行**一个**routine：Communicator::handler_thread_routine，该函数是一个死循环。在每个线程都分配到一个Communicator::handler_thread_routine后，**线程池的队列**其实就失去了它的意义。每个Communicator::handler_thread_routine会使用1当中分配的队列。\n\n转到Communicator::handler_thread_routine，它的实现如下：\n\n```cpp\nvoid Communicator::handler_thread_routine(void *context) {\n\tCommunicator *comm = (Communicator *)context;\n\tstruct poller_result *res;\n\n\twhile (1) {\n\t\tres = (struct poller_result *)msgqueue_get(comm->msgqueue);\n\t\tif (!res)\n\t\t\tbreak;\n\n\t\tswitch (res->data.operation) {\n\t\tcase PD_OP_TIMER:\n\t\t\tcomm->handle_sleep_result(res);\n\t\t\tbreak;\n\t\tcase PD_OP_READ:\n\t\t\tcomm->handle_read_result(res);\n\t\t\tbreak;\n\t\tcase PD_OP_WRITE:\n\t\t\tcomm->handle_write_result(res);\n\t\t\tbreak;\n\t\tcase PD_OP_LISTEN:\n\t\t\tcomm->handle_listen_result(res);\n\t\t\tbreak;\n        /* ... */\n\t\t}\n\n\t\tfree(res);\n\t}\n\n\tif (!comm->thrdpool) {\n\t\tmpoller_destroy(comm->mpoller);\n\t\tmsgqueue_destroy(comm->msgqueue);\n\t}\n}\n```\n\n阅读过上面的代码后，我们应该惊喜，因为我们看到了free！这里我可以自信的回答这个问题：上节poller当中，只看到了针对poller_node的malloc函数，而没有看到对应的free函数，哪里调用了free函数去释放poller_node？\n\n**没错，poller_node就是在这里释放的。**\n\npoller_node生命周期是这样的链路：\n\n```\n__poller_new_node { malloc } -> write(addr) -> pipe -> __poller_handle_pipe { addr = read() } -> poller->callback(addr) -> handler_thread_routine { free }\n```\n\n\n最终在状态迁移池启动完毕后，结合poller的事件池，Communicator最终的系统架构如下图：\n\n![](./TCPServer_2/photo/StateTranslateThreadPool.drawio.png)\n\n### IO结果的处理\n\n还是贴出上章所讲解的基本tcp服务框架示例：\n\n```\n\t+-----------+\n\t|\tsocket\t|\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tbind\t|\t这三步就是由本节的Communicator执行\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tlisten\t|\n\t+-----------+\n\t\t|\t\t\t______________________________________________\n\t\tV\n\t+-----------+\n\t|\taccept\t|\t从这里开始涉及到的所有函数是poller负责。\n\t+-----------+\n\t|\t|\t|\t|\n\tV\tV\tV\tV\n\tfd\tfd\tfd\t...\n\t\t/\\\n\tread  write\n```\n\n当然Communicator会使用mpoller暴露的api对sockfd设置所关心的IO事件。间接调用了IO系统调用接口。下面从listen fd入手，逐步揭开communicator的真面目。\n\n======================================================\n\n创建绑定监听三部曲————Communicator::bind\n\n函数如下：\n\n```cpp\nint Communicator::bind(CommService *service) {\n\tstruct poller_data data;\n\tint errno_bak = errno;\n\tint sockfd;\n\n\tsockfd = this->nonblock_listen(service);\n\tif (sockfd >= 0) {\n\t\tdata.fd = sockfd;\n\t\tdata.context = service;\n\t\t/* ... */\n\t\tdata.operation = PD_OP_LISTEN;\n\t\tdata.accept = Communicator::accept;\n\t\t// 开始接收客户端连接\n\t\tif (mpoller_add(&data, service->listen_timeout, this->mpoller) >= 0) {\n\t\t\terrno = errno_bak;\n\t\t\treturn 0;\n\t\t}\n\n\t\tclose(sockfd);\n\t}\n\n\treturn -1;\n}\n```\n\n注意到，listen套接字被分配了一个Communicator::accept回调，上一章介绍poller时每当listen套接字接收到一个客户端的连接，都会将IO socket作为参数回调一下accept函数，此处代表Communicator::accept，它实际上会为IO socket创建一个CommServiceTarget对象。\n\n三部曲核心在nonblock_listen，如下：\n\n```cpp\nint Communicator::nonblock_listen(CommService *service) {\n\tint sockfd = service->create_listen_fd();\t\t\t\t// scoket()\n\tint ret;\n\n\tif (sockfd >= 0) {\n\t\tif (__set_fd_nonblock(sockfd) >= 0)\t{\t\t\t\t// 设置为非阻塞\n\t\t\tif (__bind_sockaddr(sockfd, service->bind_addr,\n\t\t\t\t\t\t\t\tservice->addrlen) >= 0)\t{ \t// 监听socket和addr绑定\n\t\t\t\tret = listen(sockfd, SOMAXCONN);\t\t\t// 开始监听\n\t\t\t\tif (ret >= 0 || errno == EOPNOTSUPP) {\n\t\t\t\t\tservice->reliable = (ret >= 0);\n\t\t\t\t\treturn sockfd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tclose(sockfd);\n\t}\n\n\treturn -1;\n}\n```\n\n所以Communicator::bind绑定并启动一个tcpserver的流程是：\n\n1. 初始化一个监听套接字。\n\n2. 将监听套接字添加到mpoller事件池当中。开始接受来自客户端的连接。\n\n======================================================\n\n接收客户端连接————Communicator::handle_listen_result\n\n了解了前面状态迁移池和bind的流程，结合上一章poller的源码分析，一旦poller的accept接收到一条连接会回调一下Communicator::accept，然后再调用poller->callback，并将IOsocket填到res，然后res被传回Communicator队列当中。状态迁移线程会从队列当中取res，然后根据res->data.operation，会去回调Communicator::handle_listen_result，它的实现如下：\n\n```cpp\nvoid Communicator::handle_listen_result(struct poller_result *res) {\n\tCommService *service = (CommService *)res->data.context;\n\tstruct CommConnEntry *entry;\n\tCommServiceTarget *target;\n\tint timeout;\n\n\tswitch (res->state) {\n\tcase PR_ST_SUCCESS:\n\t\ttarget = (CommServiceTarget *)res->data.result;\t\t// Communicator::accept的返回值\n\t\tentry = Communicator::accept_conn(target, service);\n\t\tif (entry) {\n\t\t\tentry->mpoller = this->mpoller;\n\t\t\tres->data.operation = PD_OP_READ;\n\t\t\tres->data.fd = entry->sockfd;\n\t\t\tres->data.create_message = Communicator::create_request;\n\t\t\tres->data.context = entry;\n\t\t\tres->data.message = NULL;\n\t\t\ttimeout = target->response_timeout;\n\t\t\tif (mpoller_add(&res->data, timeout, this->mpoller) >= 0) {\n\t\t\t\tif (this->stop_flag)\n\t\t\t\t\tmpoller_del(res->data.fd, this->mpoller);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t__release_conn(entry);\n\t\t}\n\t\telse\n\t\t\tclose(target->sockfd);\n\n\t\ttarget->decref();\n\t\tbreak;\n\t}\n}\n```\n\nCommunicator::accept_conn函数根据res创建出IOsocket的连接上下文CommConnEntry，并且该连接上下文初始的state为CONN_STATE_CONNECTED。然后将该对象加入到mpoller事件池当中开启对IOsocket的读事件进行监听。\n\n======================================================\n\n边接收边解析————Communicator::create_request + Communicator::append_message\n\n客户端请求报文解析完毕，状态转移————Communicator::handle_read_result\n\n因为这两部分涉及的代码过于庞大，详细讲解的话避免不了要贴大量的代码，作者表达水平有限。还是觉得使用图解的方式去呈现比较省事。所以，为避免文章代码比例过高，下一小节将会以图画的形式向读者剖析这部分的源码。\n\n### 状态迁移总结\n\n服务端监听套接字的绑定就不说了，下面使用一张图来讲解：从服务端接收客户端连接 到 读客户端请求报文（边读边解析），最后向客户端发送回复的一个流程。\n\n======================================================\n\n接收客户端连接并读取解析客户端发来的报文流程————异步状态机之美\n\n![](./TCPServer_2/photo/ReadStatusTranslate.drawio.png)\n\n第一步，是poller当中的__poller_handle_listen回调函数：\n\n1. 服务端在接收到一个客户端连接后首先会为其创建一个CommServiceTarget对象。\n\n2. 然后将IO socketfd通过回调poller->callback（放到队列当中）传回给Communicator。\n\n第二步，是Communicator的Communicator::handle_listen_result函数：\n\n1. 状态变迁池拿到res对像后，得知operation为PD_OP_LISTEN的res，所以调用Communicator::handle_listen_result函数来处理res。\n\n2. 在Communicator::handle_listen_result函数当中，首先会构造一个连接上下文entry，它的状态被初始化为CONN_STATE_CONNECTED。\n\n3. 构造一个operation为READ的poller_node。并且data成员的create_message回调填为Communicator::create_request。\n\n4. 将poller_node加入到mpoller，开始对其度事件进行监听。\n\n第三步，是poller当中的读事件处理回调__poller_handle_read：\n\n1. 读数据。\n\n2. __poller_append_message，它里面会创建一个poller_message_t对象（如果不存在的话，一般在一轮请求的最开始会构造一个msg对象）。利用poller_message_t对象对读到的数据进行解析。这是一个边读边解析的过程，中间可能会调用数次。当msg->append返回值大于0时，说明请求报文读并且解析完了。此时将msg封装在res当中，并**回调poller->callback**。create_message和append两个回调分别对应Communicator::create_request和Communicator::append_message。这两个函数核心代码已经在上图③号虚框当中显示，读者可以仔细阅读一下。这里其实涉及到连接上下文entry的两次状态变换。在create_message时，entry->state会变更为CONN_STATE_RECEIVING，而在数据解析完毕，Communicator::append_message当中的in->append返回大于0进入到下面的if分支又会将entry->state变更为CONN_STATE_SUCCESS。\n\n第四步，也是读流程的最后一步，Communicator::handle_read_result当中的Communicator::handle_incoming_request函数：\n\n1. 状态变迁池拿到res对像后，得知operation为PD_OP_READ的res，所以调用Communicator::handle_read_result函数来处理res。因为是服务端所以Communicator::handle_read_result函数会调用Communicator::handle_incoming_request函数。\n\n2. 这里会将session的state设置成CS_STATE_TOREPLY。\n\n3. 如果entry->state == CONN_STATE_SUCCESS，则将entry挂到target的idle链表上、entry->ref++，同时entry->state修改成CONN_STATE_IDLE。session->passive 必须赋值为 2。\n\n4. 回调session->handle，然后entry->ref--，当entry->ref为0时，调用__release_conn将连接关闭，并free掉entry连接上下文。\n\n所以entry状态变化顺序为：\n\n```\n[CONN_STATE_CONNECTED] -> [CONN_STATE_RECEIVING] -> [CONN_STATE_SUCCESS] -> [CONN_STATE_IDLE]\n```\n\n======================================================\n\n向客户端发送回复报文————先尽力而为的写，然后再异步写。\n\n当服务端需要发送一个回复报文时会调用Communicator::reply接口，它的代码如下：\n\n```cpp\nint Communicator::reply(CommSession *session) {\n\tstruct CommConnEntry *entry;\n\tCommServiceTarget *target;\n\tint errno_bak;\n\tint ret;\n\n\tif (session->passive != 2) {\t// 处在读完毕的状态\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\terrno_bak = errno;\n\tsession->passive = 3;\t\t\t// 写状态\n\ttarget = (CommServiceTarget *)session->target;\n\tret = this->reply_reliable(session, target);\n\n\n\tif (ret == 0) {\t\t\t\t\t// 这里是同步写已经将所有数据发完了。无需异步写\n\t\tentry = session->in->entry;\n\t\tsession->handle(CS_STATE_SUCCESS, 0);\t// 再次回调session的handle\n\t\tif (__sync_sub_and_fetch(&entry->ref, 1) == 0) {\n\t\t\t__release_conn(entry);\n\t\t\ttarget->decref();\n\t\t}\n\t} else if (ret < 0)\n\t\treturn -1;\n\n\terrno = errno_bak;\n\treturn 0;\n}\n\nint Communicator::reply_reliable(CommSession *session, CommTarget *target) {\n\tstruct CommConnEntry *entry;\n\tstruct list_head *pos;\n\tint ret = -1;\n\n\tpthread_mutex_lock(&target->mutex);\n\tif (!list_empty(&target->idle_list)) {\t// 处于CONN_STATE_IDLE状态\n\t\tpos = target->idle_list.next;\n\t\tentry = list_entry(pos, struct CommConnEntry, list);\n\t\tlist_del(pos);\n\n\t\tsession->out = session->message_out();\n\t\tif (session->out)\n\t\t\tret = this->send_message(entry);\n\n\n\t} else\n\t\terrno = ENOENT;\n\n\tpthread_mutex_unlock(&target->mutex);\n\treturn ret;\n}\n\nint Communicator::send_message(struct CommConnEntry *entry) {\n\t/* ... */\n\tend = vectors + cnt;\n\tcnt = this->send_message_sync(vectors, cnt, entry);\t\t// 先尽力而为的同步写\n\tif (cnt <= 0)\n\t\treturn cnt;\n\n\treturn this->send_message_async(end - cnt, cnt, entry);\t// 写缓存满了，需要异步写\n}\n```\n\n写的设计思路和Muduo的很像[muduo源码阅读笔记（10、TcpConnection）](https://blog.csdn.net/m0_52566365/article/details/135720278)。这里不过多赘述，只讲一下差别。还是以全面的情况为例子，假设现在需要发送一批（回复）数据，并且同步写无法将所有的数据发送完。那么在同步写一部分我们的数据之后，肯定会触发异步写。\n\n而异步写呢，就得靠poller层的__poller_handle_write函数。只要tcp的发送缓存区非满，poller_node就会收到通知，然后尽力向发送缓存区写一些数据，这可能也需要花几轮的功夫去写数据。在这期间，每写一部分数据__poller_handle_write函数就会回调node->data.partial_written，从Communicator::send_message_async函数在构造WRITE类型的poller_node时我们可以得知partial_written就是Communicator::partial_written，而它的实现如下：\n\n```cpp\nint Communicator::partial_written(size_t n, void *context) {\n\tstruct CommConnEntry *entry = (struct CommConnEntry *)context;\n\tCommSession *session = entry->session;\n\tint timeout;\n\n\ttimeout = Communicator::next_timeout(session);\n\tmpoller_set_timeout(entry->sockfd, timeout, entry->mpoller);\n\treturn 0;\n}\n```\n\n在写完部分数据后，为什么需要回调一下partial_written呢？这里其实就得到了合理的解释，既然在规定的写超时时间内，我能向发送缓存写一些数据，那就说明网没断，只是网络状况可能不好。所以，按理来说，在规定的时间内发送了部分数据就应该更新一下发送的超时时间，避免没有必要的超时。\n\n一旦异步写完成了，和__poller_handle_read不同，**__poller_handle_write会自动将poller_node从epoll上移除**，然后回调poller->callback。（PS，如果你忘了poller的实现，建议回顾一下[WorkFlow源码剖析——Communicator之TCPServer（上）](./TcpServer_1.md)）\n\n然后同读完成类似，在Communicator当中写完成会被Communicator::handle_write_result处理，因为是服务断，所以会调用Communicator::handle_reply_result。该函数逻辑如下：\n\n```cpp\nvoid Communicator::handle_reply_result(struct poller_result *res) {\n\tstruct CommConnEntry *entry = (struct CommConnEntry *)res->data.context;\n\tCommService *service = entry->service;\n\tCommSession *session = entry->session;\n\tCommTarget *target = entry->target;\n\tint timeout;\n\tint state;\n\n\tswitch (res->state) {\n\tcase PR_ST_FINISHED:\n\t\ttimeout = session->keep_alive_timeout();\n\t\tif (timeout != 0) {\n\t\t\t__sync_add_and_fetch(&entry->ref, 1);\t\t\t\t\t\t\t// 避免被释放\n\t\t\tres->data.operation = PD_OP_READ;\n\t\t\tres->data.create_message = Communicator::create_request;\n\t\t\tres->data.message = NULL;\n\t\t\tpthread_mutex_lock(&target->mutex);\n\t\t\tif (mpoller_add(&res->data, timeout, this->mpoller) >= 0) {\t\t// 以读的方式添加到mpoller当中\n\t\t\t\tpthread_mutex_lock(&service->mutex);\n\t\t\t\tif (!this->stop_flag && service->listen_fd >= 0) {\n\t\t\t\t\tentry->state = CONN_STATE_KEEPALIVE;\t\t\t\t\t// entry->state修改成CONN_STATE_KEEPALIVE\n\t\t\t\t\tlist_add_tail(&entry->list, &service->alive_list);\t\t// 追加到保活链表\n\t\t\t\t} else {\n\t\t\t\t\tmpoller_del(res->data.fd, this->mpoller);\n\t\t\t\t\tentry->state = CONN_STATE_CLOSING;\n\t\t\t\t}\n\n\t\t\t\tpthread_mutex_unlock(&service->mutex);\n\t\t\t}\n\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 出错，该释放了\n\t\t\t\t__sync_sub_and_fetch(&entry->ref, 1);\t\t\n\n\t\t\tpthread_mutex_unlock(&target->mutex);\n\t\t}\n\n\t\tif (1)\n\t\t\tstate = CS_STATE_SUCCESS;\n\n\t\tsession->handle(state, res->error);\t\t\t\t\t\t\t\t\t// 第二次回调session->handle\n\t\tif (__sync_sub_and_fetch(&entry->ref, 1) == 0) {\n\t\t\t__release_conn(entry);\n\t\t\t((CommServiceTarget *)target)->decref();\n\t\t}\n\n\t\tbreak;\n\t}\n}\n```\n\n逻辑分成三部分：\n\n1. 将entry->ref自增一 && 以读的方式将poller_node加回到mpoller当中继续监听客户端的读请求 && 将entry->state修改成CONN_STATE_KEEPALIVE并且加到CommService的保活链表当中。\n\n2. 将session的state设置成CS_STATE_SUCCESS，再回调session->handle。\n\n3. entry->ref自减一，为零就释放连接以及上下文。\n\n所以在经过Communicator::handle_reply_result函数后，entry->state状态被修改为CONN_STATE_KEEPALIVE。然后再处理下一轮客户端请求。\n\n最后备忘一下：\n\n1. **对于session->passive的变化，在（create_request）创建msg（请求报文解析器）session->passive被置为1，在读取并解析完毕请求报文后，Communicator::handle_incoming_request函数回将session->passive置为2，在调用Communicator::reply向网络发送回复时session->passive会被置为3。**\n\n2. Communicator::send_message_async当中在吧poller_node以WRITE方式加入到mpoller时会走到mpoller_mod分支。\n\n3. 在Communicator当中，TCPServer端的session是个啥？有的人可能会联想可能是HTTPServer当中的Session？我刚开始看源码也是这样认为的，但是实际上并非如此，Communicator当中的session的定义其实和workflow里面的go-task定义很像。HTTPServer当中的Session生命周期同整个HTTP连接一样。而Communicator当中它的生命周期更像仅仅只有**一轮（请求-回复）**，在一轮 请求-回复 过后**自动**被销毁。而翻阅Communicator源码发现，session会在Communicator::create_request函数中通过service->new_session接口进行分配，而释放却并不在Communicator当中。结合之前go-task的实现来看，我们可以大胆猜想：Communicator所出现的session对象一定会派生一个子类，然后session对象的释放由子类对象 delete自身而被释放了。\n\n到了这里其实就能回答这个问题：连接上下文为什么存在状态的迁移？\n\n首先一条tcp连接在服务端必定纯在两种状态：接收、发送。而因为追求性能，我们不得不采用异步的方式将socketfd设置成非阻塞的。并且网络传输（不管是否阻塞）会引来一些问题：读不可能一次性读完、写不可能一次性写完，所以读的过程当中和写的过程当中都存在一种中间的状态。所以状态迁移是必然的。\n\n最后，在了解了workflow的底层架构之后，其实就能感觉到**异步编程就是在实现一个状体机的过程**。\n\n---\n\n**本章完结**","slug":"workflow/TCPServer_2","published":1,"updated":"2025-09-28T14:38:07.199Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9t0010q8ws2bl6bydm","content":"<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlow源码剖析——GO-Task 源码分析</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlow源码剖析——Communicator之TCPServer（上）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlow源码剖析——Communicator之TCPServer（中）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlow源码剖析——Communicator之TCPServer（下）</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上节博客已经详细介绍了workflow的poller的实现，这节我们来看看Communicator是如何利用poller的，对连接对象生命周期的管理。（PS：与其说Communicator利用的是poller，其实Communicator使用的是mpoller，上节在介绍poller时也提到过mpoller，现场帮读者回忆一下：mpoller是poller的manager类，管理多个poller事件池，对外提供的接口负责将各种poller_node负载均衡的分散给不同的poller。）</p>\n<p>上节在介绍poller时，出现了各种回调，比如poller-&gt;callback()、node-&gt;data.accept()、node-&gt;data.partial_written()、node-&gt;data.create_message()等，当时我们总是一笔带过，没有去深入分析这些回调会做什么？并且每次在IO事件结束都会回调poller-&gt;callback()为什么要这样做？在poller当中，只看到了针对poller_node的malloc函数，而没有看到对应的free函数，哪里调用了free函数去释放poller_node？</p>\n<span id=\"more\"></span>\n\n<p>别着急，本节的源码分析会逐步揭晓这些疑问。</p>\n<p>同样的，注意里还是放在TCPServer上，对于SSL和UDP相关的内容直接忽略。先把TCP给模清楚。</p>\n<h2 id=\"管理连接对象的实现\"><a href=\"#管理连接对象的实现\" class=\"headerlink\" title=\"管理连接对象的实现\"></a>管理连接对象的实现</h2><h3 id=\"连接上下文数据结构的分析\"><a href=\"#连接上下文数据结构的分析\" class=\"headerlink\" title=\"连接上下文数据结构的分析\"></a>连接上下文数据结构的分析</h3><p>既然谈到对连接对象的管理，那Communicator必然有一个数据结构来表示一个连接上下文对象，它就是CommConnEntry，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> list;          <span class=\"comment\">// 链表节点，</span></span><br><span class=\"line\">\tCommConnection *conn;           <span class=\"comment\">// 下一章介绍TCPServer的时候会用到，本文可忽略。</span></span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> seq;                  <span class=\"comment\">// seq的作用其实可以理解为：一条连接 请求-回复 的轮次。一条连接的服务端和客户端理论上讲seq值是同时递增的，并且一定是保持相同的。</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> sockfd;                     <span class=\"comment\">// 连接的句柄</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_CONNECTING\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_CONNECTED\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_RECEIVING\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_SUCCESS\t\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_IDLE\t\t\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_KEEPALIVE\t5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_CLOSING\t\t6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_ERROR\t\t7</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> state;                      <span class=\"comment\">// 连接状态</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> error;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ref;                        <span class=\"comment\">// 对对象的引用计数</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> *write_iov;        <span class=\"comment\">// 异步写缓存</span></span><br><span class=\"line\">\tCommSession *session;           <span class=\"comment\">// 含义同go-task，每次读写完毕或则出错了都会调用该对象的hanle函数</span></span><br><span class=\"line\">\tCommTarget *target;             <span class=\"comment\">// 连接目的地。对于客户端，该成员是服务器的地址；对于服务端，该成员是客户端的地址。</span></span><br><span class=\"line\">\tCommService *service;           <span class=\"comment\">// 该成员仅服务端有意义</span></span><br><span class=\"line\">\t<span class=\"type\">mpoller_t</span> *mpoller;</span><br><span class=\"line\">\t<span class=\"comment\">/* Connection entry&#x27;s mutex is for client session only. */</span></span><br><span class=\"line\">\t<span class=\"type\">pthread_mutex_t</span> mutex;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>workflow将客户端、服务端、tcp、udp、ssl的实现都混杂在一个文件当中。在第一次阅读它的源码时有点双眼摸瞎的感觉。如果你有足够丰富的网络编程的经验可能还好。</p>\n<p>需要注意一点的是：该连接上下文在客户端和服务端所使用成员可能是不同的，客户端不会使用service成员，服务端不会使用seq成员。</p>\n<p>对于CommConnEntry::list成员，其实有两种用途：</p>\n<ul>\n<li><p>一是被挂在服务端的CommService::alive_list上。可以理解为服务端的http保活池。</p>\n</li>\n<li><p>二是被挂在客户端的CommTarget::idle_list上。可以理解为客户端的（对同一个ipaddr:port的）http连接池。</p>\n</li>\n</ul>\n<p>广义上讲，服务端的CommServiceTarget::idle_list也是http连接池。只是服务端的idle_list上只可能会有一个连接。</p>\n<p>然后可以预见的是：</p>\n<ol>\n<li><p>随着tcp连接状态的变化，state成员所记录的状态也会随之更新。</p>\n</li>\n<li><p>当ref成员减为零，CommConnEntry对象将会被free掉。</p>\n</li>\n</ol>\n<p>根据以往的经验能大胆猜测到的就是这些信息。</p>\n<h3 id=\"状态迁移池\"><a href=\"#状态迁移池\" class=\"headerlink\" title=\"状态迁移池\"></a>状态迁移池</h3><p>状态迁移池——没错，类似于事件池，状态迁移池也有一个循环，它的任务是不断根据IO的结果，转换连接上下文的状态，并且根据IO的结果去回调必要的处理函数，最为代表的是：session-&gt;handle，session的概念在go-task源码剖析一节中也是存在。它存在的意义在下一章讲解workflow对TCPServer的时候才适合透露。我们重点集中在communicator如何管理连接上下文的状态的。</p>\n<p>这里其实就引入了一个问题，连接上下文为什么存在状态的迁移？别急，让我一步步道来。</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>首先是状态池的启动————Communicator::init</p>\n<p>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::init</span><span class=\"params\">(<span class=\"type\">size_t</span> poller_threads, <span class=\"type\">size_t</span> handler_threads)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">create_poller</span>(poller_threads) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">create_handler_threads</span>(handler_threads) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;stop_flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">mpoller_stop</span>(<span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t<span class=\"built_in\">mpoller_destroy</span>(<span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t<span class=\"built_in\">msgqueue_destroy</span>(<span class=\"keyword\">this</span>-&gt;msgqueue);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>涉及的代码过多，这里仅挑重点。</p>\n<ol>\n<li><p>Communicator::init首先会启动mpoller，也就是上章我们所讲的事件池。上节的poller-&gt;callback函数以及它的参数poller-&gt;context，在poller初始化时就是由struct poller_params提供。而该结构体的够着在Communicator::create_poller当中是这样被赋值的：</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::callback</span><span class=\"params\">(<span class=\"keyword\">struct</span> poller_result *res, <span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">msgqueue_t</span> *msgqueue = (<span class=\"type\">msgqueue_t</span> *)context;</span><br><span class=\"line\">    <span class=\"built_in\">msgqueue_put</span>(res, msgqueue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::create_poller</span><span class=\"params\">(<span class=\"type\">size_t</span> poller_threads)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">poller_params</span> params = &#123;</span><br><span class=\"line\">        .max_open_files\t\t=\t(<span class=\"type\">size_t</span>)<span class=\"built_in\">sysconf</span>(_SC_OPEN_MAX),</span><br><span class=\"line\">        .callback\t\t\t=\tCommunicator::callback,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;msgqueue = <span class=\"built_in\">msgqueue_create</span>(<span class=\"number\">16</span> * <span class=\"number\">1024</span>, <span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> poller_result));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;msgqueue) &#123;</span><br><span class=\"line\">        params.context = <span class=\"keyword\">this</span>-&gt;msgqueue;</span><br><span class=\"line\">        <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 所以，可以看到，上章的poller-&gt;callback回调，会将传进来的poller_result追加到Communicator的状态迁移池的队列当中。</p>\n</li>\n<li><p>Communicator::init然后会启动状态迁移池。状态迁移池使用的就是workflow自己造了链式线程池轮子。特别的是，在线程池的每个线程都运行<strong>一个</strong>routine：Communicator::handler_thread_routine，该函数是一个死循环。在每个线程都分配到一个Communicator::handler_thread_routine后，<strong>线程池的队列</strong>其实就失去了它的意义。每个Communicator::handler_thread_routine会使用1当中分配的队列。</p>\n</li>\n</ol>\n<p>转到Communicator::handler_thread_routine，它的实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::handler_thread_routine</span><span class=\"params\">(<span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">\tCommunicator *comm = (Communicator *)context;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_result</span> *res;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tres = (<span class=\"keyword\">struct</span> poller_result *)<span class=\"built_in\">msgqueue_get</span>(comm-&gt;msgqueue);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!res)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (res-&gt;data.operation) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_TIMER:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_sleep_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_READ:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_read_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_WRITE:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_write_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_LISTEN:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_listen_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(res);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!comm-&gt;thrdpool) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">mpoller_destroy</span>(comm-&gt;mpoller);</span><br><span class=\"line\">\t\t<span class=\"built_in\">msgqueue_destroy</span>(comm-&gt;msgqueue);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>阅读过上面的代码后，我们应该惊喜，因为我们看到了free！这里我可以自信的回答这个问题：上节poller当中，只看到了针对poller_node的malloc函数，而没有看到对应的free函数，哪里调用了free函数去释放poller_node？</p>\n<p><strong>没错，poller_node就是在这里释放的。</strong></p>\n<p>poller_node生命周期是这样的链路：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__poller_new_node &#123; malloc &#125; -&gt; write(addr) -&gt; pipe -&gt; __poller_handle_pipe &#123; addr = read() &#125; -&gt; poller-&gt;callback(addr) -&gt; handler_thread_routine &#123; free &#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>最终在状态迁移池启动完毕后，结合poller的事件池，Communicator最终的系统架构如下图：</p>\n<p><img src=\"/2024/11/04/workflow/TCPServer_2/photo/StateTranslateThreadPool.drawio.png\"></p>\n<h3 id=\"IO结果的处理\"><a href=\"#IO结果的处理\" class=\"headerlink\" title=\"IO结果的处理\"></a>IO结果的处理</h3><p>还是贴出上章所讲解的基本tcp服务框架示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tsocket\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tbind\t|\t这三步就是由本节的Communicator执行</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tlisten\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|\t\t\t______________________________________________</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\taccept\t|\t从这里开始涉及到的所有函数是poller负责。</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\t|\t|\t|</span><br><span class=\"line\">V\tV\tV\tV</span><br><span class=\"line\">fd\tfd\tfd\t...</span><br><span class=\"line\">\t/\\</span><br><span class=\"line\">read  write</span><br></pre></td></tr></table></figure>\n\n<p>当然Communicator会使用mpoller暴露的api对sockfd设置所关心的IO事件。间接调用了IO系统调用接口。下面从listen fd入手，逐步揭开communicator的真面目。</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>创建绑定监听三部曲————Communicator::bind</p>\n<p>函数如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::bind</span><span class=\"params\">(CommService *service)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span> data;</span><br><span class=\"line\">\t<span class=\"type\">int</span> errno_bak = errno;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sockfd;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsockfd = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">nonblock_listen</span>(service);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sockfd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tdata.fd = sockfd;</span><br><span class=\"line\">\t\tdata.context = service;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t\tdata.operation = PD_OP_LISTEN;</span><br><span class=\"line\">\t\tdata.accept = Communicator::accept;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 开始接收客户端连接</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">mpoller_add</span>(&amp;data, service-&gt;listen_timeout, <span class=\"keyword\">this</span>-&gt;mpoller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\terrno = errno_bak;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到，listen套接字被分配了一个Communicator::accept回调，上一章介绍poller时每当listen套接字接收到一个客户端的连接，都会将IO socket作为参数回调一下accept函数，此处代表Communicator::accept，它实际上会为IO socket创建一个CommServiceTarget对象。</p>\n<p>三部曲核心在nonblock_listen，如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::nonblock_listen</span><span class=\"params\">(CommService *service)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sockfd = service-&gt;<span class=\"built_in\">create_listen_fd</span>();\t\t\t\t<span class=\"comment\">// scoket()</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sockfd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (__set_fd_nonblock(sockfd) &gt;= <span class=\"number\">0</span>)\t&#123;\t\t\t\t<span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (__bind_sockaddr(sockfd, service-&gt;bind_addr,</span><br><span class=\"line\">\t\t\t\t\t\t\t\tservice-&gt;addrlen) &gt;= <span class=\"number\">0</span>)\t&#123; \t<span class=\"comment\">// 监听socket和addr绑定</span></span><br><span class=\"line\">\t\t\t\tret = <span class=\"built_in\">listen</span>(sockfd, SOMAXCONN);\t\t\t<span class=\"comment\">// 开始监听</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (ret &gt;= <span class=\"number\">0</span> || errno == EOPNOTSUPP) &#123;</span><br><span class=\"line\">\t\t\t\t\tservice-&gt;reliable = (ret &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> sockfd;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以Communicator::bind绑定并启动一个tcpserver的流程是：</p>\n<ol>\n<li><p>初始化一个监听套接字。</p>\n</li>\n<li><p>将监听套接字添加到mpoller事件池当中。开始接受来自客户端的连接。</p>\n</li>\n</ol>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>接收客户端连接————Communicator::handle_listen_result</p>\n<p>了解了前面状态迁移池和bind的流程，结合上一章poller的源码分析，一旦poller的accept接收到一条连接会回调一下Communicator::accept，然后再调用poller-&gt;callback，并将IOsocket填到res，然后res被传回Communicator队列当中。状态迁移线程会从队列当中取res，然后根据res-&gt;data.operation，会去回调Communicator::handle_listen_result，它的实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::handle_listen_result</span><span class=\"params\">(<span class=\"keyword\">struct</span> poller_result *res)</span> </span>&#123;</span><br><span class=\"line\">\tCommService *service = (CommService *)res-&gt;data.context;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry;</span><br><span class=\"line\">\tCommServiceTarget *target;</span><br><span class=\"line\">\t<span class=\"type\">int</span> timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (res-&gt;state) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> PR_ST_SUCCESS:</span><br><span class=\"line\">\t\ttarget = (CommServiceTarget *)res-&gt;data.result;\t\t<span class=\"comment\">// Communicator::accept的返回值</span></span><br><span class=\"line\">\t\tentry = Communicator::<span class=\"built_in\">accept_conn</span>(target, service);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (entry) &#123;</span><br><span class=\"line\">\t\t\tentry-&gt;mpoller = <span class=\"keyword\">this</span>-&gt;mpoller;</span><br><span class=\"line\">\t\t\tres-&gt;data.operation = PD_OP_READ;</span><br><span class=\"line\">\t\t\tres-&gt;data.fd = entry-&gt;sockfd;</span><br><span class=\"line\">\t\t\tres-&gt;data.create_message = Communicator::create_request;</span><br><span class=\"line\">\t\t\tres-&gt;data.context = entry;</span><br><span class=\"line\">\t\t\tres-&gt;data.message = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\ttimeout = target-&gt;response_timeout;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">mpoller_add</span>(&amp;res-&gt;data, timeout, <span class=\"keyword\">this</span>-&gt;mpoller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;stop_flag)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">mpoller_del</span>(res-&gt;data.fd, <span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t__release_conn(entry);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(target-&gt;sockfd);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttarget-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Communicator::accept_conn函数根据res创建出IOsocket的连接上下文CommConnEntry，并且该连接上下文初始的state为CONN_STATE_CONNECTED。然后将该对象加入到mpoller事件池当中开启对IOsocket的读事件进行监听。</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>边接收边解析————Communicator::create_request + Communicator::append_message</p>\n<p>客户端请求报文解析完毕，状态转移————Communicator::handle_read_result</p>\n<p>因为这两部分涉及的代码过于庞大，详细讲解的话避免不了要贴大量的代码，作者表达水平有限。还是觉得使用图解的方式去呈现比较省事。所以，为避免文章代码比例过高，下一小节将会以图画的形式向读者剖析这部分的源码。</p>\n<h3 id=\"状态迁移总结\"><a href=\"#状态迁移总结\" class=\"headerlink\" title=\"状态迁移总结\"></a>状态迁移总结</h3><p>服务端监听套接字的绑定就不说了，下面使用一张图来讲解：从服务端接收客户端连接 到 读客户端请求报文（边读边解析），最后向客户端发送回复的一个流程。</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>接收客户端连接并读取解析客户端发来的报文流程————异步状态机之美</p>\n<p><img src=\"/2024/11/04/workflow/TCPServer_2/photo/ReadStatusTranslate.drawio.png\"></p>\n<p>第一步，是poller当中的__poller_handle_listen回调函数：</p>\n<ol>\n<li><p>服务端在接收到一个客户端连接后首先会为其创建一个CommServiceTarget对象。</p>\n</li>\n<li><p>然后将IO socketfd通过回调poller-&gt;callback（放到队列当中）传回给Communicator。</p>\n</li>\n</ol>\n<p>第二步，是Communicator的Communicator::handle_listen_result函数：</p>\n<ol>\n<li><p>状态变迁池拿到res对像后，得知operation为PD_OP_LISTEN的res，所以调用Communicator::handle_listen_result函数来处理res。</p>\n</li>\n<li><p>在Communicator::handle_listen_result函数当中，首先会构造一个连接上下文entry，它的状态被初始化为CONN_STATE_CONNECTED。</p>\n</li>\n<li><p>构造一个operation为READ的poller_node。并且data成员的create_message回调填为Communicator::create_request。</p>\n</li>\n<li><p>将poller_node加入到mpoller，开始对其度事件进行监听。</p>\n</li>\n</ol>\n<p>第三步，是poller当中的读事件处理回调__poller_handle_read：</p>\n<ol>\n<li><p>读数据。</p>\n</li>\n<li><p>__poller_append_message，它里面会创建一个poller_message_t对象（如果不存在的话，一般在一轮请求的最开始会构造一个msg对象）。利用poller_message_t对象对读到的数据进行解析。这是一个边读边解析的过程，中间可能会调用数次。当msg-&gt;append返回值大于0时，说明请求报文读并且解析完了。此时将msg封装在res当中，并<strong>回调poller-&gt;callback</strong>。create_message和append两个回调分别对应Communicator::create_request和Communicator::append_message。这两个函数核心代码已经在上图③号虚框当中显示，读者可以仔细阅读一下。这里其实涉及到连接上下文entry的两次状态变换。在create_message时，entry-&gt;state会变更为CONN_STATE_RECEIVING，而在数据解析完毕，Communicator::append_message当中的in-&gt;append返回大于0进入到下面的if分支又会将entry-&gt;state变更为CONN_STATE_SUCCESS。</p>\n</li>\n</ol>\n<p>第四步，也是读流程的最后一步，Communicator::handle_read_result当中的Communicator::handle_incoming_request函数：</p>\n<ol>\n<li><p>状态变迁池拿到res对像后，得知operation为PD_OP_READ的res，所以调用Communicator::handle_read_result函数来处理res。因为是服务端所以Communicator::handle_read_result函数会调用Communicator::handle_incoming_request函数。</p>\n</li>\n<li><p>这里会将session的state设置成CS_STATE_TOREPLY。</p>\n</li>\n<li><p>如果entry-&gt;state &#x3D;&#x3D; CONN_STATE_SUCCESS，则将entry挂到target的idle链表上、entry-&gt;ref++，同时entry-&gt;state修改成CONN_STATE_IDLE。session-&gt;passive 必须赋值为 2。</p>\n</li>\n<li><p>回调session-&gt;handle，然后entry-&gt;ref–，当entry-&gt;ref为0时，调用__release_conn将连接关闭，并free掉entry连接上下文。</p>\n</li>\n</ol>\n<p>所以entry状态变化顺序为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[CONN_STATE_CONNECTED] -&gt; [CONN_STATE_RECEIVING] -&gt; [CONN_STATE_SUCCESS] -&gt; [CONN_STATE_IDLE]</span><br></pre></td></tr></table></figure>\n\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>向客户端发送回复报文————先尽力而为的写，然后再异步写。</p>\n<p>当服务端需要发送一个回复报文时会调用Communicator::reply接口，它的代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::reply</span><span class=\"params\">(CommSession *session)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry;</span><br><span class=\"line\">\tCommServiceTarget *target;</span><br><span class=\"line\">\t<span class=\"type\">int</span> errno_bak;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (session-&gt;passive != <span class=\"number\">2</span>) &#123;\t<span class=\"comment\">// 处在读完毕的状态</span></span><br><span class=\"line\">\t\terrno = EINVAL;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\terrno_bak = errno;</span><br><span class=\"line\">\tsession-&gt;passive = <span class=\"number\">3</span>;\t\t\t<span class=\"comment\">// 写状态</span></span><br><span class=\"line\">\ttarget = (CommServiceTarget *)session-&gt;target;</span><br><span class=\"line\">\tret = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">reply_reliable</span>(session, target);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>) &#123;\t\t\t\t\t<span class=\"comment\">// 这里是同步写已经将所有数据发完了。无需异步写</span></span><br><span class=\"line\">\t\tentry = session-&gt;in-&gt;entry;</span><br><span class=\"line\">\t\tsession-&gt;<span class=\"built_in\">handle</span>(CS_STATE_SUCCESS, <span class=\"number\">0</span>);\t<span class=\"comment\">// 再次回调session的handle</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (__sync_sub_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t__release_conn(entry);</span><br><span class=\"line\">\t\t\ttarget-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\terrno = errno_bak;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::reply_reliable</span><span class=\"params\">(CommSession *session, CommTarget *target)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> *pos;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!<span class=\"built_in\">list_empty</span>(&amp;target-&gt;idle_list)) &#123;\t<span class=\"comment\">// 处于CONN_STATE_IDLE状态</span></span><br><span class=\"line\">\t\tpos = target-&gt;idle_list.next;</span><br><span class=\"line\">\t\tentry = <span class=\"built_in\">list_entry</span>(pos, <span class=\"keyword\">struct</span> CommConnEntry, list);</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_del</span>(pos);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsession-&gt;out = session-&gt;<span class=\"built_in\">message_out</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (session-&gt;out)</span><br><span class=\"line\">\t\t\tret = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">send_message</span>(entry);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\terrno = ENOENT;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::send_message</span><span class=\"params\">(<span class=\"keyword\">struct</span> CommConnEntry *entry)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\tend = vectors + cnt;</span><br><span class=\"line\">\tcnt = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">send_message_sync</span>(vectors, cnt, entry);\t\t<span class=\"comment\">// 先尽力而为的同步写</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">send_message_async</span>(end - cnt, cnt, entry);\t<span class=\"comment\">// 写缓存满了，需要异步写</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>写的设计思路和Muduo的很像<a href=\"https://blog.csdn.net/m0_52566365/article/details/135720278\">muduo源码阅读笔记（10、TcpConnection）</a>。这里不过多赘述，只讲一下差别。还是以全面的情况为例子，假设现在需要发送一批（回复）数据，并且同步写无法将所有的数据发送完。那么在同步写一部分我们的数据之后，肯定会触发异步写。</p>\n<p>而异步写呢，就得靠poller层的__poller_handle_write函数。只要tcp的发送缓存区非满，poller_node就会收到通知，然后尽力向发送缓存区写一些数据，这可能也需要花几轮的功夫去写数据。在这期间，每写一部分数据__poller_handle_write函数就会回调node-&gt;data.partial_written，从Communicator::send_message_async函数在构造WRITE类型的poller_node时我们可以得知partial_written就是Communicator::partial_written，而它的实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::partial_written</span><span class=\"params\">(<span class=\"type\">size_t</span> n, <span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry = (<span class=\"keyword\">struct</span> CommConnEntry *)context;</span><br><span class=\"line\">\tCommSession *session = entry-&gt;session;</span><br><span class=\"line\">\t<span class=\"type\">int</span> timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttimeout = Communicator::<span class=\"built_in\">next_timeout</span>(session);</span><br><span class=\"line\">\t<span class=\"built_in\">mpoller_set_timeout</span>(entry-&gt;sockfd, timeout, entry-&gt;mpoller);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在写完部分数据后，为什么需要回调一下partial_written呢？这里其实就得到了合理的解释，既然在规定的写超时时间内，我能向发送缓存写一些数据，那就说明网没断，只是网络状况可能不好。所以，按理来说，在规定的时间内发送了部分数据就应该更新一下发送的超时时间，避免没有必要的超时。</p>\n<p>一旦异步写完成了，和__poller_handle_read不同，**__poller_handle_write会自动将poller_node从epoll上移除**，然后回调poller-&gt;callback。（PS，如果你忘了poller的实现，建议回顾一下<a href=\"./TcpServer_1.md\">WorkFlow源码剖析——Communicator之TCPServer（上）</a>）</p>\n<p>然后同读完成类似，在Communicator当中写完成会被Communicator::handle_write_result处理，因为是服务断，所以会调用Communicator::handle_reply_result。该函数逻辑如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::handle_reply_result</span><span class=\"params\">(<span class=\"keyword\">struct</span> poller_result *res)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry = (<span class=\"keyword\">struct</span> CommConnEntry *)res-&gt;data.context;</span><br><span class=\"line\">\tCommService *service = entry-&gt;service;</span><br><span class=\"line\">\tCommSession *session = entry-&gt;session;</span><br><span class=\"line\">\tCommTarget *target = entry-&gt;target;</span><br><span class=\"line\">\t<span class=\"type\">int</span> timeout;</span><br><span class=\"line\">\t<span class=\"type\">int</span> state;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (res-&gt;state) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> PR_ST_FINISHED:</span><br><span class=\"line\">\t\ttimeout = session-&gt;<span class=\"built_in\">keep_alive_timeout</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (timeout != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t__sync_add_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>);\t\t\t\t\t\t\t<span class=\"comment\">// 避免被释放</span></span><br><span class=\"line\">\t\t\tres-&gt;data.operation = PD_OP_READ;</span><br><span class=\"line\">\t\t\tres-&gt;data.create_message = Communicator::create_request;</span><br><span class=\"line\">\t\t\tres-&gt;data.message = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">mpoller_add</span>(&amp;res-&gt;data, timeout, <span class=\"keyword\">this</span>-&gt;mpoller) &gt;= <span class=\"number\">0</span>) &#123;\t\t<span class=\"comment\">// 以读的方式添加到mpoller当中</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;service-&gt;mutex);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>-&gt;stop_flag &amp;&amp; service-&gt;listen_fd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tentry-&gt;state = CONN_STATE_KEEPALIVE;\t\t\t\t\t<span class=\"comment\">// entry-&gt;state修改成CONN_STATE_KEEPALIVE</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">list_add_tail</span>(&amp;entry-&gt;list, &amp;service-&gt;alive_list);\t\t<span class=\"comment\">// 追加到保活链表</span></span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">mpoller_del</span>(res-&gt;data.fd, <span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t\t\t\tentry-&gt;state = CONN_STATE_CLOSING;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;service-&gt;mutex);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 出错，该释放了</span></span><br><span class=\"line\">\t\t\t\t__sync_sub_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>);\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tstate = CS_STATE_SUCCESS;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsession-&gt;<span class=\"built_in\">handle</span>(state, res-&gt;error);\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 第二次回调session-&gt;handle</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (__sync_sub_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t__release_conn(entry);</span><br><span class=\"line\">\t\t\t((CommServiceTarget *)target)-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>逻辑分成三部分：</p>\n<ol>\n<li><p>将entry-&gt;ref自增一 &amp;&amp; 以读的方式将poller_node加回到mpoller当中继续监听客户端的读请求 &amp;&amp; 将entry-&gt;state修改成CONN_STATE_KEEPALIVE并且加到CommService的保活链表当中。</p>\n</li>\n<li><p>将session的state设置成CS_STATE_SUCCESS，再回调session-&gt;handle。</p>\n</li>\n<li><p>entry-&gt;ref自减一，为零就释放连接以及上下文。</p>\n</li>\n</ol>\n<p>所以在经过Communicator::handle_reply_result函数后，entry-&gt;state状态被修改为CONN_STATE_KEEPALIVE。然后再处理下一轮客户端请求。</p>\n<p>最后备忘一下：</p>\n<ol>\n<li><p><strong>对于session-&gt;passive的变化，在（create_request）创建msg（请求报文解析器）session-&gt;passive被置为1，在读取并解析完毕请求报文后，Communicator::handle_incoming_request函数回将session-&gt;passive置为2，在调用Communicator::reply向网络发送回复时session-&gt;passive会被置为3。</strong></p>\n</li>\n<li><p>Communicator::send_message_async当中在吧poller_node以WRITE方式加入到mpoller时会走到mpoller_mod分支。</p>\n</li>\n<li><p>在Communicator当中，TCPServer端的session是个啥？有的人可能会联想可能是HTTPServer当中的Session？我刚开始看源码也是这样认为的，但是实际上并非如此，Communicator当中的session的定义其实和workflow里面的go-task定义很像。HTTPServer当中的Session生命周期同整个HTTP连接一样。而Communicator当中它的生命周期更像仅仅只有<strong>一轮（请求-回复）</strong>，在一轮 请求-回复 过后<strong>自动</strong>被销毁。而翻阅Communicator源码发现，session会在Communicator::create_request函数中通过service-&gt;new_session接口进行分配，而释放却并不在Communicator当中。结合之前go-task的实现来看，我们可以大胆猜想：Communicator所出现的session对象一定会派生一个子类，然后session对象的释放由子类对象 delete自身而被释放了。</p>\n</li>\n</ol>\n<p>到了这里其实就能回答这个问题：连接上下文为什么存在状态的迁移？</p>\n<p>首先一条tcp连接在服务端必定纯在两种状态：接收、发送。而因为追求性能，我们不得不采用异步的方式将socketfd设置成非阻塞的。并且网络传输（不管是否阻塞）会引来一些问题：读不可能一次性读完、写不可能一次性写完，所以读的过程当中和写的过程当中都存在一种中间的状态。所以状态迁移是必然的。</p>\n<p>最后，在了解了workflow的底层架构之后，其实就能感觉到<strong>异步编程就是在实现一个状体机的过程</strong>。</p>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlow源码剖析——GO-Task 源码分析</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlow源码剖析——Communicator之TCPServer（上）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlow源码剖析——Communicator之TCPServer（中）</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlow源码剖析——Communicator之TCPServer（下）</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上节博客已经详细介绍了workflow的poller的实现，这节我们来看看Communicator是如何利用poller的，对连接对象生命周期的管理。（PS：与其说Communicator利用的是poller，其实Communicator使用的是mpoller，上节在介绍poller时也提到过mpoller，现场帮读者回忆一下：mpoller是poller的manager类，管理多个poller事件池，对外提供的接口负责将各种poller_node负载均衡的分散给不同的poller。）</p>\n<p>上节在介绍poller时，出现了各种回调，比如poller-&gt;callback()、node-&gt;data.accept()、node-&gt;data.partial_written()、node-&gt;data.create_message()等，当时我们总是一笔带过，没有去深入分析这些回调会做什么？并且每次在IO事件结束都会回调poller-&gt;callback()为什么要这样做？在poller当中，只看到了针对poller_node的malloc函数，而没有看到对应的free函数，哪里调用了free函数去释放poller_node？</p>","more":"<p>别着急，本节的源码分析会逐步揭晓这些疑问。</p>\n<p>同样的，注意里还是放在TCPServer上，对于SSL和UDP相关的内容直接忽略。先把TCP给模清楚。</p>\n<h2 id=\"管理连接对象的实现\"><a href=\"#管理连接对象的实现\" class=\"headerlink\" title=\"管理连接对象的实现\"></a>管理连接对象的实现</h2><h3 id=\"连接上下文数据结构的分析\"><a href=\"#连接上下文数据结构的分析\" class=\"headerlink\" title=\"连接上下文数据结构的分析\"></a>连接上下文数据结构的分析</h3><p>既然谈到对连接对象的管理，那Communicator必然有一个数据结构来表示一个连接上下文对象，它就是CommConnEntry，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> list;          <span class=\"comment\">// 链表节点，</span></span><br><span class=\"line\">\tCommConnection *conn;           <span class=\"comment\">// 下一章介绍TCPServer的时候会用到，本文可忽略。</span></span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> seq;                  <span class=\"comment\">// seq的作用其实可以理解为：一条连接 请求-回复 的轮次。一条连接的服务端和客户端理论上讲seq值是同时递增的，并且一定是保持相同的。</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> sockfd;                     <span class=\"comment\">// 连接的句柄</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_CONNECTING\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_CONNECTED\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_RECEIVING\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_SUCCESS\t\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_IDLE\t\t\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_KEEPALIVE\t5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_CLOSING\t\t6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_ERROR\t\t7</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> state;                      <span class=\"comment\">// 连接状态</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> error;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ref;                        <span class=\"comment\">// 对对象的引用计数</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> *write_iov;        <span class=\"comment\">// 异步写缓存</span></span><br><span class=\"line\">\tCommSession *session;           <span class=\"comment\">// 含义同go-task，每次读写完毕或则出错了都会调用该对象的hanle函数</span></span><br><span class=\"line\">\tCommTarget *target;             <span class=\"comment\">// 连接目的地。对于客户端，该成员是服务器的地址；对于服务端，该成员是客户端的地址。</span></span><br><span class=\"line\">\tCommService *service;           <span class=\"comment\">// 该成员仅服务端有意义</span></span><br><span class=\"line\">\t<span class=\"type\">mpoller_t</span> *mpoller;</span><br><span class=\"line\">\t<span class=\"comment\">/* Connection entry&#x27;s mutex is for client session only. */</span></span><br><span class=\"line\">\t<span class=\"type\">pthread_mutex_t</span> mutex;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>workflow将客户端、服务端、tcp、udp、ssl的实现都混杂在一个文件当中。在第一次阅读它的源码时有点双眼摸瞎的感觉。如果你有足够丰富的网络编程的经验可能还好。</p>\n<p>需要注意一点的是：该连接上下文在客户端和服务端所使用成员可能是不同的，客户端不会使用service成员，服务端不会使用seq成员。</p>\n<p>对于CommConnEntry::list成员，其实有两种用途：</p>\n<ul>\n<li><p>一是被挂在服务端的CommService::alive_list上。可以理解为服务端的http保活池。</p>\n</li>\n<li><p>二是被挂在客户端的CommTarget::idle_list上。可以理解为客户端的（对同一个ipaddr:port的）http连接池。</p>\n</li>\n</ul>\n<p>广义上讲，服务端的CommServiceTarget::idle_list也是http连接池。只是服务端的idle_list上只可能会有一个连接。</p>\n<p>然后可以预见的是：</p>\n<ol>\n<li><p>随着tcp连接状态的变化，state成员所记录的状态也会随之更新。</p>\n</li>\n<li><p>当ref成员减为零，CommConnEntry对象将会被free掉。</p>\n</li>\n</ol>\n<p>根据以往的经验能大胆猜测到的就是这些信息。</p>\n<h3 id=\"状态迁移池\"><a href=\"#状态迁移池\" class=\"headerlink\" title=\"状态迁移池\"></a>状态迁移池</h3><p>状态迁移池——没错，类似于事件池，状态迁移池也有一个循环，它的任务是不断根据IO的结果，转换连接上下文的状态，并且根据IO的结果去回调必要的处理函数，最为代表的是：session-&gt;handle，session的概念在go-task源码剖析一节中也是存在。它存在的意义在下一章讲解workflow对TCPServer的时候才适合透露。我们重点集中在communicator如何管理连接上下文的状态的。</p>\n<p>这里其实就引入了一个问题，连接上下文为什么存在状态的迁移？别急，让我一步步道来。</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>首先是状态池的启动————Communicator::init</p>\n<p>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::init</span><span class=\"params\">(<span class=\"type\">size_t</span> poller_threads, <span class=\"type\">size_t</span> handler_threads)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">create_poller</span>(poller_threads) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">create_handler_threads</span>(handler_threads) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;stop_flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">mpoller_stop</span>(<span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t<span class=\"built_in\">mpoller_destroy</span>(<span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t<span class=\"built_in\">msgqueue_destroy</span>(<span class=\"keyword\">this</span>-&gt;msgqueue);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>涉及的代码过多，这里仅挑重点。</p>\n<ol>\n<li><p>Communicator::init首先会启动mpoller，也就是上章我们所讲的事件池。上节的poller-&gt;callback函数以及它的参数poller-&gt;context，在poller初始化时就是由struct poller_params提供。而该结构体的够着在Communicator::create_poller当中是这样被赋值的：</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::callback</span><span class=\"params\">(<span class=\"keyword\">struct</span> poller_result *res, <span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">msgqueue_t</span> *msgqueue = (<span class=\"type\">msgqueue_t</span> *)context;</span><br><span class=\"line\">    <span class=\"built_in\">msgqueue_put</span>(res, msgqueue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::create_poller</span><span class=\"params\">(<span class=\"type\">size_t</span> poller_threads)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">poller_params</span> params = &#123;</span><br><span class=\"line\">        .max_open_files\t\t=\t(<span class=\"type\">size_t</span>)<span class=\"built_in\">sysconf</span>(_SC_OPEN_MAX),</span><br><span class=\"line\">        .callback\t\t\t=\tCommunicator::callback,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;msgqueue = <span class=\"built_in\">msgqueue_create</span>(<span class=\"number\">16</span> * <span class=\"number\">1024</span>, <span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> poller_result));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;msgqueue) &#123;</span><br><span class=\"line\">        params.context = <span class=\"keyword\">this</span>-&gt;msgqueue;</span><br><span class=\"line\">        <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 所以，可以看到，上章的poller-&gt;callback回调，会将传进来的poller_result追加到Communicator的状态迁移池的队列当中。</p>\n</li>\n<li><p>Communicator::init然后会启动状态迁移池。状态迁移池使用的就是workflow自己造了链式线程池轮子。特别的是，在线程池的每个线程都运行<strong>一个</strong>routine：Communicator::handler_thread_routine，该函数是一个死循环。在每个线程都分配到一个Communicator::handler_thread_routine后，<strong>线程池的队列</strong>其实就失去了它的意义。每个Communicator::handler_thread_routine会使用1当中分配的队列。</p>\n</li>\n</ol>\n<p>转到Communicator::handler_thread_routine，它的实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::handler_thread_routine</span><span class=\"params\">(<span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">\tCommunicator *comm = (Communicator *)context;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_result</span> *res;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tres = (<span class=\"keyword\">struct</span> poller_result *)<span class=\"built_in\">msgqueue_get</span>(comm-&gt;msgqueue);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!res)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (res-&gt;data.operation) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_TIMER:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_sleep_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_READ:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_read_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_WRITE:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_write_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_LISTEN:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_listen_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(res);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!comm-&gt;thrdpool) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">mpoller_destroy</span>(comm-&gt;mpoller);</span><br><span class=\"line\">\t\t<span class=\"built_in\">msgqueue_destroy</span>(comm-&gt;msgqueue);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>阅读过上面的代码后，我们应该惊喜，因为我们看到了free！这里我可以自信的回答这个问题：上节poller当中，只看到了针对poller_node的malloc函数，而没有看到对应的free函数，哪里调用了free函数去释放poller_node？</p>\n<p><strong>没错，poller_node就是在这里释放的。</strong></p>\n<p>poller_node生命周期是这样的链路：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__poller_new_node &#123; malloc &#125; -&gt; write(addr) -&gt; pipe -&gt; __poller_handle_pipe &#123; addr = read() &#125; -&gt; poller-&gt;callback(addr) -&gt; handler_thread_routine &#123; free &#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>最终在状态迁移池启动完毕后，结合poller的事件池，Communicator最终的系统架构如下图：</p>\n<p><img src=\"/2024/11/04/workflow/TCPServer_2/photo/StateTranslateThreadPool.drawio.png\"></p>\n<h3 id=\"IO结果的处理\"><a href=\"#IO结果的处理\" class=\"headerlink\" title=\"IO结果的处理\"></a>IO结果的处理</h3><p>还是贴出上章所讲解的基本tcp服务框架示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tsocket\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tbind\t|\t这三步就是由本节的Communicator执行</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tlisten\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|\t\t\t______________________________________________</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\taccept\t|\t从这里开始涉及到的所有函数是poller负责。</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\t|\t|\t|</span><br><span class=\"line\">V\tV\tV\tV</span><br><span class=\"line\">fd\tfd\tfd\t...</span><br><span class=\"line\">\t/\\</span><br><span class=\"line\">read  write</span><br></pre></td></tr></table></figure>\n\n<p>当然Communicator会使用mpoller暴露的api对sockfd设置所关心的IO事件。间接调用了IO系统调用接口。下面从listen fd入手，逐步揭开communicator的真面目。</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>创建绑定监听三部曲————Communicator::bind</p>\n<p>函数如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::bind</span><span class=\"params\">(CommService *service)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span> data;</span><br><span class=\"line\">\t<span class=\"type\">int</span> errno_bak = errno;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sockfd;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsockfd = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">nonblock_listen</span>(service);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sockfd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tdata.fd = sockfd;</span><br><span class=\"line\">\t\tdata.context = service;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t\tdata.operation = PD_OP_LISTEN;</span><br><span class=\"line\">\t\tdata.accept = Communicator::accept;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 开始接收客户端连接</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">mpoller_add</span>(&amp;data, service-&gt;listen_timeout, <span class=\"keyword\">this</span>-&gt;mpoller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\terrno = errno_bak;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到，listen套接字被分配了一个Communicator::accept回调，上一章介绍poller时每当listen套接字接收到一个客户端的连接，都会将IO socket作为参数回调一下accept函数，此处代表Communicator::accept，它实际上会为IO socket创建一个CommServiceTarget对象。</p>\n<p>三部曲核心在nonblock_listen，如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::nonblock_listen</span><span class=\"params\">(CommService *service)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sockfd = service-&gt;<span class=\"built_in\">create_listen_fd</span>();\t\t\t\t<span class=\"comment\">// scoket()</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sockfd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (__set_fd_nonblock(sockfd) &gt;= <span class=\"number\">0</span>)\t&#123;\t\t\t\t<span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (__bind_sockaddr(sockfd, service-&gt;bind_addr,</span><br><span class=\"line\">\t\t\t\t\t\t\t\tservice-&gt;addrlen) &gt;= <span class=\"number\">0</span>)\t&#123; \t<span class=\"comment\">// 监听socket和addr绑定</span></span><br><span class=\"line\">\t\t\t\tret = <span class=\"built_in\">listen</span>(sockfd, SOMAXCONN);\t\t\t<span class=\"comment\">// 开始监听</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (ret &gt;= <span class=\"number\">0</span> || errno == EOPNOTSUPP) &#123;</span><br><span class=\"line\">\t\t\t\t\tservice-&gt;reliable = (ret &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> sockfd;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以Communicator::bind绑定并启动一个tcpserver的流程是：</p>\n<ol>\n<li><p>初始化一个监听套接字。</p>\n</li>\n<li><p>将监听套接字添加到mpoller事件池当中。开始接受来自客户端的连接。</p>\n</li>\n</ol>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>接收客户端连接————Communicator::handle_listen_result</p>\n<p>了解了前面状态迁移池和bind的流程，结合上一章poller的源码分析，一旦poller的accept接收到一条连接会回调一下Communicator::accept，然后再调用poller-&gt;callback，并将IOsocket填到res，然后res被传回Communicator队列当中。状态迁移线程会从队列当中取res，然后根据res-&gt;data.operation，会去回调Communicator::handle_listen_result，它的实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::handle_listen_result</span><span class=\"params\">(<span class=\"keyword\">struct</span> poller_result *res)</span> </span>&#123;</span><br><span class=\"line\">\tCommService *service = (CommService *)res-&gt;data.context;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry;</span><br><span class=\"line\">\tCommServiceTarget *target;</span><br><span class=\"line\">\t<span class=\"type\">int</span> timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (res-&gt;state) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> PR_ST_SUCCESS:</span><br><span class=\"line\">\t\ttarget = (CommServiceTarget *)res-&gt;data.result;\t\t<span class=\"comment\">// Communicator::accept的返回值</span></span><br><span class=\"line\">\t\tentry = Communicator::<span class=\"built_in\">accept_conn</span>(target, service);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (entry) &#123;</span><br><span class=\"line\">\t\t\tentry-&gt;mpoller = <span class=\"keyword\">this</span>-&gt;mpoller;</span><br><span class=\"line\">\t\t\tres-&gt;data.operation = PD_OP_READ;</span><br><span class=\"line\">\t\t\tres-&gt;data.fd = entry-&gt;sockfd;</span><br><span class=\"line\">\t\t\tres-&gt;data.create_message = Communicator::create_request;</span><br><span class=\"line\">\t\t\tres-&gt;data.context = entry;</span><br><span class=\"line\">\t\t\tres-&gt;data.message = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\ttimeout = target-&gt;response_timeout;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">mpoller_add</span>(&amp;res-&gt;data, timeout, <span class=\"keyword\">this</span>-&gt;mpoller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;stop_flag)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">mpoller_del</span>(res-&gt;data.fd, <span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t__release_conn(entry);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(target-&gt;sockfd);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttarget-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Communicator::accept_conn函数根据res创建出IOsocket的连接上下文CommConnEntry，并且该连接上下文初始的state为CONN_STATE_CONNECTED。然后将该对象加入到mpoller事件池当中开启对IOsocket的读事件进行监听。</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>边接收边解析————Communicator::create_request + Communicator::append_message</p>\n<p>客户端请求报文解析完毕，状态转移————Communicator::handle_read_result</p>\n<p>因为这两部分涉及的代码过于庞大，详细讲解的话避免不了要贴大量的代码，作者表达水平有限。还是觉得使用图解的方式去呈现比较省事。所以，为避免文章代码比例过高，下一小节将会以图画的形式向读者剖析这部分的源码。</p>\n<h3 id=\"状态迁移总结\"><a href=\"#状态迁移总结\" class=\"headerlink\" title=\"状态迁移总结\"></a>状态迁移总结</h3><p>服务端监听套接字的绑定就不说了，下面使用一张图来讲解：从服务端接收客户端连接 到 读客户端请求报文（边读边解析），最后向客户端发送回复的一个流程。</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>接收客户端连接并读取解析客户端发来的报文流程————异步状态机之美</p>\n<p><img src=\"/2024/11/04/workflow/TCPServer_2/photo/ReadStatusTranslate.drawio.png\"></p>\n<p>第一步，是poller当中的__poller_handle_listen回调函数：</p>\n<ol>\n<li><p>服务端在接收到一个客户端连接后首先会为其创建一个CommServiceTarget对象。</p>\n</li>\n<li><p>然后将IO socketfd通过回调poller-&gt;callback（放到队列当中）传回给Communicator。</p>\n</li>\n</ol>\n<p>第二步，是Communicator的Communicator::handle_listen_result函数：</p>\n<ol>\n<li><p>状态变迁池拿到res对像后，得知operation为PD_OP_LISTEN的res，所以调用Communicator::handle_listen_result函数来处理res。</p>\n</li>\n<li><p>在Communicator::handle_listen_result函数当中，首先会构造一个连接上下文entry，它的状态被初始化为CONN_STATE_CONNECTED。</p>\n</li>\n<li><p>构造一个operation为READ的poller_node。并且data成员的create_message回调填为Communicator::create_request。</p>\n</li>\n<li><p>将poller_node加入到mpoller，开始对其度事件进行监听。</p>\n</li>\n</ol>\n<p>第三步，是poller当中的读事件处理回调__poller_handle_read：</p>\n<ol>\n<li><p>读数据。</p>\n</li>\n<li><p>__poller_append_message，它里面会创建一个poller_message_t对象（如果不存在的话，一般在一轮请求的最开始会构造一个msg对象）。利用poller_message_t对象对读到的数据进行解析。这是一个边读边解析的过程，中间可能会调用数次。当msg-&gt;append返回值大于0时，说明请求报文读并且解析完了。此时将msg封装在res当中，并<strong>回调poller-&gt;callback</strong>。create_message和append两个回调分别对应Communicator::create_request和Communicator::append_message。这两个函数核心代码已经在上图③号虚框当中显示，读者可以仔细阅读一下。这里其实涉及到连接上下文entry的两次状态变换。在create_message时，entry-&gt;state会变更为CONN_STATE_RECEIVING，而在数据解析完毕，Communicator::append_message当中的in-&gt;append返回大于0进入到下面的if分支又会将entry-&gt;state变更为CONN_STATE_SUCCESS。</p>\n</li>\n</ol>\n<p>第四步，也是读流程的最后一步，Communicator::handle_read_result当中的Communicator::handle_incoming_request函数：</p>\n<ol>\n<li><p>状态变迁池拿到res对像后，得知operation为PD_OP_READ的res，所以调用Communicator::handle_read_result函数来处理res。因为是服务端所以Communicator::handle_read_result函数会调用Communicator::handle_incoming_request函数。</p>\n</li>\n<li><p>这里会将session的state设置成CS_STATE_TOREPLY。</p>\n</li>\n<li><p>如果entry-&gt;state &#x3D;&#x3D; CONN_STATE_SUCCESS，则将entry挂到target的idle链表上、entry-&gt;ref++，同时entry-&gt;state修改成CONN_STATE_IDLE。session-&gt;passive 必须赋值为 2。</p>\n</li>\n<li><p>回调session-&gt;handle，然后entry-&gt;ref–，当entry-&gt;ref为0时，调用__release_conn将连接关闭，并free掉entry连接上下文。</p>\n</li>\n</ol>\n<p>所以entry状态变化顺序为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[CONN_STATE_CONNECTED] -&gt; [CONN_STATE_RECEIVING] -&gt; [CONN_STATE_SUCCESS] -&gt; [CONN_STATE_IDLE]</span><br></pre></td></tr></table></figure>\n\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>向客户端发送回复报文————先尽力而为的写，然后再异步写。</p>\n<p>当服务端需要发送一个回复报文时会调用Communicator::reply接口，它的代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::reply</span><span class=\"params\">(CommSession *session)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry;</span><br><span class=\"line\">\tCommServiceTarget *target;</span><br><span class=\"line\">\t<span class=\"type\">int</span> errno_bak;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (session-&gt;passive != <span class=\"number\">2</span>) &#123;\t<span class=\"comment\">// 处在读完毕的状态</span></span><br><span class=\"line\">\t\terrno = EINVAL;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\terrno_bak = errno;</span><br><span class=\"line\">\tsession-&gt;passive = <span class=\"number\">3</span>;\t\t\t<span class=\"comment\">// 写状态</span></span><br><span class=\"line\">\ttarget = (CommServiceTarget *)session-&gt;target;</span><br><span class=\"line\">\tret = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">reply_reliable</span>(session, target);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>) &#123;\t\t\t\t\t<span class=\"comment\">// 这里是同步写已经将所有数据发完了。无需异步写</span></span><br><span class=\"line\">\t\tentry = session-&gt;in-&gt;entry;</span><br><span class=\"line\">\t\tsession-&gt;<span class=\"built_in\">handle</span>(CS_STATE_SUCCESS, <span class=\"number\">0</span>);\t<span class=\"comment\">// 再次回调session的handle</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (__sync_sub_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t__release_conn(entry);</span><br><span class=\"line\">\t\t\ttarget-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\terrno = errno_bak;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::reply_reliable</span><span class=\"params\">(CommSession *session, CommTarget *target)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> *pos;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!<span class=\"built_in\">list_empty</span>(&amp;target-&gt;idle_list)) &#123;\t<span class=\"comment\">// 处于CONN_STATE_IDLE状态</span></span><br><span class=\"line\">\t\tpos = target-&gt;idle_list.next;</span><br><span class=\"line\">\t\tentry = <span class=\"built_in\">list_entry</span>(pos, <span class=\"keyword\">struct</span> CommConnEntry, list);</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_del</span>(pos);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsession-&gt;out = session-&gt;<span class=\"built_in\">message_out</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (session-&gt;out)</span><br><span class=\"line\">\t\t\tret = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">send_message</span>(entry);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\terrno = ENOENT;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::send_message</span><span class=\"params\">(<span class=\"keyword\">struct</span> CommConnEntry *entry)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\tend = vectors + cnt;</span><br><span class=\"line\">\tcnt = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">send_message_sync</span>(vectors, cnt, entry);\t\t<span class=\"comment\">// 先尽力而为的同步写</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">send_message_async</span>(end - cnt, cnt, entry);\t<span class=\"comment\">// 写缓存满了，需要异步写</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>写的设计思路和Muduo的很像<a href=\"https://blog.csdn.net/m0_52566365/article/details/135720278\">muduo源码阅读笔记（10、TcpConnection）</a>。这里不过多赘述，只讲一下差别。还是以全面的情况为例子，假设现在需要发送一批（回复）数据，并且同步写无法将所有的数据发送完。那么在同步写一部分我们的数据之后，肯定会触发异步写。</p>\n<p>而异步写呢，就得靠poller层的__poller_handle_write函数。只要tcp的发送缓存区非满，poller_node就会收到通知，然后尽力向发送缓存区写一些数据，这可能也需要花几轮的功夫去写数据。在这期间，每写一部分数据__poller_handle_write函数就会回调node-&gt;data.partial_written，从Communicator::send_message_async函数在构造WRITE类型的poller_node时我们可以得知partial_written就是Communicator::partial_written，而它的实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::partial_written</span><span class=\"params\">(<span class=\"type\">size_t</span> n, <span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry = (<span class=\"keyword\">struct</span> CommConnEntry *)context;</span><br><span class=\"line\">\tCommSession *session = entry-&gt;session;</span><br><span class=\"line\">\t<span class=\"type\">int</span> timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttimeout = Communicator::<span class=\"built_in\">next_timeout</span>(session);</span><br><span class=\"line\">\t<span class=\"built_in\">mpoller_set_timeout</span>(entry-&gt;sockfd, timeout, entry-&gt;mpoller);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在写完部分数据后，为什么需要回调一下partial_written呢？这里其实就得到了合理的解释，既然在规定的写超时时间内，我能向发送缓存写一些数据，那就说明网没断，只是网络状况可能不好。所以，按理来说，在规定的时间内发送了部分数据就应该更新一下发送的超时时间，避免没有必要的超时。</p>\n<p>一旦异步写完成了，和__poller_handle_read不同，**__poller_handle_write会自动将poller_node从epoll上移除**，然后回调poller-&gt;callback。（PS，如果你忘了poller的实现，建议回顾一下<a href=\"./TcpServer_1.md\">WorkFlow源码剖析——Communicator之TCPServer（上）</a>）</p>\n<p>然后同读完成类似，在Communicator当中写完成会被Communicator::handle_write_result处理，因为是服务断，所以会调用Communicator::handle_reply_result。该函数逻辑如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::handle_reply_result</span><span class=\"params\">(<span class=\"keyword\">struct</span> poller_result *res)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry = (<span class=\"keyword\">struct</span> CommConnEntry *)res-&gt;data.context;</span><br><span class=\"line\">\tCommService *service = entry-&gt;service;</span><br><span class=\"line\">\tCommSession *session = entry-&gt;session;</span><br><span class=\"line\">\tCommTarget *target = entry-&gt;target;</span><br><span class=\"line\">\t<span class=\"type\">int</span> timeout;</span><br><span class=\"line\">\t<span class=\"type\">int</span> state;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (res-&gt;state) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> PR_ST_FINISHED:</span><br><span class=\"line\">\t\ttimeout = session-&gt;<span class=\"built_in\">keep_alive_timeout</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (timeout != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t__sync_add_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>);\t\t\t\t\t\t\t<span class=\"comment\">// 避免被释放</span></span><br><span class=\"line\">\t\t\tres-&gt;data.operation = PD_OP_READ;</span><br><span class=\"line\">\t\t\tres-&gt;data.create_message = Communicator::create_request;</span><br><span class=\"line\">\t\t\tres-&gt;data.message = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">mpoller_add</span>(&amp;res-&gt;data, timeout, <span class=\"keyword\">this</span>-&gt;mpoller) &gt;= <span class=\"number\">0</span>) &#123;\t\t<span class=\"comment\">// 以读的方式添加到mpoller当中</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;service-&gt;mutex);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>-&gt;stop_flag &amp;&amp; service-&gt;listen_fd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tentry-&gt;state = CONN_STATE_KEEPALIVE;\t\t\t\t\t<span class=\"comment\">// entry-&gt;state修改成CONN_STATE_KEEPALIVE</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">list_add_tail</span>(&amp;entry-&gt;list, &amp;service-&gt;alive_list);\t\t<span class=\"comment\">// 追加到保活链表</span></span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">mpoller_del</span>(res-&gt;data.fd, <span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t\t\t\tentry-&gt;state = CONN_STATE_CLOSING;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;service-&gt;mutex);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 出错，该释放了</span></span><br><span class=\"line\">\t\t\t\t__sync_sub_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>);\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tstate = CS_STATE_SUCCESS;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsession-&gt;<span class=\"built_in\">handle</span>(state, res-&gt;error);\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 第二次回调session-&gt;handle</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (__sync_sub_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t__release_conn(entry);</span><br><span class=\"line\">\t\t\t((CommServiceTarget *)target)-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>逻辑分成三部分：</p>\n<ol>\n<li><p>将entry-&gt;ref自增一 &amp;&amp; 以读的方式将poller_node加回到mpoller当中继续监听客户端的读请求 &amp;&amp; 将entry-&gt;state修改成CONN_STATE_KEEPALIVE并且加到CommService的保活链表当中。</p>\n</li>\n<li><p>将session的state设置成CS_STATE_SUCCESS，再回调session-&gt;handle。</p>\n</li>\n<li><p>entry-&gt;ref自减一，为零就释放连接以及上下文。</p>\n</li>\n</ol>\n<p>所以在经过Communicator::handle_reply_result函数后，entry-&gt;state状态被修改为CONN_STATE_KEEPALIVE。然后再处理下一轮客户端请求。</p>\n<p>最后备忘一下：</p>\n<ol>\n<li><p><strong>对于session-&gt;passive的变化，在（create_request）创建msg（请求报文解析器）session-&gt;passive被置为1，在读取并解析完毕请求报文后，Communicator::handle_incoming_request函数回将session-&gt;passive置为2，在调用Communicator::reply向网络发送回复时session-&gt;passive会被置为3。</strong></p>\n</li>\n<li><p>Communicator::send_message_async当中在吧poller_node以WRITE方式加入到mpoller时会走到mpoller_mod分支。</p>\n</li>\n<li><p>在Communicator当中，TCPServer端的session是个啥？有的人可能会联想可能是HTTPServer当中的Session？我刚开始看源码也是这样认为的，但是实际上并非如此，Communicator当中的session的定义其实和workflow里面的go-task定义很像。HTTPServer当中的Session生命周期同整个HTTP连接一样。而Communicator当中它的生命周期更像仅仅只有<strong>一轮（请求-回复）</strong>，在一轮 请求-回复 过后<strong>自动</strong>被销毁。而翻阅Communicator源码发现，session会在Communicator::create_request函数中通过service-&gt;new_session接口进行分配，而释放却并不在Communicator当中。结合之前go-task的实现来看，我们可以大胆猜想：Communicator所出现的session对象一定会派生一个子类，然后session对象的释放由子类对象 delete自身而被释放了。</p>\n</li>\n</ol>\n<p>到了这里其实就能回答这个问题：连接上下文为什么存在状态的迁移？</p>\n<p>首先一条tcp连接在服务端必定纯在两种状态：接收、发送。而因为追求性能，我们不得不采用异步的方式将socketfd设置成非阻塞的。并且网络传输（不管是否阻塞）会引来一些问题：读不可能一次性读完、写不可能一次性写完，所以读的过程当中和写的过程当中都存在一种中间的状态。所以状态迁移是必然的。</p>\n<p>最后，在了解了workflow的底层架构之后，其实就能感觉到<strong>异步编程就是在实现一个状体机的过程</strong>。</p>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"这才是计科之 Onix & XV6 源码分析（2、类Unix的内存管理）","date":"2024-06-07T04:00:00.000Z","_content":"\n## 前言\n\n前一章我们介绍了XV6的启动流程，在本章，我们就要开始介绍类Unix操作系统最重要的一部分——内存管理模块。\n\n本文以XV6里面的内存管理为主，后面会提炼Onix中内存管理比较好的部分，来对XV6进行一个补充。\n\nOnix相关链接：\n\n- [github仓库链接](https://github.com/StevenBaby/onix)。\n\n- [B站配套视频链接](https://www.bilibili.com/video/BV1qM4y127om/)。\n\nXV6-x86的github链接：\n\n- [链接](https://github.com/mit-pdos/xv6-public)。\n\n<!-- more -->\n\n## 分页\n\n首先了解一下unix-like系统虚拟内存做法。\n\nx86中分页涉及两个主要寄存器：cr0、cr3，cr0主要用于控制是否开启分页，cr3用于存放页目录的地址。当cr0寄存器设置开启分页，cpu所使用的一切地址皆是虚拟地址，在分页机制中，一个虚拟地址被划分成3个部分，如下图：\n\n![](./MemoryManager/photo/memmanager/vaddr.png)\n\n如图中所注释的那样，地址的高10位代表在**页目录**中的索引（一个目录项占4Byte）、中间10位代表**页表**上的索引（一个页表项占4Byte）、低12位代表在**页框**上的偏移（1Byte为单位）。一个典型的页目录大小是4096字节（一个Page的大小），页表和页目录大小一样。并且低12位的寻址范围正好也是4096，这样一切就恰到好处。此时：sizeof(页目录) == sizeof(页表) == sizeof(页框) == 4096。\n\n此外，由于页目录（页表）每一项都是4Byte为单位。所以每个页目录（页表）正好有1024个entry。\n\n一个页目录（页表）的每一个索引项都是4Byte，这4Byte格式如下图：\n\n![](./MemoryManager/photo/memmanager/entry.png)\n\n从entry的结构图可以看出，它的高20位指向页框号（物理上的），在4G的物理地址空间内，一个页面按4096个字节算的话，正好有1M个页面（页框）。所以20位正好能为每一个页框从0开始编址。\n\nentry的低12位是一些控制位，比如0位指示该entry所指向的物理地址是否有效，第1位指示entry所指的物理页是否可写，第3位代表用户态能否访问，等等。我们可以利用这些位来实现很多unix-like中的骚操作，最有名的应该是利用第1位实现**写时拷贝**。\n\nCPU会通过MMU来完成虚拟地址到物理地址的翻译，记要翻译的虚拟地址是vaddr，过程如下：\n\n0. 拿到cr3指向的页目录地址（物理地址），dir_paddr。\n\n1. 位运算取vaddr的高10位，将高10位作为页目录的索引，得到dir_entry，dir_entry会指向下一级的页表，所以通过dir_entry可以得到页表的地址（物理地址），tab_paddr。\ns\n2. 位运算取vaddr中间10位，将中间10位作为页表的索引，得到tab_entry，tab_entry会指向最后一级的页框，所以通过tab_entry可以得到页框的地址（物理地址），frm_paddr。\n\n3. 最后，位运算取vaddr的低12位，这12位作为页框的物理地址frm_addr的偏移，于此得到了虚拟地址对应的物理地址：frm_paddr + offset。\n\n整个流程可以使用xv6官方提供的图来描绘：\n\n![](./MemoryManager/photo/memmanager/vaddr2paddr.png)\n\n## 内存管理\n\n首先回顾一下，在进入main前，cpu的状态如下：关中断 & 进入了保护模式 & 安装了一个临时全局描述符 & BSP分配了一个4K的内核栈 & 开启了4M big page的临时分页。\n\nXV6在main函数中会进行内存管理相关的初始化：\n\n```cpp\nint\nmain(void)\n{\n  kinit1(end, P2V(4*1024*1024)); // phys page allocator\n  kvmalloc();      // kernel page table\n  seginit();       // segment descriptors // 扩张了用户【数据&代码】段描述符，源码很简单，读者可自行阅读，这里就不去帖代码了\n  // ...\n  startothers();   // start other processors  // 唤醒其他处理器，本文不会做过多讲解，后面的文章再深入探讨。\n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()\n  // ...\n}\n```\n\n因为cpu现在是开启分页的，所以，我们利用P2V宏来获得4M物理地址对应的虚拟地址，实现也很简单，就是物理地址加上内核基地址的偏移就能得到物理地址对应的虚拟地址：\n\n```cpp\n#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts\n#define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts\n```\n\n### kinit1：初始化内核内存分配器（阶段1）。\n\nxv6的注释将kalloc称为物理内存分配器，这是第一个吐槽点，从它的源码上来看，我认为把它称为内核内存分配器更加合适。因为xv6把物理内存、内核内存的管理全都交给kalloc做，并且内存粒度也固定为4K。由于所有的物理地址也由kalloc管理，**为此内核不得不去在自己的页表上去映射所有的物理内存！**，其优点就是代码实现上会很简单（特别是在软件实现修改页表的操作上），但是这样做是非常暴力的。如果你阅读过Onix、或者其他更完善的unix-like操作系统的话会发现，更加严谨的做法是：get_page + alloc_kpage + kmalloc：\n\n```cpp\n// Onix\n\n// src/kernel/memory.c\n\n// 底层实现为：使用连续的256页来跟踪每个页框，每个页框会对应1Byte的entry\n// 使用1Byte的好处是可以记录每个页框的索引。这里方便实现copy on write\n// 和xv6不同，我们在后面就会看到，Onix在实现fork的copy on write时，子进程的\n// 页表也是动态复制的。\n\n// 分配一页物理内存\nstatic u32 get_page() { /* ... */ }\n// 释放一页物理内存\nstatic void put_page(u32 addr) {/* ... */}\n\n// 该函数是基于位图实现，利用位图来管理内核的内存，只有页目录的内存分配会使用内核内存，\n// 页表、页框的内存分配全部通过get_page()函数。内核页表也不用相xv6那样去映射所有物理页，\n// 另外一个优点是该函数可以连续分配多个内核页，xv6就存在最大只能分配1个page的限制！\n\n// src/kernel/memory.c\n\n// 分配 count 个连续的内核页\nu32 alloc_kpage(u32 count) { /* ... */ }\n// 释放 count 个连续的内核页\nvoid free_kpage(u32 vaddr, u32 count) { /* ... */ }\n\n// src/kernel/area.c\n// 该函数是更加细粒度的分配内核内存，可以分配小于4K的小块内存。内部有一个内存池，\n\n// 对细小内存进行池化管理。\nvoid *kmalloc(size_t size) { /* ... */ }\nvoid kfree(void *ptr) { /* ... */ }\n```\n\n这里可以计算一下：如果以1byte为单位去管理1M的页（1M * pagesieze（4096）== 4G），1页可以管理4096页内存，所以1M的页需要 （1024 * 1024） / （4 * 1024） = 256页。\n\n回到kinit1函数，kinit1函数执行第一个阶段的内核内存管理的初始化。它会把从内核代码结束的位置开始往上4M的位置为止，以page为单位将每一页利用链表串起来。这部分涉及代码非常简单，直接看源码会比较清晰，这里就不贴它的代码了。大概的结构图如下：\n\n![](./MemoryManager/photo/memmanager/kalloc.drawio.png)\n\n### kvmalloc：构造并安装更加细粒度的页表kpgdir\n\n首先明确，到目前为止cpu使用的entrypgdir是4M big page的页表。kvmalloc会构造一个页表kpgdir，该页表会使用4K的页，分页粒度更加细粒，相对于entrypgdir来说做了进一步细分。kpgdir的内核映射的地址是没有任何变化的，切换到kpgdir页表后，内核的地址空间和之前没有什么区别。唯一的区别就是kpgdir的地址映射范围更大，多了一些entrypgdir页表所不可访问的范围。从数组kmap可以看到，pgdir将原来4M的内核空间扩张到了PHYSTOP（224M），同时将物理内存的高位的设备空间**直接映射**到内核高位虚拟地址空间。XV6在启动阶段没有进行内存探测，只是暴力的将可分配物理内存规定为PHYSTOP（224M）大小，我们可以通过修改PHYSTOP来动态调整XV6的物理内存上限。但是由于PHYSTOP被映射到了KERNBASE之上，所以PHYSTOP的大小是有限制的，即使物理内存是4G，KERNBASE + PHYSTOP的大小也不能覆盖设备地址空间。\n\n```cpp\nstatic struct kmap {\n  void *virt;\n  uint phys_start;\n  uint phys_end;\n  int perm;\n} kmap[] = {\n { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space\n { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata\n { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory\n { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices\n};\n```\n\n直接上代码：\n\n下面这个函数主要作用就是根据页表，用软件模拟MMU的方式，找到传进来的虚拟地址va对应的页表项的虚拟地址，这里用语言表述的可能有点绕。代码从某种程度上比语言好懂。如果alloc为1，在对应的页表不存在时就创建一个页表：\n\n```cpp\n// 简单讲，就是返回va对应页表项的虚拟地址\nstatic pte_t *\nwalkpgdir(pde_t *pgdir, const void *va, int alloc)\n{\n  pde_t *pde;   // vaddr 虚拟地址\n  pte_t *pgtab; // vaddr 虚拟地址\n\n  pde = &pgdir[PDX(va)];                          // 虚拟地址va对应的页表所在页目录项\n  if(*pde & PTE_P){\n    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));          // 存在，转换页表物理地址为虚拟地址\n  } else {\n    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0) // 不存在就创建\n      return 0;\n    // Make sure all those PTE_P bits are zero.\n    memset(pgtab, 0, PGSIZE);                     // 清零，防止垃圾值干扰\n    // The permissions here are overly generous, but they can\n    // be further restricted by the permissions in the page table\n    // entries, if necessary.\n    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;    // 用物理地址填充页目录项\n  }\n  return &pgtab[PTX(va)];\n}\n```\n\nmappages函数作用就简单了，利用walkpgdir函数将传进来的虚拟地址映射到物理地址上。当然，如果页框的页表还没被映射，walkpgdir就会创建页表项：\n\n```cpp\n// Create PTEs for virtual addresses starting at va that refer to\n// physical addresses starting at pa. va and size might not\n// be page-aligned.\nstatic int\nmappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)\n{\n  char *a, *last;\n  pte_t *pte;\n\n  a = (char*)PGROUNDDOWN((uint)va);                 // 4k对齐\n  last = (char*)PGROUNDDOWN(((uint)va) + size - 1); // 结尾对齐\n  for(;;){\n    if((pte = walkpgdir(pgdir, a, 1)) == 0)         // 查询虚拟地址a的页表项，不存在就创建。\n      return -1;\n    if(*pte & PTE_P)\n      panic(\"remap\");\n    *pte = pa | perm | PTE_P;                       // 填充页表项，让页表项指向页框。\n    if(a == last)\n      break;\n    a += PGSIZE;\n    pa += PGSIZE;\n  }\n  return 0;\n}\n\n```\n\nsetupkvm函数利用mappages根据数组kmap来构造一个正式的内核页表：kpgdir：\n\n```cpp\n\n// Set up kernel part of a page table.\npde_t*\nsetupkvm(void)\n{\n  pde_t *pgdir;\n  struct kmap *k;\n\n  if((pgdir = (pde_t*)kalloc()) == 0)   // 分配页目录\n    return 0;\n  memset(pgdir, 0, PGSIZE);             // 清零，以免野值干扰\n  if (P2V(PHYSTOP) > (void*)DEVSPACE)   // PHYSTOP要合理，不能占用设备io空间\n    panic(\"PHYSTOP too high\");\n  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)    // 这里主要就是对内核映射进行细化，因为最开始内核是4M big page映射\n    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,\n                (uint)k->phys_start, k->perm) < 0) {\n      freevm(pgdir);\n      return 0;\n    }\n  return pgdir;\n}\n\n// Allocate one page table for the machine for the kernel address\n// space for scheduler processes.\nvoid\nkvmalloc(void)\n{\n  kpgdir = setupkvm();\n  switchkvm();\n}\n```\n\n在阅读上面这段代码时，一定要分清哪里是物理地址，哪里是物理地址。读者一定要时刻铭记，只要开启分页后，一切地址都是虚拟地址，但是页目录项、页表项都是存的物理地址，我们在拿到物理地址后，在访问前需要将他们进一步转换为虚拟地址。V2P、P2V的实现代码上面已经贴过，就是减去或者加上一个偏移量即可。\n\n我们的内存空间又有了一些变化：\n\n![](./MemoryManager/photo/memmanager/main_page_table.drawio.png)\n\n### kinit2：初始化内核内存分配器（阶段2）。\n\n根据注释要求：该函数是在所有其他AP（从处理器）处理器启动之后调用。在查看startothers的实现得知，BSP会为每个AP核都会单独分配一个（scheduler的）内核栈，所以结合kfree的头插法实现，我猜测，XV6是要让这（scheduler的）内核栈在KERNBASE + 4M以内，这暗示了只有KERNBASE + 4M才是内核真正的内存，尽管物理内存和内核内存都在kmem上混合管理。\n\n回归正题，和kinit1类似，kinit2就是将KERNBASE + 4M到KERNBASE + PHYSTOP之间的物理内存页正式挂到kmem的freelist上。**进程页表、页目录、页框的内存分配统一由kalloc来做。**（又一次强调！）\n\n最后，cpu的状态如下：关中断 & 进入了保护模式 & 安装了包括【内核&用户】【代码&数据】段描述符 & BSP分配了一个4K的内核栈 & 开启了以kmap为基础的粒度为4K的内核分页。\n\n至此XV6的内存管理的介绍差不多结束，\n\n## 简单聊一下内存管理在Onix中的做法\n\n首先再次强调，XV6将所有物理地址映射到内核页表并且统一交由kalloc管理的做法极大简化了我们对页目录、页表的修改。但这种将所有物理内存都映射到内核页表的做法是不明智的！\n\nOnix内核页表采用的是直接映射，直接将Onix内核虚拟地址空间映射到物理地址空间。前面提到过，Onix操作系统对内存的管理采用：get_page + alloc_kpage + kmalloc的方式。get_page（管理单位：page）管理的是整个4G物理内存空间，底层是一个256页的大数组，每一byte记录4G物理内存的一个page的引用计数；alloc_kpage（管理单位：page）管理的就是Onix内核（虚拟）页内存，底层是位图，Onix初始化时会向大数组中申请内核所需要的连续的物理内存（将物理数组的byte置为1），申请的内核页会以位图的方式交由alloc_kpage管理；kmalloc（管理单位：小于page的内存碎片）管理内核的小块（虚拟）内存分配与释放，实现较为复杂，底层它是一个小块内存的内存池，实现上和C++中标准库的内存分配器类似。感兴趣的读者可以去深入阅读Onix的代码。这里了解Onix的内存管理基本架构即可。\n\nOnix内存布局如下，盗取了Onix作者的图：\n\n![](./MemoryManager/photo/memmanager/onix_memory_map.drawio.png)\n\n关于虚拟内存，Onix同样采用了两级页表的形式，所不同的是，Onix中进程的页表是由内核页内存分配器alloc_kpage负责，而像进程的页表、页框则是由get_page负责。\n\n这就引入了一个问题，Onix内核页表并不会像XV6那样，把所有的物理内存页都映射到内核页上，那么Onix是如何实现修改页表、页框的操作的呢？\n\n**答案就是将页目录的最后一个entry指向自己**，这里还是引用Onix作者画的页表映射图为例：\n\n![](./MemoryManager/photo/memmanager/memory_paging_02.drawio.png)\n\n从图中我们可以看到，页目录的最后一个entry指向了页目录本身。（0x1007中低12位是控制位！\n\n有了这个前提，我们的页目录就有两种访问方式：\n\n1. 直接通过页目录的虚拟地址访问。\n\n2. **通过虚拟地址：0xfffff000访问。**\n\n你可以在脑海中模拟MMU映射地址过程，试着去翻译地址0xfffff000，最终你一定会发现，翻译后的物理地址确实指向页目录本身。这真的是一种很神奇的方法。\n\n同理在Onix中，如果你想访问一个虚拟地址的页表，你可以且只能使用：\n\n- **虚拟地址：0xFFC00000 | 虚拟地址在页目录中的索引（虚拟地址高10位）**\n\n至此，我们通过“欺骗”MMU的方式实现了，即使我们的内核页表没有映射进程的页表、页框的物理地址，我门的程序还是可以去修改进程的页表。\n\nOnix操作页表、页框的核心函数如下：\n\n```cpp\n// 获取页目录vd\nstatic page_entry_t *get_pde()\n{\n    return (page_entry_t *)(0xfffff000);\n}\n\n// 获取虚拟地址 vaddr 对应的页表vd\nstatic page_entry_t *get_pte(u32 vaddr, bool create)\n{\n    page_entry_t *pde = get_pde();\n    u32 idx = DIDX(vaddr);\n    page_entry_t *entry = &pde[idx];\n\n    assert(create || (!create && entry->present));\n\n    page_entry_t *table = (page_entry_t *)(PDE_MASK | (idx << 12));\n\n    if (!entry->present)\n    {\n        LOGK(\"Get and create page table entry for 0x%p\\n\", vaddr);\n        u32 page = get_page();\n\n        //页目录、页表项的项必须存物理地址!!!\n        entry_init(entry, IDX(page));\n        memset(table, 0, PAGE_SIZE);\n    }\n\n    return table;\n}\n\npage_entry_t *get_entry(u32 vaddr, bool create)\n{\n    page_entry_t *pte = get_pte(vaddr, create);\n    return &pte[TIDX(vaddr)];\n}\n```\n\n再有一次，强烈建议各位想深入学习Unix-like操作系统的同学去阅读一下Onix的源码。链接放在文章的开头了。\n\n参考文档：\n\nXV6中文文档：https://th0ar.gitbooks.io/xv6-chinese/content/\n\nOnix分页机制（含）的文档：https://github.com/StevenBaby/onix/blob/dev/docs/05%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/041%20%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86.md\n\nCR0寄存器详解：https://blog.csdn.net/qq_30528603/article/details/131143850\n\n---\n\n**本章完结**\n","source":"_posts/xv6/MemoryManager.md","raw":"---\ntitle: 这才是计科之 Onix & XV6 源码分析（2、类Unix的内存管理）\ndate: 2024-06-07 12:00:00\ntags:\n  - 类Unix源码剖析\n---\n\n## 前言\n\n前一章我们介绍了XV6的启动流程，在本章，我们就要开始介绍类Unix操作系统最重要的一部分——内存管理模块。\n\n本文以XV6里面的内存管理为主，后面会提炼Onix中内存管理比较好的部分，来对XV6进行一个补充。\n\nOnix相关链接：\n\n- [github仓库链接](https://github.com/StevenBaby/onix)。\n\n- [B站配套视频链接](https://www.bilibili.com/video/BV1qM4y127om/)。\n\nXV6-x86的github链接：\n\n- [链接](https://github.com/mit-pdos/xv6-public)。\n\n<!-- more -->\n\n## 分页\n\n首先了解一下unix-like系统虚拟内存做法。\n\nx86中分页涉及两个主要寄存器：cr0、cr3，cr0主要用于控制是否开启分页，cr3用于存放页目录的地址。当cr0寄存器设置开启分页，cpu所使用的一切地址皆是虚拟地址，在分页机制中，一个虚拟地址被划分成3个部分，如下图：\n\n![](./MemoryManager/photo/memmanager/vaddr.png)\n\n如图中所注释的那样，地址的高10位代表在**页目录**中的索引（一个目录项占4Byte）、中间10位代表**页表**上的索引（一个页表项占4Byte）、低12位代表在**页框**上的偏移（1Byte为单位）。一个典型的页目录大小是4096字节（一个Page的大小），页表和页目录大小一样。并且低12位的寻址范围正好也是4096，这样一切就恰到好处。此时：sizeof(页目录) == sizeof(页表) == sizeof(页框) == 4096。\n\n此外，由于页目录（页表）每一项都是4Byte为单位。所以每个页目录（页表）正好有1024个entry。\n\n一个页目录（页表）的每一个索引项都是4Byte，这4Byte格式如下图：\n\n![](./MemoryManager/photo/memmanager/entry.png)\n\n从entry的结构图可以看出，它的高20位指向页框号（物理上的），在4G的物理地址空间内，一个页面按4096个字节算的话，正好有1M个页面（页框）。所以20位正好能为每一个页框从0开始编址。\n\nentry的低12位是一些控制位，比如0位指示该entry所指向的物理地址是否有效，第1位指示entry所指的物理页是否可写，第3位代表用户态能否访问，等等。我们可以利用这些位来实现很多unix-like中的骚操作，最有名的应该是利用第1位实现**写时拷贝**。\n\nCPU会通过MMU来完成虚拟地址到物理地址的翻译，记要翻译的虚拟地址是vaddr，过程如下：\n\n0. 拿到cr3指向的页目录地址（物理地址），dir_paddr。\n\n1. 位运算取vaddr的高10位，将高10位作为页目录的索引，得到dir_entry，dir_entry会指向下一级的页表，所以通过dir_entry可以得到页表的地址（物理地址），tab_paddr。\ns\n2. 位运算取vaddr中间10位，将中间10位作为页表的索引，得到tab_entry，tab_entry会指向最后一级的页框，所以通过tab_entry可以得到页框的地址（物理地址），frm_paddr。\n\n3. 最后，位运算取vaddr的低12位，这12位作为页框的物理地址frm_addr的偏移，于此得到了虚拟地址对应的物理地址：frm_paddr + offset。\n\n整个流程可以使用xv6官方提供的图来描绘：\n\n![](./MemoryManager/photo/memmanager/vaddr2paddr.png)\n\n## 内存管理\n\n首先回顾一下，在进入main前，cpu的状态如下：关中断 & 进入了保护模式 & 安装了一个临时全局描述符 & BSP分配了一个4K的内核栈 & 开启了4M big page的临时分页。\n\nXV6在main函数中会进行内存管理相关的初始化：\n\n```cpp\nint\nmain(void)\n{\n  kinit1(end, P2V(4*1024*1024)); // phys page allocator\n  kvmalloc();      // kernel page table\n  seginit();       // segment descriptors // 扩张了用户【数据&代码】段描述符，源码很简单，读者可自行阅读，这里就不去帖代码了\n  // ...\n  startothers();   // start other processors  // 唤醒其他处理器，本文不会做过多讲解，后面的文章再深入探讨。\n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()\n  // ...\n}\n```\n\n因为cpu现在是开启分页的，所以，我们利用P2V宏来获得4M物理地址对应的虚拟地址，实现也很简单，就是物理地址加上内核基地址的偏移就能得到物理地址对应的虚拟地址：\n\n```cpp\n#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts\n#define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts\n```\n\n### kinit1：初始化内核内存分配器（阶段1）。\n\nxv6的注释将kalloc称为物理内存分配器，这是第一个吐槽点，从它的源码上来看，我认为把它称为内核内存分配器更加合适。因为xv6把物理内存、内核内存的管理全都交给kalloc做，并且内存粒度也固定为4K。由于所有的物理地址也由kalloc管理，**为此内核不得不去在自己的页表上去映射所有的物理内存！**，其优点就是代码实现上会很简单（特别是在软件实现修改页表的操作上），但是这样做是非常暴力的。如果你阅读过Onix、或者其他更完善的unix-like操作系统的话会发现，更加严谨的做法是：get_page + alloc_kpage + kmalloc：\n\n```cpp\n// Onix\n\n// src/kernel/memory.c\n\n// 底层实现为：使用连续的256页来跟踪每个页框，每个页框会对应1Byte的entry\n// 使用1Byte的好处是可以记录每个页框的索引。这里方便实现copy on write\n// 和xv6不同，我们在后面就会看到，Onix在实现fork的copy on write时，子进程的\n// 页表也是动态复制的。\n\n// 分配一页物理内存\nstatic u32 get_page() { /* ... */ }\n// 释放一页物理内存\nstatic void put_page(u32 addr) {/* ... */}\n\n// 该函数是基于位图实现，利用位图来管理内核的内存，只有页目录的内存分配会使用内核内存，\n// 页表、页框的内存分配全部通过get_page()函数。内核页表也不用相xv6那样去映射所有物理页，\n// 另外一个优点是该函数可以连续分配多个内核页，xv6就存在最大只能分配1个page的限制！\n\n// src/kernel/memory.c\n\n// 分配 count 个连续的内核页\nu32 alloc_kpage(u32 count) { /* ... */ }\n// 释放 count 个连续的内核页\nvoid free_kpage(u32 vaddr, u32 count) { /* ... */ }\n\n// src/kernel/area.c\n// 该函数是更加细粒度的分配内核内存，可以分配小于4K的小块内存。内部有一个内存池，\n\n// 对细小内存进行池化管理。\nvoid *kmalloc(size_t size) { /* ... */ }\nvoid kfree(void *ptr) { /* ... */ }\n```\n\n这里可以计算一下：如果以1byte为单位去管理1M的页（1M * pagesieze（4096）== 4G），1页可以管理4096页内存，所以1M的页需要 （1024 * 1024） / （4 * 1024） = 256页。\n\n回到kinit1函数，kinit1函数执行第一个阶段的内核内存管理的初始化。它会把从内核代码结束的位置开始往上4M的位置为止，以page为单位将每一页利用链表串起来。这部分涉及代码非常简单，直接看源码会比较清晰，这里就不贴它的代码了。大概的结构图如下：\n\n![](./MemoryManager/photo/memmanager/kalloc.drawio.png)\n\n### kvmalloc：构造并安装更加细粒度的页表kpgdir\n\n首先明确，到目前为止cpu使用的entrypgdir是4M big page的页表。kvmalloc会构造一个页表kpgdir，该页表会使用4K的页，分页粒度更加细粒，相对于entrypgdir来说做了进一步细分。kpgdir的内核映射的地址是没有任何变化的，切换到kpgdir页表后，内核的地址空间和之前没有什么区别。唯一的区别就是kpgdir的地址映射范围更大，多了一些entrypgdir页表所不可访问的范围。从数组kmap可以看到，pgdir将原来4M的内核空间扩张到了PHYSTOP（224M），同时将物理内存的高位的设备空间**直接映射**到内核高位虚拟地址空间。XV6在启动阶段没有进行内存探测，只是暴力的将可分配物理内存规定为PHYSTOP（224M）大小，我们可以通过修改PHYSTOP来动态调整XV6的物理内存上限。但是由于PHYSTOP被映射到了KERNBASE之上，所以PHYSTOP的大小是有限制的，即使物理内存是4G，KERNBASE + PHYSTOP的大小也不能覆盖设备地址空间。\n\n```cpp\nstatic struct kmap {\n  void *virt;\n  uint phys_start;\n  uint phys_end;\n  int perm;\n} kmap[] = {\n { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space\n { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata\n { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory\n { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices\n};\n```\n\n直接上代码：\n\n下面这个函数主要作用就是根据页表，用软件模拟MMU的方式，找到传进来的虚拟地址va对应的页表项的虚拟地址，这里用语言表述的可能有点绕。代码从某种程度上比语言好懂。如果alloc为1，在对应的页表不存在时就创建一个页表：\n\n```cpp\n// 简单讲，就是返回va对应页表项的虚拟地址\nstatic pte_t *\nwalkpgdir(pde_t *pgdir, const void *va, int alloc)\n{\n  pde_t *pde;   // vaddr 虚拟地址\n  pte_t *pgtab; // vaddr 虚拟地址\n\n  pde = &pgdir[PDX(va)];                          // 虚拟地址va对应的页表所在页目录项\n  if(*pde & PTE_P){\n    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));          // 存在，转换页表物理地址为虚拟地址\n  } else {\n    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0) // 不存在就创建\n      return 0;\n    // Make sure all those PTE_P bits are zero.\n    memset(pgtab, 0, PGSIZE);                     // 清零，防止垃圾值干扰\n    // The permissions here are overly generous, but they can\n    // be further restricted by the permissions in the page table\n    // entries, if necessary.\n    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;    // 用物理地址填充页目录项\n  }\n  return &pgtab[PTX(va)];\n}\n```\n\nmappages函数作用就简单了，利用walkpgdir函数将传进来的虚拟地址映射到物理地址上。当然，如果页框的页表还没被映射，walkpgdir就会创建页表项：\n\n```cpp\n// Create PTEs for virtual addresses starting at va that refer to\n// physical addresses starting at pa. va and size might not\n// be page-aligned.\nstatic int\nmappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)\n{\n  char *a, *last;\n  pte_t *pte;\n\n  a = (char*)PGROUNDDOWN((uint)va);                 // 4k对齐\n  last = (char*)PGROUNDDOWN(((uint)va) + size - 1); // 结尾对齐\n  for(;;){\n    if((pte = walkpgdir(pgdir, a, 1)) == 0)         // 查询虚拟地址a的页表项，不存在就创建。\n      return -1;\n    if(*pte & PTE_P)\n      panic(\"remap\");\n    *pte = pa | perm | PTE_P;                       // 填充页表项，让页表项指向页框。\n    if(a == last)\n      break;\n    a += PGSIZE;\n    pa += PGSIZE;\n  }\n  return 0;\n}\n\n```\n\nsetupkvm函数利用mappages根据数组kmap来构造一个正式的内核页表：kpgdir：\n\n```cpp\n\n// Set up kernel part of a page table.\npde_t*\nsetupkvm(void)\n{\n  pde_t *pgdir;\n  struct kmap *k;\n\n  if((pgdir = (pde_t*)kalloc()) == 0)   // 分配页目录\n    return 0;\n  memset(pgdir, 0, PGSIZE);             // 清零，以免野值干扰\n  if (P2V(PHYSTOP) > (void*)DEVSPACE)   // PHYSTOP要合理，不能占用设备io空间\n    panic(\"PHYSTOP too high\");\n  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)    // 这里主要就是对内核映射进行细化，因为最开始内核是4M big page映射\n    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,\n                (uint)k->phys_start, k->perm) < 0) {\n      freevm(pgdir);\n      return 0;\n    }\n  return pgdir;\n}\n\n// Allocate one page table for the machine for the kernel address\n// space for scheduler processes.\nvoid\nkvmalloc(void)\n{\n  kpgdir = setupkvm();\n  switchkvm();\n}\n```\n\n在阅读上面这段代码时，一定要分清哪里是物理地址，哪里是物理地址。读者一定要时刻铭记，只要开启分页后，一切地址都是虚拟地址，但是页目录项、页表项都是存的物理地址，我们在拿到物理地址后，在访问前需要将他们进一步转换为虚拟地址。V2P、P2V的实现代码上面已经贴过，就是减去或者加上一个偏移量即可。\n\n我们的内存空间又有了一些变化：\n\n![](./MemoryManager/photo/memmanager/main_page_table.drawio.png)\n\n### kinit2：初始化内核内存分配器（阶段2）。\n\n根据注释要求：该函数是在所有其他AP（从处理器）处理器启动之后调用。在查看startothers的实现得知，BSP会为每个AP核都会单独分配一个（scheduler的）内核栈，所以结合kfree的头插法实现，我猜测，XV6是要让这（scheduler的）内核栈在KERNBASE + 4M以内，这暗示了只有KERNBASE + 4M才是内核真正的内存，尽管物理内存和内核内存都在kmem上混合管理。\n\n回归正题，和kinit1类似，kinit2就是将KERNBASE + 4M到KERNBASE + PHYSTOP之间的物理内存页正式挂到kmem的freelist上。**进程页表、页目录、页框的内存分配统一由kalloc来做。**（又一次强调！）\n\n最后，cpu的状态如下：关中断 & 进入了保护模式 & 安装了包括【内核&用户】【代码&数据】段描述符 & BSP分配了一个4K的内核栈 & 开启了以kmap为基础的粒度为4K的内核分页。\n\n至此XV6的内存管理的介绍差不多结束，\n\n## 简单聊一下内存管理在Onix中的做法\n\n首先再次强调，XV6将所有物理地址映射到内核页表并且统一交由kalloc管理的做法极大简化了我们对页目录、页表的修改。但这种将所有物理内存都映射到内核页表的做法是不明智的！\n\nOnix内核页表采用的是直接映射，直接将Onix内核虚拟地址空间映射到物理地址空间。前面提到过，Onix操作系统对内存的管理采用：get_page + alloc_kpage + kmalloc的方式。get_page（管理单位：page）管理的是整个4G物理内存空间，底层是一个256页的大数组，每一byte记录4G物理内存的一个page的引用计数；alloc_kpage（管理单位：page）管理的就是Onix内核（虚拟）页内存，底层是位图，Onix初始化时会向大数组中申请内核所需要的连续的物理内存（将物理数组的byte置为1），申请的内核页会以位图的方式交由alloc_kpage管理；kmalloc（管理单位：小于page的内存碎片）管理内核的小块（虚拟）内存分配与释放，实现较为复杂，底层它是一个小块内存的内存池，实现上和C++中标准库的内存分配器类似。感兴趣的读者可以去深入阅读Onix的代码。这里了解Onix的内存管理基本架构即可。\n\nOnix内存布局如下，盗取了Onix作者的图：\n\n![](./MemoryManager/photo/memmanager/onix_memory_map.drawio.png)\n\n关于虚拟内存，Onix同样采用了两级页表的形式，所不同的是，Onix中进程的页表是由内核页内存分配器alloc_kpage负责，而像进程的页表、页框则是由get_page负责。\n\n这就引入了一个问题，Onix内核页表并不会像XV6那样，把所有的物理内存页都映射到内核页上，那么Onix是如何实现修改页表、页框的操作的呢？\n\n**答案就是将页目录的最后一个entry指向自己**，这里还是引用Onix作者画的页表映射图为例：\n\n![](./MemoryManager/photo/memmanager/memory_paging_02.drawio.png)\n\n从图中我们可以看到，页目录的最后一个entry指向了页目录本身。（0x1007中低12位是控制位！\n\n有了这个前提，我们的页目录就有两种访问方式：\n\n1. 直接通过页目录的虚拟地址访问。\n\n2. **通过虚拟地址：0xfffff000访问。**\n\n你可以在脑海中模拟MMU映射地址过程，试着去翻译地址0xfffff000，最终你一定会发现，翻译后的物理地址确实指向页目录本身。这真的是一种很神奇的方法。\n\n同理在Onix中，如果你想访问一个虚拟地址的页表，你可以且只能使用：\n\n- **虚拟地址：0xFFC00000 | 虚拟地址在页目录中的索引（虚拟地址高10位）**\n\n至此，我们通过“欺骗”MMU的方式实现了，即使我们的内核页表没有映射进程的页表、页框的物理地址，我门的程序还是可以去修改进程的页表。\n\nOnix操作页表、页框的核心函数如下：\n\n```cpp\n// 获取页目录vd\nstatic page_entry_t *get_pde()\n{\n    return (page_entry_t *)(0xfffff000);\n}\n\n// 获取虚拟地址 vaddr 对应的页表vd\nstatic page_entry_t *get_pte(u32 vaddr, bool create)\n{\n    page_entry_t *pde = get_pde();\n    u32 idx = DIDX(vaddr);\n    page_entry_t *entry = &pde[idx];\n\n    assert(create || (!create && entry->present));\n\n    page_entry_t *table = (page_entry_t *)(PDE_MASK | (idx << 12));\n\n    if (!entry->present)\n    {\n        LOGK(\"Get and create page table entry for 0x%p\\n\", vaddr);\n        u32 page = get_page();\n\n        //页目录、页表项的项必须存物理地址!!!\n        entry_init(entry, IDX(page));\n        memset(table, 0, PAGE_SIZE);\n    }\n\n    return table;\n}\n\npage_entry_t *get_entry(u32 vaddr, bool create)\n{\n    page_entry_t *pte = get_pte(vaddr, create);\n    return &pte[TIDX(vaddr)];\n}\n```\n\n再有一次，强烈建议各位想深入学习Unix-like操作系统的同学去阅读一下Onix的源码。链接放在文章的开头了。\n\n参考文档：\n\nXV6中文文档：https://th0ar.gitbooks.io/xv6-chinese/content/\n\nOnix分页机制（含）的文档：https://github.com/StevenBaby/onix/blob/dev/docs/05%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/041%20%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86.md\n\nCR0寄存器详解：https://blog.csdn.net/qq_30528603/article/details/131143850\n\n---\n\n**本章完结**\n","slug":"xv6/MemoryManager","published":1,"updated":"2025-09-28T09:40:58.181Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9u0012q8wsfwecb723","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前一章我们介绍了XV6的启动流程，在本章，我们就要开始介绍类Unix操作系统最重要的一部分——内存管理模块。</p>\n<p>本文以XV6里面的内存管理为主，后面会提炼Onix中内存管理比较好的部分，来对XV6进行一个补充。</p>\n<p>Onix相关链接：</p>\n<ul>\n<li><p><a href=\"https://github.com/StevenBaby/onix\">github仓库链接</a>。</p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/BV1qM4y127om/\">B站配套视频链接</a>。</p>\n</li>\n</ul>\n<p>XV6-x86的github链接：</p>\n<ul>\n<li><a href=\"https://github.com/mit-pdos/xv6-public\">链接</a>。</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h2><p>首先了解一下unix-like系统虚拟内存做法。</p>\n<p>x86中分页涉及两个主要寄存器：cr0、cr3，cr0主要用于控制是否开启分页，cr3用于存放页目录的地址。当cr0寄存器设置开启分页，cpu所使用的一切地址皆是虚拟地址，在分页机制中，一个虚拟地址被划分成3个部分，如下图：</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/vaddr.png\"></p>\n<p>如图中所注释的那样，地址的高10位代表在<strong>页目录</strong>中的索引（一个目录项占4Byte）、中间10位代表<strong>页表</strong>上的索引（一个页表项占4Byte）、低12位代表在<strong>页框</strong>上的偏移（1Byte为单位）。一个典型的页目录大小是4096字节（一个Page的大小），页表和页目录大小一样。并且低12位的寻址范围正好也是4096，这样一切就恰到好处。此时：sizeof(页目录) &#x3D;&#x3D; sizeof(页表) &#x3D;&#x3D; sizeof(页框) &#x3D;&#x3D; 4096。</p>\n<p>此外，由于页目录（页表）每一项都是4Byte为单位。所以每个页目录（页表）正好有1024个entry。</p>\n<p>一个页目录（页表）的每一个索引项都是4Byte，这4Byte格式如下图：</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/entry.png\"></p>\n<p>从entry的结构图可以看出，它的高20位指向页框号（物理上的），在4G的物理地址空间内，一个页面按4096个字节算的话，正好有1M个页面（页框）。所以20位正好能为每一个页框从0开始编址。</p>\n<p>entry的低12位是一些控制位，比如0位指示该entry所指向的物理地址是否有效，第1位指示entry所指的物理页是否可写，第3位代表用户态能否访问，等等。我们可以利用这些位来实现很多unix-like中的骚操作，最有名的应该是利用第1位实现<strong>写时拷贝</strong>。</p>\n<p>CPU会通过MMU来完成虚拟地址到物理地址的翻译，记要翻译的虚拟地址是vaddr，过程如下：</p>\n<ol start=\"0\">\n<li><p>拿到cr3指向的页目录地址（物理地址），dir_paddr。</p>\n</li>\n<li><p>位运算取vaddr的高10位，将高10位作为页目录的索引，得到dir_entry，dir_entry会指向下一级的页表，所以通过dir_entry可以得到页表的地址（物理地址），tab_paddr。<br>s</p>\n</li>\n<li><p>位运算取vaddr中间10位，将中间10位作为页表的索引，得到tab_entry，tab_entry会指向最后一级的页框，所以通过tab_entry可以得到页框的地址（物理地址），frm_paddr。</p>\n</li>\n<li><p>最后，位运算取vaddr的低12位，这12位作为页框的物理地址frm_addr的偏移，于此得到了虚拟地址对应的物理地址：frm_paddr + offset。</p>\n</li>\n</ol>\n<p>整个流程可以使用xv6官方提供的图来描绘：</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/vaddr2paddr.png\"></p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><p>首先回顾一下，在进入main前，cpu的状态如下：关中断 &amp; 进入了保护模式 &amp; 安装了一个临时全局描述符 &amp; BSP分配了一个4K的内核栈 &amp; 开启了4M big page的临时分页。</p>\n<p>XV6在main函数中会进行内存管理相关的初始化：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">kinit1</span>(end, <span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>)); <span class=\"comment\">// phys page allocator</span></span><br><span class=\"line\">  <span class=\"built_in\">kvmalloc</span>();      <span class=\"comment\">// kernel page table</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();       <span class=\"comment\">// segment descriptors // 扩张了用户【数据&amp;代码】段描述符，源码很简单，读者可自行阅读，这里就不去帖代码了</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">startothers</span>();   <span class=\"comment\">// start other processors  // 唤醒其他处理器，本文不会做过多讲解，后面的文章再深入探讨。</span></span><br><span class=\"line\">  <span class=\"built_in\">kinit2</span>(<span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>), <span class=\"built_in\">P2V</span>(PHYSTOP)); <span class=\"comment\">// must come after startothers()</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为cpu现在是开启分页的，所以，我们利用P2V宏来获得4M物理地址对应的虚拟地址，实现也很简单，就是物理地址加上内核基地址的偏移就能得到物理地址对应的虚拟地址：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> V2P_WO(x) ((x) - KERNBASE)    <span class=\"comment\">// same as V2P, but without casts</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> P2V_WO(x) ((x) + KERNBASE)    <span class=\"comment\">// same as P2V, but without casts</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"kinit1：初始化内核内存分配器（阶段1）。\"><a href=\"#kinit1：初始化内核内存分配器（阶段1）。\" class=\"headerlink\" title=\"kinit1：初始化内核内存分配器（阶段1）。\"></a>kinit1：初始化内核内存分配器（阶段1）。</h3><p>xv6的注释将kalloc称为物理内存分配器，这是第一个吐槽点，从它的源码上来看，我认为把它称为内核内存分配器更加合适。因为xv6把物理内存、内核内存的管理全都交给kalloc做，并且内存粒度也固定为4K。由于所有的物理地址也由kalloc管理，<strong>为此内核不得不去在自己的页表上去映射所有的物理内存！</strong>，其优点就是代码实现上会很简单（特别是在软件实现修改页表的操作上），但是这样做是非常暴力的。如果你阅读过Onix、或者其他更完善的unix-like操作系统的话会发现，更加严谨的做法是：get_page + alloc_kpage + kmalloc：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Onix</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/kernel/memory.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 底层实现为：使用连续的256页来跟踪每个页框，每个页框会对应1Byte的entry</span></span><br><span class=\"line\"><span class=\"comment\">// 使用1Byte的好处是可以记录每个页框的索引。这里方便实现copy on write</span></span><br><span class=\"line\"><span class=\"comment\">// 和xv6不同，我们在后面就会看到，Onix在实现fork的copy on write时，子进程的</span></span><br><span class=\"line\"><span class=\"comment\">// 页表也是动态复制的。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分配一页物理内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> u32 <span class=\"title\">get_page</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">// 释放一页物理内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">put_page</span><span class=\"params\">(u32 addr)</span> </span>&#123;<span class=\"comment\">/* ... */</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 该函数是基于位图实现，利用位图来管理内核的内存，只有页目录的内存分配会使用内核内存，</span></span><br><span class=\"line\"><span class=\"comment\">// 页表、页框的内存分配全部通过get_page()函数。内核页表也不用相xv6那样去映射所有物理页，</span></span><br><span class=\"line\"><span class=\"comment\">// 另外一个优点是该函数可以连续分配多个内核页，xv6就存在最大只能分配1个page的限制！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/kernel/memory.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分配 count 个连续的内核页</span></span><br><span class=\"line\"><span class=\"function\">u32 <span class=\"title\">alloc_kpage</span><span class=\"params\">(u32 count)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">// 释放 count 个连续的内核页</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">free_kpage</span><span class=\"params\">(u32 vaddr, u32 count)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/kernel/area.c</span></span><br><span class=\"line\"><span class=\"comment\">// 该函数是更加细粒度的分配内核内存，可以分配小于4K的小块内存。内部有一个内存池，</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对细小内存进行池化管理。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">kmalloc</span><span class=\"params\">(<span class=\"type\">size_t</span> size)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">kfree</span><span class=\"params\">(<span class=\"type\">void</span> *ptr)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里可以计算一下：如果以1byte为单位去管理1M的页（1M * pagesieze（4096）&#x3D;&#x3D; 4G），1页可以管理4096页内存，所以1M的页需要 （1024 * 1024） &#x2F; （4 * 1024） &#x3D; 256页。</p>\n<p>回到kinit1函数，kinit1函数执行第一个阶段的内核内存管理的初始化。它会把从内核代码结束的位置开始往上4M的位置为止，以page为单位将每一页利用链表串起来。这部分涉及代码非常简单，直接看源码会比较清晰，这里就不贴它的代码了。大概的结构图如下：</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/kalloc.drawio.png\"></p>\n<h3 id=\"kvmalloc：构造并安装更加细粒度的页表kpgdir\"><a href=\"#kvmalloc：构造并安装更加细粒度的页表kpgdir\" class=\"headerlink\" title=\"kvmalloc：构造并安装更加细粒度的页表kpgdir\"></a>kvmalloc：构造并安装更加细粒度的页表kpgdir</h3><p>首先明确，到目前为止cpu使用的entrypgdir是4M big page的页表。kvmalloc会构造一个页表kpgdir，该页表会使用4K的页，分页粒度更加细粒，相对于entrypgdir来说做了进一步细分。kpgdir的内核映射的地址是没有任何变化的，切换到kpgdir页表后，内核的地址空间和之前没有什么区别。唯一的区别就是kpgdir的地址映射范围更大，多了一些entrypgdir页表所不可访问的范围。从数组kmap可以看到，pgdir将原来4M的内核空间扩张到了PHYSTOP（224M），同时将物理内存的高位的设备空间<strong>直接映射</strong>到内核高位虚拟地址空间。XV6在启动阶段没有进行内存探测，只是暴力的将可分配物理内存规定为PHYSTOP（224M）大小，我们可以通过修改PHYSTOP来动态调整XV6的物理内存上限。但是由于PHYSTOP被映射到了KERNBASE之上，所以PHYSTOP的大小是有限制的，即使物理内存是4G，KERNBASE + PHYSTOP的大小也不能覆盖设备地址空间。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">kmap</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">void</span> *virt;</span><br><span class=\"line\">  uint phys_start;</span><br><span class=\"line\">  uint phys_end;</span><br><span class=\"line\">  <span class=\"type\">int</span> perm;</span><br><span class=\"line\">&#125; kmap[] = &#123;</span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)KERNBASE, <span class=\"number\">0</span>,             EXTMEM,    PTE_W&#125;, <span class=\"comment\">// I/O space</span></span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)KERNLINK, <span class=\"built_in\">V2P</span>(KERNLINK), <span class=\"built_in\">V2P</span>(data), <span class=\"number\">0</span>&#125;,     <span class=\"comment\">// kern text+rodata</span></span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)data,     <span class=\"built_in\">V2P</span>(data),     PHYSTOP,   PTE_W&#125;, <span class=\"comment\">// kern data+memory</span></span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)DEVSPACE, DEVSPACE,      <span class=\"number\">0</span>,         PTE_W&#125;, <span class=\"comment\">// more devices</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>直接上代码：</p>\n<p>下面这个函数主要作用就是根据页表，用软件模拟MMU的方式，找到传进来的虚拟地址va对应的页表项的虚拟地址，这里用语言表述的可能有点绕。代码从某种程度上比语言好懂。如果alloc为1，在对应的页表不存在时就创建一个页表：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简单讲，就是返回va对应页表项的虚拟地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">pte_t</span> *</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">walkpgdir</span><span class=\"params\">(<span class=\"type\">pde_t</span> *pgdir, <span class=\"type\">const</span> <span class=\"type\">void</span> *va, <span class=\"type\">int</span> alloc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">pde_t</span> *pde;   <span class=\"comment\">// vaddr 虚拟地址</span></span><br><span class=\"line\">  <span class=\"type\">pte_t</span> *pgtab; <span class=\"comment\">// vaddr 虚拟地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">  pde = &amp;pgdir[<span class=\"built_in\">PDX</span>(va)];                          <span class=\"comment\">// 虚拟地址va对应的页表所在页目录项</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(*pde &amp; PTE_P)&#123;</span><br><span class=\"line\">    pgtab = (<span class=\"type\">pte_t</span>*)<span class=\"built_in\">P2V</span>(<span class=\"built_in\">PTE_ADDR</span>(*pde));          <span class=\"comment\">// 存在，转换页表物理地址为虚拟地址</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!alloc || (pgtab = (<span class=\"type\">pte_t</span>*)<span class=\"built_in\">kalloc</span>()) == <span class=\"number\">0</span>) <span class=\"comment\">// 不存在就创建</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Make sure all those PTE_P bits are zero.</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(pgtab, <span class=\"number\">0</span>, PGSIZE);                     <span class=\"comment\">// 清零，防止垃圾值干扰</span></span><br><span class=\"line\">    <span class=\"comment\">// The permissions here are overly generous, but they can</span></span><br><span class=\"line\">    <span class=\"comment\">// be further restricted by the permissions in the page table</span></span><br><span class=\"line\">    <span class=\"comment\">// entries, if necessary.</span></span><br><span class=\"line\">    *pde = <span class=\"built_in\">V2P</span>(pgtab) | PTE_P | PTE_W | PTE_U;    <span class=\"comment\">// 用物理地址填充页目录项</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;pgtab[<span class=\"built_in\">PTX</span>(va)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mappages函数作用就简单了，利用walkpgdir函数将传进来的虚拟地址映射到物理地址上。当然，如果页框的页表还没被映射，walkpgdir就会创建页表项：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class=\"line\"><span class=\"comment\">// physical addresses starting at pa. va and size might not</span></span><br><span class=\"line\"><span class=\"comment\">// be page-aligned.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mappages</span><span class=\"params\">(<span class=\"type\">pde_t</span> *pgdir, <span class=\"type\">void</span> *va, uint size, uint pa, <span class=\"type\">int</span> perm)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> *a, *last;</span><br><span class=\"line\">  <span class=\"type\">pte_t</span> *pte;</span><br><span class=\"line\"></span><br><span class=\"line\">  a = (<span class=\"type\">char</span>*)<span class=\"built_in\">PGROUNDDOWN</span>((uint)va);                 <span class=\"comment\">// 4k对齐</span></span><br><span class=\"line\">  last = (<span class=\"type\">char</span>*)<span class=\"built_in\">PGROUNDDOWN</span>(((uint)va) + size - <span class=\"number\">1</span>); <span class=\"comment\">// 结尾对齐</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((pte = <span class=\"built_in\">walkpgdir</span>(pgdir, a, <span class=\"number\">1</span>)) == <span class=\"number\">0</span>)         <span class=\"comment\">// 查询虚拟地址a的页表项，不存在就创建。</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(*pte &amp; PTE_P)</span><br><span class=\"line\">      <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;remap&quot;</span>);</span><br><span class=\"line\">    *pte = pa | perm | PTE_P;                       <span class=\"comment\">// 填充页表项，让页表项指向页框。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a == last)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    a += PGSIZE;</span><br><span class=\"line\">    pa += PGSIZE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>setupkvm函数利用mappages根据数组kmap来构造一个正式的内核页表：kpgdir：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set up kernel part of a page table.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">pde_t</span>*</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">setupkvm</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">pde_t</span> *pgdir;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">kmap</span> *k;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((pgdir = (<span class=\"type\">pde_t</span>*)<span class=\"built_in\">kalloc</span>()) == <span class=\"number\">0</span>)   <span class=\"comment\">// 分配页目录</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(pgdir, <span class=\"number\">0</span>, PGSIZE);             <span class=\"comment\">// 清零，以免野值干扰</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">P2V</span>(PHYSTOP) &gt; (<span class=\"type\">void</span>*)DEVSPACE)   <span class=\"comment\">// PHYSTOP要合理，不能占用设备io空间</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;PHYSTOP too high&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(k = kmap; k &lt; &amp;kmap[<span class=\"built_in\">NELEM</span>(kmap)]; k++)    <span class=\"comment\">// 这里主要就是对内核映射进行细化，因为最开始内核是4M big page映射</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">mappages</span>(pgdir, k-&gt;virt, k-&gt;phys_end - k-&gt;phys_start,</span><br><span class=\"line\">                (uint)k-&gt;phys_start, k-&gt;perm) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">freevm</span>(pgdir);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pgdir;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Allocate one page table for the machine for the kernel address</span></span><br><span class=\"line\"><span class=\"comment\">// space for scheduler processes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kvmalloc</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  kpgdir = <span class=\"built_in\">setupkvm</span>();</span><br><span class=\"line\">  switchkvm();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在阅读上面这段代码时，一定要分清哪里是物理地址，哪里是物理地址。读者一定要时刻铭记，只要开启分页后，一切地址都是虚拟地址，但是页目录项、页表项都是存的物理地址，我们在拿到物理地址后，在访问前需要将他们进一步转换为虚拟地址。V2P、P2V的实现代码上面已经贴过，就是减去或者加上一个偏移量即可。</p>\n<p>我们的内存空间又有了一些变化：</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/main_page_table.drawio.png\"></p>\n<h3 id=\"kinit2：初始化内核内存分配器（阶段2）。\"><a href=\"#kinit2：初始化内核内存分配器（阶段2）。\" class=\"headerlink\" title=\"kinit2：初始化内核内存分配器（阶段2）。\"></a>kinit2：初始化内核内存分配器（阶段2）。</h3><p>根据注释要求：该函数是在所有其他AP（从处理器）处理器启动之后调用。在查看startothers的实现得知，BSP会为每个AP核都会单独分配一个（scheduler的）内核栈，所以结合kfree的头插法实现，我猜测，XV6是要让这（scheduler的）内核栈在KERNBASE + 4M以内，这暗示了只有KERNBASE + 4M才是内核真正的内存，尽管物理内存和内核内存都在kmem上混合管理。</p>\n<p>回归正题，和kinit1类似，kinit2就是将KERNBASE + 4M到KERNBASE + PHYSTOP之间的物理内存页正式挂到kmem的freelist上。<strong>进程页表、页目录、页框的内存分配统一由kalloc来做。</strong>（又一次强调！）</p>\n<p>最后，cpu的状态如下：关中断 &amp; 进入了保护模式 &amp; 安装了包括【内核&amp;用户】【代码&amp;数据】段描述符 &amp; BSP分配了一个4K的内核栈 &amp; 开启了以kmap为基础的粒度为4K的内核分页。</p>\n<p>至此XV6的内存管理的介绍差不多结束，</p>\n<h2 id=\"简单聊一下内存管理在Onix中的做法\"><a href=\"#简单聊一下内存管理在Onix中的做法\" class=\"headerlink\" title=\"简单聊一下内存管理在Onix中的做法\"></a>简单聊一下内存管理在Onix中的做法</h2><p>首先再次强调，XV6将所有物理地址映射到内核页表并且统一交由kalloc管理的做法极大简化了我们对页目录、页表的修改。但这种将所有物理内存都映射到内核页表的做法是不明智的！</p>\n<p>Onix内核页表采用的是直接映射，直接将Onix内核虚拟地址空间映射到物理地址空间。前面提到过，Onix操作系统对内存的管理采用：get_page + alloc_kpage + kmalloc的方式。get_page（管理单位：page）管理的是整个4G物理内存空间，底层是一个256页的大数组，每一byte记录4G物理内存的一个page的引用计数；alloc_kpage（管理单位：page）管理的就是Onix内核（虚拟）页内存，底层是位图，Onix初始化时会向大数组中申请内核所需要的连续的物理内存（将物理数组的byte置为1），申请的内核页会以位图的方式交由alloc_kpage管理；kmalloc（管理单位：小于page的内存碎片）管理内核的小块（虚拟）内存分配与释放，实现较为复杂，底层它是一个小块内存的内存池，实现上和C++中标准库的内存分配器类似。感兴趣的读者可以去深入阅读Onix的代码。这里了解Onix的内存管理基本架构即可。</p>\n<p>Onix内存布局如下，盗取了Onix作者的图：</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/onix_memory_map.drawio.png\"></p>\n<p>关于虚拟内存，Onix同样采用了两级页表的形式，所不同的是，Onix中进程的页表是由内核页内存分配器alloc_kpage负责，而像进程的页表、页框则是由get_page负责。</p>\n<p>这就引入了一个问题，Onix内核页表并不会像XV6那样，把所有的物理内存页都映射到内核页上，那么Onix是如何实现修改页表、页框的操作的呢？</p>\n<p><strong>答案就是将页目录的最后一个entry指向自己</strong>，这里还是引用Onix作者画的页表映射图为例：</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/memory_paging_02.drawio.png\"></p>\n<p>从图中我们可以看到，页目录的最后一个entry指向了页目录本身。（0x1007中低12位是控制位！</p>\n<p>有了这个前提，我们的页目录就有两种访问方式：</p>\n<ol>\n<li><p>直接通过页目录的虚拟地址访问。</p>\n</li>\n<li><p><strong>通过虚拟地址：0xfffff000访问。</strong></p>\n</li>\n</ol>\n<p>你可以在脑海中模拟MMU映射地址过程，试着去翻译地址0xfffff000，最终你一定会发现，翻译后的物理地址确实指向页目录本身。这真的是一种很神奇的方法。</p>\n<p>同理在Onix中，如果你想访问一个虚拟地址的页表，你可以且只能使用：</p>\n<ul>\n<li><strong>虚拟地址：0xFFC00000 | 虚拟地址在页目录中的索引（虚拟地址高10位）</strong></li>\n</ul>\n<p>至此，我们通过“欺骗”MMU的方式实现了，即使我们的内核页表没有映射进程的页表、页框的物理地址，我门的程序还是可以去修改进程的页表。</p>\n<p>Onix操作页表、页框的核心函数如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取页目录vd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">page_entry_t</span> *<span class=\"title\">get_pde</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">page_entry_t</span> *)(<span class=\"number\">0xfffff000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取虚拟地址 vaddr 对应的页表vd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">page_entry_t</span> *<span class=\"title\">get_pte</span><span class=\"params\">(u32 vaddr, <span class=\"type\">bool</span> create)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *pde = <span class=\"built_in\">get_pde</span>();</span><br><span class=\"line\">    u32 idx = <span class=\"built_in\">DIDX</span>(vaddr);</span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *entry = &amp;pde[idx];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(create || (!create &amp;&amp; entry-&gt;present));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *table = (<span class=\"type\">page_entry_t</span> *)(PDE_MASK | (idx &lt;&lt; <span class=\"number\">12</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!entry-&gt;present)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">LOGK</span>(<span class=\"string\">&quot;Get and create page table entry for 0x%p\\n&quot;</span>, vaddr);</span><br><span class=\"line\">        u32 page = <span class=\"built_in\">get_page</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//页目录、页表项的项必须存物理地址!!!</span></span><br><span class=\"line\">        <span class=\"built_in\">entry_init</span>(entry, <span class=\"built_in\">IDX</span>(page));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(table, <span class=\"number\">0</span>, PAGE_SIZE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">page_entry_t</span> *<span class=\"title\">get_entry</span><span class=\"params\">(u32 vaddr, <span class=\"type\">bool</span> create)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *pte = <span class=\"built_in\">get_pte</span>(vaddr, create);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;pte[<span class=\"built_in\">TIDX</span>(vaddr)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再有一次，强烈建议各位想深入学习Unix-like操作系统的同学去阅读一下Onix的源码。链接放在文章的开头了。</p>\n<p>参考文档：</p>\n<p>XV6中文文档：<a href=\"https://th0ar.gitbooks.io/xv6-chinese/content/\">https://th0ar.gitbooks.io/xv6-chinese/content/</a></p>\n<p>Onix分页机制（含）的文档：<a href=\"https://github.com/StevenBaby/onix/blob/dev/docs/05%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/041%20%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86.md\">https://github.com/StevenBaby/onix/blob/dev/docs/05%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/041%20%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86.md</a></p>\n<p>CR0寄存器详解：<a href=\"https://blog.csdn.net/qq_30528603/article/details/131143850\">https://blog.csdn.net/qq_30528603/article/details/131143850</a></p>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前一章我们介绍了XV6的启动流程，在本章，我们就要开始介绍类Unix操作系统最重要的一部分——内存管理模块。</p>\n<p>本文以XV6里面的内存管理为主，后面会提炼Onix中内存管理比较好的部分，来对XV6进行一个补充。</p>\n<p>Onix相关链接：</p>\n<ul>\n<li><p><a href=\"https://github.com/StevenBaby/onix\">github仓库链接</a>。</p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/BV1qM4y127om/\">B站配套视频链接</a>。</p>\n</li>\n</ul>\n<p>XV6-x86的github链接：</p>\n<ul>\n<li><a href=\"https://github.com/mit-pdos/xv6-public\">链接</a>。</li>\n</ul>","more":"<h2 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h2><p>首先了解一下unix-like系统虚拟内存做法。</p>\n<p>x86中分页涉及两个主要寄存器：cr0、cr3，cr0主要用于控制是否开启分页，cr3用于存放页目录的地址。当cr0寄存器设置开启分页，cpu所使用的一切地址皆是虚拟地址，在分页机制中，一个虚拟地址被划分成3个部分，如下图：</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/vaddr.png\"></p>\n<p>如图中所注释的那样，地址的高10位代表在<strong>页目录</strong>中的索引（一个目录项占4Byte）、中间10位代表<strong>页表</strong>上的索引（一个页表项占4Byte）、低12位代表在<strong>页框</strong>上的偏移（1Byte为单位）。一个典型的页目录大小是4096字节（一个Page的大小），页表和页目录大小一样。并且低12位的寻址范围正好也是4096，这样一切就恰到好处。此时：sizeof(页目录) &#x3D;&#x3D; sizeof(页表) &#x3D;&#x3D; sizeof(页框) &#x3D;&#x3D; 4096。</p>\n<p>此外，由于页目录（页表）每一项都是4Byte为单位。所以每个页目录（页表）正好有1024个entry。</p>\n<p>一个页目录（页表）的每一个索引项都是4Byte，这4Byte格式如下图：</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/entry.png\"></p>\n<p>从entry的结构图可以看出，它的高20位指向页框号（物理上的），在4G的物理地址空间内，一个页面按4096个字节算的话，正好有1M个页面（页框）。所以20位正好能为每一个页框从0开始编址。</p>\n<p>entry的低12位是一些控制位，比如0位指示该entry所指向的物理地址是否有效，第1位指示entry所指的物理页是否可写，第3位代表用户态能否访问，等等。我们可以利用这些位来实现很多unix-like中的骚操作，最有名的应该是利用第1位实现<strong>写时拷贝</strong>。</p>\n<p>CPU会通过MMU来完成虚拟地址到物理地址的翻译，记要翻译的虚拟地址是vaddr，过程如下：</p>\n<ol start=\"0\">\n<li><p>拿到cr3指向的页目录地址（物理地址），dir_paddr。</p>\n</li>\n<li><p>位运算取vaddr的高10位，将高10位作为页目录的索引，得到dir_entry，dir_entry会指向下一级的页表，所以通过dir_entry可以得到页表的地址（物理地址），tab_paddr。<br>s</p>\n</li>\n<li><p>位运算取vaddr中间10位，将中间10位作为页表的索引，得到tab_entry，tab_entry会指向最后一级的页框，所以通过tab_entry可以得到页框的地址（物理地址），frm_paddr。</p>\n</li>\n<li><p>最后，位运算取vaddr的低12位，这12位作为页框的物理地址frm_addr的偏移，于此得到了虚拟地址对应的物理地址：frm_paddr + offset。</p>\n</li>\n</ol>\n<p>整个流程可以使用xv6官方提供的图来描绘：</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/vaddr2paddr.png\"></p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><p>首先回顾一下，在进入main前，cpu的状态如下：关中断 &amp; 进入了保护模式 &amp; 安装了一个临时全局描述符 &amp; BSP分配了一个4K的内核栈 &amp; 开启了4M big page的临时分页。</p>\n<p>XV6在main函数中会进行内存管理相关的初始化：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">kinit1</span>(end, <span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>)); <span class=\"comment\">// phys page allocator</span></span><br><span class=\"line\">  <span class=\"built_in\">kvmalloc</span>();      <span class=\"comment\">// kernel page table</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();       <span class=\"comment\">// segment descriptors // 扩张了用户【数据&amp;代码】段描述符，源码很简单，读者可自行阅读，这里就不去帖代码了</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">startothers</span>();   <span class=\"comment\">// start other processors  // 唤醒其他处理器，本文不会做过多讲解，后面的文章再深入探讨。</span></span><br><span class=\"line\">  <span class=\"built_in\">kinit2</span>(<span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>), <span class=\"built_in\">P2V</span>(PHYSTOP)); <span class=\"comment\">// must come after startothers()</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为cpu现在是开启分页的，所以，我们利用P2V宏来获得4M物理地址对应的虚拟地址，实现也很简单，就是物理地址加上内核基地址的偏移就能得到物理地址对应的虚拟地址：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> V2P_WO(x) ((x) - KERNBASE)    <span class=\"comment\">// same as V2P, but without casts</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> P2V_WO(x) ((x) + KERNBASE)    <span class=\"comment\">// same as P2V, but without casts</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"kinit1：初始化内核内存分配器（阶段1）。\"><a href=\"#kinit1：初始化内核内存分配器（阶段1）。\" class=\"headerlink\" title=\"kinit1：初始化内核内存分配器（阶段1）。\"></a>kinit1：初始化内核内存分配器（阶段1）。</h3><p>xv6的注释将kalloc称为物理内存分配器，这是第一个吐槽点，从它的源码上来看，我认为把它称为内核内存分配器更加合适。因为xv6把物理内存、内核内存的管理全都交给kalloc做，并且内存粒度也固定为4K。由于所有的物理地址也由kalloc管理，<strong>为此内核不得不去在自己的页表上去映射所有的物理内存！</strong>，其优点就是代码实现上会很简单（特别是在软件实现修改页表的操作上），但是这样做是非常暴力的。如果你阅读过Onix、或者其他更完善的unix-like操作系统的话会发现，更加严谨的做法是：get_page + alloc_kpage + kmalloc：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Onix</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/kernel/memory.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 底层实现为：使用连续的256页来跟踪每个页框，每个页框会对应1Byte的entry</span></span><br><span class=\"line\"><span class=\"comment\">// 使用1Byte的好处是可以记录每个页框的索引。这里方便实现copy on write</span></span><br><span class=\"line\"><span class=\"comment\">// 和xv6不同，我们在后面就会看到，Onix在实现fork的copy on write时，子进程的</span></span><br><span class=\"line\"><span class=\"comment\">// 页表也是动态复制的。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分配一页物理内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> u32 <span class=\"title\">get_page</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">// 释放一页物理内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">put_page</span><span class=\"params\">(u32 addr)</span> </span>&#123;<span class=\"comment\">/* ... */</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 该函数是基于位图实现，利用位图来管理内核的内存，只有页目录的内存分配会使用内核内存，</span></span><br><span class=\"line\"><span class=\"comment\">// 页表、页框的内存分配全部通过get_page()函数。内核页表也不用相xv6那样去映射所有物理页，</span></span><br><span class=\"line\"><span class=\"comment\">// 另外一个优点是该函数可以连续分配多个内核页，xv6就存在最大只能分配1个page的限制！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/kernel/memory.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分配 count 个连续的内核页</span></span><br><span class=\"line\"><span class=\"function\">u32 <span class=\"title\">alloc_kpage</span><span class=\"params\">(u32 count)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">// 释放 count 个连续的内核页</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">free_kpage</span><span class=\"params\">(u32 vaddr, u32 count)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/kernel/area.c</span></span><br><span class=\"line\"><span class=\"comment\">// 该函数是更加细粒度的分配内核内存，可以分配小于4K的小块内存。内部有一个内存池，</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对细小内存进行池化管理。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">kmalloc</span><span class=\"params\">(<span class=\"type\">size_t</span> size)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">kfree</span><span class=\"params\">(<span class=\"type\">void</span> *ptr)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里可以计算一下：如果以1byte为单位去管理1M的页（1M * pagesieze（4096）&#x3D;&#x3D; 4G），1页可以管理4096页内存，所以1M的页需要 （1024 * 1024） &#x2F; （4 * 1024） &#x3D; 256页。</p>\n<p>回到kinit1函数，kinit1函数执行第一个阶段的内核内存管理的初始化。它会把从内核代码结束的位置开始往上4M的位置为止，以page为单位将每一页利用链表串起来。这部分涉及代码非常简单，直接看源码会比较清晰，这里就不贴它的代码了。大概的结构图如下：</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/kalloc.drawio.png\"></p>\n<h3 id=\"kvmalloc：构造并安装更加细粒度的页表kpgdir\"><a href=\"#kvmalloc：构造并安装更加细粒度的页表kpgdir\" class=\"headerlink\" title=\"kvmalloc：构造并安装更加细粒度的页表kpgdir\"></a>kvmalloc：构造并安装更加细粒度的页表kpgdir</h3><p>首先明确，到目前为止cpu使用的entrypgdir是4M big page的页表。kvmalloc会构造一个页表kpgdir，该页表会使用4K的页，分页粒度更加细粒，相对于entrypgdir来说做了进一步细分。kpgdir的内核映射的地址是没有任何变化的，切换到kpgdir页表后，内核的地址空间和之前没有什么区别。唯一的区别就是kpgdir的地址映射范围更大，多了一些entrypgdir页表所不可访问的范围。从数组kmap可以看到，pgdir将原来4M的内核空间扩张到了PHYSTOP（224M），同时将物理内存的高位的设备空间<strong>直接映射</strong>到内核高位虚拟地址空间。XV6在启动阶段没有进行内存探测，只是暴力的将可分配物理内存规定为PHYSTOP（224M）大小，我们可以通过修改PHYSTOP来动态调整XV6的物理内存上限。但是由于PHYSTOP被映射到了KERNBASE之上，所以PHYSTOP的大小是有限制的，即使物理内存是4G，KERNBASE + PHYSTOP的大小也不能覆盖设备地址空间。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">kmap</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">void</span> *virt;</span><br><span class=\"line\">  uint phys_start;</span><br><span class=\"line\">  uint phys_end;</span><br><span class=\"line\">  <span class=\"type\">int</span> perm;</span><br><span class=\"line\">&#125; kmap[] = &#123;</span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)KERNBASE, <span class=\"number\">0</span>,             EXTMEM,    PTE_W&#125;, <span class=\"comment\">// I/O space</span></span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)KERNLINK, <span class=\"built_in\">V2P</span>(KERNLINK), <span class=\"built_in\">V2P</span>(data), <span class=\"number\">0</span>&#125;,     <span class=\"comment\">// kern text+rodata</span></span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)data,     <span class=\"built_in\">V2P</span>(data),     PHYSTOP,   PTE_W&#125;, <span class=\"comment\">// kern data+memory</span></span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)DEVSPACE, DEVSPACE,      <span class=\"number\">0</span>,         PTE_W&#125;, <span class=\"comment\">// more devices</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>直接上代码：</p>\n<p>下面这个函数主要作用就是根据页表，用软件模拟MMU的方式，找到传进来的虚拟地址va对应的页表项的虚拟地址，这里用语言表述的可能有点绕。代码从某种程度上比语言好懂。如果alloc为1，在对应的页表不存在时就创建一个页表：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简单讲，就是返回va对应页表项的虚拟地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">pte_t</span> *</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">walkpgdir</span><span class=\"params\">(<span class=\"type\">pde_t</span> *pgdir, <span class=\"type\">const</span> <span class=\"type\">void</span> *va, <span class=\"type\">int</span> alloc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">pde_t</span> *pde;   <span class=\"comment\">// vaddr 虚拟地址</span></span><br><span class=\"line\">  <span class=\"type\">pte_t</span> *pgtab; <span class=\"comment\">// vaddr 虚拟地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">  pde = &amp;pgdir[<span class=\"built_in\">PDX</span>(va)];                          <span class=\"comment\">// 虚拟地址va对应的页表所在页目录项</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(*pde &amp; PTE_P)&#123;</span><br><span class=\"line\">    pgtab = (<span class=\"type\">pte_t</span>*)<span class=\"built_in\">P2V</span>(<span class=\"built_in\">PTE_ADDR</span>(*pde));          <span class=\"comment\">// 存在，转换页表物理地址为虚拟地址</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!alloc || (pgtab = (<span class=\"type\">pte_t</span>*)<span class=\"built_in\">kalloc</span>()) == <span class=\"number\">0</span>) <span class=\"comment\">// 不存在就创建</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Make sure all those PTE_P bits are zero.</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(pgtab, <span class=\"number\">0</span>, PGSIZE);                     <span class=\"comment\">// 清零，防止垃圾值干扰</span></span><br><span class=\"line\">    <span class=\"comment\">// The permissions here are overly generous, but they can</span></span><br><span class=\"line\">    <span class=\"comment\">// be further restricted by the permissions in the page table</span></span><br><span class=\"line\">    <span class=\"comment\">// entries, if necessary.</span></span><br><span class=\"line\">    *pde = <span class=\"built_in\">V2P</span>(pgtab) | PTE_P | PTE_W | PTE_U;    <span class=\"comment\">// 用物理地址填充页目录项</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;pgtab[<span class=\"built_in\">PTX</span>(va)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mappages函数作用就简单了，利用walkpgdir函数将传进来的虚拟地址映射到物理地址上。当然，如果页框的页表还没被映射，walkpgdir就会创建页表项：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class=\"line\"><span class=\"comment\">// physical addresses starting at pa. va and size might not</span></span><br><span class=\"line\"><span class=\"comment\">// be page-aligned.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mappages</span><span class=\"params\">(<span class=\"type\">pde_t</span> *pgdir, <span class=\"type\">void</span> *va, uint size, uint pa, <span class=\"type\">int</span> perm)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> *a, *last;</span><br><span class=\"line\">  <span class=\"type\">pte_t</span> *pte;</span><br><span class=\"line\"></span><br><span class=\"line\">  a = (<span class=\"type\">char</span>*)<span class=\"built_in\">PGROUNDDOWN</span>((uint)va);                 <span class=\"comment\">// 4k对齐</span></span><br><span class=\"line\">  last = (<span class=\"type\">char</span>*)<span class=\"built_in\">PGROUNDDOWN</span>(((uint)va) + size - <span class=\"number\">1</span>); <span class=\"comment\">// 结尾对齐</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((pte = <span class=\"built_in\">walkpgdir</span>(pgdir, a, <span class=\"number\">1</span>)) == <span class=\"number\">0</span>)         <span class=\"comment\">// 查询虚拟地址a的页表项，不存在就创建。</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(*pte &amp; PTE_P)</span><br><span class=\"line\">      <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;remap&quot;</span>);</span><br><span class=\"line\">    *pte = pa | perm | PTE_P;                       <span class=\"comment\">// 填充页表项，让页表项指向页框。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a == last)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    a += PGSIZE;</span><br><span class=\"line\">    pa += PGSIZE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>setupkvm函数利用mappages根据数组kmap来构造一个正式的内核页表：kpgdir：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set up kernel part of a page table.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">pde_t</span>*</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">setupkvm</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">pde_t</span> *pgdir;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">kmap</span> *k;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((pgdir = (<span class=\"type\">pde_t</span>*)<span class=\"built_in\">kalloc</span>()) == <span class=\"number\">0</span>)   <span class=\"comment\">// 分配页目录</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(pgdir, <span class=\"number\">0</span>, PGSIZE);             <span class=\"comment\">// 清零，以免野值干扰</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">P2V</span>(PHYSTOP) &gt; (<span class=\"type\">void</span>*)DEVSPACE)   <span class=\"comment\">// PHYSTOP要合理，不能占用设备io空间</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;PHYSTOP too high&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(k = kmap; k &lt; &amp;kmap[<span class=\"built_in\">NELEM</span>(kmap)]; k++)    <span class=\"comment\">// 这里主要就是对内核映射进行细化，因为最开始内核是4M big page映射</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">mappages</span>(pgdir, k-&gt;virt, k-&gt;phys_end - k-&gt;phys_start,</span><br><span class=\"line\">                (uint)k-&gt;phys_start, k-&gt;perm) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">freevm</span>(pgdir);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pgdir;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Allocate one page table for the machine for the kernel address</span></span><br><span class=\"line\"><span class=\"comment\">// space for scheduler processes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kvmalloc</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  kpgdir = <span class=\"built_in\">setupkvm</span>();</span><br><span class=\"line\">  switchkvm();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在阅读上面这段代码时，一定要分清哪里是物理地址，哪里是物理地址。读者一定要时刻铭记，只要开启分页后，一切地址都是虚拟地址，但是页目录项、页表项都是存的物理地址，我们在拿到物理地址后，在访问前需要将他们进一步转换为虚拟地址。V2P、P2V的实现代码上面已经贴过，就是减去或者加上一个偏移量即可。</p>\n<p>我们的内存空间又有了一些变化：</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/main_page_table.drawio.png\"></p>\n<h3 id=\"kinit2：初始化内核内存分配器（阶段2）。\"><a href=\"#kinit2：初始化内核内存分配器（阶段2）。\" class=\"headerlink\" title=\"kinit2：初始化内核内存分配器（阶段2）。\"></a>kinit2：初始化内核内存分配器（阶段2）。</h3><p>根据注释要求：该函数是在所有其他AP（从处理器）处理器启动之后调用。在查看startothers的实现得知，BSP会为每个AP核都会单独分配一个（scheduler的）内核栈，所以结合kfree的头插法实现，我猜测，XV6是要让这（scheduler的）内核栈在KERNBASE + 4M以内，这暗示了只有KERNBASE + 4M才是内核真正的内存，尽管物理内存和内核内存都在kmem上混合管理。</p>\n<p>回归正题，和kinit1类似，kinit2就是将KERNBASE + 4M到KERNBASE + PHYSTOP之间的物理内存页正式挂到kmem的freelist上。<strong>进程页表、页目录、页框的内存分配统一由kalloc来做。</strong>（又一次强调！）</p>\n<p>最后，cpu的状态如下：关中断 &amp; 进入了保护模式 &amp; 安装了包括【内核&amp;用户】【代码&amp;数据】段描述符 &amp; BSP分配了一个4K的内核栈 &amp; 开启了以kmap为基础的粒度为4K的内核分页。</p>\n<p>至此XV6的内存管理的介绍差不多结束，</p>\n<h2 id=\"简单聊一下内存管理在Onix中的做法\"><a href=\"#简单聊一下内存管理在Onix中的做法\" class=\"headerlink\" title=\"简单聊一下内存管理在Onix中的做法\"></a>简单聊一下内存管理在Onix中的做法</h2><p>首先再次强调，XV6将所有物理地址映射到内核页表并且统一交由kalloc管理的做法极大简化了我们对页目录、页表的修改。但这种将所有物理内存都映射到内核页表的做法是不明智的！</p>\n<p>Onix内核页表采用的是直接映射，直接将Onix内核虚拟地址空间映射到物理地址空间。前面提到过，Onix操作系统对内存的管理采用：get_page + alloc_kpage + kmalloc的方式。get_page（管理单位：page）管理的是整个4G物理内存空间，底层是一个256页的大数组，每一byte记录4G物理内存的一个page的引用计数；alloc_kpage（管理单位：page）管理的就是Onix内核（虚拟）页内存，底层是位图，Onix初始化时会向大数组中申请内核所需要的连续的物理内存（将物理数组的byte置为1），申请的内核页会以位图的方式交由alloc_kpage管理；kmalloc（管理单位：小于page的内存碎片）管理内核的小块（虚拟）内存分配与释放，实现较为复杂，底层它是一个小块内存的内存池，实现上和C++中标准库的内存分配器类似。感兴趣的读者可以去深入阅读Onix的代码。这里了解Onix的内存管理基本架构即可。</p>\n<p>Onix内存布局如下，盗取了Onix作者的图：</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/onix_memory_map.drawio.png\"></p>\n<p>关于虚拟内存，Onix同样采用了两级页表的形式，所不同的是，Onix中进程的页表是由内核页内存分配器alloc_kpage负责，而像进程的页表、页框则是由get_page负责。</p>\n<p>这就引入了一个问题，Onix内核页表并不会像XV6那样，把所有的物理内存页都映射到内核页上，那么Onix是如何实现修改页表、页框的操作的呢？</p>\n<p><strong>答案就是将页目录的最后一个entry指向自己</strong>，这里还是引用Onix作者画的页表映射图为例：</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/memory_paging_02.drawio.png\"></p>\n<p>从图中我们可以看到，页目录的最后一个entry指向了页目录本身。（0x1007中低12位是控制位！</p>\n<p>有了这个前提，我们的页目录就有两种访问方式：</p>\n<ol>\n<li><p>直接通过页目录的虚拟地址访问。</p>\n</li>\n<li><p><strong>通过虚拟地址：0xfffff000访问。</strong></p>\n</li>\n</ol>\n<p>你可以在脑海中模拟MMU映射地址过程，试着去翻译地址0xfffff000，最终你一定会发现，翻译后的物理地址确实指向页目录本身。这真的是一种很神奇的方法。</p>\n<p>同理在Onix中，如果你想访问一个虚拟地址的页表，你可以且只能使用：</p>\n<ul>\n<li><strong>虚拟地址：0xFFC00000 | 虚拟地址在页目录中的索引（虚拟地址高10位）</strong></li>\n</ul>\n<p>至此，我们通过“欺骗”MMU的方式实现了，即使我们的内核页表没有映射进程的页表、页框的物理地址，我门的程序还是可以去修改进程的页表。</p>\n<p>Onix操作页表、页框的核心函数如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取页目录vd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">page_entry_t</span> *<span class=\"title\">get_pde</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">page_entry_t</span> *)(<span class=\"number\">0xfffff000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取虚拟地址 vaddr 对应的页表vd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">page_entry_t</span> *<span class=\"title\">get_pte</span><span class=\"params\">(u32 vaddr, <span class=\"type\">bool</span> create)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *pde = <span class=\"built_in\">get_pde</span>();</span><br><span class=\"line\">    u32 idx = <span class=\"built_in\">DIDX</span>(vaddr);</span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *entry = &amp;pde[idx];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(create || (!create &amp;&amp; entry-&gt;present));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *table = (<span class=\"type\">page_entry_t</span> *)(PDE_MASK | (idx &lt;&lt; <span class=\"number\">12</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!entry-&gt;present)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">LOGK</span>(<span class=\"string\">&quot;Get and create page table entry for 0x%p\\n&quot;</span>, vaddr);</span><br><span class=\"line\">        u32 page = <span class=\"built_in\">get_page</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//页目录、页表项的项必须存物理地址!!!</span></span><br><span class=\"line\">        <span class=\"built_in\">entry_init</span>(entry, <span class=\"built_in\">IDX</span>(page));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(table, <span class=\"number\">0</span>, PAGE_SIZE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">page_entry_t</span> *<span class=\"title\">get_entry</span><span class=\"params\">(u32 vaddr, <span class=\"type\">bool</span> create)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *pte = <span class=\"built_in\">get_pte</span>(vaddr, create);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;pte[<span class=\"built_in\">TIDX</span>(vaddr)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再有一次，强烈建议各位想深入学习Unix-like操作系统的同学去阅读一下Onix的源码。链接放在文章的开头了。</p>\n<p>参考文档：</p>\n<p>XV6中文文档：<a href=\"https://th0ar.gitbooks.io/xv6-chinese/content/\">https://th0ar.gitbooks.io/xv6-chinese/content/</a></p>\n<p>Onix分页机制（含）的文档：<a href=\"https://github.com/StevenBaby/onix/blob/dev/docs/05%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/041%20%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86.md\">https://github.com/StevenBaby/onix/blob/dev/docs/05%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/041%20%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86.md</a></p>\n<p>CR0寄存器详解：<a href=\"https://blog.csdn.net/qq_30528603/article/details/131143850\">https://blog.csdn.net/qq_30528603/article/details/131143850</a></p>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"这才是计科之 Onix & XV6 源码分析（4、文件系统）","date":"2025-09-28T04:00:00.000Z","_content":"\n## 前言\n\n拖了这么久，终于到了最后一篇关于类unix源码分析的文章————文件系统。\n\n（偷偷告诉你，本篇博客起草于我即将从毕业以来第一家公司离职前一个星期（2025-9-16），忍着牙痛ing ing ing）。\n\n如你所见，文件系统完全值得另开一篇博文单独去记录它。这里为了方便，同样将Onix的文件系统和XV6的文件系统放一块进行记录。并且，Onix的文件系统确实更加规范和完善，而XV6的文件系统相对来说更加简洁。但值得一提的是，XV6文件系统实现了一个简单而确实又很重要的东西————基于写时日志的事务系统。这是Onix所没有的。\n\nlinux的一切皆文件的伟大思想，将所有的IO行为（包括IO设备读写、pipe读写、进程读写）都抽象成文件。在本篇文章当中，我们将通过两个小型操作系统源码一一揭开linux文件系统的面纱。\n\n<!-- more -->\n\n首先贴上XV6文件系统的模块方图：\n\n![](./FileSystem/photo/filesystem/xv6_fs_structure.drawio.png)\n\n其次是Onix文件系统的模块方图：\n\n![](./FileSystem/photo/filesystem/onix_fs_structure.drawio.png)\n\n诈一看，你一定会认为XV6实现的文件系统比Onix的更复杂，实际上恰恰相反。尽管XV6实现了更多的模块，但是因为它教学系统的本质，每个模块的实现都以简单且精简为目的，没有为扩展性做任何多余操作。： ）读过的人表示非常干脆利落。\n\n反观Onix，为了适配 终端、串口、键盘、磁盘、软盘以及以后可能有的各种IO设备，根据他们的特点，抽象出了 `struct device_t` 结构体，分离出虚拟设备抽象层，将共有的io操作提取出来。为了统一文件系统的管理，抽象出了 `fs_op_t` 结构体。更贴近真实Linux操作系统的做法。具体细节将逐一解释。\n\n依据我阅读源码的习惯，下面就来自底向上逐步介绍文件系统的实现。**以Onix文件系统为主。**\n\n## 磁盘IO驱动层 & 虚拟设备实现层\n\n- 磁盘IO驱动层: 一句话概括该模块的作用：所谓磁盘IO驱动层，实际上就是操作系统当中，最底层的直接和磁盘设备打交道的代码。使用厂商规定的指令对磁盘设备按一定规则进行读写操作。\n\n- 虚拟设备实现层: 对IO设备抽象出统一接口，并且针对磁盘设备访问，Onix还实现了经典的电梯算法。XV6当中虚拟设备实现层过于简单，这里以Onix为主进行深入讲解。 \n\n### 对于XV6\n\nXV6的磁盘IO驱动层可以分为两块：IO请求队列 和 磁盘IO驱动。实现可以参考文件：ide.c，IO请求队列的实现非常巧妙，其思想为：**多个进程需要并发对一块磁盘进行IO，为了保证正确性，我们必须对并行操作串行化处理。让请求IO的进程入队。仅让位于队头的进行执行磁盘IO，其他进程休眠等待。当队头的进程执行完IO请求后出队列唤醒进程，下一个队头再进行IO操作。** 如果你有看过LevelDB的源码，应该对这种思想非常熟悉，因为LevelDB的Write方法实现运用了同样的手法。参考：[LevelDB源码阅读笔记（1、整体架构）](https://blog.csdn.net/m0_52566365/article/details/137910783)\n\n框图图如下：\n\n![](./FileSystem/photo/filesystem/xv6_ide.drawio.png)\n\n流程如下：\n\n首先对外暴露iderw接口。\n\n**iderw函数的逻辑：**\n\n> 1. 上层调用对外暴露的磁盘操作接口 `iderw(struct buf *b)`。\n> 2. 将请求push到IO队列尾部。\n> 3. 如果本身就是队头，直接执行IO函数 `idestart`。\n> 4. 非队头，**阻塞直到 IO任务 被中断处理函数消费。**\n\n**磁盘中断处理函数ideintr的逻辑：**（一旦磁盘准备好，就会触发中断）\n\n> 1. IO队列为空直接返回。\n> 2. 移除并唤醒队头。\n> 3. 如果IO队列还非空，**为 IO任务 执行IO函数 `idestart`。**\n\n实现了简单的先来先服务(FCFS)调度\n\n### 对于Onix\n\n而Onix的磁盘IO驱动极其复杂，需要深入了解 IDE（Integrated Drive Electronics）硬盘控制器（IDE是一种常见的硬盘接口标准，也称为ATA（Advanced Technology Attachment））。感兴趣的可以先阅读一下XV6当中idestart函数，该函数使用几行代码实现了对磁盘设备的读写操作，然后深入去阅读Onix的磁盘IO驱动，代码路径：kernel/ide.c，我的重心在文件系统的架构，所以Onix最底层的磁盘IO驱动就跳过了。笔者重点要讲的是Onix的虚拟设备实现层。\n\nOnix对虚拟设备的实现定义了如下虚拟设备控制结构体：\n\n```c\ntypedef struct device_t\n{\n    char name[NAMELEN];  // 设备名\n    int type;            // 设备类型\n    int subtype;         // 设备子类型\n    dev_t dev;           // 设备号\n    dev_t parent;        // 父设备号\n    void *ptr;           // 设备指针\n    list_t request_list; // 块设备请求链表\n    bool direct;         // 磁盘寻道方向\n\n    // 设备控制\n    int (*ioctl)(void *dev, int cmd, void *args, int flags);\n    // 读设备\n    int (*read)(void *dev, void *buf, size_t count, idx_t idx, int flags);\n    // 写设备\n    int (*write)(void *dev, void *buf, size_t count, idx_t idx, int flags);\n} device_t;\n```\n\n针对IO设备，抽象出了ioctl、read、write接口，这样，每种IO设备只需根据实际情况实现回调函数，任何IO设备都能被实例化成该结构体，并且我们即将讲解的minix（onix文件系统类型）文件系统也能更好的对IO设备做适配。\n\nOnix当中对IO设备的设备类型按读取的粒度分成了两类：字符设备（单字节）和块设备（1024为一快）。\n\n```c\n// 设备类型\nenum device_type_t\n{\n    DEV_NULL,  // 空设备\n    DEV_CHAR,  // 字符设备\n    DEV_BLOCK, // 块设备\n};\n```\n\n设备子类型（也即具体的设备）就多了，比如：控制台、键盘、串口、磁盘、磁盘分区、软盘等。设备子类型定义在枚举类型 `enum device_subtype_t` 当中。\n\nOnix的设备抽象层，为了保证磁盘IO的正确性，其实也存在类似XV6的IO请求队列的设计，它的核心代码如下：\n\n```c\n// 块设备请求\nerr_t device_request(dev_t dev, void *buf, u8 count, idx_t idx, int flags, u32 type) {\n    device_t *device = device_get(dev);\n    request_t *req = kmalloc(sizeof(request_t));\n\n    // ...\n\n    // 判断列表是否为空\n    bool empty = list_empty(&device->request_list);\n\n    // 将请求插入链表\n    list_insert_sort(&device->request_list, &req->node, element_node_offset(request_t, node, idx));\n\n    // 如果列表不为空，则阻塞，因为已经有请求在处理了，等待处理完成；\n    if (!empty)\n    {\n        req->task = running_task();\n        assert(task_block(req->task, NULL, TASK_BLOCKED, TIMELESS) == EOK);\n    }\n\n    // do io\n    err_t ret = do_request(req);\n\n    // 跑一轮电梯算法，获取紧挨着req的下一个任务执行IO\n    request_t *nextreq = request_nextreq(device, req);\n\n    list_remove(&req->node);\n    kfree(req);\n\n    // 唤醒新队头\n    if (nextreq)\n    {\n        assert(nextreq->task->magic == ONIX_MAGIC);\n        task_unblock(nextreq->task, EOK);\n    }\n\n    return ret;\n}\n```\n\nOnix IO请求队列的逻辑更加清晰易懂：\n\n![](./FileSystem/photo/filesystem/onix_ide.drawio.png)\n\n流程如下：\n\n> 1. 进程调用磁盘IO接口 `device_request`。\n> 2. 为IO请求分配一个句柄req。\n> 3. 将req利用插入排序，升序插入请求队列。\n> 4. 如果在该任务插入到队列前，队列非空，就当前阻塞进程。说明已经有进程在执行IO任务。\n> 5. 如果在该任务插入到队列前，队列为空，由当前进程执行IO操作。\n> 6. 依据电梯算法，获取到紧挨着req的下一个IO请求任务reqnext。\n> 7. 从请求队列当中移除req。\n> 8. 唤醒reqnext进程。注意可以确定的是，在请求队列当中只有一个进程是活跃状态其他进程都处于阻塞状态，所以在reqnext此前必定为阻塞状态，在这里我们需要唤醒它。\n\nOnix实现了比XV6更高效的磁盘调度算法——电梯算法。电梯算法能有效避免饥饿现象，比简单的先来先服务（FCFS）更高效，减少了磁头移动距离，能够有效平衡响应时间和吞吐量。\n\n电梯算法的工作原理：**磁头（电梯）沿一个方向移动（比如向上），处理该方向上所有的请求。到达该方向的最后一个请求后，改变方向（向下），处理反方向上的请求。如此往复循环，就像电梯在楼层间上下运行一样。**\n\nOnix电梯算法实现函数request_nextreq如下：\n\n```c\n// 获得下一个请求\nstatic request_t *request_nextreq(device_t *device, request_t *req) {\n    list_t *list = &device->request_list;\n\n    if (device->direct == DIRECT_UP && req->node.next == &list->tail) {\n        device->direct = DIRECT_DOWN;\n    } else if (device->direct == DIRECT_DOWN && req->node.prev == &list->head) {\n        device->direct = DIRECT_UP;\n    }\n\n    void *next = NULL;\n    if (device->direct == DIRECT_UP) {\n        next = req->node.next;\n    } else {\n        next = req->node.prev;\n    }\n\n    if (next == &list->head || next == &list->tail) {\n        return NULL;\n    }\n\n    return element_entry(request_t, node, next);\n}\n```\n\n## 磁盘块缓存层\n\nOS对磁盘的任何访问都是基于块的，XV6当中，一个磁盘块的大小为512字节，Onix当中，默认为1024字节。如果我们每次访问文件都直接从磁盘上去读取，显然大部分时间都被浪费在磁盘IO上。所以，为了提高效率，内存（高速设备）和磁盘（低速设备）之间必然需要缓存层。本小节以Onix的代码为主。代码参考：onix-dev/src/kernel/buffer.c\n\n缓存层主要作用是：在在有限的内存当中，**缓存访问频率最高的部分磁盘块**。那么我们如何定性一个磁盘块的访问频率是高还是低呢？这就得靠大名鼎鼎的LRU算法。在CMU15445实验1当中可以学习到更高级的LRU算法——LRU-K算法、在LevelDB当中.sst文件结构的缓存也是用到了LRU算法。Onix实现的磁盘块缓存层使用的是最朴素的LRU算法。\n\n本节简单介绍一下Onix当中LRU算法运行逻辑。\n\n首先假设LRU相关数据结构的初始状态如下图：\n\n![](./FileSystem/photo/filesystem/onix_cache.drawio.png)\n\n如图所示，LRU算法涉及的基本数据结构包括：哈希表和链表。\n\n- 空闲链表 `idle_list`:  一旦OS对缓存块的引用为0，缓存块就会被放入到空闲链表。当OS需要读取一块没有缓存到内存的磁盘块时，就会触发LRU替换策略，LRU替换策略会将空闲链表当中最久未被访问过的缓存块写回磁盘，并且将缓存块的内容覆盖成新的磁盘块。空闲链表的插入和删除的逻辑非常重要，LRU替换策略实现的关键。\n- 哈希表: 记录已经缓存的磁盘块。用于快速查找缓存的磁盘块。\n\n磁盘块的读取：\n- 有被缓存到内存（这里假设要读 `block1`）：\n    1. 根据哈希算法 ` (设备号 ^ 块号) % 哈希表长度` 获取block1的所在哈希数组的位置，这里block1计算所得哈希数组索引为0。\n    2. 遍历链表，得到buffer1。\n    3. 将buffer1的引用计数加一。\n    4. 从idle_list当中移除buffer1，防止缓存块被替换出磁盘。\n\n    最终，结构如下：\n    ![](./FileSystem/photo/filesystem/onix_caceh1.drawio.png)\n\n- 没有被缓存到内存（这里假设要读 `block4`）：\n    1. 基于idle_list执行LRU替换策略。从idle_list可以了解到，idle_list的最后一个元素即为我们需要的 最久未被访问过的缓存块。也就是本节最开始所放图片当中的buffer3。\n    2. 将buffer3写回磁盘（如果标记为脏）。并从哈希表当中去除buffer3。\n    3. 将block4读到buffer3。\n    4. 根据哈希算法，计算block4所在哈希表的位置。这里假设计算block4的哈希值为1，并将block4插入到哈希表。\n\n    最终，结构如下：\n    ![](./FileSystem/photo/filesystem/onix_cache2.drawio.png)\n\n磁盘块的释放：\n1. 假设，现在要释放buffer4，将缓存块的引用计数减一。\n2. 当缓存块引用计数变为0时，将缓存块挂到idle_list开头。这样可以确保idle_list当中缓冲块从左到右，最后一次访问时间越来越长。\n\n    最终，结构如下：\n    ![](./FileSystem/photo/filesystem/onix_cache3.drawio.png)\n\n## 事务层（日志层）\n\n### 日志层简介\n\n事务层是XV6所拥有的模块，在Onix当中并不存在，所以，本节会以XV6为主进行叙述。在XV6的文档当中，将事务层称为日志层。不管是日志层还是事务层，作用都是一样的。**旨在实现错误恢复** 的机制，保证磁盘上文件系统的一致性。\n\n依我的理解，其实linux文件系统本身就是一个通用数据库。像mysql、oracle、leveldb等数据库存在一些共有问题（包括：一致性、错误恢复等问题），解决问题的思想或多或少都借鉴linux的文件系统的实现。\n\n文件系统设计中最有趣的问题之一就是错误恢复，产生这样的问题是因为大多数的文件系统都涉及到对磁盘多次的写操作，如果在写操作的过程当中系统崩溃了，就会使得磁盘上的文件系统处于不一致的状态中。举例来说，根据写的顺序的不同，上述错误可能会导致一个目录项指向一个空闲的 i 节点，或者产生一个已被分配但是未被引用的块。后一种情况相对来说好一些，但在前一种情况中，目录项指向了一个空闲的 i 节点，重启之后就会导致非常严重的问题。\n\nxv6 通过简单的日志系统来解决文件操作过程当中崩溃所导致的问题。一个系统调用并不直接导致对磁盘上文件系统的写操作，相反，他会把一个对磁盘写操作的描述包装成一个日志写在磁盘中。当系统调用把所有的写操作都写入了日志，它就会写一个特殊的提交记录到磁盘上，代表一次完整的操作。从那时起，系统调用就会把日志中的数据写入磁盘文件系统的数据结构中。在那些写操作都成功完成后，系统调用就会删除磁盘上的日志文件。\n\n为什么日志可以解决文件系统操作中出现的崩溃呢？如果崩溃发生在操作提交之前，那么磁盘上的日志文件就不会被标记为已完成，恢复系统的代码就会忽视它，磁盘的状态正如这个操作从未执行过一样。如果是在操作提交之后崩溃的，恢复程序会重演所有的写操作，可能会重复之前已经进行了的对磁盘文件系统的写操作。在任何一种情况下，日志文件都使得磁盘操作对于系统崩溃来说是原子操作：在恢复之后，要么所有的写操作都完成了，要么一个写操作都没有完成。\n\n### 日志层设计——日志的磁盘结构\n\n首先，这里可以放上一张XV6当中文件系统在磁盘上的结构图：\n\n![](./FileSystem/photo/filesystem/xv6_fsstructureondisk.png)\n\n可以直观看到，我们的日志信息被放在磁盘分区最末尾的位置。\n\n然后，你需要感到疑惑的是：那么末尾的日志信息具体的内部结构是啥？要弄清这个问题，就需要我们深入查看xv6的代码了，日志层实现代码位于log.c文件，我们直接来到initlog函数的实现：\n\n```c\nstruct logheader {\n  int n;\n  int block[LOGSIZE];\n};\n\nstruct log {\n  struct spinlock lock;\n  int start;\n  int size;\n  int outstanding; // how many FS sys calls are executing.\n  int committing;  // in commit(), please wait.\n  int dev;\n  struct logheader lh;\n};\nstruct log log;\n\nvoid\ninitlog(int dev)\n{\n  struct superblock sb;\n  initlock(&log.lock, \"log\");\n  readsb(dev, &sb);\n  log.start = sb.logstart;\n  log.size = sb.nlog;\n  log.dev = dev;\n  recover_from_log();\n}\n```\n\n1. 首先可以看到初始化函数从超级快当中获取了日志的起始块 `sb.logstart` 和 日志磁盘块数限制 `sb.nlog`。\n\n2. 然后调用了recover_from_log函数，在系统初始化阶段，尝试进行磁盘错误恢复，recover_from_log函数实现如下：\n\n    1. 调用read_head函数，读取前面拿到的日志起始块，日志起始块结构如下：\n        ```c\n        struct logheader {\n            int n;\n            int block[LOGSIZE];\n        };\n        ```\n        简单来说，成员n代表block数组的有效长度，而block数组，其实表示日志起始块之后的日志块 和 文件（磁盘）的数据块的映射关系。这点在介绍install_trans函数时会更有体会。\n    2. 调用install_trans函数，进行差错恢复，将上一次关机记录在日志块的没有提交完的数据重新提交。确保文件系统的一致性：\n        ```c\n        // Copy committed blocks from log to their home location\n        static void\n        install_trans(void)\n        {\n        int tail;\n\n        for (tail = 0; tail < log.lh.n; tail++) {\n            struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block\n            struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst\n            memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst\n            bwrite(dbuf);  // write dst to disk\n            brelse(lbuf);\n            brelse(dbuf);\n        }\n        }\n        ```\n        仔细阅读代码可以了解到，就是顺序将日志起始块后面的日志块读出，然后根据起始块提供的文件（磁盘）数据块映射数组，将日志块拷贝到文件（磁盘）的数据块当中。**并且同步到磁盘**\n    3. 将日志起始块的logheader::n改为0，意味着日志的清空，标志着事务的完成。这一步也就是本节最开头所谓的“特殊的提交记录”。\n\n综上所述，磁盘当中日志的结构如下图：\n\n![](./FileSystem/photo/filesystem/xv6_log_structure.drawio.png)\n\n### 日志层设计——日志的封装\n\n首先是日志写操作——log_write函数，xv6规定，所有文件的写操作，都使用log_write函数进行，并且log_write函数必须在begin_op函数和end_op函数之间调用。在进程每次写一些缓存块后都会调用log_write函数。该函数只做两件事：\n\n1. 将被修改的缓存块的块号记录到logheader.block数组当中。\n2. 将缓存块标记为脏。\n\n需要明确的是：进程对文件任何写操作都是基于被缓存到内存的缓存块。写操作开始并未同步到磁盘块。真正的同步操作是在commit函数当中进行。\n\n事务包装函数如下：\n\n```c\n// called at the start of each FS system call.\nvoid\nbegin_op(void)\n{\n  acquire(&log.lock);\n  while(1){\n    if(log.committing){\n      sleep(&log, &log.lock);\n    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){\n      // this op might exhaust log space; wait for commit.\n      sleep(&log, &log.lock);\n    } else {\n      log.outstanding += 1;\n      release(&log.lock);\n      break;\n    }\n  }\n}\n\n// called at the end of each FS system call.\n// commits if this was the last outstanding operation.\nvoid\nend_op(void)\n{\n  int do_commit = 0;\n\n  acquire(&log.lock);\n  log.outstanding -= 1;\n  if(log.committing)\n    panic(\"log.committing\");\n  if(log.outstanding == 0){\n    do_commit = 1;\n    log.committing = 1;\n  } else {\n    // begin_op() may be waiting for log space,\n    // and decrementing log.outstanding has decreased\n    // the amount of reserved space.\n    wakeup(&log);\n  }\n  release(&log.lock);\n\n  if(do_commit){\n    // call commit w/o holding locks, since not allowed\n    // to sleep with locks.\n    commit();\n    acquire(&log.lock);\n    log.committing = 0;\n    wakeup(&log);\n    release(&log.lock);\n  }\n}\n```\n\n仔细阅读begin_op和end_op函数的源码，可以了解到，**xv6允许多个进程在begin_op和end_op之间执行事务。但是，提交操作只能由最后一个执行完的进程执行，并且提交期间，其他要执行事务的进程都将被阻塞在begin_op函数。**假设存在A、B、C三个进程要执行一组写操作。ABC都调用begin_op函数，然后对缓存块进行修改。此时 `log.outstanding` 为3。而A、B的写操作很快执行完调用end_op因为`log.outstanding`非0而直接退出，只有C执行完后，`log.outstanding` 为0，才能执行提交操作。并且在执行提交操作期间，其他任何准备执行事务的进程都将阻塞在begin_op函数。这里体现了xv6文档当中提到的：任何时候只能有一个进程在一个会话之中，其他进程必须等待当前会话中的进程结束。因此同一时刻日志最多只记录一次会话。\n\nxv6 不允许并发会话，目的是为了避免下面几种问题。假设会话 X 把一个对 i 节点的修改写入了会话中。并发的会话 Y 从同一块中读出了另一个 i 节点，更新了它，把 i 节点块写入了日志并且提交。这就会导致可怕的后果：Y 的提交导致被 X 修改过的 i 节点块被写入磁盘，而 X 此时并没有提交它的修改。如果这时候发生崩溃会使得 X 的修改只应用了一部分而不是全部，从而打破会话是原子的这一性质。有一些复杂的办法可以解决这个问题，但 xv6 直接通过不允许并行的会话来回避这个问题。\n\ncommit函数实现如下：\n\n```c\nstatic void\ncommit()\n{\n  if (log.lh.n > 0) {\n    write_log();     // Write modified blocks from cache to log\n    write_head();    // Write header to disk -- the real commit\n    install_trans(); // Now install writes to home locations\n    log.lh.n = 0;\n    write_head();    // Erase the transaction from the log\n  }\n}\n```\n\n从注释当中可以直观了解到，干了如下4件事：\n\n> 1. 将被改动的文件缓存块**同步追加到日志（磁盘）块**当中。\n> 2. 更新日志（磁盘）起始块logheader磁盘结构。\n> 3. 将日志块同步到适合的文件（磁盘）数据块当中。\n> 4. 清空日志块。\n\nxv6 使用固定量的磁盘空间来保存日志。系统调用写入日志的块的总大小不能大于日志的总大小。所以源码当中，会有很多预防日志过大导致空间不足的处理措施。比如限制每个进程每次事务操作最大写数量，或者在空间不足时，阻塞进程，直到有足够可用空间被唤醒。\n\n## 虚拟文件系统实现层\n\n本小节将借Onix Minix文件系统的实现，解答虚拟文件神秘的面纱。在此之前，你一定对linux的文件系统有许多疑惑：\n\n- 为什么一个int类型的fd能代表文件？\n- 都说fd代表进程内核文件描述数组的下标，那么文件描述数组类型本身是什么？\n- 一块256G的磁盘，linux怎么做到让每个文件打开，能从0开始顺序读写，就好像每个文件都占用了独立的磁盘一样？\n- IO设备、网络套接字、管道等怎么被抽象成fd，可以使用统一的系统调用的？\n\n### i节点初步介绍\n\n这里从i节点作为切入。\n\ni 节点这个术语可以有两个的意思。（对于常规文件系统）它可以指的是磁盘上的记录文件类型、文件大小、数据块扇区号的数据结构。也可以指内存中的一个 i 节点代理，它包含了i节点（实体）描述符、文件系统类型、文件操作回调等。\n\n简单来说，一个i节点对应一个虚拟文件。并且，对于常规的文件系统，i节点分：内存结构、磁盘结构，这两种结构并不等同，内存i节点代理会引用磁盘上的i节点。\n\n超级快代理和i节点代理的内存结构，如下：\n\n```c\ntypedef struct super_t\n{\n    void *desc;           // 超级块描述符\n    struct buffer_t *buf; // 超级块描述符 buffer\n    dev_t dev;            // 设备号\n    u32 count;            // 引用计数\n    int type;             // 文件系统类型\n    size_t sector_size;   // 扇区大小\n    size_t block_size;    // 块大小\n    list_t inode_list;    // 使用中 inode 链表\n    inode_t *iroot;       // 根目录 inode\n    inode_t *imount;      // 安装到的 inode\n} super_t;\n\ntypedef struct inode_t\n{\n    list_node_t node; // 链表结点\n\n    void *desc; // inode 描述符（可能是 磁盘i节点、套接字结构体、管道结构体等。\n\n    union\n    {\n        struct buffer_t *buf; // inode 描述符对应 buffer\n        void *addr;           // pipe 缓冲地址\n    };\n\n    dev_t dev;  // 设备号\n    dev_t rdev; // 虚拟设备号\n\n    idx_t nr;     // i 节点号\n    size_t count; // 引用计数\n\n    time_t atime; // 访问时间\n    time_t mtime; // 修改时间\n    time_t ctime; // 创建时间\n\n    dev_t mount; // 安装设备\n\n    mode_t mode; // 文件模式\n    size_t size; // 文件大小\n    int type;    // 文件系统类型\n\n    int uid; // 用户 id\n    int gid; // 组 id\n\n    struct super_t *super;   // 超级块\n    struct fs_op_t *op;      // 文件系统操作\n    struct task_t *rxwaiter; // 读等待进程\n    struct task_t *txwaiter; // 写等待进程\n} inode_t;\n```\n\n对于inode_t::type字段，onix当中有如下可选值：\n\n```c\nenum\n{\n    FS_TYPE_NONE = 0,\n    FS_TYPE_PIPE,\n    FS_TYPE_SOCKET,\n    FS_TYPE_MINIX,\n    FS_TYPE_NUM,\n};\n```\n\n虚拟文件系统将所有的IO操作都抽象成了这样一个i节点——inode_t。这里主要提一下 `inode_t::desc` 这个成员，如果i节点对应文件的话（FS_TYPE_MINIX），inode_t::desc会被赋值成 `minix_inode_t` 也就是i节点在磁盘上的数据结构；如果i节点对应网络套接字（FS_TYPE_SOCKET），那么inode_t::desc会被赋值成 `socket_t`。如果i节点对应管道（FS_TYPE_PIPE），那么inode_t::desc会被赋值成 `fifo_t`。\n\n本文主要介绍FS_TYPE_MINIX类型的i节点。minix文件系统初始化函数会向数组 `fs_ops` 当中注册一组minix文件系统专用回调函数。\n\n```c\nstatic fs_op_t minix_op = {\n    minix_mkfs,\n    minix_super,\n\n    minix_open,\n    minix_close,\n\n    minix_read,\n    minix_write,\n    minix_truncate,\n\n    minix_stat,\n    minix_permission,\n\n    minix_namei,\n    minix_mkdir,\n    minix_rmdir,\n    minix_link,\n    minix_unlink,\n    minix_mknod,\n    minix_readdir,\n};\n\nvoid minix_init()\n{\n    fs_register_op(FS_TYPE_MINIX, &minix_op);\n}\n```\n\n如果需要实现新的文件系统，仿照minix，只需实现上面所列的必要回调函数即可。使用minix文件系统创建的i节点inode_t::op都会被赋值成minix_op。\n\n下面可以先了解一下minix文件系统在磁盘上的结构：\n\n![](./FileSystem/photo/filesystem/onix_fsstructureondisk.drawio.png)\n\n各字段起始位置和作用如下表：\n\n>|  | 起始位置 | 作用 |\n>| :-: | :-: | :-: |\n>| 超级块 | 块1 | 记录i节点位图所占块数、（磁盘数据块）逻辑块位图所占块数、第一个逻辑块号等解析文件系统的关键信息 |\n>| i节点位图 | 块2 | 管理磁盘i节点分配情况 |\n>| （磁盘数据块）逻辑块位图 | 块2 + super->imap_blocks | 管理磁盘数据块分配情况 |\n>| i节点 | 块2 + super->imap_blocks + super->zmap_blocks | 磁盘i节点数组 |\n>| （磁盘数据块）逻辑块 | minix_super_t::firstdatazone | 磁盘数据块数组 |\n\n### i节点的分配与释放\n\n上面提到，由于i节点在虚拟文件系统当中有两种存在形式，所以本小节i节点的分配与释放也是分为两种。当需要创建文件时我们需要分配一个i节点，当文件需要被删除（文件磁盘i节点引用计数减为零）时我们需要释放这一个i节点。\n\n首先对于磁盘i节点的分配与释放，磁盘i节点分配/释放的管理由磁盘上 i节点位图 和 磁盘i节点数组 共同管理，它们的起始位置在上小结已给出。所有的磁盘上的 i 节点都被统一存放在一个称为 i 节点数组的连续区域中。每一个 i 节点的大小都是一样的，所以对于一个给定的数字n，很容易找到磁盘上对应的 i 节点。事实上这个给定的数字就是操作系统中 i 节点的编号。\n\n磁盘上的 i 节点由结构体 `minix_inode_t` 定义。`mode` 域用来区分文件、目录和特殊文件。nlink 域用来记录指向了这一个 i 节点的目录项，这是用于判断一个 i 节点是否应该被释放的。size 域记录了文件的字节数。`zone` 数组用于这个文件的数据块的块号。在后面 **虚拟文件的打开/读写/关闭** 小结就会看到，每个文件采用 `zone` 数组管理文件数据的方式非常巧妙，该数组就是每个文件都能从0偏移开始读取和写入，看起来像多块磁盘的原因。\n\ni节点和超级快磁盘结构如下：\n\n```c\ntypedef struct minix_inode_t\n{\n    u16 mode;    // 文件类型和属性(rwx 位)\n    u16 uid;     // 用户id（文件拥有者标识符）\n    u32 size;    // 文件大小（字节数）\n    u32 mtime;   // 修改时间戳 这个时间戳应该用 UTC 时间，不然有瑕疵\n    u8 gid;      // 组id(文件拥有者所在的组)\n    u8 nlinks;   // 链接数（多少个文件目录项指向该i 节点）\n    u16 zone[9]; // 直接 (0-6)、间接(7)或双重间接 (8) 逻辑块号\n} minix_inode_t;\n\ntypedef struct minix_super_t\n{\n    u16 inodes;        // 节点数\n    u16 zones;         // 逻辑块数\n    u16 imap_blocks;   // i 节点位图所占用的数据块数\n    u16 zmap_blocks;   // 逻辑块位图所占用的数据块数\n    u16 firstdatazone; // 第一个数据逻辑块号\n    u16 log_zone_size; // log2(每逻辑块数据块数)\n    u32 max_size;      // 文件最大长度\n    u16 magic;         // 文件系统魔数\n} minix_super_t;\n```\n\n磁盘i节点分配/释放的核心函数是 `minix_ialloc` 和 `minix_ifree`。分配函数首先会从超级块当中定位i节点位图的起始位置和长度。然后遍历i节点位图，找到一个可用i节点编号，将位图置为true（占用）并返回。minix_ialloc只负责从磁盘上找到一个可用的i节点编号返回给调用者，其他的什么也不做。`minix_ifree` 就是 `minix_ialloc` 逆过程，将分配的i节点编号对应的位图置为false（可分配）。两函数代码如下：\n\n```c\n// 分配一个文件系统 inode\nidx_t minix_ialloc(super_t *super)\n{\n    buffer_t *buf = NULL;\n    idx_t bit = EOF;\n    bitmap_t map;\n\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    idx_t bidx = 2;\n    for (size_t i = 0; i < desc->imap_blocks; i++)\n    {\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        bitmap_make(&map, buf->data, BLOCK_BITS, i * BLOCK_BITS);\n        bit = bitmap_scan(&map, 1);\n        if (bit != EOF)\n        {\n            assert(bit < desc->inodes);\n            buf->dirty = true;\n            break;\n        }\n    }\n    brelse(buf); // todo 调试期间强同步\n    return bit;\n}\n\n// 释放一个文件系统 inode\nvoid minix_ifree(super_t *super, idx_t idx)\n{\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    assert(idx < desc->inodes);\n\n    buffer_t *buf;\n    bitmap_t map;\n\n    idx_t bidx = 2;\n    for (size_t i = 0; i < desc->imap_blocks; i++)\n    {\n        if (idx > BLOCK_BITS * (i + 1))\n        {\n            continue;\n        }\n\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        bitmap_make(&map, buf->data, BLOCK_BITS, i * BLOCK_BITS);\n        assert(bitmap_test(&map, idx));\n        bitmap_set(&map, idx, 0);\n        buf->dirty = true;\n        break;\n    }\n    brelse(buf); // todo 调试期间强同步\n}\n```\n\n调用者得到i节点编号后，可以通过 `iget` 函数**将i节点编号转为i节点代理**。它的逻辑是这样的，先尝试在现有内存i节点代理当中根据i节点编号查找i节点，如果查到了，就直接返回，否则调用 `get_free_inode` 函数先从空闲的i节点代理缓存当中获取一个空闲i节点代理，再将i节点编号转为磁盘i节点所在块号，然后将磁盘i节点所在磁盘块缓存到内存获取磁盘上的i节点，然后对空闲的i节点代理进行初始化。\n\ni节点代理的核心初始化步骤包括：\n\n>- 将inode_t::desc填充成 磁盘i节点缓存地址。\n>- inode::buf填充成 磁盘i节点所在块缓存地址，inode::buf指向 磁盘i节点所在块缓存地址 这样能保证 磁盘i节点所在块缓存 的引用计数非零，防止inode_t::desc所指向的磁盘i节点缓存地址 因磁盘块的lru算法被置换出内存而失效。\n>- 如果i节点对应的是IO设备，而非文件，将inode_t::rdev填充为minix_inode_t::zone[0]，对于设备文件，minix_inode_t::zone[0]表示IO设备的虚拟设备号。\n>- inode_t::super填充成所在设备的超级快。同一设备上的文件系统，超级快是相同的！\n>- inode_t::type设置成FS_TYPE_MINIX。\n>- 并且inode_t::op安装成FS_TYPE_MINIX对应的回调。\n\n核心代码如下：\n\n```c\n#define BLOCK_INODES (BLOCK_SIZE / sizeof(minix_inode_t))    // 1个磁盘块能容纳 inode的数量\n\n// 计算 inode nr 对应的块号\nstatic inline idx_t inode_block(minix_super_t *desc, idx_t nr) {\n    // inode 编号 从 1 开始\n    return 2 + desc->imap_blocks + desc->zmap_blocks + (nr - 1) / BLOCK_INODES;\n}\n\n// 将i节点编号转为i节点代理\nstatic inode_t *iget(dev_t dev, idx_t nr) {\n    inode_t *inode = find_inode(dev, nr);\n    if (inode)\n    {\n        inode->count++;\n        inode->atime = time();\n        return fit_inode(inode);\n    }\n\n    super_t *super = get_super(dev);\n    assert(super);\n\n    minix_super_t *desc = (minix_super_t *)super->desc;\n\n    assert(nr <= desc->inodes);\n\n    inode = get_free_inode();\n    inode->dev = dev;\n    inode->nr = nr;\n    inode->count++;\n\n    // 加入超级块 inode 链表\n    list_push(&super->inode_list, &inode->node);\n\n    idx_t block = inode_block(desc, inode->nr);\n    buffer_t *buf = bread(inode->dev, block);\n\n    inode->buf = buf;\n\n    // 将缓冲视为一个 inode 描述符数组，获取对应的指针；\n    inode->desc = &((minix_inode_t *)buf->data)[(inode->nr - 1) % BLOCK_INODES];\n    minix_inode_t *minode = (minix_inode_t *)inode->desc;\n\n    inode->rdev = minode->zone[0];\n\n    inode->mode = minode->mode;\n    inode->size = minode->size;\n    inode->super = super;\n\n    inode->type = FS_TYPE_MINIX;\n    inode->op = fs_get_op(FS_TYPE_MINIX);\n\n    return fit_inode(inode);\n}\n```\n\n与iget对立的是iput函数，该函数定义在onix-dev/src/fs/inode.c，函数iput用于将i节点代理进行释放，iput会借助 minix_close 函数，一旦inode_t::count成员减为零，就将inode::buf（磁盘i节点所在块缓存）释放，然后将i节点代理放回空闲缓存区。\n\n### 磁盘数据块的分配与释放\n\nonix当中，文件系统文件的数据存在于分散的磁盘数据块当中。文件使用磁盘上的i节点minix_inode_t::zone数组管理磁盘数据块。文件创建后，向里面不断顺序写入数据，一旦当前磁盘数据块写满了，文件系统就会调用 `minix_balloc` 函数给文件分配一块磁盘数据块。相反的，如果一个文件需要被删除，调用 `minix_bfree` 函数释放所有分配的磁盘数据块。磁盘块同样采用位图的方式去管理。\n\n磁盘数据块分配释放/器的原理和 磁盘i节点分配/释放器（`minix_ialloc` 和 `minix_ifree`）极其类似。磁盘数据块分配器首先会从超级块当中定位磁盘数据块位图的起始位置和长度。然后遍历磁盘数据块位图，找到一个可用磁盘数据块号，将位图置为true（占用）并返回。minix_ialloc只负责从磁盘上找到一个可用的磁盘数据块号返回给调用者，其他的什么也不做。`minix_bfree` 就是 `minix_balloc` 逆过程，将分配的磁盘数据块号对应的位图置为false（可分配）。\n\n代码如下：\n\n```c\n// 分配一个文件块\nidx_t minix_balloc(super_t *super)\n{\n    buffer_t *buf = NULL;\n    idx_t bit = EOF;\n    bitmap_t map;\n\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    idx_t bidx = 2 + desc->imap_blocks;\n\n    for (size_t i = 0; i < desc->zmap_blocks; i++)\n    {\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        // 将整个缓冲区作为位图\n        bitmap_make(&map, buf->data, BLOCK_SIZE, i * BLOCK_BITS + desc->firstdatazone - 1);\n\n        // 从位图中扫描一位\n        bit = bitmap_scan(&map, 1);\n        if (bit != EOF)\n        {\n            // 如果扫描成功，则 标记缓冲区脏，中止查找\n            assert(bit < desc->zones);\n            buf->dirty = true;\n            break;\n        }\n    }\n    brelse(buf); // todo 调试期间强同步\n    return bit;\n}\n\n// 释放一个文件块\nvoid minix_bfree(super_t *super, idx_t idx)\n{\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    assert(idx < desc->zones);\n\n    buffer_t *buf;\n    bitmap_t map;\n\n    idx_t bidx = 2 + desc->imap_blocks;\n\n    for (size_t i = 0; i < desc->zmap_blocks; i++)\n    {\n        // 跳过开始的块\n        if (idx > BLOCK_BITS * (i + 1))\n        {\n            continue;\n        }\n\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        // 将整个缓冲区作为位图\n        bitmap_make(&map, buf->data, BLOCK_SIZE, BLOCK_BITS * i + desc->firstdatazone - 1);\n\n        // 将 idx 对应的位图置位 0\n        assert(bitmap_test(&map, idx));\n        bitmap_set(&map, idx, 0);\n\n        // 标记缓冲区脏\n        buf->dirty = true;\n        break;\n    }\n    brelse(buf); // todo 调试期间强同步\n}\n```\n\n### 根文件系统的挂载\n\n在onix初始化阶段在使用文件系统之前，必须先对根目录进行挂载。我们使用系统调用 `open` 函数打开的文件时，需要传入路径作为参数，而想要通过路径找到最终文件的i节点，必经过根目录的i节点。任何路径的解析，都以根目录为基础的。所以，分析onix根目录的挂载流程是很重要的。\n\n根文件系统挂载触发点位于super_init函数：\n\n- super_init函数首先会初始化全局超级块表，为后续文件系统挂载做准备，每个超级块维护一个inode链表，用于管理该文件系统打开的文件节点，超级块表初始化完毕后，会调用mount_root函数。\n- mount_root函数首先获取磁盘第一个分区的虚拟设备控制句柄，然后从设备控制句柄当中获取设备号dev（方便读写），然后调用read_super函数获取dev设备的超级快。最后将**超级块和根目录i节点代理做绑定**，方便将路径解析为i节点。\n    ```c\n    // 挂载根文件系统\n    static void mount_root() {\n        LOGK(\"Mount root file system...\\n\");\n        // 假设主硬盘第一个分区是根文件系统\n        device_t *device = device_find(DEV_IDE_PART, 0);\n        assert(device);\n\n        // 读根文件系统超级块\n        root = read_super(device->dev);\n\n        // 超级快和根目录i节点代理做绑定。\n        root->imount = root->iroot;\n        root->imount->count++;\n\n        root->iroot->mount = device->dev;\n    }\n    ```\n- read_super函数首先会尝试使用设备号dev从超级快列表当中直接获取超级快，但由于系统刚启动，正处在初始化阶段，所以，必然失败。然后read_super函数会尝试从超级块列表当中获取一个空闲的超级快，然后调用minix_super函数对空闲超级快进行初始化。\n    ```c\n    // 读设备 dev 的超级块\n    super_t *read_super(dev_t dev) {\n        super_t *super = get_super(dev);\n        if (super) {\n            super->count++;\n            return super;\n        }\n\n        LOGK(\"Reading super block of device %d\\n\", dev);\n\n        // 获得空闲超级块\n        super = get_free_super();\n        super->count++;\n\n        for (size_t i = 1; i < FS_TYPE_NUM; i++) {\n            fs_op_t *op = fs_get_op(i);\n            if (!op)\n                continue;\n            // minix_super\n            if (op->super(dev, super) == EOK) {\n                return super;\n            }\n        }\n\n        put_super(super);\n        return NULL;\n    }\n    ```\n- minix_super函数实现较为简单，通过读取磁盘的 磁盘块1 （在前面的列出的磁盘分区结构图当中有列出，超级块位于1号磁盘块），将 磁盘超级快 读到内存当中，然后将磁盘超级块缓存填充到super_t::desc，当然为了避免磁盘超级块缓存被替换出磁盘，将磁盘超级快所在的磁盘块缓存填充给super_t::buf，最后调用 iget 函数获取根目录的i节点代理（按规定，根目录磁盘i节点的编号为1）。\n    ```c\n    static int minix_super(dev_t dev, super_t *super) {\n        // 读取超级块\n        buffer_t *buf = bread(dev, 1);\n        if (!buf)\n            return -EFSUNK;\n\n        assert(buf);\n        minix_super_t *desc = (minix_super_t *)buf->data;\n\n        if (desc->magic != MINIX1_MAGIC) {\n            brelse(buf);\n            return -EFSUNK;\n        }\n\n        super->buf = buf;\n        super->desc = desc;\n        super->dev = dev;\n        super->type = FS_TYPE_MINIX;\n        super->block_size = BLOCK_SIZE;\n        super->sector_size = SECTOR_SIZE;\n        super->iroot = iget(dev, 1);\n\n        return EOK;\n    }\n    ```\n\n注意 `super->iroot` 成员的初始化被放在了最后，这里是一定要放在最后。如果你深入阅读 iget 函数的代码就会发现 iget函数 里面需要用到超级块如下：\n\n```c\nstatic inode_t *iget(dev_t dev, idx_t nr) {\n    inode_t *inode = find_inode(dev, nr);\n    if (inode) {\n        inode->count++;\n        inode->atime = time();\n        return fit_inode(inode);\n    }\n\n    super_t *super = get_super(dev);\n    assert(super);\n\n    // ...\n    return fit_inode(inode);\n}\n```\n\n等等，我们正在初始化超级快，但是 iget 函数又用到了超级快，这样对吗？我的回答是没有任何毛病，因为 在minix_super超级快初始化函数当中最后一刻才调用了iget函数，此时超级快其实已经初始化的差不多了，并且iget函数内部也并没有用到 `super->iroot` 成员，所以逻辑并没有什么问题。\n\n### 虚拟文件的打开/关闭\n\nonix当中，使用open函数打开一个文件，如果要创建以一个文件，实际上使用的是带 `O_CREAT | O_TRUNC` 标志的open函数，我们只需要重点研究open系统调用 `sys_open` 的实现，伪代码如下：\n\n```c\nfd_t sys_open(char *filename, int flags, int mode) {\n    char *next;\n    inode_t *dir = NULL;\n\n    // 获取filename父目录i节点代理，并且，将最后的文件名填到next当中。\n    dir = named(filename, &next);\n\n    // 如果路径本身是目录（/a/b/）。跳过minix文件系统open回调\n    if (!*next) {\n        inode = dir;\n        dir->count++;\n        goto makeup;\n    }\n    // 调用minix文件系统open回调。打开/创建文件。\n    int ret = dir->op->open(dir, next, flags, mode, &inode);\n\n    // 从进程文件表（数组）当中获取一个空闲的文件描述符，并且初始化其元素file_t。\n    file_t *file;\n    fd_t fd = fd_get(&file);\n\n    file->inode = inode;\n    file->flags = flags;\n    file->count = 1;\n    file->offset = 0;\n    // 有追加参数就将file的偏移移到文件末尾。\n    if (flags & O_APPEND) {\n        file->offset = file->inode->size;\n    }\n\n    return fd;\n}\n```\n\n> 1. 调用named函数，获取filename父目录i节点代理，并且，将最后的文件名填到next当中。\n> 2. 如果路径本身是目录（/a/b/）。跳过minix文件系统open回调。进入4。\n> 3. 调用minix的open回调，打开/创建文件。获取文件的i节点代理。\n> 4. 从进程文件表（数组）当中获取一个空闲的文件描述符，并且初始化其元素file_t。\n> 5. 如果flags标志包含 `O_APPEND` ，将file的偏移移到文件末尾。\n\nnamed函数的作用就是根据路径找到文件父目录的i节点，并且将最后的文件名填到next当中。named函数代码稍微有些复杂，特别是这一段：\n\n```c\n// 获取 pathname 对应的父目录 inode\ninode_t *named(char *pathname, char **next) {\n\n    // ...\n    while (true) {\n        // 返回上一级目录且上一级目录是个挂载点\n        if (match_name(name, \"..\", next) && dir == dir->super->iroot) {\n            super_t *super = dir->super;\n            inode = super->imount;\n            inode->count++;\n            iput(dir);\n            dir = inode;\n        }\n    }\n    // ...\n}\n```\n\n如果路径 `name`（基于pathname经过预处理的路径） 解析到了 `..` 文件名并且（同一文件系统下）其父目录正好是设备的根节点，就会进入该if分支。因为linux当中一切皆文件的思想，（跨文件系统）父目录可能是作为子目录的挂载点而存在，导致父目录和子目录不在一个设备（文件系统）上。故我们在跨文件系统的情况下执行 `..` 目录回退操作时，必须执行这样一段 \"换根\" 代码。\n\n这段if换根代码强烈建议读者结合 `sys_mknod` 和 `sys_mount` 函数实现去理解。在onix当中（参考：onix-dev/src/fs/dev.c），挂载一个设备首先要使用 sys_mknod 系统调用为设备创建一个设备文件，然后，在根文件系统下寻找一个目录作为挂载点，最后使用 sys_mount 系统调用挂载设备。\n\n下面深入介绍一下onix当中如何实现设备挂载的：\n\n挂载点内部数据结构链接细节如下图：\n\n![](./FileSystem/photo/filesystem/onix_mount.drawio.png)\n\nsys_mknod会接收设备号作为参数。它的实现最终会调用minix_mknod函数，这会创建一个特殊的文件，我们称它为设备文件，然后文件的磁盘i节点当中zone数组只使用第一个元素，存放传入的设备号，在将磁盘i节点转成i节点代理过程当中，i节点代理的rdev成员就会被赋值成minode->zone[0]，minix_mknod伪代码如下：\n\n```c\nint minix_mknod(inode_t *dir, char *name, int mode, int dev) {\n    // ...\n    // 创建一个特殊的文件。\n    // ...\n    if (ISBLK(mode) || ISCHR(mode))\n        minode->zone[0] = dev;\n\n    // ...\n}\n```\n\nsys_mount函数负责将一个设备文件挂载到指定目录下。比如sd卡，一般来说，它的设备文件名为/dev/sdb1，当我们要访问sd卡时，需要执行命令 `mount /dev/sdb1 /mnt` 。**这里需要注意的是，sd卡所有的文件系统 和 我们的根目录所挂载的文件系统一定是两个独立的互不相干的两个文件系统，他们各自拥有自己独立、自包含的i节点编号空间。在同一个Linux系统下，SD卡上文件的i节点号与根文件系统下文件的i节点号即使数字相同，也绝对不会发生冲突。系统能够清晰地区分它们。** onix sys_mount函数实现伪代码如下：\n\n```c\nint sys_mount(char *devname, char *dirname, int flags) {\n    // 获取设备文件i节点代理\n    devinode = namei(devname);\n\n    // 获取挂载点i节点代理\n    dirinode = namei(dirname);\n\n    // 获取设备超级块\n    super = read_super(devinode->rdev);\n\n    // 设备超级快指向挂载点\n    super->imount = dirinode;\n\n    // 挂载点指向挂载的设备\n    dirinode->mount = devinode->rdev;\n    iput(devinode);\n    return EOK;\n}\n```\n\n核心逻辑如下：\n\n> 1. 获取设备文件i节点代理。\n> 2. 获取挂载点i节点代理。\n> 3. 获取设备超级块。\n> 4. 将设备超级块指向挂载点。\n> 5. 挂载点指向挂载的设备。\n\nsys_open当中核心函数还是中间调用的minix_open回调，它的伪代码如下：\n\n```c\nstatic int minix_open(inode_t *dir, char *name, int flags, int mode, inode_t **result) {\n    minix_dentry_t *entry = NULL;\n\n    // 在dir下尝试查找name文件，并将目录项存到entry。\n    buf = find_entry(dir, name, &next, &entry);\n    if (buf) {\n        // 如果找到了根据目录项将 i节点号转为i节点代理。iget函数是老朋友了，前面小结经常用到。\n        inode = iget(dir->dev, entry->nr);\n        assert(inode);\n        goto makeup;\n    } // 不存在\n\n    // 不带创建标志，返回文件不存在的错误。\n    if (!(flags & O_CREAT)) {\n        ret = -EEXIST;\n        return res;\n    }\n\n    // 向父目录当中添加名为name的文件项。并且返回其文件项缓存块地址，确保entry有效。\n    buf = add_entry(dir, name, &entry);\n\n    // 申请一个i节点号。\n    entry->nr = minix_ialloc(dir->super);\n\n    // 初始化磁盘i节点和i节点代理。\n    inode = new_inode(dir->dev, entry->nr);\n\nmakeup:\n    // 传给输出参数。\n    *result = inode;\n    return EOK;\n}\n```\n\n首先明确：sys_open调用minix_open，传入的name是单个文件名，dir是name文件的父目录i节点。\n\n> 1. 调用find_entry函数，首先在dir下尝试查找name文件，并将目录项存到entry。如果找到了，根据目录项将 i节点号转为i节点代理，并快进到 `makeup` 阶段。iget函数是老朋友了，前面小结经常用到。如果没找到，尝试去创建一个新文件。\n> 2. 检测是否带 `O_CREAT` 标志，不带标志就返回文件不存在的错误。\n> 3. 调用add_entry函数向父目录当中添加名为name的文件项。并且返回其文件项缓存块地址，确保entry有效。\n> 4. 申请一个i节点号。\n> 5. 初始化磁盘i节点和i节点代理。\n\n有关 `find_entry` 和 `add_entry` 函数，这两函数属于目录操作函数，在 **目录的操作** 小结将深入展开讲解。\n\n踪上，一个进程打开一个文件后，系统状态图如下：\n\n![](./FileSystem/photo/filesystem/onix_vfs_structure.drawio.png)\n\n### 虚拟文件的读/写\n\n如果说超级块是更高维度的能解析文件系统的磁盘结构，那么i节点其实可以理解成低维度的能解析文件的磁盘结构。\n\n在 **i节点的分配与释放** 小结已经列出过i节点的磁盘结构，但因为文章结构原因我们没有多费口舌去讲解它具体成员的作用。在本节，因为文件的操作是极度依赖i节点磁盘结构的。所以，下面用一张图片直观了解i节点的磁盘结构：\n\n![](./FileSystem/photo/filesystem/onix_minix_inode.drawio.png)\n\n一般的，i节点磁盘数据结构各个字段作用如下：\n\n| i节点字段名 | 作用 |\n| :-: | :-: |\n| minix_inode_t::mode | 文件类型和属性位，onix支持的文件类型包含：常规文件、目录文件、字符设备文件、块设备文件。文件屬性包含：读、写、可执行。 |\n| minix_inode_t::uid | 用户id，也即文件拥有者标识符 |\n| minix_inode_t::size | 文件大小（Byte） |\n| minix_inode_t::mtime | 最后修改的时间戳 |\n| minix_inode_t::gid | 用户所属组id |\n| minix_inode_t::nlinks | 链接数，表示有多少目录项指向该i节点 |\n| minix_inode_t::zone | 长度为9的uint16_t类型数组，前7个元素代表直接块，直接指向磁盘数据块，第8个元素为一级间接块，第9个元素为二级间接块 |\n\n磁盘i节点的设计非常精妙，前面部分存放文件属性，**后面的数组 `minix_inode_t::zone` 是你打开每一个文件，都能从0偏移开始读取的根本原因**。如果你有仔细研究过onix/xv6内存管理当中内存虚拟内存机制，你会发现，i节点对文件数据块的管理 和 虚拟内存的页表-页框-页目录机制思想一模一样。\n\n尽管物理上磁盘只有一块，i节点磁盘数据结构这种 直接块-间接块-双重间接块 机制让虚拟文件系统当中的每个文件都像独占一块磁盘一样，使（实际上）非连续空间连续化，可以从偏移0位置开始顺序读写数据。同时，在这种机制的加持下，更便于磁盘块的管理，增加零散磁盘块的利用率。\n\n有了上面i节点管理数据块的理论知识，下面让我们一步步了解 `sys_read` 和 `sys_write` 系统调用的实现。\n\n首先是 `sys_read` 函数，伪代码如下：\n\n```c\nint sys_read(fd_t fd, char *buf, int count) {\n    // ...\n    if ((ret = fd_check(fd, &file)) < EOK)\n        return ret;\n\n    inode_t *inode = file->inode;\n\n    int len = inode->op->read(inode, buf, count, file->offset);\n\n    if (len > 0)\n        file->offset += len;\n\n    return len;\n}\n```\n\n> 1. 首先将fd转换为文件表项 `file_t` 。\n> 2. 由文件表项获得文件的i节点代理。\n> 3. 调用 minix read 回调读取数据。\n\n直接来到了minix read 回调——minix_read。该函数根据传入的要读的数据长度len和文件偏移offset来来逐块读取数据。如下：\n\n```c\n// 从 inode 的 offset 处，读 len 个字节到 buf\nstatic int minix_read(inode_t *inode, char *data, int len, off_t offset) {\n    minix_inode_t *minode = (minix_inode_t *)inode->desc;\n    if (ISCHR(minode->mode)) {\n        assert(minode->zone[0]);\n        return device_read(minode->zone[0], data, len, 0, 0);\n    } else if (ISBLK(minode->mode)) {\n        assert(minode->zone[0]);\n        device_t *device = device_get(minode->zone[0]);\n        assert(len % BLOCK_SIZE == 0);\n        assert(device_read(minode->zone[0], data, len / BLOCK_SIZE, offset / BLOCK_SIZE, 0) == EOK);\n        return len;\n    }\n\n    assert(ISFILE(minode->mode) || ISDIR(minode->mode));\n\n    // 如果偏移量超过文件大小，返回 EOF\n    if (offset >= minode->size) {\n        return EOF;\n    }\n\n    // 开始读取的位置\n    u32 begin = offset;\n\n    // 剩余字节数\n    u32 left = MIN(len, minode->size - offset);\n    while (left) {\n        // 找到对应的文件便宜，所在文件块\n        idx_t nr = minix_bmap(inode, offset / BLOCK_SIZE, false);\n        assert(nr);\n\n        // 读取文件块缓冲\n        buffer_t *buf = bread(inode->dev, nr);\n\n        // 文件块中的偏移量\n        u32 start = offset % BLOCK_SIZE;\n\n        // 本次需要读取的字节数\n        u32 chars = MIN(BLOCK_SIZE - start, left);\n\n        // 更新 偏移量 和 剩余字节数\n        offset += chars;\n        left -= chars;\n\n        // 文件块中的指针\n        char *ptr = buf->data + start;\n\n        // 拷贝内容\n        memcpy(data, ptr, chars);\n\n        // 更新缓存位置\n        data += chars;\n\n        // 释放文件块缓冲\n        brelse(buf);\n    }\n\n    // 更新访问时间\n    inode->atime = time();\n\n    // 返回读取数量\n    return offset - begin;\n}\n```\n\n函数逻辑如下：\n\n> 1. 判断文件类型，如果是字符设备或者块设备，就根据minode->zone[0]获取到设备的设备号，然后调用虚拟设备回调函数，去读取数据并返回。如果是普通文件/目录，继续下面步骤。\n> 2. 普通文件的话，进入while循环，调用minix_bmap函数基于i节点的zone数组将offset转换为数据所在磁盘块。\n> 3. 获取磁盘块缓存。\n> 4. 读取 `MIN(BLOCK_SIZE - start, left)` 长的数据。\n> 5. 如果读取的数据不够len字节，重复2~4步骤。\n\n那么，minix_bmap函数是怎么实现的呢？onix对minix_bmap稍微有些复杂。这里附上我的想法，我觉得可以重用 [这才是计科之 Onix & XV6 源码分析（2、类Unix的内存管理）](https://blog.csdn.net/m0_52566365/article/details/139525258) 的做法。思想就是基于 i节点的磁盘结构图 对offset进行划分，如下：\n\n> - 如果 offset 在直接块覆盖范围内，直接通过zone数组读取数据块即可。\n> - 如果 offset 在一级间接块覆盖范围内。\n>   - 首先将offset减去直接块所能表示的最大地址。\n>   - 将offset看成虚拟磁盘地址，然后由 `(offset & 0x7FC00) >> 10` 公式获取虚拟磁盘地址高9位作为一级间接块的数组（元素为uint16_t）索引，然后取得磁盘数据块号后，将offset末尾的10位作为磁盘数据块内偏移。 获取块内偏移的公式：`offset & 0x3FF` ，最终获得到物理磁盘地址。\n> - 如果 offset 在二级间接块覆盖范围内。\n>   - 首先将offset减去直接块 + 一级间接块所能表示的最大地址。\n>   - 将offset看成虚拟磁盘地址，然后由 `(offset & 0xFF80000) >> 10` 公式获取虚拟磁盘地址高9位作为一级间接块的数组（元素为uint16_t）索引，取得二级间接块号后，根据公式 `(offset & 0x7FC00) >> 10` 得到二级间接块数组（元素同样为uint16_t）索引，取得磁盘数据块号后，将offset末尾的10位作为磁盘数据块内偏移。 获取块内偏移的公式：`offset & 0x3FF` ，最终获得到物理磁盘地址。\n\n但是， **由于onix规定zone数组元素类型为uint16_t，所以这决定了onix最大能表示的磁盘块号为2^16 - 1， 故onix的磁盘有效大小的上限为 64MB。** 当然，作为学习操作系统，我们就不必太过于精益求精。\n\n文件系统的写，是读的逆过程，代码逻辑极其相似，行文至此，篇幅过多，这里就不带着大家读代码了，建议读者亲自去扒一扒onix的源码。\n\n### 目录的操作\n\n最后就是文件系统目录的操作，这里主要讲解两个函数：`find_entry` 和 `add_entry`。面对目录，只需要记住一点，目录其实就是一个 文件内容被规定死的 普通文件。目录文件会存放一个个目录条目，onix当中目录条目数据结构如下：\n\n```c\n// 文件目录项结构\ntypedef struct minix_dentry_t\n{\n    u16 nr;              // i 节点\n    char name[NAME_LEN]; // 文件名\n} minix_dentry_t;\n```\n\n目录项图解如下：\n\n![](./FileSystem/photo/filesystem/onix_dentry.drawio.png)\n\n在onix当中，find_entry函数为了找到目标目录项会使用for循环遍历传进来的目录的所有目录项。\n\nadd_entry同样会遍历目录的目录项，直到找到一个 `nr` 成员为0的目录项，在onix当中，nr为0意味这该目录项未被占用。所以相应的，如果你想删除一个目录项，只需将对应的nr置为0即可。onix的minix_rmdir函数也正是这样做的。\n\n---\n\n**本章完结**","source":"_posts/xv6/FileSystem.md","raw":"---\ntitle: 这才是计科之 Onix & XV6 源码分析（4、文件系统）\ndate: 2025-09-28 12:00:00\ntags:\n  - 类Unix源码剖析\n---\n\n## 前言\n\n拖了这么久，终于到了最后一篇关于类unix源码分析的文章————文件系统。\n\n（偷偷告诉你，本篇博客起草于我即将从毕业以来第一家公司离职前一个星期（2025-9-16），忍着牙痛ing ing ing）。\n\n如你所见，文件系统完全值得另开一篇博文单独去记录它。这里为了方便，同样将Onix的文件系统和XV6的文件系统放一块进行记录。并且，Onix的文件系统确实更加规范和完善，而XV6的文件系统相对来说更加简洁。但值得一提的是，XV6文件系统实现了一个简单而确实又很重要的东西————基于写时日志的事务系统。这是Onix所没有的。\n\nlinux的一切皆文件的伟大思想，将所有的IO行为（包括IO设备读写、pipe读写、进程读写）都抽象成文件。在本篇文章当中，我们将通过两个小型操作系统源码一一揭开linux文件系统的面纱。\n\n<!-- more -->\n\n首先贴上XV6文件系统的模块方图：\n\n![](./FileSystem/photo/filesystem/xv6_fs_structure.drawio.png)\n\n其次是Onix文件系统的模块方图：\n\n![](./FileSystem/photo/filesystem/onix_fs_structure.drawio.png)\n\n诈一看，你一定会认为XV6实现的文件系统比Onix的更复杂，实际上恰恰相反。尽管XV6实现了更多的模块，但是因为它教学系统的本质，每个模块的实现都以简单且精简为目的，没有为扩展性做任何多余操作。： ）读过的人表示非常干脆利落。\n\n反观Onix，为了适配 终端、串口、键盘、磁盘、软盘以及以后可能有的各种IO设备，根据他们的特点，抽象出了 `struct device_t` 结构体，分离出虚拟设备抽象层，将共有的io操作提取出来。为了统一文件系统的管理，抽象出了 `fs_op_t` 结构体。更贴近真实Linux操作系统的做法。具体细节将逐一解释。\n\n依据我阅读源码的习惯，下面就来自底向上逐步介绍文件系统的实现。**以Onix文件系统为主。**\n\n## 磁盘IO驱动层 & 虚拟设备实现层\n\n- 磁盘IO驱动层: 一句话概括该模块的作用：所谓磁盘IO驱动层，实际上就是操作系统当中，最底层的直接和磁盘设备打交道的代码。使用厂商规定的指令对磁盘设备按一定规则进行读写操作。\n\n- 虚拟设备实现层: 对IO设备抽象出统一接口，并且针对磁盘设备访问，Onix还实现了经典的电梯算法。XV6当中虚拟设备实现层过于简单，这里以Onix为主进行深入讲解。 \n\n### 对于XV6\n\nXV6的磁盘IO驱动层可以分为两块：IO请求队列 和 磁盘IO驱动。实现可以参考文件：ide.c，IO请求队列的实现非常巧妙，其思想为：**多个进程需要并发对一块磁盘进行IO，为了保证正确性，我们必须对并行操作串行化处理。让请求IO的进程入队。仅让位于队头的进行执行磁盘IO，其他进程休眠等待。当队头的进程执行完IO请求后出队列唤醒进程，下一个队头再进行IO操作。** 如果你有看过LevelDB的源码，应该对这种思想非常熟悉，因为LevelDB的Write方法实现运用了同样的手法。参考：[LevelDB源码阅读笔记（1、整体架构）](https://blog.csdn.net/m0_52566365/article/details/137910783)\n\n框图图如下：\n\n![](./FileSystem/photo/filesystem/xv6_ide.drawio.png)\n\n流程如下：\n\n首先对外暴露iderw接口。\n\n**iderw函数的逻辑：**\n\n> 1. 上层调用对外暴露的磁盘操作接口 `iderw(struct buf *b)`。\n> 2. 将请求push到IO队列尾部。\n> 3. 如果本身就是队头，直接执行IO函数 `idestart`。\n> 4. 非队头，**阻塞直到 IO任务 被中断处理函数消费。**\n\n**磁盘中断处理函数ideintr的逻辑：**（一旦磁盘准备好，就会触发中断）\n\n> 1. IO队列为空直接返回。\n> 2. 移除并唤醒队头。\n> 3. 如果IO队列还非空，**为 IO任务 执行IO函数 `idestart`。**\n\n实现了简单的先来先服务(FCFS)调度\n\n### 对于Onix\n\n而Onix的磁盘IO驱动极其复杂，需要深入了解 IDE（Integrated Drive Electronics）硬盘控制器（IDE是一种常见的硬盘接口标准，也称为ATA（Advanced Technology Attachment））。感兴趣的可以先阅读一下XV6当中idestart函数，该函数使用几行代码实现了对磁盘设备的读写操作，然后深入去阅读Onix的磁盘IO驱动，代码路径：kernel/ide.c，我的重心在文件系统的架构，所以Onix最底层的磁盘IO驱动就跳过了。笔者重点要讲的是Onix的虚拟设备实现层。\n\nOnix对虚拟设备的实现定义了如下虚拟设备控制结构体：\n\n```c\ntypedef struct device_t\n{\n    char name[NAMELEN];  // 设备名\n    int type;            // 设备类型\n    int subtype;         // 设备子类型\n    dev_t dev;           // 设备号\n    dev_t parent;        // 父设备号\n    void *ptr;           // 设备指针\n    list_t request_list; // 块设备请求链表\n    bool direct;         // 磁盘寻道方向\n\n    // 设备控制\n    int (*ioctl)(void *dev, int cmd, void *args, int flags);\n    // 读设备\n    int (*read)(void *dev, void *buf, size_t count, idx_t idx, int flags);\n    // 写设备\n    int (*write)(void *dev, void *buf, size_t count, idx_t idx, int flags);\n} device_t;\n```\n\n针对IO设备，抽象出了ioctl、read、write接口，这样，每种IO设备只需根据实际情况实现回调函数，任何IO设备都能被实例化成该结构体，并且我们即将讲解的minix（onix文件系统类型）文件系统也能更好的对IO设备做适配。\n\nOnix当中对IO设备的设备类型按读取的粒度分成了两类：字符设备（单字节）和块设备（1024为一快）。\n\n```c\n// 设备类型\nenum device_type_t\n{\n    DEV_NULL,  // 空设备\n    DEV_CHAR,  // 字符设备\n    DEV_BLOCK, // 块设备\n};\n```\n\n设备子类型（也即具体的设备）就多了，比如：控制台、键盘、串口、磁盘、磁盘分区、软盘等。设备子类型定义在枚举类型 `enum device_subtype_t` 当中。\n\nOnix的设备抽象层，为了保证磁盘IO的正确性，其实也存在类似XV6的IO请求队列的设计，它的核心代码如下：\n\n```c\n// 块设备请求\nerr_t device_request(dev_t dev, void *buf, u8 count, idx_t idx, int flags, u32 type) {\n    device_t *device = device_get(dev);\n    request_t *req = kmalloc(sizeof(request_t));\n\n    // ...\n\n    // 判断列表是否为空\n    bool empty = list_empty(&device->request_list);\n\n    // 将请求插入链表\n    list_insert_sort(&device->request_list, &req->node, element_node_offset(request_t, node, idx));\n\n    // 如果列表不为空，则阻塞，因为已经有请求在处理了，等待处理完成；\n    if (!empty)\n    {\n        req->task = running_task();\n        assert(task_block(req->task, NULL, TASK_BLOCKED, TIMELESS) == EOK);\n    }\n\n    // do io\n    err_t ret = do_request(req);\n\n    // 跑一轮电梯算法，获取紧挨着req的下一个任务执行IO\n    request_t *nextreq = request_nextreq(device, req);\n\n    list_remove(&req->node);\n    kfree(req);\n\n    // 唤醒新队头\n    if (nextreq)\n    {\n        assert(nextreq->task->magic == ONIX_MAGIC);\n        task_unblock(nextreq->task, EOK);\n    }\n\n    return ret;\n}\n```\n\nOnix IO请求队列的逻辑更加清晰易懂：\n\n![](./FileSystem/photo/filesystem/onix_ide.drawio.png)\n\n流程如下：\n\n> 1. 进程调用磁盘IO接口 `device_request`。\n> 2. 为IO请求分配一个句柄req。\n> 3. 将req利用插入排序，升序插入请求队列。\n> 4. 如果在该任务插入到队列前，队列非空，就当前阻塞进程。说明已经有进程在执行IO任务。\n> 5. 如果在该任务插入到队列前，队列为空，由当前进程执行IO操作。\n> 6. 依据电梯算法，获取到紧挨着req的下一个IO请求任务reqnext。\n> 7. 从请求队列当中移除req。\n> 8. 唤醒reqnext进程。注意可以确定的是，在请求队列当中只有一个进程是活跃状态其他进程都处于阻塞状态，所以在reqnext此前必定为阻塞状态，在这里我们需要唤醒它。\n\nOnix实现了比XV6更高效的磁盘调度算法——电梯算法。电梯算法能有效避免饥饿现象，比简单的先来先服务（FCFS）更高效，减少了磁头移动距离，能够有效平衡响应时间和吞吐量。\n\n电梯算法的工作原理：**磁头（电梯）沿一个方向移动（比如向上），处理该方向上所有的请求。到达该方向的最后一个请求后，改变方向（向下），处理反方向上的请求。如此往复循环，就像电梯在楼层间上下运行一样。**\n\nOnix电梯算法实现函数request_nextreq如下：\n\n```c\n// 获得下一个请求\nstatic request_t *request_nextreq(device_t *device, request_t *req) {\n    list_t *list = &device->request_list;\n\n    if (device->direct == DIRECT_UP && req->node.next == &list->tail) {\n        device->direct = DIRECT_DOWN;\n    } else if (device->direct == DIRECT_DOWN && req->node.prev == &list->head) {\n        device->direct = DIRECT_UP;\n    }\n\n    void *next = NULL;\n    if (device->direct == DIRECT_UP) {\n        next = req->node.next;\n    } else {\n        next = req->node.prev;\n    }\n\n    if (next == &list->head || next == &list->tail) {\n        return NULL;\n    }\n\n    return element_entry(request_t, node, next);\n}\n```\n\n## 磁盘块缓存层\n\nOS对磁盘的任何访问都是基于块的，XV6当中，一个磁盘块的大小为512字节，Onix当中，默认为1024字节。如果我们每次访问文件都直接从磁盘上去读取，显然大部分时间都被浪费在磁盘IO上。所以，为了提高效率，内存（高速设备）和磁盘（低速设备）之间必然需要缓存层。本小节以Onix的代码为主。代码参考：onix-dev/src/kernel/buffer.c\n\n缓存层主要作用是：在在有限的内存当中，**缓存访问频率最高的部分磁盘块**。那么我们如何定性一个磁盘块的访问频率是高还是低呢？这就得靠大名鼎鼎的LRU算法。在CMU15445实验1当中可以学习到更高级的LRU算法——LRU-K算法、在LevelDB当中.sst文件结构的缓存也是用到了LRU算法。Onix实现的磁盘块缓存层使用的是最朴素的LRU算法。\n\n本节简单介绍一下Onix当中LRU算法运行逻辑。\n\n首先假设LRU相关数据结构的初始状态如下图：\n\n![](./FileSystem/photo/filesystem/onix_cache.drawio.png)\n\n如图所示，LRU算法涉及的基本数据结构包括：哈希表和链表。\n\n- 空闲链表 `idle_list`:  一旦OS对缓存块的引用为0，缓存块就会被放入到空闲链表。当OS需要读取一块没有缓存到内存的磁盘块时，就会触发LRU替换策略，LRU替换策略会将空闲链表当中最久未被访问过的缓存块写回磁盘，并且将缓存块的内容覆盖成新的磁盘块。空闲链表的插入和删除的逻辑非常重要，LRU替换策略实现的关键。\n- 哈希表: 记录已经缓存的磁盘块。用于快速查找缓存的磁盘块。\n\n磁盘块的读取：\n- 有被缓存到内存（这里假设要读 `block1`）：\n    1. 根据哈希算法 ` (设备号 ^ 块号) % 哈希表长度` 获取block1的所在哈希数组的位置，这里block1计算所得哈希数组索引为0。\n    2. 遍历链表，得到buffer1。\n    3. 将buffer1的引用计数加一。\n    4. 从idle_list当中移除buffer1，防止缓存块被替换出磁盘。\n\n    最终，结构如下：\n    ![](./FileSystem/photo/filesystem/onix_caceh1.drawio.png)\n\n- 没有被缓存到内存（这里假设要读 `block4`）：\n    1. 基于idle_list执行LRU替换策略。从idle_list可以了解到，idle_list的最后一个元素即为我们需要的 最久未被访问过的缓存块。也就是本节最开始所放图片当中的buffer3。\n    2. 将buffer3写回磁盘（如果标记为脏）。并从哈希表当中去除buffer3。\n    3. 将block4读到buffer3。\n    4. 根据哈希算法，计算block4所在哈希表的位置。这里假设计算block4的哈希值为1，并将block4插入到哈希表。\n\n    最终，结构如下：\n    ![](./FileSystem/photo/filesystem/onix_cache2.drawio.png)\n\n磁盘块的释放：\n1. 假设，现在要释放buffer4，将缓存块的引用计数减一。\n2. 当缓存块引用计数变为0时，将缓存块挂到idle_list开头。这样可以确保idle_list当中缓冲块从左到右，最后一次访问时间越来越长。\n\n    最终，结构如下：\n    ![](./FileSystem/photo/filesystem/onix_cache3.drawio.png)\n\n## 事务层（日志层）\n\n### 日志层简介\n\n事务层是XV6所拥有的模块，在Onix当中并不存在，所以，本节会以XV6为主进行叙述。在XV6的文档当中，将事务层称为日志层。不管是日志层还是事务层，作用都是一样的。**旨在实现错误恢复** 的机制，保证磁盘上文件系统的一致性。\n\n依我的理解，其实linux文件系统本身就是一个通用数据库。像mysql、oracle、leveldb等数据库存在一些共有问题（包括：一致性、错误恢复等问题），解决问题的思想或多或少都借鉴linux的文件系统的实现。\n\n文件系统设计中最有趣的问题之一就是错误恢复，产生这样的问题是因为大多数的文件系统都涉及到对磁盘多次的写操作，如果在写操作的过程当中系统崩溃了，就会使得磁盘上的文件系统处于不一致的状态中。举例来说，根据写的顺序的不同，上述错误可能会导致一个目录项指向一个空闲的 i 节点，或者产生一个已被分配但是未被引用的块。后一种情况相对来说好一些，但在前一种情况中，目录项指向了一个空闲的 i 节点，重启之后就会导致非常严重的问题。\n\nxv6 通过简单的日志系统来解决文件操作过程当中崩溃所导致的问题。一个系统调用并不直接导致对磁盘上文件系统的写操作，相反，他会把一个对磁盘写操作的描述包装成一个日志写在磁盘中。当系统调用把所有的写操作都写入了日志，它就会写一个特殊的提交记录到磁盘上，代表一次完整的操作。从那时起，系统调用就会把日志中的数据写入磁盘文件系统的数据结构中。在那些写操作都成功完成后，系统调用就会删除磁盘上的日志文件。\n\n为什么日志可以解决文件系统操作中出现的崩溃呢？如果崩溃发生在操作提交之前，那么磁盘上的日志文件就不会被标记为已完成，恢复系统的代码就会忽视它，磁盘的状态正如这个操作从未执行过一样。如果是在操作提交之后崩溃的，恢复程序会重演所有的写操作，可能会重复之前已经进行了的对磁盘文件系统的写操作。在任何一种情况下，日志文件都使得磁盘操作对于系统崩溃来说是原子操作：在恢复之后，要么所有的写操作都完成了，要么一个写操作都没有完成。\n\n### 日志层设计——日志的磁盘结构\n\n首先，这里可以放上一张XV6当中文件系统在磁盘上的结构图：\n\n![](./FileSystem/photo/filesystem/xv6_fsstructureondisk.png)\n\n可以直观看到，我们的日志信息被放在磁盘分区最末尾的位置。\n\n然后，你需要感到疑惑的是：那么末尾的日志信息具体的内部结构是啥？要弄清这个问题，就需要我们深入查看xv6的代码了，日志层实现代码位于log.c文件，我们直接来到initlog函数的实现：\n\n```c\nstruct logheader {\n  int n;\n  int block[LOGSIZE];\n};\n\nstruct log {\n  struct spinlock lock;\n  int start;\n  int size;\n  int outstanding; // how many FS sys calls are executing.\n  int committing;  // in commit(), please wait.\n  int dev;\n  struct logheader lh;\n};\nstruct log log;\n\nvoid\ninitlog(int dev)\n{\n  struct superblock sb;\n  initlock(&log.lock, \"log\");\n  readsb(dev, &sb);\n  log.start = sb.logstart;\n  log.size = sb.nlog;\n  log.dev = dev;\n  recover_from_log();\n}\n```\n\n1. 首先可以看到初始化函数从超级快当中获取了日志的起始块 `sb.logstart` 和 日志磁盘块数限制 `sb.nlog`。\n\n2. 然后调用了recover_from_log函数，在系统初始化阶段，尝试进行磁盘错误恢复，recover_from_log函数实现如下：\n\n    1. 调用read_head函数，读取前面拿到的日志起始块，日志起始块结构如下：\n        ```c\n        struct logheader {\n            int n;\n            int block[LOGSIZE];\n        };\n        ```\n        简单来说，成员n代表block数组的有效长度，而block数组，其实表示日志起始块之后的日志块 和 文件（磁盘）的数据块的映射关系。这点在介绍install_trans函数时会更有体会。\n    2. 调用install_trans函数，进行差错恢复，将上一次关机记录在日志块的没有提交完的数据重新提交。确保文件系统的一致性：\n        ```c\n        // Copy committed blocks from log to their home location\n        static void\n        install_trans(void)\n        {\n        int tail;\n\n        for (tail = 0; tail < log.lh.n; tail++) {\n            struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block\n            struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst\n            memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst\n            bwrite(dbuf);  // write dst to disk\n            brelse(lbuf);\n            brelse(dbuf);\n        }\n        }\n        ```\n        仔细阅读代码可以了解到，就是顺序将日志起始块后面的日志块读出，然后根据起始块提供的文件（磁盘）数据块映射数组，将日志块拷贝到文件（磁盘）的数据块当中。**并且同步到磁盘**\n    3. 将日志起始块的logheader::n改为0，意味着日志的清空，标志着事务的完成。这一步也就是本节最开头所谓的“特殊的提交记录”。\n\n综上所述，磁盘当中日志的结构如下图：\n\n![](./FileSystem/photo/filesystem/xv6_log_structure.drawio.png)\n\n### 日志层设计——日志的封装\n\n首先是日志写操作——log_write函数，xv6规定，所有文件的写操作，都使用log_write函数进行，并且log_write函数必须在begin_op函数和end_op函数之间调用。在进程每次写一些缓存块后都会调用log_write函数。该函数只做两件事：\n\n1. 将被修改的缓存块的块号记录到logheader.block数组当中。\n2. 将缓存块标记为脏。\n\n需要明确的是：进程对文件任何写操作都是基于被缓存到内存的缓存块。写操作开始并未同步到磁盘块。真正的同步操作是在commit函数当中进行。\n\n事务包装函数如下：\n\n```c\n// called at the start of each FS system call.\nvoid\nbegin_op(void)\n{\n  acquire(&log.lock);\n  while(1){\n    if(log.committing){\n      sleep(&log, &log.lock);\n    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){\n      // this op might exhaust log space; wait for commit.\n      sleep(&log, &log.lock);\n    } else {\n      log.outstanding += 1;\n      release(&log.lock);\n      break;\n    }\n  }\n}\n\n// called at the end of each FS system call.\n// commits if this was the last outstanding operation.\nvoid\nend_op(void)\n{\n  int do_commit = 0;\n\n  acquire(&log.lock);\n  log.outstanding -= 1;\n  if(log.committing)\n    panic(\"log.committing\");\n  if(log.outstanding == 0){\n    do_commit = 1;\n    log.committing = 1;\n  } else {\n    // begin_op() may be waiting for log space,\n    // and decrementing log.outstanding has decreased\n    // the amount of reserved space.\n    wakeup(&log);\n  }\n  release(&log.lock);\n\n  if(do_commit){\n    // call commit w/o holding locks, since not allowed\n    // to sleep with locks.\n    commit();\n    acquire(&log.lock);\n    log.committing = 0;\n    wakeup(&log);\n    release(&log.lock);\n  }\n}\n```\n\n仔细阅读begin_op和end_op函数的源码，可以了解到，**xv6允许多个进程在begin_op和end_op之间执行事务。但是，提交操作只能由最后一个执行完的进程执行，并且提交期间，其他要执行事务的进程都将被阻塞在begin_op函数。**假设存在A、B、C三个进程要执行一组写操作。ABC都调用begin_op函数，然后对缓存块进行修改。此时 `log.outstanding` 为3。而A、B的写操作很快执行完调用end_op因为`log.outstanding`非0而直接退出，只有C执行完后，`log.outstanding` 为0，才能执行提交操作。并且在执行提交操作期间，其他任何准备执行事务的进程都将阻塞在begin_op函数。这里体现了xv6文档当中提到的：任何时候只能有一个进程在一个会话之中，其他进程必须等待当前会话中的进程结束。因此同一时刻日志最多只记录一次会话。\n\nxv6 不允许并发会话，目的是为了避免下面几种问题。假设会话 X 把一个对 i 节点的修改写入了会话中。并发的会话 Y 从同一块中读出了另一个 i 节点，更新了它，把 i 节点块写入了日志并且提交。这就会导致可怕的后果：Y 的提交导致被 X 修改过的 i 节点块被写入磁盘，而 X 此时并没有提交它的修改。如果这时候发生崩溃会使得 X 的修改只应用了一部分而不是全部，从而打破会话是原子的这一性质。有一些复杂的办法可以解决这个问题，但 xv6 直接通过不允许并行的会话来回避这个问题。\n\ncommit函数实现如下：\n\n```c\nstatic void\ncommit()\n{\n  if (log.lh.n > 0) {\n    write_log();     // Write modified blocks from cache to log\n    write_head();    // Write header to disk -- the real commit\n    install_trans(); // Now install writes to home locations\n    log.lh.n = 0;\n    write_head();    // Erase the transaction from the log\n  }\n}\n```\n\n从注释当中可以直观了解到，干了如下4件事：\n\n> 1. 将被改动的文件缓存块**同步追加到日志（磁盘）块**当中。\n> 2. 更新日志（磁盘）起始块logheader磁盘结构。\n> 3. 将日志块同步到适合的文件（磁盘）数据块当中。\n> 4. 清空日志块。\n\nxv6 使用固定量的磁盘空间来保存日志。系统调用写入日志的块的总大小不能大于日志的总大小。所以源码当中，会有很多预防日志过大导致空间不足的处理措施。比如限制每个进程每次事务操作最大写数量，或者在空间不足时，阻塞进程，直到有足够可用空间被唤醒。\n\n## 虚拟文件系统实现层\n\n本小节将借Onix Minix文件系统的实现，解答虚拟文件神秘的面纱。在此之前，你一定对linux的文件系统有许多疑惑：\n\n- 为什么一个int类型的fd能代表文件？\n- 都说fd代表进程内核文件描述数组的下标，那么文件描述数组类型本身是什么？\n- 一块256G的磁盘，linux怎么做到让每个文件打开，能从0开始顺序读写，就好像每个文件都占用了独立的磁盘一样？\n- IO设备、网络套接字、管道等怎么被抽象成fd，可以使用统一的系统调用的？\n\n### i节点初步介绍\n\n这里从i节点作为切入。\n\ni 节点这个术语可以有两个的意思。（对于常规文件系统）它可以指的是磁盘上的记录文件类型、文件大小、数据块扇区号的数据结构。也可以指内存中的一个 i 节点代理，它包含了i节点（实体）描述符、文件系统类型、文件操作回调等。\n\n简单来说，一个i节点对应一个虚拟文件。并且，对于常规的文件系统，i节点分：内存结构、磁盘结构，这两种结构并不等同，内存i节点代理会引用磁盘上的i节点。\n\n超级快代理和i节点代理的内存结构，如下：\n\n```c\ntypedef struct super_t\n{\n    void *desc;           // 超级块描述符\n    struct buffer_t *buf; // 超级块描述符 buffer\n    dev_t dev;            // 设备号\n    u32 count;            // 引用计数\n    int type;             // 文件系统类型\n    size_t sector_size;   // 扇区大小\n    size_t block_size;    // 块大小\n    list_t inode_list;    // 使用中 inode 链表\n    inode_t *iroot;       // 根目录 inode\n    inode_t *imount;      // 安装到的 inode\n} super_t;\n\ntypedef struct inode_t\n{\n    list_node_t node; // 链表结点\n\n    void *desc; // inode 描述符（可能是 磁盘i节点、套接字结构体、管道结构体等。\n\n    union\n    {\n        struct buffer_t *buf; // inode 描述符对应 buffer\n        void *addr;           // pipe 缓冲地址\n    };\n\n    dev_t dev;  // 设备号\n    dev_t rdev; // 虚拟设备号\n\n    idx_t nr;     // i 节点号\n    size_t count; // 引用计数\n\n    time_t atime; // 访问时间\n    time_t mtime; // 修改时间\n    time_t ctime; // 创建时间\n\n    dev_t mount; // 安装设备\n\n    mode_t mode; // 文件模式\n    size_t size; // 文件大小\n    int type;    // 文件系统类型\n\n    int uid; // 用户 id\n    int gid; // 组 id\n\n    struct super_t *super;   // 超级块\n    struct fs_op_t *op;      // 文件系统操作\n    struct task_t *rxwaiter; // 读等待进程\n    struct task_t *txwaiter; // 写等待进程\n} inode_t;\n```\n\n对于inode_t::type字段，onix当中有如下可选值：\n\n```c\nenum\n{\n    FS_TYPE_NONE = 0,\n    FS_TYPE_PIPE,\n    FS_TYPE_SOCKET,\n    FS_TYPE_MINIX,\n    FS_TYPE_NUM,\n};\n```\n\n虚拟文件系统将所有的IO操作都抽象成了这样一个i节点——inode_t。这里主要提一下 `inode_t::desc` 这个成员，如果i节点对应文件的话（FS_TYPE_MINIX），inode_t::desc会被赋值成 `minix_inode_t` 也就是i节点在磁盘上的数据结构；如果i节点对应网络套接字（FS_TYPE_SOCKET），那么inode_t::desc会被赋值成 `socket_t`。如果i节点对应管道（FS_TYPE_PIPE），那么inode_t::desc会被赋值成 `fifo_t`。\n\n本文主要介绍FS_TYPE_MINIX类型的i节点。minix文件系统初始化函数会向数组 `fs_ops` 当中注册一组minix文件系统专用回调函数。\n\n```c\nstatic fs_op_t minix_op = {\n    minix_mkfs,\n    minix_super,\n\n    minix_open,\n    minix_close,\n\n    minix_read,\n    minix_write,\n    minix_truncate,\n\n    minix_stat,\n    minix_permission,\n\n    minix_namei,\n    minix_mkdir,\n    minix_rmdir,\n    minix_link,\n    minix_unlink,\n    minix_mknod,\n    minix_readdir,\n};\n\nvoid minix_init()\n{\n    fs_register_op(FS_TYPE_MINIX, &minix_op);\n}\n```\n\n如果需要实现新的文件系统，仿照minix，只需实现上面所列的必要回调函数即可。使用minix文件系统创建的i节点inode_t::op都会被赋值成minix_op。\n\n下面可以先了解一下minix文件系统在磁盘上的结构：\n\n![](./FileSystem/photo/filesystem/onix_fsstructureondisk.drawio.png)\n\n各字段起始位置和作用如下表：\n\n>|  | 起始位置 | 作用 |\n>| :-: | :-: | :-: |\n>| 超级块 | 块1 | 记录i节点位图所占块数、（磁盘数据块）逻辑块位图所占块数、第一个逻辑块号等解析文件系统的关键信息 |\n>| i节点位图 | 块2 | 管理磁盘i节点分配情况 |\n>| （磁盘数据块）逻辑块位图 | 块2 + super->imap_blocks | 管理磁盘数据块分配情况 |\n>| i节点 | 块2 + super->imap_blocks + super->zmap_blocks | 磁盘i节点数组 |\n>| （磁盘数据块）逻辑块 | minix_super_t::firstdatazone | 磁盘数据块数组 |\n\n### i节点的分配与释放\n\n上面提到，由于i节点在虚拟文件系统当中有两种存在形式，所以本小节i节点的分配与释放也是分为两种。当需要创建文件时我们需要分配一个i节点，当文件需要被删除（文件磁盘i节点引用计数减为零）时我们需要释放这一个i节点。\n\n首先对于磁盘i节点的分配与释放，磁盘i节点分配/释放的管理由磁盘上 i节点位图 和 磁盘i节点数组 共同管理，它们的起始位置在上小结已给出。所有的磁盘上的 i 节点都被统一存放在一个称为 i 节点数组的连续区域中。每一个 i 节点的大小都是一样的，所以对于一个给定的数字n，很容易找到磁盘上对应的 i 节点。事实上这个给定的数字就是操作系统中 i 节点的编号。\n\n磁盘上的 i 节点由结构体 `minix_inode_t` 定义。`mode` 域用来区分文件、目录和特殊文件。nlink 域用来记录指向了这一个 i 节点的目录项，这是用于判断一个 i 节点是否应该被释放的。size 域记录了文件的字节数。`zone` 数组用于这个文件的数据块的块号。在后面 **虚拟文件的打开/读写/关闭** 小结就会看到，每个文件采用 `zone` 数组管理文件数据的方式非常巧妙，该数组就是每个文件都能从0偏移开始读取和写入，看起来像多块磁盘的原因。\n\ni节点和超级快磁盘结构如下：\n\n```c\ntypedef struct minix_inode_t\n{\n    u16 mode;    // 文件类型和属性(rwx 位)\n    u16 uid;     // 用户id（文件拥有者标识符）\n    u32 size;    // 文件大小（字节数）\n    u32 mtime;   // 修改时间戳 这个时间戳应该用 UTC 时间，不然有瑕疵\n    u8 gid;      // 组id(文件拥有者所在的组)\n    u8 nlinks;   // 链接数（多少个文件目录项指向该i 节点）\n    u16 zone[9]; // 直接 (0-6)、间接(7)或双重间接 (8) 逻辑块号\n} minix_inode_t;\n\ntypedef struct minix_super_t\n{\n    u16 inodes;        // 节点数\n    u16 zones;         // 逻辑块数\n    u16 imap_blocks;   // i 节点位图所占用的数据块数\n    u16 zmap_blocks;   // 逻辑块位图所占用的数据块数\n    u16 firstdatazone; // 第一个数据逻辑块号\n    u16 log_zone_size; // log2(每逻辑块数据块数)\n    u32 max_size;      // 文件最大长度\n    u16 magic;         // 文件系统魔数\n} minix_super_t;\n```\n\n磁盘i节点分配/释放的核心函数是 `minix_ialloc` 和 `minix_ifree`。分配函数首先会从超级块当中定位i节点位图的起始位置和长度。然后遍历i节点位图，找到一个可用i节点编号，将位图置为true（占用）并返回。minix_ialloc只负责从磁盘上找到一个可用的i节点编号返回给调用者，其他的什么也不做。`minix_ifree` 就是 `minix_ialloc` 逆过程，将分配的i节点编号对应的位图置为false（可分配）。两函数代码如下：\n\n```c\n// 分配一个文件系统 inode\nidx_t minix_ialloc(super_t *super)\n{\n    buffer_t *buf = NULL;\n    idx_t bit = EOF;\n    bitmap_t map;\n\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    idx_t bidx = 2;\n    for (size_t i = 0; i < desc->imap_blocks; i++)\n    {\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        bitmap_make(&map, buf->data, BLOCK_BITS, i * BLOCK_BITS);\n        bit = bitmap_scan(&map, 1);\n        if (bit != EOF)\n        {\n            assert(bit < desc->inodes);\n            buf->dirty = true;\n            break;\n        }\n    }\n    brelse(buf); // todo 调试期间强同步\n    return bit;\n}\n\n// 释放一个文件系统 inode\nvoid minix_ifree(super_t *super, idx_t idx)\n{\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    assert(idx < desc->inodes);\n\n    buffer_t *buf;\n    bitmap_t map;\n\n    idx_t bidx = 2;\n    for (size_t i = 0; i < desc->imap_blocks; i++)\n    {\n        if (idx > BLOCK_BITS * (i + 1))\n        {\n            continue;\n        }\n\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        bitmap_make(&map, buf->data, BLOCK_BITS, i * BLOCK_BITS);\n        assert(bitmap_test(&map, idx));\n        bitmap_set(&map, idx, 0);\n        buf->dirty = true;\n        break;\n    }\n    brelse(buf); // todo 调试期间强同步\n}\n```\n\n调用者得到i节点编号后，可以通过 `iget` 函数**将i节点编号转为i节点代理**。它的逻辑是这样的，先尝试在现有内存i节点代理当中根据i节点编号查找i节点，如果查到了，就直接返回，否则调用 `get_free_inode` 函数先从空闲的i节点代理缓存当中获取一个空闲i节点代理，再将i节点编号转为磁盘i节点所在块号，然后将磁盘i节点所在磁盘块缓存到内存获取磁盘上的i节点，然后对空闲的i节点代理进行初始化。\n\ni节点代理的核心初始化步骤包括：\n\n>- 将inode_t::desc填充成 磁盘i节点缓存地址。\n>- inode::buf填充成 磁盘i节点所在块缓存地址，inode::buf指向 磁盘i节点所在块缓存地址 这样能保证 磁盘i节点所在块缓存 的引用计数非零，防止inode_t::desc所指向的磁盘i节点缓存地址 因磁盘块的lru算法被置换出内存而失效。\n>- 如果i节点对应的是IO设备，而非文件，将inode_t::rdev填充为minix_inode_t::zone[0]，对于设备文件，minix_inode_t::zone[0]表示IO设备的虚拟设备号。\n>- inode_t::super填充成所在设备的超级快。同一设备上的文件系统，超级快是相同的！\n>- inode_t::type设置成FS_TYPE_MINIX。\n>- 并且inode_t::op安装成FS_TYPE_MINIX对应的回调。\n\n核心代码如下：\n\n```c\n#define BLOCK_INODES (BLOCK_SIZE / sizeof(minix_inode_t))    // 1个磁盘块能容纳 inode的数量\n\n// 计算 inode nr 对应的块号\nstatic inline idx_t inode_block(minix_super_t *desc, idx_t nr) {\n    // inode 编号 从 1 开始\n    return 2 + desc->imap_blocks + desc->zmap_blocks + (nr - 1) / BLOCK_INODES;\n}\n\n// 将i节点编号转为i节点代理\nstatic inode_t *iget(dev_t dev, idx_t nr) {\n    inode_t *inode = find_inode(dev, nr);\n    if (inode)\n    {\n        inode->count++;\n        inode->atime = time();\n        return fit_inode(inode);\n    }\n\n    super_t *super = get_super(dev);\n    assert(super);\n\n    minix_super_t *desc = (minix_super_t *)super->desc;\n\n    assert(nr <= desc->inodes);\n\n    inode = get_free_inode();\n    inode->dev = dev;\n    inode->nr = nr;\n    inode->count++;\n\n    // 加入超级块 inode 链表\n    list_push(&super->inode_list, &inode->node);\n\n    idx_t block = inode_block(desc, inode->nr);\n    buffer_t *buf = bread(inode->dev, block);\n\n    inode->buf = buf;\n\n    // 将缓冲视为一个 inode 描述符数组，获取对应的指针；\n    inode->desc = &((minix_inode_t *)buf->data)[(inode->nr - 1) % BLOCK_INODES];\n    minix_inode_t *minode = (minix_inode_t *)inode->desc;\n\n    inode->rdev = minode->zone[0];\n\n    inode->mode = minode->mode;\n    inode->size = minode->size;\n    inode->super = super;\n\n    inode->type = FS_TYPE_MINIX;\n    inode->op = fs_get_op(FS_TYPE_MINIX);\n\n    return fit_inode(inode);\n}\n```\n\n与iget对立的是iput函数，该函数定义在onix-dev/src/fs/inode.c，函数iput用于将i节点代理进行释放，iput会借助 minix_close 函数，一旦inode_t::count成员减为零，就将inode::buf（磁盘i节点所在块缓存）释放，然后将i节点代理放回空闲缓存区。\n\n### 磁盘数据块的分配与释放\n\nonix当中，文件系统文件的数据存在于分散的磁盘数据块当中。文件使用磁盘上的i节点minix_inode_t::zone数组管理磁盘数据块。文件创建后，向里面不断顺序写入数据，一旦当前磁盘数据块写满了，文件系统就会调用 `minix_balloc` 函数给文件分配一块磁盘数据块。相反的，如果一个文件需要被删除，调用 `minix_bfree` 函数释放所有分配的磁盘数据块。磁盘块同样采用位图的方式去管理。\n\n磁盘数据块分配释放/器的原理和 磁盘i节点分配/释放器（`minix_ialloc` 和 `minix_ifree`）极其类似。磁盘数据块分配器首先会从超级块当中定位磁盘数据块位图的起始位置和长度。然后遍历磁盘数据块位图，找到一个可用磁盘数据块号，将位图置为true（占用）并返回。minix_ialloc只负责从磁盘上找到一个可用的磁盘数据块号返回给调用者，其他的什么也不做。`minix_bfree` 就是 `minix_balloc` 逆过程，将分配的磁盘数据块号对应的位图置为false（可分配）。\n\n代码如下：\n\n```c\n// 分配一个文件块\nidx_t minix_balloc(super_t *super)\n{\n    buffer_t *buf = NULL;\n    idx_t bit = EOF;\n    bitmap_t map;\n\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    idx_t bidx = 2 + desc->imap_blocks;\n\n    for (size_t i = 0; i < desc->zmap_blocks; i++)\n    {\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        // 将整个缓冲区作为位图\n        bitmap_make(&map, buf->data, BLOCK_SIZE, i * BLOCK_BITS + desc->firstdatazone - 1);\n\n        // 从位图中扫描一位\n        bit = bitmap_scan(&map, 1);\n        if (bit != EOF)\n        {\n            // 如果扫描成功，则 标记缓冲区脏，中止查找\n            assert(bit < desc->zones);\n            buf->dirty = true;\n            break;\n        }\n    }\n    brelse(buf); // todo 调试期间强同步\n    return bit;\n}\n\n// 释放一个文件块\nvoid minix_bfree(super_t *super, idx_t idx)\n{\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    assert(idx < desc->zones);\n\n    buffer_t *buf;\n    bitmap_t map;\n\n    idx_t bidx = 2 + desc->imap_blocks;\n\n    for (size_t i = 0; i < desc->zmap_blocks; i++)\n    {\n        // 跳过开始的块\n        if (idx > BLOCK_BITS * (i + 1))\n        {\n            continue;\n        }\n\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        // 将整个缓冲区作为位图\n        bitmap_make(&map, buf->data, BLOCK_SIZE, BLOCK_BITS * i + desc->firstdatazone - 1);\n\n        // 将 idx 对应的位图置位 0\n        assert(bitmap_test(&map, idx));\n        bitmap_set(&map, idx, 0);\n\n        // 标记缓冲区脏\n        buf->dirty = true;\n        break;\n    }\n    brelse(buf); // todo 调试期间强同步\n}\n```\n\n### 根文件系统的挂载\n\n在onix初始化阶段在使用文件系统之前，必须先对根目录进行挂载。我们使用系统调用 `open` 函数打开的文件时，需要传入路径作为参数，而想要通过路径找到最终文件的i节点，必经过根目录的i节点。任何路径的解析，都以根目录为基础的。所以，分析onix根目录的挂载流程是很重要的。\n\n根文件系统挂载触发点位于super_init函数：\n\n- super_init函数首先会初始化全局超级块表，为后续文件系统挂载做准备，每个超级块维护一个inode链表，用于管理该文件系统打开的文件节点，超级块表初始化完毕后，会调用mount_root函数。\n- mount_root函数首先获取磁盘第一个分区的虚拟设备控制句柄，然后从设备控制句柄当中获取设备号dev（方便读写），然后调用read_super函数获取dev设备的超级快。最后将**超级块和根目录i节点代理做绑定**，方便将路径解析为i节点。\n    ```c\n    // 挂载根文件系统\n    static void mount_root() {\n        LOGK(\"Mount root file system...\\n\");\n        // 假设主硬盘第一个分区是根文件系统\n        device_t *device = device_find(DEV_IDE_PART, 0);\n        assert(device);\n\n        // 读根文件系统超级块\n        root = read_super(device->dev);\n\n        // 超级快和根目录i节点代理做绑定。\n        root->imount = root->iroot;\n        root->imount->count++;\n\n        root->iroot->mount = device->dev;\n    }\n    ```\n- read_super函数首先会尝试使用设备号dev从超级快列表当中直接获取超级快，但由于系统刚启动，正处在初始化阶段，所以，必然失败。然后read_super函数会尝试从超级块列表当中获取一个空闲的超级快，然后调用minix_super函数对空闲超级快进行初始化。\n    ```c\n    // 读设备 dev 的超级块\n    super_t *read_super(dev_t dev) {\n        super_t *super = get_super(dev);\n        if (super) {\n            super->count++;\n            return super;\n        }\n\n        LOGK(\"Reading super block of device %d\\n\", dev);\n\n        // 获得空闲超级块\n        super = get_free_super();\n        super->count++;\n\n        for (size_t i = 1; i < FS_TYPE_NUM; i++) {\n            fs_op_t *op = fs_get_op(i);\n            if (!op)\n                continue;\n            // minix_super\n            if (op->super(dev, super) == EOK) {\n                return super;\n            }\n        }\n\n        put_super(super);\n        return NULL;\n    }\n    ```\n- minix_super函数实现较为简单，通过读取磁盘的 磁盘块1 （在前面的列出的磁盘分区结构图当中有列出，超级块位于1号磁盘块），将 磁盘超级快 读到内存当中，然后将磁盘超级块缓存填充到super_t::desc，当然为了避免磁盘超级块缓存被替换出磁盘，将磁盘超级快所在的磁盘块缓存填充给super_t::buf，最后调用 iget 函数获取根目录的i节点代理（按规定，根目录磁盘i节点的编号为1）。\n    ```c\n    static int minix_super(dev_t dev, super_t *super) {\n        // 读取超级块\n        buffer_t *buf = bread(dev, 1);\n        if (!buf)\n            return -EFSUNK;\n\n        assert(buf);\n        minix_super_t *desc = (minix_super_t *)buf->data;\n\n        if (desc->magic != MINIX1_MAGIC) {\n            brelse(buf);\n            return -EFSUNK;\n        }\n\n        super->buf = buf;\n        super->desc = desc;\n        super->dev = dev;\n        super->type = FS_TYPE_MINIX;\n        super->block_size = BLOCK_SIZE;\n        super->sector_size = SECTOR_SIZE;\n        super->iroot = iget(dev, 1);\n\n        return EOK;\n    }\n    ```\n\n注意 `super->iroot` 成员的初始化被放在了最后，这里是一定要放在最后。如果你深入阅读 iget 函数的代码就会发现 iget函数 里面需要用到超级块如下：\n\n```c\nstatic inode_t *iget(dev_t dev, idx_t nr) {\n    inode_t *inode = find_inode(dev, nr);\n    if (inode) {\n        inode->count++;\n        inode->atime = time();\n        return fit_inode(inode);\n    }\n\n    super_t *super = get_super(dev);\n    assert(super);\n\n    // ...\n    return fit_inode(inode);\n}\n```\n\n等等，我们正在初始化超级快，但是 iget 函数又用到了超级快，这样对吗？我的回答是没有任何毛病，因为 在minix_super超级快初始化函数当中最后一刻才调用了iget函数，此时超级快其实已经初始化的差不多了，并且iget函数内部也并没有用到 `super->iroot` 成员，所以逻辑并没有什么问题。\n\n### 虚拟文件的打开/关闭\n\nonix当中，使用open函数打开一个文件，如果要创建以一个文件，实际上使用的是带 `O_CREAT | O_TRUNC` 标志的open函数，我们只需要重点研究open系统调用 `sys_open` 的实现，伪代码如下：\n\n```c\nfd_t sys_open(char *filename, int flags, int mode) {\n    char *next;\n    inode_t *dir = NULL;\n\n    // 获取filename父目录i节点代理，并且，将最后的文件名填到next当中。\n    dir = named(filename, &next);\n\n    // 如果路径本身是目录（/a/b/）。跳过minix文件系统open回调\n    if (!*next) {\n        inode = dir;\n        dir->count++;\n        goto makeup;\n    }\n    // 调用minix文件系统open回调。打开/创建文件。\n    int ret = dir->op->open(dir, next, flags, mode, &inode);\n\n    // 从进程文件表（数组）当中获取一个空闲的文件描述符，并且初始化其元素file_t。\n    file_t *file;\n    fd_t fd = fd_get(&file);\n\n    file->inode = inode;\n    file->flags = flags;\n    file->count = 1;\n    file->offset = 0;\n    // 有追加参数就将file的偏移移到文件末尾。\n    if (flags & O_APPEND) {\n        file->offset = file->inode->size;\n    }\n\n    return fd;\n}\n```\n\n> 1. 调用named函数，获取filename父目录i节点代理，并且，将最后的文件名填到next当中。\n> 2. 如果路径本身是目录（/a/b/）。跳过minix文件系统open回调。进入4。\n> 3. 调用minix的open回调，打开/创建文件。获取文件的i节点代理。\n> 4. 从进程文件表（数组）当中获取一个空闲的文件描述符，并且初始化其元素file_t。\n> 5. 如果flags标志包含 `O_APPEND` ，将file的偏移移到文件末尾。\n\nnamed函数的作用就是根据路径找到文件父目录的i节点，并且将最后的文件名填到next当中。named函数代码稍微有些复杂，特别是这一段：\n\n```c\n// 获取 pathname 对应的父目录 inode\ninode_t *named(char *pathname, char **next) {\n\n    // ...\n    while (true) {\n        // 返回上一级目录且上一级目录是个挂载点\n        if (match_name(name, \"..\", next) && dir == dir->super->iroot) {\n            super_t *super = dir->super;\n            inode = super->imount;\n            inode->count++;\n            iput(dir);\n            dir = inode;\n        }\n    }\n    // ...\n}\n```\n\n如果路径 `name`（基于pathname经过预处理的路径） 解析到了 `..` 文件名并且（同一文件系统下）其父目录正好是设备的根节点，就会进入该if分支。因为linux当中一切皆文件的思想，（跨文件系统）父目录可能是作为子目录的挂载点而存在，导致父目录和子目录不在一个设备（文件系统）上。故我们在跨文件系统的情况下执行 `..` 目录回退操作时，必须执行这样一段 \"换根\" 代码。\n\n这段if换根代码强烈建议读者结合 `sys_mknod` 和 `sys_mount` 函数实现去理解。在onix当中（参考：onix-dev/src/fs/dev.c），挂载一个设备首先要使用 sys_mknod 系统调用为设备创建一个设备文件，然后，在根文件系统下寻找一个目录作为挂载点，最后使用 sys_mount 系统调用挂载设备。\n\n下面深入介绍一下onix当中如何实现设备挂载的：\n\n挂载点内部数据结构链接细节如下图：\n\n![](./FileSystem/photo/filesystem/onix_mount.drawio.png)\n\nsys_mknod会接收设备号作为参数。它的实现最终会调用minix_mknod函数，这会创建一个特殊的文件，我们称它为设备文件，然后文件的磁盘i节点当中zone数组只使用第一个元素，存放传入的设备号，在将磁盘i节点转成i节点代理过程当中，i节点代理的rdev成员就会被赋值成minode->zone[0]，minix_mknod伪代码如下：\n\n```c\nint minix_mknod(inode_t *dir, char *name, int mode, int dev) {\n    // ...\n    // 创建一个特殊的文件。\n    // ...\n    if (ISBLK(mode) || ISCHR(mode))\n        minode->zone[0] = dev;\n\n    // ...\n}\n```\n\nsys_mount函数负责将一个设备文件挂载到指定目录下。比如sd卡，一般来说，它的设备文件名为/dev/sdb1，当我们要访问sd卡时，需要执行命令 `mount /dev/sdb1 /mnt` 。**这里需要注意的是，sd卡所有的文件系统 和 我们的根目录所挂载的文件系统一定是两个独立的互不相干的两个文件系统，他们各自拥有自己独立、自包含的i节点编号空间。在同一个Linux系统下，SD卡上文件的i节点号与根文件系统下文件的i节点号即使数字相同，也绝对不会发生冲突。系统能够清晰地区分它们。** onix sys_mount函数实现伪代码如下：\n\n```c\nint sys_mount(char *devname, char *dirname, int flags) {\n    // 获取设备文件i节点代理\n    devinode = namei(devname);\n\n    // 获取挂载点i节点代理\n    dirinode = namei(dirname);\n\n    // 获取设备超级块\n    super = read_super(devinode->rdev);\n\n    // 设备超级快指向挂载点\n    super->imount = dirinode;\n\n    // 挂载点指向挂载的设备\n    dirinode->mount = devinode->rdev;\n    iput(devinode);\n    return EOK;\n}\n```\n\n核心逻辑如下：\n\n> 1. 获取设备文件i节点代理。\n> 2. 获取挂载点i节点代理。\n> 3. 获取设备超级块。\n> 4. 将设备超级块指向挂载点。\n> 5. 挂载点指向挂载的设备。\n\nsys_open当中核心函数还是中间调用的minix_open回调，它的伪代码如下：\n\n```c\nstatic int minix_open(inode_t *dir, char *name, int flags, int mode, inode_t **result) {\n    minix_dentry_t *entry = NULL;\n\n    // 在dir下尝试查找name文件，并将目录项存到entry。\n    buf = find_entry(dir, name, &next, &entry);\n    if (buf) {\n        // 如果找到了根据目录项将 i节点号转为i节点代理。iget函数是老朋友了，前面小结经常用到。\n        inode = iget(dir->dev, entry->nr);\n        assert(inode);\n        goto makeup;\n    } // 不存在\n\n    // 不带创建标志，返回文件不存在的错误。\n    if (!(flags & O_CREAT)) {\n        ret = -EEXIST;\n        return res;\n    }\n\n    // 向父目录当中添加名为name的文件项。并且返回其文件项缓存块地址，确保entry有效。\n    buf = add_entry(dir, name, &entry);\n\n    // 申请一个i节点号。\n    entry->nr = minix_ialloc(dir->super);\n\n    // 初始化磁盘i节点和i节点代理。\n    inode = new_inode(dir->dev, entry->nr);\n\nmakeup:\n    // 传给输出参数。\n    *result = inode;\n    return EOK;\n}\n```\n\n首先明确：sys_open调用minix_open，传入的name是单个文件名，dir是name文件的父目录i节点。\n\n> 1. 调用find_entry函数，首先在dir下尝试查找name文件，并将目录项存到entry。如果找到了，根据目录项将 i节点号转为i节点代理，并快进到 `makeup` 阶段。iget函数是老朋友了，前面小结经常用到。如果没找到，尝试去创建一个新文件。\n> 2. 检测是否带 `O_CREAT` 标志，不带标志就返回文件不存在的错误。\n> 3. 调用add_entry函数向父目录当中添加名为name的文件项。并且返回其文件项缓存块地址，确保entry有效。\n> 4. 申请一个i节点号。\n> 5. 初始化磁盘i节点和i节点代理。\n\n有关 `find_entry` 和 `add_entry` 函数，这两函数属于目录操作函数，在 **目录的操作** 小结将深入展开讲解。\n\n踪上，一个进程打开一个文件后，系统状态图如下：\n\n![](./FileSystem/photo/filesystem/onix_vfs_structure.drawio.png)\n\n### 虚拟文件的读/写\n\n如果说超级块是更高维度的能解析文件系统的磁盘结构，那么i节点其实可以理解成低维度的能解析文件的磁盘结构。\n\n在 **i节点的分配与释放** 小结已经列出过i节点的磁盘结构，但因为文章结构原因我们没有多费口舌去讲解它具体成员的作用。在本节，因为文件的操作是极度依赖i节点磁盘结构的。所以，下面用一张图片直观了解i节点的磁盘结构：\n\n![](./FileSystem/photo/filesystem/onix_minix_inode.drawio.png)\n\n一般的，i节点磁盘数据结构各个字段作用如下：\n\n| i节点字段名 | 作用 |\n| :-: | :-: |\n| minix_inode_t::mode | 文件类型和属性位，onix支持的文件类型包含：常规文件、目录文件、字符设备文件、块设备文件。文件屬性包含：读、写、可执行。 |\n| minix_inode_t::uid | 用户id，也即文件拥有者标识符 |\n| minix_inode_t::size | 文件大小（Byte） |\n| minix_inode_t::mtime | 最后修改的时间戳 |\n| minix_inode_t::gid | 用户所属组id |\n| minix_inode_t::nlinks | 链接数，表示有多少目录项指向该i节点 |\n| minix_inode_t::zone | 长度为9的uint16_t类型数组，前7个元素代表直接块，直接指向磁盘数据块，第8个元素为一级间接块，第9个元素为二级间接块 |\n\n磁盘i节点的设计非常精妙，前面部分存放文件属性，**后面的数组 `minix_inode_t::zone` 是你打开每一个文件，都能从0偏移开始读取的根本原因**。如果你有仔细研究过onix/xv6内存管理当中内存虚拟内存机制，你会发现，i节点对文件数据块的管理 和 虚拟内存的页表-页框-页目录机制思想一模一样。\n\n尽管物理上磁盘只有一块，i节点磁盘数据结构这种 直接块-间接块-双重间接块 机制让虚拟文件系统当中的每个文件都像独占一块磁盘一样，使（实际上）非连续空间连续化，可以从偏移0位置开始顺序读写数据。同时，在这种机制的加持下，更便于磁盘块的管理，增加零散磁盘块的利用率。\n\n有了上面i节点管理数据块的理论知识，下面让我们一步步了解 `sys_read` 和 `sys_write` 系统调用的实现。\n\n首先是 `sys_read` 函数，伪代码如下：\n\n```c\nint sys_read(fd_t fd, char *buf, int count) {\n    // ...\n    if ((ret = fd_check(fd, &file)) < EOK)\n        return ret;\n\n    inode_t *inode = file->inode;\n\n    int len = inode->op->read(inode, buf, count, file->offset);\n\n    if (len > 0)\n        file->offset += len;\n\n    return len;\n}\n```\n\n> 1. 首先将fd转换为文件表项 `file_t` 。\n> 2. 由文件表项获得文件的i节点代理。\n> 3. 调用 minix read 回调读取数据。\n\n直接来到了minix read 回调——minix_read。该函数根据传入的要读的数据长度len和文件偏移offset来来逐块读取数据。如下：\n\n```c\n// 从 inode 的 offset 处，读 len 个字节到 buf\nstatic int minix_read(inode_t *inode, char *data, int len, off_t offset) {\n    minix_inode_t *minode = (minix_inode_t *)inode->desc;\n    if (ISCHR(minode->mode)) {\n        assert(minode->zone[0]);\n        return device_read(minode->zone[0], data, len, 0, 0);\n    } else if (ISBLK(minode->mode)) {\n        assert(minode->zone[0]);\n        device_t *device = device_get(minode->zone[0]);\n        assert(len % BLOCK_SIZE == 0);\n        assert(device_read(minode->zone[0], data, len / BLOCK_SIZE, offset / BLOCK_SIZE, 0) == EOK);\n        return len;\n    }\n\n    assert(ISFILE(minode->mode) || ISDIR(minode->mode));\n\n    // 如果偏移量超过文件大小，返回 EOF\n    if (offset >= minode->size) {\n        return EOF;\n    }\n\n    // 开始读取的位置\n    u32 begin = offset;\n\n    // 剩余字节数\n    u32 left = MIN(len, minode->size - offset);\n    while (left) {\n        // 找到对应的文件便宜，所在文件块\n        idx_t nr = minix_bmap(inode, offset / BLOCK_SIZE, false);\n        assert(nr);\n\n        // 读取文件块缓冲\n        buffer_t *buf = bread(inode->dev, nr);\n\n        // 文件块中的偏移量\n        u32 start = offset % BLOCK_SIZE;\n\n        // 本次需要读取的字节数\n        u32 chars = MIN(BLOCK_SIZE - start, left);\n\n        // 更新 偏移量 和 剩余字节数\n        offset += chars;\n        left -= chars;\n\n        // 文件块中的指针\n        char *ptr = buf->data + start;\n\n        // 拷贝内容\n        memcpy(data, ptr, chars);\n\n        // 更新缓存位置\n        data += chars;\n\n        // 释放文件块缓冲\n        brelse(buf);\n    }\n\n    // 更新访问时间\n    inode->atime = time();\n\n    // 返回读取数量\n    return offset - begin;\n}\n```\n\n函数逻辑如下：\n\n> 1. 判断文件类型，如果是字符设备或者块设备，就根据minode->zone[0]获取到设备的设备号，然后调用虚拟设备回调函数，去读取数据并返回。如果是普通文件/目录，继续下面步骤。\n> 2. 普通文件的话，进入while循环，调用minix_bmap函数基于i节点的zone数组将offset转换为数据所在磁盘块。\n> 3. 获取磁盘块缓存。\n> 4. 读取 `MIN(BLOCK_SIZE - start, left)` 长的数据。\n> 5. 如果读取的数据不够len字节，重复2~4步骤。\n\n那么，minix_bmap函数是怎么实现的呢？onix对minix_bmap稍微有些复杂。这里附上我的想法，我觉得可以重用 [这才是计科之 Onix & XV6 源码分析（2、类Unix的内存管理）](https://blog.csdn.net/m0_52566365/article/details/139525258) 的做法。思想就是基于 i节点的磁盘结构图 对offset进行划分，如下：\n\n> - 如果 offset 在直接块覆盖范围内，直接通过zone数组读取数据块即可。\n> - 如果 offset 在一级间接块覆盖范围内。\n>   - 首先将offset减去直接块所能表示的最大地址。\n>   - 将offset看成虚拟磁盘地址，然后由 `(offset & 0x7FC00) >> 10` 公式获取虚拟磁盘地址高9位作为一级间接块的数组（元素为uint16_t）索引，然后取得磁盘数据块号后，将offset末尾的10位作为磁盘数据块内偏移。 获取块内偏移的公式：`offset & 0x3FF` ，最终获得到物理磁盘地址。\n> - 如果 offset 在二级间接块覆盖范围内。\n>   - 首先将offset减去直接块 + 一级间接块所能表示的最大地址。\n>   - 将offset看成虚拟磁盘地址，然后由 `(offset & 0xFF80000) >> 10` 公式获取虚拟磁盘地址高9位作为一级间接块的数组（元素为uint16_t）索引，取得二级间接块号后，根据公式 `(offset & 0x7FC00) >> 10` 得到二级间接块数组（元素同样为uint16_t）索引，取得磁盘数据块号后，将offset末尾的10位作为磁盘数据块内偏移。 获取块内偏移的公式：`offset & 0x3FF` ，最终获得到物理磁盘地址。\n\n但是， **由于onix规定zone数组元素类型为uint16_t，所以这决定了onix最大能表示的磁盘块号为2^16 - 1， 故onix的磁盘有效大小的上限为 64MB。** 当然，作为学习操作系统，我们就不必太过于精益求精。\n\n文件系统的写，是读的逆过程，代码逻辑极其相似，行文至此，篇幅过多，这里就不带着大家读代码了，建议读者亲自去扒一扒onix的源码。\n\n### 目录的操作\n\n最后就是文件系统目录的操作，这里主要讲解两个函数：`find_entry` 和 `add_entry`。面对目录，只需要记住一点，目录其实就是一个 文件内容被规定死的 普通文件。目录文件会存放一个个目录条目，onix当中目录条目数据结构如下：\n\n```c\n// 文件目录项结构\ntypedef struct minix_dentry_t\n{\n    u16 nr;              // i 节点\n    char name[NAME_LEN]; // 文件名\n} minix_dentry_t;\n```\n\n目录项图解如下：\n\n![](./FileSystem/photo/filesystem/onix_dentry.drawio.png)\n\n在onix当中，find_entry函数为了找到目标目录项会使用for循环遍历传进来的目录的所有目录项。\n\nadd_entry同样会遍历目录的目录项，直到找到一个 `nr` 成员为0的目录项，在onix当中，nr为0意味这该目录项未被占用。所以相应的，如果你想删除一个目录项，只需将对应的nr置为0即可。onix的minix_rmdir函数也正是这样做的。\n\n---\n\n**本章完结**","slug":"xv6/FileSystem","published":1,"updated":"2025-09-28T15:01:19.926Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9u0014q8ws9y7072z2","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>拖了这么久，终于到了最后一篇关于类unix源码分析的文章————文件系统。</p>\n<p>（偷偷告诉你，本篇博客起草于我即将从毕业以来第一家公司离职前一个星期（2025-9-16），忍着牙痛ing ing ing）。</p>\n<p>如你所见，文件系统完全值得另开一篇博文单独去记录它。这里为了方便，同样将Onix的文件系统和XV6的文件系统放一块进行记录。并且，Onix的文件系统确实更加规范和完善，而XV6的文件系统相对来说更加简洁。但值得一提的是，XV6文件系统实现了一个简单而确实又很重要的东西————基于写时日志的事务系统。这是Onix所没有的。</p>\n<p>linux的一切皆文件的伟大思想，将所有的IO行为（包括IO设备读写、pipe读写、进程读写）都抽象成文件。在本篇文章当中，我们将通过两个小型操作系统源码一一揭开linux文件系统的面纱。</p>\n<span id=\"more\"></span>\n\n<p>首先贴上XV6文件系统的模块方图：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio.png\"></p>\n<p>其次是Onix文件系统的模块方图：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio.png\"></p>\n<p>诈一看，你一定会认为XV6实现的文件系统比Onix的更复杂，实际上恰恰相反。尽管XV6实现了更多的模块，但是因为它教学系统的本质，每个模块的实现都以简单且精简为目的，没有为扩展性做任何多余操作。： ）读过的人表示非常干脆利落。</p>\n<p>反观Onix，为了适配 终端、串口、键盘、磁盘、软盘以及以后可能有的各种IO设备，根据他们的特点，抽象出了 <code>struct device_t</code> 结构体，分离出虚拟设备抽象层，将共有的io操作提取出来。为了统一文件系统的管理，抽象出了 <code>fs_op_t</code> 结构体。更贴近真实Linux操作系统的做法。具体细节将逐一解释。</p>\n<p>依据我阅读源码的习惯，下面就来自底向上逐步介绍文件系统的实现。<strong>以Onix文件系统为主。</strong></p>\n<h2 id=\"磁盘IO驱动层-虚拟设备实现层\"><a href=\"#磁盘IO驱动层-虚拟设备实现层\" class=\"headerlink\" title=\"磁盘IO驱动层 &amp; 虚拟设备实现层\"></a>磁盘IO驱动层 &amp; 虚拟设备实现层</h2><ul>\n<li><p>磁盘IO驱动层: 一句话概括该模块的作用：所谓磁盘IO驱动层，实际上就是操作系统当中，最底层的直接和磁盘设备打交道的代码。使用厂商规定的指令对磁盘设备按一定规则进行读写操作。</p>\n</li>\n<li><p>虚拟设备实现层: 对IO设备抽象出统一接口，并且针对磁盘设备访问，Onix还实现了经典的电梯算法。XV6当中虚拟设备实现层过于简单，这里以Onix为主进行深入讲解。</p>\n</li>\n</ul>\n<h3 id=\"对于XV6\"><a href=\"#对于XV6\" class=\"headerlink\" title=\"对于XV6\"></a>对于XV6</h3><p>XV6的磁盘IO驱动层可以分为两块：IO请求队列 和 磁盘IO驱动。实现可以参考文件：ide.c，IO请求队列的实现非常巧妙，其思想为：<strong>多个进程需要并发对一块磁盘进行IO，为了保证正确性，我们必须对并行操作串行化处理。让请求IO的进程入队。仅让位于队头的进行执行磁盘IO，其他进程休眠等待。当队头的进程执行完IO请求后出队列唤醒进程，下一个队头再进行IO操作。</strong> 如果你有看过LevelDB的源码，应该对这种思想非常熟悉，因为LevelDB的Write方法实现运用了同样的手法。参考：<a href=\"https://blog.csdn.net/m0_52566365/article/details/137910783\">LevelDB源码阅读笔记（1、整体架构）</a></p>\n<p>框图图如下：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_ide.drawio.png\"></p>\n<p>流程如下：</p>\n<p>首先对外暴露iderw接口。</p>\n<p><strong>iderw函数的逻辑：</strong></p>\n<blockquote>\n<ol>\n<li>上层调用对外暴露的磁盘操作接口 <code>iderw(struct buf *b)</code>。</li>\n<li>将请求push到IO队列尾部。</li>\n<li>如果本身就是队头，直接执行IO函数 <code>idestart</code>。</li>\n<li>非队头，<strong>阻塞直到 IO任务 被中断处理函数消费。</strong></li>\n</ol>\n</blockquote>\n<p><strong>磁盘中断处理函数ideintr的逻辑：</strong>（一旦磁盘准备好，就会触发中断）</p>\n<blockquote>\n<ol>\n<li>IO队列为空直接返回。</li>\n<li>移除并唤醒队头。</li>\n<li>如果IO队列还非空，<strong>为 IO任务 执行IO函数 <code>idestart</code>。</strong></li>\n</ol>\n</blockquote>\n<p>实现了简单的先来先服务(FCFS)调度</p>\n<h3 id=\"对于Onix\"><a href=\"#对于Onix\" class=\"headerlink\" title=\"对于Onix\"></a>对于Onix</h3><p>而Onix的磁盘IO驱动极其复杂，需要深入了解 IDE（Integrated Drive Electronics）硬盘控制器（IDE是一种常见的硬盘接口标准，也称为ATA（Advanced Technology Attachment））。感兴趣的可以先阅读一下XV6当中idestart函数，该函数使用几行代码实现了对磁盘设备的读写操作，然后深入去阅读Onix的磁盘IO驱动，代码路径：kernel&#x2F;ide.c，我的重心在文件系统的架构，所以Onix最底层的磁盘IO驱动就跳过了。笔者重点要讲的是Onix的虚拟设备实现层。</p>\n<p>Onix对虚拟设备的实现定义了如下虚拟设备控制结构体：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> name[NAMELEN];  <span class=\"comment\">// 设备名</span></span><br><span class=\"line\">    <span class=\"type\">int</span> type;            <span class=\"comment\">// 设备类型</span></span><br><span class=\"line\">    <span class=\"type\">int</span> subtype;         <span class=\"comment\">// 设备子类型</span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> dev;           <span class=\"comment\">// 设备号</span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> parent;        <span class=\"comment\">// 父设备号</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *ptr;           <span class=\"comment\">// 设备指针</span></span><br><span class=\"line\">    <span class=\"type\">list_t</span> request_list; <span class=\"comment\">// 块设备请求链表</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> direct;         <span class=\"comment\">// 磁盘寻道方向</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设备控制</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*ioctl)(<span class=\"type\">void</span> *dev, <span class=\"type\">int</span> cmd, <span class=\"type\">void</span> *args, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">    <span class=\"comment\">// 读设备</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*read)(<span class=\"type\">void</span> *dev, <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> count, <span class=\"type\">idx_t</span> idx, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">    <span class=\"comment\">// 写设备</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*write)(<span class=\"type\">void</span> *dev, <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> count, <span class=\"type\">idx_t</span> idx, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">&#125; <span class=\"type\">device_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>针对IO设备，抽象出了ioctl、read、write接口，这样，每种IO设备只需根据实际情况实现回调函数，任何IO设备都能被实例化成该结构体，并且我们即将讲解的minix（onix文件系统类型）文件系统也能更好的对IO设备做适配。</p>\n<p>Onix当中对IO设备的设备类型按读取的粒度分成了两类：字符设备（单字节）和块设备（1024为一快）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设备类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">device_type_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    DEV_NULL,  <span class=\"comment\">// 空设备</span></span><br><span class=\"line\">    DEV_CHAR,  <span class=\"comment\">// 字符设备</span></span><br><span class=\"line\">    DEV_BLOCK, <span class=\"comment\">// 块设备</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>设备子类型（也即具体的设备）就多了，比如：控制台、键盘、串口、磁盘、磁盘分区、软盘等。设备子类型定义在枚举类型 <code>enum device_subtype_t</code> 当中。</p>\n<p>Onix的设备抽象层，为了保证磁盘IO的正确性，其实也存在类似XV6的IO请求队列的设计，它的核心代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 块设备请求</span></span><br><span class=\"line\"><span class=\"type\">err_t</span> <span class=\"title function_\">device_request</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">void</span> *buf, u8 count, <span class=\"type\">idx_t</span> idx, <span class=\"type\">int</span> flags, u32 type)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">device_t</span> *device = device_get(dev);</span><br><span class=\"line\">    <span class=\"type\">request_t</span> *req = kmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"type\">request_t</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断列表是否为空</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> empty = list_empty(&amp;device-&gt;request_list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将请求插入链表</span></span><br><span class=\"line\">    list_insert_sort(&amp;device-&gt;request_list, &amp;req-&gt;node, element_node_offset(<span class=\"type\">request_t</span>, node, idx));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果列表不为空，则阻塞，因为已经有请求在处理了，等待处理完成；</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!empty)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        req-&gt;task = running_task();</span><br><span class=\"line\">        assert(task_block(req-&gt;task, <span class=\"literal\">NULL</span>, TASK_BLOCKED, TIMELESS) == EOK);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// do io</span></span><br><span class=\"line\">    <span class=\"type\">err_t</span> ret = do_request(req);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 跑一轮电梯算法，获取紧挨着req的下一个任务执行IO</span></span><br><span class=\"line\">    <span class=\"type\">request_t</span> *nextreq = request_nextreq(device, req);</span><br><span class=\"line\"></span><br><span class=\"line\">    list_remove(&amp;req-&gt;node);</span><br><span class=\"line\">    kfree(req);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 唤醒新队头</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextreq)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        assert(nextreq-&gt;task-&gt;magic == ONIX_MAGIC);</span><br><span class=\"line\">        task_unblock(nextreq-&gt;task, EOK);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Onix IO请求队列的逻辑更加清晰易懂：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_ide.drawio.png\"></p>\n<p>流程如下：</p>\n<blockquote>\n<ol>\n<li>进程调用磁盘IO接口 <code>device_request</code>。</li>\n<li>为IO请求分配一个句柄req。</li>\n<li>将req利用插入排序，升序插入请求队列。</li>\n<li>如果在该任务插入到队列前，队列非空，就当前阻塞进程。说明已经有进程在执行IO任务。</li>\n<li>如果在该任务插入到队列前，队列为空，由当前进程执行IO操作。</li>\n<li>依据电梯算法，获取到紧挨着req的下一个IO请求任务reqnext。</li>\n<li>从请求队列当中移除req。</li>\n<li>唤醒reqnext进程。注意可以确定的是，在请求队列当中只有一个进程是活跃状态其他进程都处于阻塞状态，所以在reqnext此前必定为阻塞状态，在这里我们需要唤醒它。</li>\n</ol>\n</blockquote>\n<p>Onix实现了比XV6更高效的磁盘调度算法——电梯算法。电梯算法能有效避免饥饿现象，比简单的先来先服务（FCFS）更高效，减少了磁头移动距离，能够有效平衡响应时间和吞吐量。</p>\n<p>电梯算法的工作原理：<strong>磁头（电梯）沿一个方向移动（比如向上），处理该方向上所有的请求。到达该方向的最后一个请求后，改变方向（向下），处理反方向上的请求。如此往复循环，就像电梯在楼层间上下运行一样。</strong></p>\n<p>Onix电梯算法实现函数request_nextreq如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获得下一个请求</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">request_t</span> *<span class=\"title function_\">request_nextreq</span><span class=\"params\">(<span class=\"type\">device_t</span> *device, <span class=\"type\">request_t</span> *req)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">list_t</span> *<span class=\"built_in\">list</span> = &amp;device-&gt;request_list;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (device-&gt;direct == DIRECT_UP &amp;&amp; req-&gt;node.next == &amp;<span class=\"built_in\">list</span>-&gt;tail) &#123;</span><br><span class=\"line\">        device-&gt;direct = DIRECT_DOWN;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (device-&gt;direct == DIRECT_DOWN &amp;&amp; req-&gt;node.prev == &amp;<span class=\"built_in\">list</span>-&gt;head) &#123;</span><br><span class=\"line\">        device-&gt;direct = DIRECT_UP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">void</span> *next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (device-&gt;direct == DIRECT_UP) &#123;</span><br><span class=\"line\">        next = req-&gt;node.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        next = req-&gt;node.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == &amp;<span class=\"built_in\">list</span>-&gt;head || next == &amp;<span class=\"built_in\">list</span>-&gt;tail) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> element_entry(<span class=\"type\">request_t</span>, node, next);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"磁盘块缓存层\"><a href=\"#磁盘块缓存层\" class=\"headerlink\" title=\"磁盘块缓存层\"></a>磁盘块缓存层</h2><p>OS对磁盘的任何访问都是基于块的，XV6当中，一个磁盘块的大小为512字节，Onix当中，默认为1024字节。如果我们每次访问文件都直接从磁盘上去读取，显然大部分时间都被浪费在磁盘IO上。所以，为了提高效率，内存（高速设备）和磁盘（低速设备）之间必然需要缓存层。本小节以Onix的代码为主。代码参考：onix-dev&#x2F;src&#x2F;kernel&#x2F;buffer.c</p>\n<p>缓存层主要作用是：在在有限的内存当中，<strong>缓存访问频率最高的部分磁盘块</strong>。那么我们如何定性一个磁盘块的访问频率是高还是低呢？这就得靠大名鼎鼎的LRU算法。在CMU15445实验1当中可以学习到更高级的LRU算法——LRU-K算法、在LevelDB当中.sst文件结构的缓存也是用到了LRU算法。Onix实现的磁盘块缓存层使用的是最朴素的LRU算法。</p>\n<p>本节简单介绍一下Onix当中LRU算法运行逻辑。</p>\n<p>首先假设LRU相关数据结构的初始状态如下图：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache.drawio.png\"></p>\n<p>如图所示，LRU算法涉及的基本数据结构包括：哈希表和链表。</p>\n<ul>\n<li>空闲链表 <code>idle_list</code>:  一旦OS对缓存块的引用为0，缓存块就会被放入到空闲链表。当OS需要读取一块没有缓存到内存的磁盘块时，就会触发LRU替换策略，LRU替换策略会将空闲链表当中最久未被访问过的缓存块写回磁盘，并且将缓存块的内容覆盖成新的磁盘块。空闲链表的插入和删除的逻辑非常重要，LRU替换策略实现的关键。</li>\n<li>哈希表: 记录已经缓存的磁盘块。用于快速查找缓存的磁盘块。</li>\n</ul>\n<p>磁盘块的读取：</p>\n<ul>\n<li><p>有被缓存到内存（这里假设要读 <code>block1</code>）：</p>\n<ol>\n<li>根据哈希算法 <code> (设备号 ^ 块号) % 哈希表长度</code> 获取block1的所在哈希数组的位置，这里block1计算所得哈希数组索引为0。</li>\n<li>遍历链表，得到buffer1。</li>\n<li>将buffer1的引用计数加一。</li>\n<li>从idle_list当中移除buffer1，防止缓存块被替换出磁盘。</li>\n</ol>\n<p>  最终，结构如下：<br>  <img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio.png\"></p>\n</li>\n<li><p>没有被缓存到内存（这里假设要读 <code>block4</code>）：</p>\n<ol>\n<li>基于idle_list执行LRU替换策略。从idle_list可以了解到，idle_list的最后一个元素即为我们需要的 最久未被访问过的缓存块。也就是本节最开始所放图片当中的buffer3。</li>\n<li>将buffer3写回磁盘（如果标记为脏）。并从哈希表当中去除buffer3。</li>\n<li>将block4读到buffer3。</li>\n<li>根据哈希算法，计算block4所在哈希表的位置。这里假设计算block4的哈希值为1，并将block4插入到哈希表。</li>\n</ol>\n<p>  最终，结构如下：<br>  <img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache2.drawio.png\"></p>\n</li>\n</ul>\n<p>磁盘块的释放：</p>\n<ol>\n<li><p>假设，现在要释放buffer4，将缓存块的引用计数减一。</p>\n</li>\n<li><p>当缓存块引用计数变为0时，将缓存块挂到idle_list开头。这样可以确保idle_list当中缓冲块从左到右，最后一次访问时间越来越长。</p>\n<p> 最终，结构如下：<br> <img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache3.drawio.png\"></p>\n</li>\n</ol>\n<h2 id=\"事务层（日志层）\"><a href=\"#事务层（日志层）\" class=\"headerlink\" title=\"事务层（日志层）\"></a>事务层（日志层）</h2><h3 id=\"日志层简介\"><a href=\"#日志层简介\" class=\"headerlink\" title=\"日志层简介\"></a>日志层简介</h3><p>事务层是XV6所拥有的模块，在Onix当中并不存在，所以，本节会以XV6为主进行叙述。在XV6的文档当中，将事务层称为日志层。不管是日志层还是事务层，作用都是一样的。<strong>旨在实现错误恢复</strong> 的机制，保证磁盘上文件系统的一致性。</p>\n<p>依我的理解，其实linux文件系统本身就是一个通用数据库。像mysql、oracle、leveldb等数据库存在一些共有问题（包括：一致性、错误恢复等问题），解决问题的思想或多或少都借鉴linux的文件系统的实现。</p>\n<p>文件系统设计中最有趣的问题之一就是错误恢复，产生这样的问题是因为大多数的文件系统都涉及到对磁盘多次的写操作，如果在写操作的过程当中系统崩溃了，就会使得磁盘上的文件系统处于不一致的状态中。举例来说，根据写的顺序的不同，上述错误可能会导致一个目录项指向一个空闲的 i 节点，或者产生一个已被分配但是未被引用的块。后一种情况相对来说好一些，但在前一种情况中，目录项指向了一个空闲的 i 节点，重启之后就会导致非常严重的问题。</p>\n<p>xv6 通过简单的日志系统来解决文件操作过程当中崩溃所导致的问题。一个系统调用并不直接导致对磁盘上文件系统的写操作，相反，他会把一个对磁盘写操作的描述包装成一个日志写在磁盘中。当系统调用把所有的写操作都写入了日志，它就会写一个特殊的提交记录到磁盘上，代表一次完整的操作。从那时起，系统调用就会把日志中的数据写入磁盘文件系统的数据结构中。在那些写操作都成功完成后，系统调用就会删除磁盘上的日志文件。</p>\n<p>为什么日志可以解决文件系统操作中出现的崩溃呢？如果崩溃发生在操作提交之前，那么磁盘上的日志文件就不会被标记为已完成，恢复系统的代码就会忽视它，磁盘的状态正如这个操作从未执行过一样。如果是在操作提交之后崩溃的，恢复程序会重演所有的写操作，可能会重复之前已经进行了的对磁盘文件系统的写操作。在任何一种情况下，日志文件都使得磁盘操作对于系统崩溃来说是原子操作：在恢复之后，要么所有的写操作都完成了，要么一个写操作都没有完成。</p>\n<h3 id=\"日志层设计——日志的磁盘结构\"><a href=\"#日志层设计——日志的磁盘结构\" class=\"headerlink\" title=\"日志层设计——日志的磁盘结构\"></a>日志层设计——日志的磁盘结构</h3><p>首先，这里可以放上一张XV6当中文件系统在磁盘上的结构图：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_fsstructureondisk.png\"></p>\n<p>可以直观看到，我们的日志信息被放在磁盘分区最末尾的位置。</p>\n<p>然后，你需要感到疑惑的是：那么末尾的日志信息具体的内部结构是啥？要弄清这个问题，就需要我们深入查看xv6的代码了，日志层实现代码位于log.c文件，我们直接来到initlog函数的实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">logheader</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> n;</span><br><span class=\"line\">  <span class=\"type\">int</span> block[LOGSIZE];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">log</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">spinlock</span> <span class=\"title\">lock</span>;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> start;</span><br><span class=\"line\">  <span class=\"type\">int</span> size;</span><br><span class=\"line\">  <span class=\"type\">int</span> outstanding; <span class=\"comment\">// how many FS sys calls are executing.</span></span><br><span class=\"line\">  <span class=\"type\">int</span> committing;  <span class=\"comment\">// in commit(), please wait.</span></span><br><span class=\"line\">  <span class=\"type\">int</span> dev;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">logheader</span> <span class=\"title\">lh</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">log</span> <span class=\"title\">log</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">initlog</span><span class=\"params\">(<span class=\"type\">int</span> dev)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">superblock</span> <span class=\"title\">sb</span>;</span></span><br><span class=\"line\">  initlock(&amp;<span class=\"built_in\">log</span>.lock, <span class=\"string\">&quot;log&quot;</span>);</span><br><span class=\"line\">  readsb(dev, &amp;sb);</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.start = sb.logstart;</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.size = sb.nlog;</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.dev = dev;</span><br><span class=\"line\">  recover_from_log();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>首先可以看到初始化函数从超级快当中获取了日志的起始块 <code>sb.logstart</code> 和 日志磁盘块数限制 <code>sb.nlog</code>。</p>\n</li>\n<li><p>然后调用了recover_from_log函数，在系统初始化阶段，尝试进行磁盘错误恢复，recover_from_log函数实现如下：</p>\n<ol>\n<li>调用read_head函数，读取前面拿到的日志起始块，日志起始块结构如下： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">logheader</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"type\">int</span> block[LOGSIZE];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n 简单来说，成员n代表block数组的有效长度，而block数组，其实表示日志起始块之后的日志块 和 文件（磁盘）的数据块的映射关系。这点在介绍install_trans函数时会更有体会。</li>\n<li>调用install_trans函数，进行差错恢复，将上一次关机记录在日志块的没有提交完的数据重新提交。确保文件系统的一致性： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copy committed blocks from log to their home location</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">install_trans</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> tail;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (tail = <span class=\"number\">0</span>; tail &lt; <span class=\"built_in\">log</span>.lh.n; tail++) &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> *<span class=\"title\">lbuf</span> =</span> bread(<span class=\"built_in\">log</span>.dev, <span class=\"built_in\">log</span>.start+tail+<span class=\"number\">1</span>); <span class=\"comment\">// read log block</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> *<span class=\"title\">dbuf</span> =</span> bread(<span class=\"built_in\">log</span>.dev, <span class=\"built_in\">log</span>.lh.block[tail]); <span class=\"comment\">// read dst</span></span><br><span class=\"line\">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class=\"comment\">// copy block to dst</span></span><br><span class=\"line\">    bwrite(dbuf);  <span class=\"comment\">// write dst to disk</span></span><br><span class=\"line\">    brelse(lbuf);</span><br><span class=\"line\">    brelse(dbuf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n 仔细阅读代码可以了解到，就是顺序将日志起始块后面的日志块读出，然后根据起始块提供的文件（磁盘）数据块映射数组，将日志块拷贝到文件（磁盘）的数据块当中。<strong>并且同步到磁盘</strong></li>\n<li>将日志起始块的logheader::n改为0，意味着日志的清空，标志着事务的完成。这一步也就是本节最开头所谓的“特殊的提交记录”。</li>\n</ol>\n</li>\n</ol>\n<p>综上所述，磁盘当中日志的结构如下图：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio.png\"></p>\n<h3 id=\"日志层设计——日志的封装\"><a href=\"#日志层设计——日志的封装\" class=\"headerlink\" title=\"日志层设计——日志的封装\"></a>日志层设计——日志的封装</h3><p>首先是日志写操作——log_write函数，xv6规定，所有文件的写操作，都使用log_write函数进行，并且log_write函数必须在begin_op函数和end_op函数之间调用。在进程每次写一些缓存块后都会调用log_write函数。该函数只做两件事：</p>\n<ol>\n<li>将被修改的缓存块的块号记录到logheader.block数组当中。</li>\n<li>将缓存块标记为脏。</li>\n</ol>\n<p>需要明确的是：进程对文件任何写操作都是基于被缓存到内存的缓存块。写操作开始并未同步到磁盘块。真正的同步操作是在commit函数当中进行。</p>\n<p>事务包装函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// called at the start of each FS system call.</span></span><br><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">begin_op</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  acquire(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.committing)&#123;</span><br><span class=\"line\">      sleep(&amp;<span class=\"built_in\">log</span>, &amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.lh.n + (<span class=\"built_in\">log</span>.outstanding+<span class=\"number\">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// this op might exhaust log space; wait for commit.</span></span><br><span class=\"line\">      sleep(&amp;<span class=\"built_in\">log</span>, &amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">log</span>.outstanding += <span class=\"number\">1</span>;</span><br><span class=\"line\">      release(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// called at the end of each FS system call.</span></span><br><span class=\"line\"><span class=\"comment\">// commits if this was the last outstanding operation.</span></span><br><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">end_op</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> do_commit = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  acquire(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.outstanding -= <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.committing)</span><br><span class=\"line\">    panic(<span class=\"string\">&quot;log.committing&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.outstanding == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    do_commit = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">log</span>.committing = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// begin_op() may be waiting for log space,</span></span><br><span class=\"line\">    <span class=\"comment\">// and decrementing log.outstanding has decreased</span></span><br><span class=\"line\">    <span class=\"comment\">// the amount of reserved space.</span></span><br><span class=\"line\">    wakeup(&amp;<span class=\"built_in\">log</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  release(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(do_commit)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// call commit w/o holding locks, since not allowed</span></span><br><span class=\"line\">    <span class=\"comment\">// to sleep with locks.</span></span><br><span class=\"line\">    commit();</span><br><span class=\"line\">    acquire(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">    <span class=\"built_in\">log</span>.committing = <span class=\"number\">0</span>;</span><br><span class=\"line\">    wakeup(&amp;<span class=\"built_in\">log</span>);</span><br><span class=\"line\">    release(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>仔细阅读begin_op和end_op函数的源码，可以了解到，<strong>xv6允许多个进程在begin_op和end_op之间执行事务。但是，提交操作只能由最后一个执行完的进程执行，并且提交期间，其他要执行事务的进程都将被阻塞在begin_op函数。</strong>假设存在A、B、C三个进程要执行一组写操作。ABC都调用begin_op函数，然后对缓存块进行修改。此时 <code>log.outstanding</code> 为3。而A、B的写操作很快执行完调用end_op因为<code>log.outstanding</code>非0而直接退出，只有C执行完后，<code>log.outstanding</code> 为0，才能执行提交操作。并且在执行提交操作期间，其他任何准备执行事务的进程都将阻塞在begin_op函数。这里体现了xv6文档当中提到的：任何时候只能有一个进程在一个会话之中，其他进程必须等待当前会话中的进程结束。因此同一时刻日志最多只记录一次会话。</p>\n<p>xv6 不允许并发会话，目的是为了避免下面几种问题。假设会话 X 把一个对 i 节点的修改写入了会话中。并发的会话 Y 从同一块中读出了另一个 i 节点，更新了它，把 i 节点块写入了日志并且提交。这就会导致可怕的后果：Y 的提交导致被 X 修改过的 i 节点块被写入磁盘，而 X 此时并没有提交它的修改。如果这时候发生崩溃会使得 X 的修改只应用了一部分而不是全部，从而打破会话是原子的这一性质。有一些复杂的办法可以解决这个问题，但 xv6 直接通过不允许并行的会话来回避这个问题。</p>\n<p>commit函数实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">commit</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">log</span>.lh.n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    write_log();     <span class=\"comment\">// Write modified blocks from cache to log</span></span><br><span class=\"line\">    write_head();    <span class=\"comment\">// Write header to disk -- the real commit</span></span><br><span class=\"line\">    install_trans(); <span class=\"comment\">// Now install writes to home locations</span></span><br><span class=\"line\">    <span class=\"built_in\">log</span>.lh.n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    write_head();    <span class=\"comment\">// Erase the transaction from the log</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从注释当中可以直观了解到，干了如下4件事：</p>\n<blockquote>\n<ol>\n<li>将被改动的文件缓存块<strong>同步追加到日志（磁盘）块</strong>当中。</li>\n<li>更新日志（磁盘）起始块logheader磁盘结构。</li>\n<li>将日志块同步到适合的文件（磁盘）数据块当中。</li>\n<li>清空日志块。</li>\n</ol>\n</blockquote>\n<p>xv6 使用固定量的磁盘空间来保存日志。系统调用写入日志的块的总大小不能大于日志的总大小。所以源码当中，会有很多预防日志过大导致空间不足的处理措施。比如限制每个进程每次事务操作最大写数量，或者在空间不足时，阻塞进程，直到有足够可用空间被唤醒。</p>\n<h2 id=\"虚拟文件系统实现层\"><a href=\"#虚拟文件系统实现层\" class=\"headerlink\" title=\"虚拟文件系统实现层\"></a>虚拟文件系统实现层</h2><p>本小节将借Onix Minix文件系统的实现，解答虚拟文件神秘的面纱。在此之前，你一定对linux的文件系统有许多疑惑：</p>\n<ul>\n<li>为什么一个int类型的fd能代表文件？</li>\n<li>都说fd代表进程内核文件描述数组的下标，那么文件描述数组类型本身是什么？</li>\n<li>一块256G的磁盘，linux怎么做到让每个文件打开，能从0开始顺序读写，就好像每个文件都占用了独立的磁盘一样？</li>\n<li>IO设备、网络套接字、管道等怎么被抽象成fd，可以使用统一的系统调用的？</li>\n</ul>\n<h3 id=\"i节点初步介绍\"><a href=\"#i节点初步介绍\" class=\"headerlink\" title=\"i节点初步介绍\"></a>i节点初步介绍</h3><p>这里从i节点作为切入。</p>\n<p>i 节点这个术语可以有两个的意思。（对于常规文件系统）它可以指的是磁盘上的记录文件类型、文件大小、数据块扇区号的数据结构。也可以指内存中的一个 i 节点代理，它包含了i节点（实体）描述符、文件系统类型、文件操作回调等。</p>\n<p>简单来说，一个i节点对应一个虚拟文件。并且，对于常规的文件系统，i节点分：内存结构、磁盘结构，这两种结构并不等同，内存i节点代理会引用磁盘上的i节点。</p>\n<p>超级快代理和i节点代理的内存结构，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">super_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *desc;           <span class=\"comment\">// 超级块描述符</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buffer_t</span> *<span class=\"title\">buf</span>;</span> <span class=\"comment\">// 超级块描述符 buffer</span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> dev;            <span class=\"comment\">// 设备号</span></span><br><span class=\"line\">    u32 count;            <span class=\"comment\">// 引用计数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> type;             <span class=\"comment\">// 文件系统类型</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> sector_size;   <span class=\"comment\">// 扇区大小</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> block_size;    <span class=\"comment\">// 块大小</span></span><br><span class=\"line\">    <span class=\"type\">list_t</span> inode_list;    <span class=\"comment\">// 使用中 inode 链表</span></span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *iroot;       <span class=\"comment\">// 根目录 inode</span></span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *imount;      <span class=\"comment\">// 安装到的 inode</span></span><br><span class=\"line\">&#125; <span class=\"type\">super_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">list_node_t</span> node; <span class=\"comment\">// 链表结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">void</span> *desc; <span class=\"comment\">// inode 描述符（可能是 磁盘i节点、套接字结构体、管道结构体等。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buffer_t</span> *<span class=\"title\">buf</span>;</span> <span class=\"comment\">// inode 描述符对应 buffer</span></span><br><span class=\"line\">        <span class=\"type\">void</span> *addr;           <span class=\"comment\">// pipe 缓冲地址</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> dev;  <span class=\"comment\">// 设备号</span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> rdev; <span class=\"comment\">// 虚拟设备号</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> nr;     <span class=\"comment\">// i 节点号</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> count; <span class=\"comment\">// 引用计数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">time_t</span> atime; <span class=\"comment\">// 访问时间</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span> mtime; <span class=\"comment\">// 修改时间</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span> ctime; <span class=\"comment\">// 创建时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> mount; <span class=\"comment\">// 安装设备</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">mode_t</span> mode; <span class=\"comment\">// 文件模式</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size; <span class=\"comment\">// 文件大小</span></span><br><span class=\"line\">    <span class=\"type\">int</span> type;    <span class=\"comment\">// 文件系统类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> uid; <span class=\"comment\">// 用户 id</span></span><br><span class=\"line\">    <span class=\"type\">int</span> gid; <span class=\"comment\">// 组 id</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">super_t</span> *<span class=\"title\">super</span>;</span>   <span class=\"comment\">// 超级块</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fs_op_t</span> *<span class=\"title\">op</span>;</span>      <span class=\"comment\">// 文件系统操作</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_t</span> *<span class=\"title\">rxwaiter</span>;</span> <span class=\"comment\">// 读等待进程</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_t</span> *<span class=\"title\">txwaiter</span>;</span> <span class=\"comment\">// 写等待进程</span></span><br><span class=\"line\">&#125; <span class=\"type\">inode_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>对于inode_t::type字段，onix当中有如下可选值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    FS_TYPE_NONE = <span class=\"number\">0</span>,</span><br><span class=\"line\">    FS_TYPE_PIPE,</span><br><span class=\"line\">    FS_TYPE_SOCKET,</span><br><span class=\"line\">    FS_TYPE_MINIX,</span><br><span class=\"line\">    FS_TYPE_NUM,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>虚拟文件系统将所有的IO操作都抽象成了这样一个i节点——inode_t。这里主要提一下 <code>inode_t::desc</code> 这个成员，如果i节点对应文件的话（FS_TYPE_MINIX），inode_t::desc会被赋值成 <code>minix_inode_t</code> 也就是i节点在磁盘上的数据结构；如果i节点对应网络套接字（FS_TYPE_SOCKET），那么inode_t::desc会被赋值成 <code>socket_t</code>。如果i节点对应管道（FS_TYPE_PIPE），那么inode_t::desc会被赋值成 <code>fifo_t</code>。</p>\n<p>本文主要介绍FS_TYPE_MINIX类型的i节点。minix文件系统初始化函数会向数组 <code>fs_ops</code> 当中注册一组minix文件系统专用回调函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">fs_op_t</span> minix_op = &#123;</span><br><span class=\"line\">    minix_mkfs,</span><br><span class=\"line\">    minix_super,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_open,</span><br><span class=\"line\">    minix_close,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_read,</span><br><span class=\"line\">    minix_write,</span><br><span class=\"line\">    minix_truncate,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_stat,</span><br><span class=\"line\">    minix_permission,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_namei,</span><br><span class=\"line\">    minix_mkdir,</span><br><span class=\"line\">    minix_rmdir,</span><br><span class=\"line\">    minix_link,</span><br><span class=\"line\">    minix_unlink,</span><br><span class=\"line\">    minix_mknod,</span><br><span class=\"line\">    minix_readdir,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">minix_init</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    fs_register_op(FS_TYPE_MINIX, &amp;minix_op);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果需要实现新的文件系统，仿照minix，只需实现上面所列的必要回调函数即可。使用minix文件系统创建的i节点inode_t::op都会被赋值成minix_op。</p>\n<p>下面可以先了解一下minix文件系统在磁盘上的结构：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio.png\"></p>\n<p>各字段起始位置和作用如下表：</p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">起始位置</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">超级块</td>\n<td align=\"center\">块1</td>\n<td align=\"center\">记录i节点位图所占块数、（磁盘数据块）逻辑块位图所占块数、第一个逻辑块号等解析文件系统的关键信息</td>\n</tr>\n<tr>\n<td align=\"center\">i节点位图</td>\n<td align=\"center\">块2</td>\n<td align=\"center\">管理磁盘i节点分配情况</td>\n</tr>\n<tr>\n<td align=\"center\">（磁盘数据块）逻辑块位图</td>\n<td align=\"center\">块2 + super-&gt;imap_blocks</td>\n<td align=\"center\">管理磁盘数据块分配情况</td>\n</tr>\n<tr>\n<td align=\"center\">i节点</td>\n<td align=\"center\">块2 + super-&gt;imap_blocks + super-&gt;zmap_blocks</td>\n<td align=\"center\">磁盘i节点数组</td>\n</tr>\n<tr>\n<td align=\"center\">（磁盘数据块）逻辑块</td>\n<td align=\"center\">minix_super_t::firstdatazone</td>\n<td align=\"center\">磁盘数据块数组</td>\n</tr>\n</tbody></table>\n</blockquote>\n<h3 id=\"i节点的分配与释放\"><a href=\"#i节点的分配与释放\" class=\"headerlink\" title=\"i节点的分配与释放\"></a>i节点的分配与释放</h3><p>上面提到，由于i节点在虚拟文件系统当中有两种存在形式，所以本小节i节点的分配与释放也是分为两种。当需要创建文件时我们需要分配一个i节点，当文件需要被删除（文件磁盘i节点引用计数减为零）时我们需要释放这一个i节点。</p>\n<p>首先对于磁盘i节点的分配与释放，磁盘i节点分配&#x2F;释放的管理由磁盘上 i节点位图 和 磁盘i节点数组 共同管理，它们的起始位置在上小结已给出。所有的磁盘上的 i 节点都被统一存放在一个称为 i 节点数组的连续区域中。每一个 i 节点的大小都是一样的，所以对于一个给定的数字n，很容易找到磁盘上对应的 i 节点。事实上这个给定的数字就是操作系统中 i 节点的编号。</p>\n<p>磁盘上的 i 节点由结构体 <code>minix_inode_t</code> 定义。<code>mode</code> 域用来区分文件、目录和特殊文件。nlink 域用来记录指向了这一个 i 节点的目录项，这是用于判断一个 i 节点是否应该被释放的。size 域记录了文件的字节数。<code>zone</code> 数组用于这个文件的数据块的块号。在后面 <strong>虚拟文件的打开&#x2F;读写&#x2F;关闭</strong> 小结就会看到，每个文件采用 <code>zone</code> 数组管理文件数据的方式非常巧妙，该数组就是每个文件都能从0偏移开始读取和写入，看起来像多块磁盘的原因。</p>\n<p>i节点和超级快磁盘结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minix_inode_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    u16 mode;    <span class=\"comment\">// 文件类型和属性(rwx 位)</span></span><br><span class=\"line\">    u16 uid;     <span class=\"comment\">// 用户id（文件拥有者标识符）</span></span><br><span class=\"line\">    u32 size;    <span class=\"comment\">// 文件大小（字节数）</span></span><br><span class=\"line\">    u32 mtime;   <span class=\"comment\">// 修改时间戳 这个时间戳应该用 UTC 时间，不然有瑕疵</span></span><br><span class=\"line\">    u8 gid;      <span class=\"comment\">// 组id(文件拥有者所在的组)</span></span><br><span class=\"line\">    u8 nlinks;   <span class=\"comment\">// 链接数（多少个文件目录项指向该i 节点）</span></span><br><span class=\"line\">    u16 zone[<span class=\"number\">9</span>]; <span class=\"comment\">// 直接 (0-6)、间接(7)或双重间接 (8) 逻辑块号</span></span><br><span class=\"line\">&#125; <span class=\"type\">minix_inode_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minix_super_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    u16 inodes;        <span class=\"comment\">// 节点数</span></span><br><span class=\"line\">    u16 zones;         <span class=\"comment\">// 逻辑块数</span></span><br><span class=\"line\">    u16 imap_blocks;   <span class=\"comment\">// i 节点位图所占用的数据块数</span></span><br><span class=\"line\">    u16 zmap_blocks;   <span class=\"comment\">// 逻辑块位图所占用的数据块数</span></span><br><span class=\"line\">    u16 firstdatazone; <span class=\"comment\">// 第一个数据逻辑块号</span></span><br><span class=\"line\">    u16 log_zone_size; <span class=\"comment\">// log2(每逻辑块数据块数)</span></span><br><span class=\"line\">    u32 max_size;      <span class=\"comment\">// 文件最大长度</span></span><br><span class=\"line\">    u16 magic;         <span class=\"comment\">// 文件系统魔数</span></span><br><span class=\"line\">&#125; <span class=\"type\">minix_super_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>磁盘i节点分配&#x2F;释放的核心函数是 <code>minix_ialloc</code> 和 <code>minix_ifree</code>。分配函数首先会从超级块当中定位i节点位图的起始位置和长度。然后遍历i节点位图，找到一个可用i节点编号，将位图置为true（占用）并返回。minix_ialloc只负责从磁盘上找到一个可用的i节点编号返回给调用者，其他的什么也不做。<code>minix_ifree</code> 就是 <code>minix_ialloc</code> 逆过程，将分配的i节点编号对应的位图置为false（可分配）。两函数代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分配一个文件系统 inode</span></span><br><span class=\"line\"><span class=\"type\">idx_t</span> <span class=\"title function_\">minix_ialloc</span><span class=\"params\">(<span class=\"type\">super_t</span> *super)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bit = EOF;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;imap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_BITS, i * BLOCK_BITS);</span><br><span class=\"line\">        bit = bitmap_scan(&amp;<span class=\"built_in\">map</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bit != EOF)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            assert(bit &lt; desc-&gt;inodes);</span><br><span class=\"line\">            buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo 调试期间强同步</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bit;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放一个文件系统 inode</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">minix_ifree</span><span class=\"params\">(<span class=\"type\">super_t</span> *super, <span class=\"type\">idx_t</span> idx)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    assert(idx &lt; desc-&gt;inodes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;imap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &gt; BLOCK_BITS * (i + <span class=\"number\">1</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_BITS, i * BLOCK_BITS);</span><br><span class=\"line\">        assert(bitmap_test(&amp;<span class=\"built_in\">map</span>, idx));</span><br><span class=\"line\">        bitmap_set(&amp;<span class=\"built_in\">map</span>, idx, <span class=\"number\">0</span>);</span><br><span class=\"line\">        buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo 调试期间强同步</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用者得到i节点编号后，可以通过 <code>iget</code> 函数<strong>将i节点编号转为i节点代理</strong>。它的逻辑是这样的，先尝试在现有内存i节点代理当中根据i节点编号查找i节点，如果查到了，就直接返回，否则调用 <code>get_free_inode</code> 函数先从空闲的i节点代理缓存当中获取一个空闲i节点代理，再将i节点编号转为磁盘i节点所在块号，然后将磁盘i节点所在磁盘块缓存到内存获取磁盘上的i节点，然后对空闲的i节点代理进行初始化。</p>\n<p>i节点代理的核心初始化步骤包括：</p>\n<blockquote>\n<ul>\n<li>将inode_t::desc填充成 磁盘i节点缓存地址。</li>\n<li>inode::buf填充成 磁盘i节点所在块缓存地址，inode::buf指向 磁盘i节点所在块缓存地址 这样能保证 磁盘i节点所在块缓存 的引用计数非零，防止inode_t::desc所指向的磁盘i节点缓存地址 因磁盘块的lru算法被置换出内存而失效。</li>\n<li>如果i节点对应的是IO设备，而非文件，将inode_t::rdev填充为minix_inode_t::zone[0]，对于设备文件，minix_inode_t::zone[0]表示IO设备的虚拟设备号。</li>\n<li>inode_t::super填充成所在设备的超级快。同一设备上的文件系统，超级快是相同的！</li>\n<li>inode_t::type设置成FS_TYPE_MINIX。</li>\n<li>并且inode_t::op安装成FS_TYPE_MINIX对应的回调。</li>\n</ul>\n</blockquote>\n<p>核心代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BLOCK_INODES (BLOCK_SIZE / sizeof(minix_inode_t))    <span class=\"comment\">// 1个磁盘块能容纳 inode的数量</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计算 inode nr 对应的块号</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">idx_t</span> <span class=\"title function_\">inode_block</span><span class=\"params\">(<span class=\"type\">minix_super_t</span> *desc, <span class=\"type\">idx_t</span> nr)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// inode 编号 从 1 开始</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> + desc-&gt;imap_blocks + desc-&gt;zmap_blocks + (nr - <span class=\"number\">1</span>) / BLOCK_INODES;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将i节点编号转为i节点代理</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">inode_t</span> *<span class=\"title function_\">iget</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">idx_t</span> nr)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *inode = find_inode(dev, nr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inode)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        inode-&gt;count++;</span><br><span class=\"line\">        inode-&gt;atime = time();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">super_t</span> *super = get_super(dev);</span><br><span class=\"line\">    assert(super);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(nr &lt;= desc-&gt;inodes);</span><br><span class=\"line\"></span><br><span class=\"line\">    inode = get_free_inode();</span><br><span class=\"line\">    inode-&gt;dev = dev;</span><br><span class=\"line\">    inode-&gt;nr = nr;</span><br><span class=\"line\">    inode-&gt;count++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加入超级块 inode 链表</span></span><br><span class=\"line\">    list_push(&amp;super-&gt;inode_list, &amp;inode-&gt;node);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> block = inode_block(desc, inode-&gt;nr);</span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = bread(inode-&gt;dev, block);</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;buf = buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将缓冲视为一个 inode 描述符数组，获取对应的指针；</span></span><br><span class=\"line\">    inode-&gt;desc = &amp;((<span class=\"type\">minix_inode_t</span> *)buf-&gt;data)[(inode-&gt;nr - <span class=\"number\">1</span>) % BLOCK_INODES];</span><br><span class=\"line\">    <span class=\"type\">minix_inode_t</span> *minode = (<span class=\"type\">minix_inode_t</span> *)inode-&gt;desc;</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;rdev = minode-&gt;zone[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;mode = minode-&gt;mode;</span><br><span class=\"line\">    inode-&gt;size = minode-&gt;size;</span><br><span class=\"line\">    inode-&gt;super = super;</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;type = FS_TYPE_MINIX;</span><br><span class=\"line\">    inode-&gt;op = fs_get_op(FS_TYPE_MINIX);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与iget对立的是iput函数，该函数定义在onix-dev&#x2F;src&#x2F;fs&#x2F;inode.c，函数iput用于将i节点代理进行释放，iput会借助 minix_close 函数，一旦inode_t::count成员减为零，就将inode::buf（磁盘i节点所在块缓存）释放，然后将i节点代理放回空闲缓存区。</p>\n<h3 id=\"磁盘数据块的分配与释放\"><a href=\"#磁盘数据块的分配与释放\" class=\"headerlink\" title=\"磁盘数据块的分配与释放\"></a>磁盘数据块的分配与释放</h3><p>onix当中，文件系统文件的数据存在于分散的磁盘数据块当中。文件使用磁盘上的i节点minix_inode_t::zone数组管理磁盘数据块。文件创建后，向里面不断顺序写入数据，一旦当前磁盘数据块写满了，文件系统就会调用 <code>minix_balloc</code> 函数给文件分配一块磁盘数据块。相反的，如果一个文件需要被删除，调用 <code>minix_bfree</code> 函数释放所有分配的磁盘数据块。磁盘块同样采用位图的方式去管理。</p>\n<p>磁盘数据块分配释放&#x2F;器的原理和 磁盘i节点分配&#x2F;释放器（<code>minix_ialloc</code> 和 <code>minix_ifree</code>）极其类似。磁盘数据块分配器首先会从超级块当中定位磁盘数据块位图的起始位置和长度。然后遍历磁盘数据块位图，找到一个可用磁盘数据块号，将位图置为true（占用）并返回。minix_ialloc只负责从磁盘上找到一个可用的磁盘数据块号返回给调用者，其他的什么也不做。<code>minix_bfree</code> 就是 <code>minix_balloc</code> 逆过程，将分配的磁盘数据块号对应的位图置为false（可分配）。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分配一个文件块</span></span><br><span class=\"line\"><span class=\"type\">idx_t</span> <span class=\"title function_\">minix_balloc</span><span class=\"params\">(<span class=\"type\">super_t</span> *super)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bit = EOF;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span> + desc-&gt;imap_blocks;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;zmap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将整个缓冲区作为位图</span></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_SIZE, i * BLOCK_BITS + desc-&gt;firstdatazone - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从位图中扫描一位</span></span><br><span class=\"line\">        bit = bitmap_scan(&amp;<span class=\"built_in\">map</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bit != EOF)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果扫描成功，则 标记缓冲区脏，中止查找</span></span><br><span class=\"line\">            assert(bit &lt; desc-&gt;zones);</span><br><span class=\"line\">            buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo 调试期间强同步</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bit;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放一个文件块</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">minix_bfree</span><span class=\"params\">(<span class=\"type\">super_t</span> *super, <span class=\"type\">idx_t</span> idx)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    assert(idx &lt; desc-&gt;zones);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span> + desc-&gt;imap_blocks;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;zmap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 跳过开始的块</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &gt; BLOCK_BITS * (i + <span class=\"number\">1</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将整个缓冲区作为位图</span></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_SIZE, BLOCK_BITS * i + desc-&gt;firstdatazone - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将 idx 对应的位图置位 0</span></span><br><span class=\"line\">        assert(bitmap_test(&amp;<span class=\"built_in\">map</span>, idx));</span><br><span class=\"line\">        bitmap_set(&amp;<span class=\"built_in\">map</span>, idx, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 标记缓冲区脏</span></span><br><span class=\"line\">        buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo 调试期间强同步</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"根文件系统的挂载\"><a href=\"#根文件系统的挂载\" class=\"headerlink\" title=\"根文件系统的挂载\"></a>根文件系统的挂载</h3><p>在onix初始化阶段在使用文件系统之前，必须先对根目录进行挂载。我们使用系统调用 <code>open</code> 函数打开的文件时，需要传入路径作为参数，而想要通过路径找到最终文件的i节点，必经过根目录的i节点。任何路径的解析，都以根目录为基础的。所以，分析onix根目录的挂载流程是很重要的。</p>\n<p>根文件系统挂载触发点位于super_init函数：</p>\n<ul>\n<li>super_init函数首先会初始化全局超级块表，为后续文件系统挂载做准备，每个超级块维护一个inode链表，用于管理该文件系统打开的文件节点，超级块表初始化完毕后，会调用mount_root函数。</li>\n<li>mount_root函数首先获取磁盘第一个分区的虚拟设备控制句柄，然后从设备控制句柄当中获取设备号dev（方便读写），然后调用read_super函数获取dev设备的超级快。最后将<strong>超级块和根目录i节点代理做绑定</strong>，方便将路径解析为i节点。  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 挂载根文件系统</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">mount_root</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    LOGK(<span class=\"string\">&quot;Mount root file system...\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 假设主硬盘第一个分区是根文件系统</span></span><br><span class=\"line\">    <span class=\"type\">device_t</span> *device = device_find(DEV_IDE_PART, <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(device);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 读根文件系统超级块</span></span><br><span class=\"line\">    root = read_super(device-&gt;dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 超级快和根目录i节点代理做绑定。</span></span><br><span class=\"line\">    root-&gt;imount = root-&gt;iroot;</span><br><span class=\"line\">    root-&gt;imount-&gt;count++;</span><br><span class=\"line\"></span><br><span class=\"line\">    root-&gt;iroot-&gt;mount = device-&gt;dev;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>read_super函数首先会尝试使用设备号dev从超级快列表当中直接获取超级快，但由于系统刚启动，正处在初始化阶段，所以，必然失败。然后read_super函数会尝试从超级块列表当中获取一个空闲的超级快，然后调用minix_super函数对空闲超级快进行初始化。  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读设备 dev 的超级块</span></span><br><span class=\"line\"><span class=\"type\">super_t</span> *<span class=\"title function_\">read_super</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">super_t</span> *super = get_super(dev);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (super) &#123;</span><br><span class=\"line\">        super-&gt;count++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> super;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOGK(<span class=\"string\">&quot;Reading super block of device %d\\n&quot;</span>, dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获得空闲超级块</span></span><br><span class=\"line\">    super = get_free_super();</span><br><span class=\"line\">    super-&gt;count++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">1</span>; i &lt; FS_TYPE_NUM; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">fs_op_t</span> *op = fs_get_op(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!op)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"comment\">// minix_super</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (op-&gt;super(dev, super) == EOK) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> super;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    put_super(super);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>minix_super函数实现较为简单，通过读取磁盘的 磁盘块1 （在前面的列出的磁盘分区结构图当中有列出，超级块位于1号磁盘块），将 磁盘超级快 读到内存当中，然后将磁盘超级块缓存填充到super_t::desc，当然为了避免磁盘超级块缓存被替换出磁盘，将磁盘超级快所在的磁盘块缓存填充给super_t::buf，最后调用 iget 函数获取根目录的i节点代理（按规定，根目录磁盘i节点的编号为1）。  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">minix_super</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">super_t</span> *super)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 读取超级块</span></span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = bread(dev, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!buf)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EFSUNK;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(buf);</span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)buf-&gt;data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (desc-&gt;magic != MINIX1_MAGIC) &#123;</span><br><span class=\"line\">        brelse(buf);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EFSUNK;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    super-&gt;buf = buf;</span><br><span class=\"line\">    super-&gt;desc = desc;</span><br><span class=\"line\">    super-&gt;dev = dev;</span><br><span class=\"line\">    super-&gt;type = FS_TYPE_MINIX;</span><br><span class=\"line\">    super-&gt;block_size = BLOCK_SIZE;</span><br><span class=\"line\">    super-&gt;sector_size = SECTOR_SIZE;</span><br><span class=\"line\">    super-&gt;iroot = iget(dev, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>注意 <code>super-&gt;iroot</code> 成员的初始化被放在了最后，这里是一定要放在最后。如果你深入阅读 iget 函数的代码就会发现 iget函数 里面需要用到超级块如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">inode_t</span> *<span class=\"title function_\">iget</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">idx_t</span> nr)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *inode = find_inode(dev, nr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inode) &#123;</span><br><span class=\"line\">        inode-&gt;count++;</span><br><span class=\"line\">        inode-&gt;atime = time();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">super_t</span> *super = get_super(dev);</span><br><span class=\"line\">    assert(super);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等等，我们正在初始化超级快，但是 iget 函数又用到了超级快，这样对吗？我的回答是没有任何毛病，因为 在minix_super超级快初始化函数当中最后一刻才调用了iget函数，此时超级快其实已经初始化的差不多了，并且iget函数内部也并没有用到 <code>super-&gt;iroot</code> 成员，所以逻辑并没有什么问题。</p>\n<h3 id=\"虚拟文件的打开-关闭\"><a href=\"#虚拟文件的打开-关闭\" class=\"headerlink\" title=\"虚拟文件的打开&#x2F;关闭\"></a>虚拟文件的打开&#x2F;关闭</h3><p>onix当中，使用open函数打开一个文件，如果要创建以一个文件，实际上使用的是带 <code>O_CREAT | O_TRUNC</code> 标志的open函数，我们只需要重点研究open系统调用 <code>sys_open</code> 的实现，伪代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">fd_t</span> <span class=\"title function_\">sys_open</span><span class=\"params\">(<span class=\"type\">char</span> *filename, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> mode)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *next;</span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *dir = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取filename父目录i节点代理，并且，将最后的文件名填到next当中。</span></span><br><span class=\"line\">    dir = named(filename, &amp;next);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果路径本身是目录（/a/b/）。跳过minix文件系统open回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*next) &#123;</span><br><span class=\"line\">        inode = dir;</span><br><span class=\"line\">        dir-&gt;count++;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> makeup;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 调用minix文件系统open回调。打开/创建文件。</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ret = dir-&gt;op-&gt;open(dir, next, flags, mode, &amp;inode);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从进程文件表（数组）当中获取一个空闲的文件描述符，并且初始化其元素file_t。</span></span><br><span class=\"line\">    <span class=\"type\">file_t</span> *file;</span><br><span class=\"line\">    <span class=\"type\">fd_t</span> fd = fd_get(&amp;file);</span><br><span class=\"line\"></span><br><span class=\"line\">    file-&gt;inode = inode;</span><br><span class=\"line\">    file-&gt;flags = flags;</span><br><span class=\"line\">    file-&gt;count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    file-&gt;offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 有追加参数就将file的偏移移到文件末尾。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags &amp; O_APPEND) &#123;</span><br><span class=\"line\">        file-&gt;offset = file-&gt;inode-&gt;size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>调用named函数，获取filename父目录i节点代理，并且，将最后的文件名填到next当中。</li>\n<li>如果路径本身是目录（&#x2F;a&#x2F;b&#x2F;）。跳过minix文件系统open回调。进入4。</li>\n<li>调用minix的open回调，打开&#x2F;创建文件。获取文件的i节点代理。</li>\n<li>从进程文件表（数组）当中获取一个空闲的文件描述符，并且初始化其元素file_t。</li>\n<li>如果flags标志包含 <code>O_APPEND</code> ，将file的偏移移到文件末尾。</li>\n</ol>\n</blockquote>\n<p>named函数的作用就是根据路径找到文件父目录的i节点，并且将最后的文件名填到next当中。named函数代码稍微有些复杂，特别是这一段：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取 pathname 对应的父目录 inode</span></span><br><span class=\"line\"><span class=\"type\">inode_t</span> *<span class=\"title function_\">named</span><span class=\"params\">(<span class=\"type\">char</span> *pathname, <span class=\"type\">char</span> **next)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回上一级目录且上一级目录是个挂载点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (match_name(name, <span class=\"string\">&quot;..&quot;</span>, next) &amp;&amp; dir == dir-&gt;super-&gt;iroot) &#123;</span><br><span class=\"line\">            <span class=\"type\">super_t</span> *super = dir-&gt;super;</span><br><span class=\"line\">            inode = super-&gt;imount;</span><br><span class=\"line\">            inode-&gt;count++;</span><br><span class=\"line\">            iput(dir);</span><br><span class=\"line\">            dir = inode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果路径 <code>name</code>（基于pathname经过预处理的路径） 解析到了 <code>..</code> 文件名并且（同一文件系统下）其父目录正好是设备的根节点，就会进入该if分支。因为linux当中一切皆文件的思想，（跨文件系统）父目录可能是作为子目录的挂载点而存在，导致父目录和子目录不在一个设备（文件系统）上。故我们在跨文件系统的情况下执行 <code>..</code> 目录回退操作时，必须执行这样一段 “换根” 代码。</p>\n<p>这段if换根代码强烈建议读者结合 <code>sys_mknod</code> 和 <code>sys_mount</code> 函数实现去理解。在onix当中（参考：onix-dev&#x2F;src&#x2F;fs&#x2F;dev.c），挂载一个设备首先要使用 sys_mknod 系统调用为设备创建一个设备文件，然后，在根文件系统下寻找一个目录作为挂载点，最后使用 sys_mount 系统调用挂载设备。</p>\n<p>下面深入介绍一下onix当中如何实现设备挂载的：</p>\n<p>挂载点内部数据结构链接细节如下图：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_mount.drawio.png\"></p>\n<p>sys_mknod会接收设备号作为参数。它的实现最终会调用minix_mknod函数，这会创建一个特殊的文件，我们称它为设备文件，然后文件的磁盘i节点当中zone数组只使用第一个元素，存放传入的设备号，在将磁盘i节点转成i节点代理过程当中，i节点代理的rdev成员就会被赋值成minode-&gt;zone[0]，minix_mknod伪代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">minix_mknod</span><span class=\"params\">(<span class=\"type\">inode_t</span> *dir, <span class=\"type\">char</span> *name, <span class=\"type\">int</span> mode, <span class=\"type\">int</span> dev)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 创建一个特殊的文件。</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ISBLK(mode) || ISCHR(mode))</span><br><span class=\"line\">        minode-&gt;zone[<span class=\"number\">0</span>] = dev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sys_mount函数负责将一个设备文件挂载到指定目录下。比如sd卡，一般来说，它的设备文件名为&#x2F;dev&#x2F;sdb1，当我们要访问sd卡时，需要执行命令 <code>mount /dev/sdb1 /mnt</code> 。<strong>这里需要注意的是，sd卡所有的文件系统 和 我们的根目录所挂载的文件系统一定是两个独立的互不相干的两个文件系统，他们各自拥有自己独立、自包含的i节点编号空间。在同一个Linux系统下，SD卡上文件的i节点号与根文件系统下文件的i节点号即使数字相同，也绝对不会发生冲突。系统能够清晰地区分它们。</strong> onix sys_mount函数实现伪代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sys_mount</span><span class=\"params\">(<span class=\"type\">char</span> *devname, <span class=\"type\">char</span> *dirname, <span class=\"type\">int</span> flags)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取设备文件i节点代理</span></span><br><span class=\"line\">    devinode = namei(devname);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取挂载点i节点代理</span></span><br><span class=\"line\">    dirinode = namei(dirname);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取设备超级块</span></span><br><span class=\"line\">    super = read_super(devinode-&gt;rdev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设备超级快指向挂载点</span></span><br><span class=\"line\">    super-&gt;imount = dirinode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 挂载点指向挂载的设备</span></span><br><span class=\"line\">    dirinode-&gt;mount = devinode-&gt;rdev;</span><br><span class=\"line\">    iput(devinode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>核心逻辑如下：</p>\n<blockquote>\n<ol>\n<li>获取设备文件i节点代理。</li>\n<li>获取挂载点i节点代理。</li>\n<li>获取设备超级块。</li>\n<li>将设备超级块指向挂载点。</li>\n<li>挂载点指向挂载的设备。</li>\n</ol>\n</blockquote>\n<p>sys_open当中核心函数还是中间调用的minix_open回调，它的伪代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">minix_open</span><span class=\"params\">(<span class=\"type\">inode_t</span> *dir, <span class=\"type\">char</span> *name, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> mode, <span class=\"type\">inode_t</span> **result)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">minix_dentry_t</span> *entry = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在dir下尝试查找name文件，并将目录项存到entry。</span></span><br><span class=\"line\">    buf = find_entry(dir, name, &amp;next, &amp;entry);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buf) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果找到了根据目录项将 i节点号转为i节点代理。iget函数是老朋友了，前面小结经常用到。</span></span><br><span class=\"line\">        inode = iget(dir-&gt;dev, entry-&gt;nr);</span><br><span class=\"line\">        assert(inode);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> makeup;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// 不存在</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 不带创建标志，返回文件不存在的错误。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(flags &amp; O_CREAT)) &#123;</span><br><span class=\"line\">        ret = -EEXIST;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 向父目录当中添加名为name的文件项。并且返回其文件项缓存块地址，确保entry有效。</span></span><br><span class=\"line\">    buf = add_entry(dir, name, &amp;entry);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 申请一个i节点号。</span></span><br><span class=\"line\">    entry-&gt;nr = minix_ialloc(dir-&gt;super);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化磁盘i节点和i节点代理。</span></span><br><span class=\"line\">    inode = new_inode(dir-&gt;dev, entry-&gt;nr);</span><br><span class=\"line\"></span><br><span class=\"line\">makeup:</span><br><span class=\"line\">    <span class=\"comment\">// 传给输出参数。</span></span><br><span class=\"line\">    *result = inode;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先明确：sys_open调用minix_open，传入的name是单个文件名，dir是name文件的父目录i节点。</p>\n<blockquote>\n<ol>\n<li>调用find_entry函数，首先在dir下尝试查找name文件，并将目录项存到entry。如果找到了，根据目录项将 i节点号转为i节点代理，并快进到 <code>makeup</code> 阶段。iget函数是老朋友了，前面小结经常用到。如果没找到，尝试去创建一个新文件。</li>\n<li>检测是否带 <code>O_CREAT</code> 标志，不带标志就返回文件不存在的错误。</li>\n<li>调用add_entry函数向父目录当中添加名为name的文件项。并且返回其文件项缓存块地址，确保entry有效。</li>\n<li>申请一个i节点号。</li>\n<li>初始化磁盘i节点和i节点代理。</li>\n</ol>\n</blockquote>\n<p>有关 <code>find_entry</code> 和 <code>add_entry</code> 函数，这两函数属于目录操作函数，在 <strong>目录的操作</strong> 小结将深入展开讲解。</p>\n<p>踪上，一个进程打开一个文件后，系统状态图如下：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio.png\"></p>\n<h3 id=\"虚拟文件的读-写\"><a href=\"#虚拟文件的读-写\" class=\"headerlink\" title=\"虚拟文件的读&#x2F;写\"></a>虚拟文件的读&#x2F;写</h3><p>如果说超级块是更高维度的能解析文件系统的磁盘结构，那么i节点其实可以理解成低维度的能解析文件的磁盘结构。</p>\n<p>在 <strong>i节点的分配与释放</strong> 小结已经列出过i节点的磁盘结构，但因为文章结构原因我们没有多费口舌去讲解它具体成员的作用。在本节，因为文件的操作是极度依赖i节点磁盘结构的。所以，下面用一张图片直观了解i节点的磁盘结构：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio.png\"></p>\n<p>一般的，i节点磁盘数据结构各个字段作用如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">i节点字段名</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">minix_inode_t::mode</td>\n<td align=\"center\">文件类型和属性位，onix支持的文件类型包含：常规文件、目录文件、字符设备文件、块设备文件。文件屬性包含：读、写、可执行。</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::uid</td>\n<td align=\"center\">用户id，也即文件拥有者标识符</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::size</td>\n<td align=\"center\">文件大小（Byte）</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::mtime</td>\n<td align=\"center\">最后修改的时间戳</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::gid</td>\n<td align=\"center\">用户所属组id</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::nlinks</td>\n<td align=\"center\">链接数，表示有多少目录项指向该i节点</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::zone</td>\n<td align=\"center\">长度为9的uint16_t类型数组，前7个元素代表直接块，直接指向磁盘数据块，第8个元素为一级间接块，第9个元素为二级间接块</td>\n</tr>\n</tbody></table>\n<p>磁盘i节点的设计非常精妙，前面部分存放文件属性，<strong>后面的数组 <code>minix_inode_t::zone</code> 是你打开每一个文件，都能从0偏移开始读取的根本原因</strong>。如果你有仔细研究过onix&#x2F;xv6内存管理当中内存虚拟内存机制，你会发现，i节点对文件数据块的管理 和 虚拟内存的页表-页框-页目录机制思想一模一样。</p>\n<p>尽管物理上磁盘只有一块，i节点磁盘数据结构这种 直接块-间接块-双重间接块 机制让虚拟文件系统当中的每个文件都像独占一块磁盘一样，使（实际上）非连续空间连续化，可以从偏移0位置开始顺序读写数据。同时，在这种机制的加持下，更便于磁盘块的管理，增加零散磁盘块的利用率。</p>\n<p>有了上面i节点管理数据块的理论知识，下面让我们一步步了解 <code>sys_read</code> 和 <code>sys_write</code> 系统调用的实现。</p>\n<p>首先是 <code>sys_read</code> 函数，伪代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sys_read</span><span class=\"params\">(<span class=\"type\">fd_t</span> fd, <span class=\"type\">char</span> *buf, <span class=\"type\">int</span> count)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((ret = fd_check(fd, &amp;file)) &lt; EOK)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *inode = file-&gt;inode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> len = inode-&gt;op-&gt;read(inode, buf, count, file-&gt;offset);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        file-&gt;offset += len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>首先将fd转换为文件表项 <code>file_t</code> 。</li>\n<li>由文件表项获得文件的i节点代理。</li>\n<li>调用 minix read 回调读取数据。</li>\n</ol>\n</blockquote>\n<p>直接来到了minix read 回调——minix_read。该函数根据传入的要读的数据长度len和文件偏移offset来来逐块读取数据。如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从 inode 的 offset 处，读 len 个字节到 buf</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">minix_read</span><span class=\"params\">(<span class=\"type\">inode_t</span> *inode, <span class=\"type\">char</span> *data, <span class=\"type\">int</span> len, <span class=\"type\">off_t</span> offset)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">minix_inode_t</span> *minode = (<span class=\"type\">minix_inode_t</span> *)inode-&gt;desc;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ISCHR(minode-&gt;mode)) &#123;</span><br><span class=\"line\">        assert(minode-&gt;zone[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> device_read(minode-&gt;zone[<span class=\"number\">0</span>], data, len, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ISBLK(minode-&gt;mode)) &#123;</span><br><span class=\"line\">        assert(minode-&gt;zone[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"type\">device_t</span> *device = device_get(minode-&gt;zone[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        assert(len % BLOCK_SIZE == <span class=\"number\">0</span>);</span><br><span class=\"line\">        assert(device_read(minode-&gt;zone[<span class=\"number\">0</span>], data, len / BLOCK_SIZE, offset / BLOCK_SIZE, <span class=\"number\">0</span>) == EOK);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(ISFILE(minode-&gt;mode) || ISDIR(minode-&gt;mode));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果偏移量超过文件大小，返回 EOF</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset &gt;= minode-&gt;size) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 开始读取的位置</span></span><br><span class=\"line\">    u32 begin = offset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 剩余字节数</span></span><br><span class=\"line\">    u32 left = MIN(len, minode-&gt;size - offset);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 找到对应的文件便宜，所在文件块</span></span><br><span class=\"line\">        <span class=\"type\">idx_t</span> nr = minix_bmap(inode, offset / BLOCK_SIZE, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        assert(nr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 读取文件块缓冲</span></span><br><span class=\"line\">        <span class=\"type\">buffer_t</span> *buf = bread(inode-&gt;dev, nr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 文件块中的偏移量</span></span><br><span class=\"line\">        u32 start = offset % BLOCK_SIZE;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 本次需要读取的字节数</span></span><br><span class=\"line\">        u32 chars = MIN(BLOCK_SIZE - start, left);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新 偏移量 和 剩余字节数</span></span><br><span class=\"line\">        offset += chars;</span><br><span class=\"line\">        left -= chars;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 文件块中的指针</span></span><br><span class=\"line\">        <span class=\"type\">char</span> *ptr = buf-&gt;data + start;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 拷贝内容</span></span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(data, ptr, chars);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新缓存位置</span></span><br><span class=\"line\">        data += chars;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 释放文件块缓冲</span></span><br><span class=\"line\">        brelse(buf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新访问时间</span></span><br><span class=\"line\">    inode-&gt;atime = time();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回读取数量</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> offset - begin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数逻辑如下：</p>\n<blockquote>\n<ol>\n<li>判断文件类型，如果是字符设备或者块设备，就根据minode-&gt;zone[0]获取到设备的设备号，然后调用虚拟设备回调函数，去读取数据并返回。如果是普通文件&#x2F;目录，继续下面步骤。</li>\n<li>普通文件的话，进入while循环，调用minix_bmap函数基于i节点的zone数组将offset转换为数据所在磁盘块。</li>\n<li>获取磁盘块缓存。</li>\n<li>读取 <code>MIN(BLOCK_SIZE - start, left)</code> 长的数据。</li>\n<li>如果读取的数据不够len字节，重复2~4步骤。</li>\n</ol>\n</blockquote>\n<p>那么，minix_bmap函数是怎么实现的呢？onix对minix_bmap稍微有些复杂。这里附上我的想法，我觉得可以重用 <a href=\"https://blog.csdn.net/m0_52566365/article/details/139525258\">这才是计科之 Onix &amp; XV6 源码分析（2、类Unix的内存管理）</a> 的做法。思想就是基于 i节点的磁盘结构图 对offset进行划分，如下：</p>\n<blockquote>\n<ul>\n<li>如果 offset 在直接块覆盖范围内，直接通过zone数组读取数据块即可。</li>\n<li>如果 offset 在一级间接块覆盖范围内。<ul>\n<li>首先将offset减去直接块所能表示的最大地址。</li>\n<li>将offset看成虚拟磁盘地址，然后由 <code>(offset &amp; 0x7FC00) &gt;&gt; 10</code> 公式获取虚拟磁盘地址高9位作为一级间接块的数组（元素为uint16_t）索引，然后取得磁盘数据块号后，将offset末尾的10位作为磁盘数据块内偏移。 获取块内偏移的公式：<code>offset &amp; 0x3FF</code> ，最终获得到物理磁盘地址。</li>\n</ul>\n</li>\n<li>如果 offset 在二级间接块覆盖范围内。<ul>\n<li>首先将offset减去直接块 + 一级间接块所能表示的最大地址。</li>\n<li>将offset看成虚拟磁盘地址，然后由 <code>(offset &amp; 0xFF80000) &gt;&gt; 10</code> 公式获取虚拟磁盘地址高9位作为一级间接块的数组（元素为uint16_t）索引，取得二级间接块号后，根据公式 <code>(offset &amp; 0x7FC00) &gt;&gt; 10</code> 得到二级间接块数组（元素同样为uint16_t）索引，取得磁盘数据块号后，将offset末尾的10位作为磁盘数据块内偏移。 获取块内偏移的公式：<code>offset &amp; 0x3FF</code> ，最终获得到物理磁盘地址。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>但是， <strong>由于onix规定zone数组元素类型为uint16_t，所以这决定了onix最大能表示的磁盘块号为2^16 - 1， 故onix的磁盘有效大小的上限为 64MB。</strong> 当然，作为学习操作系统，我们就不必太过于精益求精。</p>\n<p>文件系统的写，是读的逆过程，代码逻辑极其相似，行文至此，篇幅过多，这里就不带着大家读代码了，建议读者亲自去扒一扒onix的源码。</p>\n<h3 id=\"目录的操作\"><a href=\"#目录的操作\" class=\"headerlink\" title=\"目录的操作\"></a>目录的操作</h3><p>最后就是文件系统目录的操作，这里主要讲解两个函数：<code>find_entry</code> 和 <code>add_entry</code>。面对目录，只需要记住一点，目录其实就是一个 文件内容被规定死的 普通文件。目录文件会存放一个个目录条目，onix当中目录条目数据结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 文件目录项结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minix_dentry_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    u16 nr;              <span class=\"comment\">// i 节点</span></span><br><span class=\"line\">    <span class=\"type\">char</span> name[NAME_LEN]; <span class=\"comment\">// 文件名</span></span><br><span class=\"line\">&#125; <span class=\"type\">minix_dentry_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>目录项图解如下：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_dentry.drawio.png\"></p>\n<p>在onix当中，find_entry函数为了找到目标目录项会使用for循环遍历传进来的目录的所有目录项。</p>\n<p>add_entry同样会遍历目录的目录项，直到找到一个 <code>nr</code> 成员为0的目录项，在onix当中，nr为0意味这该目录项未被占用。所以相应的，如果你想删除一个目录项，只需将对应的nr置为0即可。onix的minix_rmdir函数也正是这样做的。</p>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>拖了这么久，终于到了最后一篇关于类unix源码分析的文章————文件系统。</p>\n<p>（偷偷告诉你，本篇博客起草于我即将从毕业以来第一家公司离职前一个星期（2025-9-16），忍着牙痛ing ing ing）。</p>\n<p>如你所见，文件系统完全值得另开一篇博文单独去记录它。这里为了方便，同样将Onix的文件系统和XV6的文件系统放一块进行记录。并且，Onix的文件系统确实更加规范和完善，而XV6的文件系统相对来说更加简洁。但值得一提的是，XV6文件系统实现了一个简单而确实又很重要的东西————基于写时日志的事务系统。这是Onix所没有的。</p>\n<p>linux的一切皆文件的伟大思想，将所有的IO行为（包括IO设备读写、pipe读写、进程读写）都抽象成文件。在本篇文章当中，我们将通过两个小型操作系统源码一一揭开linux文件系统的面纱。</p>","more":"<p>首先贴上XV6文件系统的模块方图：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio.png\"></p>\n<p>其次是Onix文件系统的模块方图：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio.png\"></p>\n<p>诈一看，你一定会认为XV6实现的文件系统比Onix的更复杂，实际上恰恰相反。尽管XV6实现了更多的模块，但是因为它教学系统的本质，每个模块的实现都以简单且精简为目的，没有为扩展性做任何多余操作。： ）读过的人表示非常干脆利落。</p>\n<p>反观Onix，为了适配 终端、串口、键盘、磁盘、软盘以及以后可能有的各种IO设备，根据他们的特点，抽象出了 <code>struct device_t</code> 结构体，分离出虚拟设备抽象层，将共有的io操作提取出来。为了统一文件系统的管理，抽象出了 <code>fs_op_t</code> 结构体。更贴近真实Linux操作系统的做法。具体细节将逐一解释。</p>\n<p>依据我阅读源码的习惯，下面就来自底向上逐步介绍文件系统的实现。<strong>以Onix文件系统为主。</strong></p>\n<h2 id=\"磁盘IO驱动层-虚拟设备实现层\"><a href=\"#磁盘IO驱动层-虚拟设备实现层\" class=\"headerlink\" title=\"磁盘IO驱动层 &amp; 虚拟设备实现层\"></a>磁盘IO驱动层 &amp; 虚拟设备实现层</h2><ul>\n<li><p>磁盘IO驱动层: 一句话概括该模块的作用：所谓磁盘IO驱动层，实际上就是操作系统当中，最底层的直接和磁盘设备打交道的代码。使用厂商规定的指令对磁盘设备按一定规则进行读写操作。</p>\n</li>\n<li><p>虚拟设备实现层: 对IO设备抽象出统一接口，并且针对磁盘设备访问，Onix还实现了经典的电梯算法。XV6当中虚拟设备实现层过于简单，这里以Onix为主进行深入讲解。</p>\n</li>\n</ul>\n<h3 id=\"对于XV6\"><a href=\"#对于XV6\" class=\"headerlink\" title=\"对于XV6\"></a>对于XV6</h3><p>XV6的磁盘IO驱动层可以分为两块：IO请求队列 和 磁盘IO驱动。实现可以参考文件：ide.c，IO请求队列的实现非常巧妙，其思想为：<strong>多个进程需要并发对一块磁盘进行IO，为了保证正确性，我们必须对并行操作串行化处理。让请求IO的进程入队。仅让位于队头的进行执行磁盘IO，其他进程休眠等待。当队头的进程执行完IO请求后出队列唤醒进程，下一个队头再进行IO操作。</strong> 如果你有看过LevelDB的源码，应该对这种思想非常熟悉，因为LevelDB的Write方法实现运用了同样的手法。参考：<a href=\"https://blog.csdn.net/m0_52566365/article/details/137910783\">LevelDB源码阅读笔记（1、整体架构）</a></p>\n<p>框图图如下：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_ide.drawio.png\"></p>\n<p>流程如下：</p>\n<p>首先对外暴露iderw接口。</p>\n<p><strong>iderw函数的逻辑：</strong></p>\n<blockquote>\n<ol>\n<li>上层调用对外暴露的磁盘操作接口 <code>iderw(struct buf *b)</code>。</li>\n<li>将请求push到IO队列尾部。</li>\n<li>如果本身就是队头，直接执行IO函数 <code>idestart</code>。</li>\n<li>非队头，<strong>阻塞直到 IO任务 被中断处理函数消费。</strong></li>\n</ol>\n</blockquote>\n<p><strong>磁盘中断处理函数ideintr的逻辑：</strong>（一旦磁盘准备好，就会触发中断）</p>\n<blockquote>\n<ol>\n<li>IO队列为空直接返回。</li>\n<li>移除并唤醒队头。</li>\n<li>如果IO队列还非空，<strong>为 IO任务 执行IO函数 <code>idestart</code>。</strong></li>\n</ol>\n</blockquote>\n<p>实现了简单的先来先服务(FCFS)调度</p>\n<h3 id=\"对于Onix\"><a href=\"#对于Onix\" class=\"headerlink\" title=\"对于Onix\"></a>对于Onix</h3><p>而Onix的磁盘IO驱动极其复杂，需要深入了解 IDE（Integrated Drive Electronics）硬盘控制器（IDE是一种常见的硬盘接口标准，也称为ATA（Advanced Technology Attachment））。感兴趣的可以先阅读一下XV6当中idestart函数，该函数使用几行代码实现了对磁盘设备的读写操作，然后深入去阅读Onix的磁盘IO驱动，代码路径：kernel&#x2F;ide.c，我的重心在文件系统的架构，所以Onix最底层的磁盘IO驱动就跳过了。笔者重点要讲的是Onix的虚拟设备实现层。</p>\n<p>Onix对虚拟设备的实现定义了如下虚拟设备控制结构体：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> name[NAMELEN];  <span class=\"comment\">// 设备名</span></span><br><span class=\"line\">    <span class=\"type\">int</span> type;            <span class=\"comment\">// 设备类型</span></span><br><span class=\"line\">    <span class=\"type\">int</span> subtype;         <span class=\"comment\">// 设备子类型</span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> dev;           <span class=\"comment\">// 设备号</span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> parent;        <span class=\"comment\">// 父设备号</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *ptr;           <span class=\"comment\">// 设备指针</span></span><br><span class=\"line\">    <span class=\"type\">list_t</span> request_list; <span class=\"comment\">// 块设备请求链表</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> direct;         <span class=\"comment\">// 磁盘寻道方向</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设备控制</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*ioctl)(<span class=\"type\">void</span> *dev, <span class=\"type\">int</span> cmd, <span class=\"type\">void</span> *args, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">    <span class=\"comment\">// 读设备</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*read)(<span class=\"type\">void</span> *dev, <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> count, <span class=\"type\">idx_t</span> idx, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">    <span class=\"comment\">// 写设备</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*write)(<span class=\"type\">void</span> *dev, <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> count, <span class=\"type\">idx_t</span> idx, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">&#125; <span class=\"type\">device_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>针对IO设备，抽象出了ioctl、read、write接口，这样，每种IO设备只需根据实际情况实现回调函数，任何IO设备都能被实例化成该结构体，并且我们即将讲解的minix（onix文件系统类型）文件系统也能更好的对IO设备做适配。</p>\n<p>Onix当中对IO设备的设备类型按读取的粒度分成了两类：字符设备（单字节）和块设备（1024为一快）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设备类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">device_type_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    DEV_NULL,  <span class=\"comment\">// 空设备</span></span><br><span class=\"line\">    DEV_CHAR,  <span class=\"comment\">// 字符设备</span></span><br><span class=\"line\">    DEV_BLOCK, <span class=\"comment\">// 块设备</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>设备子类型（也即具体的设备）就多了，比如：控制台、键盘、串口、磁盘、磁盘分区、软盘等。设备子类型定义在枚举类型 <code>enum device_subtype_t</code> 当中。</p>\n<p>Onix的设备抽象层，为了保证磁盘IO的正确性，其实也存在类似XV6的IO请求队列的设计，它的核心代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 块设备请求</span></span><br><span class=\"line\"><span class=\"type\">err_t</span> <span class=\"title function_\">device_request</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">void</span> *buf, u8 count, <span class=\"type\">idx_t</span> idx, <span class=\"type\">int</span> flags, u32 type)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">device_t</span> *device = device_get(dev);</span><br><span class=\"line\">    <span class=\"type\">request_t</span> *req = kmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"type\">request_t</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断列表是否为空</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> empty = list_empty(&amp;device-&gt;request_list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将请求插入链表</span></span><br><span class=\"line\">    list_insert_sort(&amp;device-&gt;request_list, &amp;req-&gt;node, element_node_offset(<span class=\"type\">request_t</span>, node, idx));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果列表不为空，则阻塞，因为已经有请求在处理了，等待处理完成；</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!empty)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        req-&gt;task = running_task();</span><br><span class=\"line\">        assert(task_block(req-&gt;task, <span class=\"literal\">NULL</span>, TASK_BLOCKED, TIMELESS) == EOK);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// do io</span></span><br><span class=\"line\">    <span class=\"type\">err_t</span> ret = do_request(req);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 跑一轮电梯算法，获取紧挨着req的下一个任务执行IO</span></span><br><span class=\"line\">    <span class=\"type\">request_t</span> *nextreq = request_nextreq(device, req);</span><br><span class=\"line\"></span><br><span class=\"line\">    list_remove(&amp;req-&gt;node);</span><br><span class=\"line\">    kfree(req);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 唤醒新队头</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextreq)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        assert(nextreq-&gt;task-&gt;magic == ONIX_MAGIC);</span><br><span class=\"line\">        task_unblock(nextreq-&gt;task, EOK);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Onix IO请求队列的逻辑更加清晰易懂：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_ide.drawio.png\"></p>\n<p>流程如下：</p>\n<blockquote>\n<ol>\n<li>进程调用磁盘IO接口 <code>device_request</code>。</li>\n<li>为IO请求分配一个句柄req。</li>\n<li>将req利用插入排序，升序插入请求队列。</li>\n<li>如果在该任务插入到队列前，队列非空，就当前阻塞进程。说明已经有进程在执行IO任务。</li>\n<li>如果在该任务插入到队列前，队列为空，由当前进程执行IO操作。</li>\n<li>依据电梯算法，获取到紧挨着req的下一个IO请求任务reqnext。</li>\n<li>从请求队列当中移除req。</li>\n<li>唤醒reqnext进程。注意可以确定的是，在请求队列当中只有一个进程是活跃状态其他进程都处于阻塞状态，所以在reqnext此前必定为阻塞状态，在这里我们需要唤醒它。</li>\n</ol>\n</blockquote>\n<p>Onix实现了比XV6更高效的磁盘调度算法——电梯算法。电梯算法能有效避免饥饿现象，比简单的先来先服务（FCFS）更高效，减少了磁头移动距离，能够有效平衡响应时间和吞吐量。</p>\n<p>电梯算法的工作原理：<strong>磁头（电梯）沿一个方向移动（比如向上），处理该方向上所有的请求。到达该方向的最后一个请求后，改变方向（向下），处理反方向上的请求。如此往复循环，就像电梯在楼层间上下运行一样。</strong></p>\n<p>Onix电梯算法实现函数request_nextreq如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获得下一个请求</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">request_t</span> *<span class=\"title function_\">request_nextreq</span><span class=\"params\">(<span class=\"type\">device_t</span> *device, <span class=\"type\">request_t</span> *req)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">list_t</span> *<span class=\"built_in\">list</span> = &amp;device-&gt;request_list;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (device-&gt;direct == DIRECT_UP &amp;&amp; req-&gt;node.next == &amp;<span class=\"built_in\">list</span>-&gt;tail) &#123;</span><br><span class=\"line\">        device-&gt;direct = DIRECT_DOWN;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (device-&gt;direct == DIRECT_DOWN &amp;&amp; req-&gt;node.prev == &amp;<span class=\"built_in\">list</span>-&gt;head) &#123;</span><br><span class=\"line\">        device-&gt;direct = DIRECT_UP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">void</span> *next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (device-&gt;direct == DIRECT_UP) &#123;</span><br><span class=\"line\">        next = req-&gt;node.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        next = req-&gt;node.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == &amp;<span class=\"built_in\">list</span>-&gt;head || next == &amp;<span class=\"built_in\">list</span>-&gt;tail) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> element_entry(<span class=\"type\">request_t</span>, node, next);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"磁盘块缓存层\"><a href=\"#磁盘块缓存层\" class=\"headerlink\" title=\"磁盘块缓存层\"></a>磁盘块缓存层</h2><p>OS对磁盘的任何访问都是基于块的，XV6当中，一个磁盘块的大小为512字节，Onix当中，默认为1024字节。如果我们每次访问文件都直接从磁盘上去读取，显然大部分时间都被浪费在磁盘IO上。所以，为了提高效率，内存（高速设备）和磁盘（低速设备）之间必然需要缓存层。本小节以Onix的代码为主。代码参考：onix-dev&#x2F;src&#x2F;kernel&#x2F;buffer.c</p>\n<p>缓存层主要作用是：在在有限的内存当中，<strong>缓存访问频率最高的部分磁盘块</strong>。那么我们如何定性一个磁盘块的访问频率是高还是低呢？这就得靠大名鼎鼎的LRU算法。在CMU15445实验1当中可以学习到更高级的LRU算法——LRU-K算法、在LevelDB当中.sst文件结构的缓存也是用到了LRU算法。Onix实现的磁盘块缓存层使用的是最朴素的LRU算法。</p>\n<p>本节简单介绍一下Onix当中LRU算法运行逻辑。</p>\n<p>首先假设LRU相关数据结构的初始状态如下图：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache.drawio.png\"></p>\n<p>如图所示，LRU算法涉及的基本数据结构包括：哈希表和链表。</p>\n<ul>\n<li>空闲链表 <code>idle_list</code>:  一旦OS对缓存块的引用为0，缓存块就会被放入到空闲链表。当OS需要读取一块没有缓存到内存的磁盘块时，就会触发LRU替换策略，LRU替换策略会将空闲链表当中最久未被访问过的缓存块写回磁盘，并且将缓存块的内容覆盖成新的磁盘块。空闲链表的插入和删除的逻辑非常重要，LRU替换策略实现的关键。</li>\n<li>哈希表: 记录已经缓存的磁盘块。用于快速查找缓存的磁盘块。</li>\n</ul>\n<p>磁盘块的读取：</p>\n<ul>\n<li><p>有被缓存到内存（这里假设要读 <code>block1</code>）：</p>\n<ol>\n<li>根据哈希算法 <code> (设备号 ^ 块号) % 哈希表长度</code> 获取block1的所在哈希数组的位置，这里block1计算所得哈希数组索引为0。</li>\n<li>遍历链表，得到buffer1。</li>\n<li>将buffer1的引用计数加一。</li>\n<li>从idle_list当中移除buffer1，防止缓存块被替换出磁盘。</li>\n</ol>\n<p>  最终，结构如下：<br>  <img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio.png\"></p>\n</li>\n<li><p>没有被缓存到内存（这里假设要读 <code>block4</code>）：</p>\n<ol>\n<li>基于idle_list执行LRU替换策略。从idle_list可以了解到，idle_list的最后一个元素即为我们需要的 最久未被访问过的缓存块。也就是本节最开始所放图片当中的buffer3。</li>\n<li>将buffer3写回磁盘（如果标记为脏）。并从哈希表当中去除buffer3。</li>\n<li>将block4读到buffer3。</li>\n<li>根据哈希算法，计算block4所在哈希表的位置。这里假设计算block4的哈希值为1，并将block4插入到哈希表。</li>\n</ol>\n<p>  最终，结构如下：<br>  <img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache2.drawio.png\"></p>\n</li>\n</ul>\n<p>磁盘块的释放：</p>\n<ol>\n<li><p>假设，现在要释放buffer4，将缓存块的引用计数减一。</p>\n</li>\n<li><p>当缓存块引用计数变为0时，将缓存块挂到idle_list开头。这样可以确保idle_list当中缓冲块从左到右，最后一次访问时间越来越长。</p>\n<p> 最终，结构如下：<br> <img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache3.drawio.png\"></p>\n</li>\n</ol>\n<h2 id=\"事务层（日志层）\"><a href=\"#事务层（日志层）\" class=\"headerlink\" title=\"事务层（日志层）\"></a>事务层（日志层）</h2><h3 id=\"日志层简介\"><a href=\"#日志层简介\" class=\"headerlink\" title=\"日志层简介\"></a>日志层简介</h3><p>事务层是XV6所拥有的模块，在Onix当中并不存在，所以，本节会以XV6为主进行叙述。在XV6的文档当中，将事务层称为日志层。不管是日志层还是事务层，作用都是一样的。<strong>旨在实现错误恢复</strong> 的机制，保证磁盘上文件系统的一致性。</p>\n<p>依我的理解，其实linux文件系统本身就是一个通用数据库。像mysql、oracle、leveldb等数据库存在一些共有问题（包括：一致性、错误恢复等问题），解决问题的思想或多或少都借鉴linux的文件系统的实现。</p>\n<p>文件系统设计中最有趣的问题之一就是错误恢复，产生这样的问题是因为大多数的文件系统都涉及到对磁盘多次的写操作，如果在写操作的过程当中系统崩溃了，就会使得磁盘上的文件系统处于不一致的状态中。举例来说，根据写的顺序的不同，上述错误可能会导致一个目录项指向一个空闲的 i 节点，或者产生一个已被分配但是未被引用的块。后一种情况相对来说好一些，但在前一种情况中，目录项指向了一个空闲的 i 节点，重启之后就会导致非常严重的问题。</p>\n<p>xv6 通过简单的日志系统来解决文件操作过程当中崩溃所导致的问题。一个系统调用并不直接导致对磁盘上文件系统的写操作，相反，他会把一个对磁盘写操作的描述包装成一个日志写在磁盘中。当系统调用把所有的写操作都写入了日志，它就会写一个特殊的提交记录到磁盘上，代表一次完整的操作。从那时起，系统调用就会把日志中的数据写入磁盘文件系统的数据结构中。在那些写操作都成功完成后，系统调用就会删除磁盘上的日志文件。</p>\n<p>为什么日志可以解决文件系统操作中出现的崩溃呢？如果崩溃发生在操作提交之前，那么磁盘上的日志文件就不会被标记为已完成，恢复系统的代码就会忽视它，磁盘的状态正如这个操作从未执行过一样。如果是在操作提交之后崩溃的，恢复程序会重演所有的写操作，可能会重复之前已经进行了的对磁盘文件系统的写操作。在任何一种情况下，日志文件都使得磁盘操作对于系统崩溃来说是原子操作：在恢复之后，要么所有的写操作都完成了，要么一个写操作都没有完成。</p>\n<h3 id=\"日志层设计——日志的磁盘结构\"><a href=\"#日志层设计——日志的磁盘结构\" class=\"headerlink\" title=\"日志层设计——日志的磁盘结构\"></a>日志层设计——日志的磁盘结构</h3><p>首先，这里可以放上一张XV6当中文件系统在磁盘上的结构图：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_fsstructureondisk.png\"></p>\n<p>可以直观看到，我们的日志信息被放在磁盘分区最末尾的位置。</p>\n<p>然后，你需要感到疑惑的是：那么末尾的日志信息具体的内部结构是啥？要弄清这个问题，就需要我们深入查看xv6的代码了，日志层实现代码位于log.c文件，我们直接来到initlog函数的实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">logheader</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> n;</span><br><span class=\"line\">  <span class=\"type\">int</span> block[LOGSIZE];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">log</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">spinlock</span> <span class=\"title\">lock</span>;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> start;</span><br><span class=\"line\">  <span class=\"type\">int</span> size;</span><br><span class=\"line\">  <span class=\"type\">int</span> outstanding; <span class=\"comment\">// how many FS sys calls are executing.</span></span><br><span class=\"line\">  <span class=\"type\">int</span> committing;  <span class=\"comment\">// in commit(), please wait.</span></span><br><span class=\"line\">  <span class=\"type\">int</span> dev;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">logheader</span> <span class=\"title\">lh</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">log</span> <span class=\"title\">log</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">initlog</span><span class=\"params\">(<span class=\"type\">int</span> dev)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">superblock</span> <span class=\"title\">sb</span>;</span></span><br><span class=\"line\">  initlock(&amp;<span class=\"built_in\">log</span>.lock, <span class=\"string\">&quot;log&quot;</span>);</span><br><span class=\"line\">  readsb(dev, &amp;sb);</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.start = sb.logstart;</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.size = sb.nlog;</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.dev = dev;</span><br><span class=\"line\">  recover_from_log();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>首先可以看到初始化函数从超级快当中获取了日志的起始块 <code>sb.logstart</code> 和 日志磁盘块数限制 <code>sb.nlog</code>。</p>\n</li>\n<li><p>然后调用了recover_from_log函数，在系统初始化阶段，尝试进行磁盘错误恢复，recover_from_log函数实现如下：</p>\n<ol>\n<li>调用read_head函数，读取前面拿到的日志起始块，日志起始块结构如下： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">logheader</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"type\">int</span> block[LOGSIZE];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n 简单来说，成员n代表block数组的有效长度，而block数组，其实表示日志起始块之后的日志块 和 文件（磁盘）的数据块的映射关系。这点在介绍install_trans函数时会更有体会。</li>\n<li>调用install_trans函数，进行差错恢复，将上一次关机记录在日志块的没有提交完的数据重新提交。确保文件系统的一致性： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copy committed blocks from log to their home location</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">install_trans</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> tail;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (tail = <span class=\"number\">0</span>; tail &lt; <span class=\"built_in\">log</span>.lh.n; tail++) &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> *<span class=\"title\">lbuf</span> =</span> bread(<span class=\"built_in\">log</span>.dev, <span class=\"built_in\">log</span>.start+tail+<span class=\"number\">1</span>); <span class=\"comment\">// read log block</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> *<span class=\"title\">dbuf</span> =</span> bread(<span class=\"built_in\">log</span>.dev, <span class=\"built_in\">log</span>.lh.block[tail]); <span class=\"comment\">// read dst</span></span><br><span class=\"line\">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class=\"comment\">// copy block to dst</span></span><br><span class=\"line\">    bwrite(dbuf);  <span class=\"comment\">// write dst to disk</span></span><br><span class=\"line\">    brelse(lbuf);</span><br><span class=\"line\">    brelse(dbuf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n 仔细阅读代码可以了解到，就是顺序将日志起始块后面的日志块读出，然后根据起始块提供的文件（磁盘）数据块映射数组，将日志块拷贝到文件（磁盘）的数据块当中。<strong>并且同步到磁盘</strong></li>\n<li>将日志起始块的logheader::n改为0，意味着日志的清空，标志着事务的完成。这一步也就是本节最开头所谓的“特殊的提交记录”。</li>\n</ol>\n</li>\n</ol>\n<p>综上所述，磁盘当中日志的结构如下图：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio.png\"></p>\n<h3 id=\"日志层设计——日志的封装\"><a href=\"#日志层设计——日志的封装\" class=\"headerlink\" title=\"日志层设计——日志的封装\"></a>日志层设计——日志的封装</h3><p>首先是日志写操作——log_write函数，xv6规定，所有文件的写操作，都使用log_write函数进行，并且log_write函数必须在begin_op函数和end_op函数之间调用。在进程每次写一些缓存块后都会调用log_write函数。该函数只做两件事：</p>\n<ol>\n<li>将被修改的缓存块的块号记录到logheader.block数组当中。</li>\n<li>将缓存块标记为脏。</li>\n</ol>\n<p>需要明确的是：进程对文件任何写操作都是基于被缓存到内存的缓存块。写操作开始并未同步到磁盘块。真正的同步操作是在commit函数当中进行。</p>\n<p>事务包装函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// called at the start of each FS system call.</span></span><br><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">begin_op</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  acquire(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.committing)&#123;</span><br><span class=\"line\">      sleep(&amp;<span class=\"built_in\">log</span>, &amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.lh.n + (<span class=\"built_in\">log</span>.outstanding+<span class=\"number\">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// this op might exhaust log space; wait for commit.</span></span><br><span class=\"line\">      sleep(&amp;<span class=\"built_in\">log</span>, &amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">log</span>.outstanding += <span class=\"number\">1</span>;</span><br><span class=\"line\">      release(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// called at the end of each FS system call.</span></span><br><span class=\"line\"><span class=\"comment\">// commits if this was the last outstanding operation.</span></span><br><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">end_op</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> do_commit = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  acquire(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.outstanding -= <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.committing)</span><br><span class=\"line\">    panic(<span class=\"string\">&quot;log.committing&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.outstanding == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    do_commit = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">log</span>.committing = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// begin_op() may be waiting for log space,</span></span><br><span class=\"line\">    <span class=\"comment\">// and decrementing log.outstanding has decreased</span></span><br><span class=\"line\">    <span class=\"comment\">// the amount of reserved space.</span></span><br><span class=\"line\">    wakeup(&amp;<span class=\"built_in\">log</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  release(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(do_commit)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// call commit w/o holding locks, since not allowed</span></span><br><span class=\"line\">    <span class=\"comment\">// to sleep with locks.</span></span><br><span class=\"line\">    commit();</span><br><span class=\"line\">    acquire(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">    <span class=\"built_in\">log</span>.committing = <span class=\"number\">0</span>;</span><br><span class=\"line\">    wakeup(&amp;<span class=\"built_in\">log</span>);</span><br><span class=\"line\">    release(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>仔细阅读begin_op和end_op函数的源码，可以了解到，<strong>xv6允许多个进程在begin_op和end_op之间执行事务。但是，提交操作只能由最后一个执行完的进程执行，并且提交期间，其他要执行事务的进程都将被阻塞在begin_op函数。</strong>假设存在A、B、C三个进程要执行一组写操作。ABC都调用begin_op函数，然后对缓存块进行修改。此时 <code>log.outstanding</code> 为3。而A、B的写操作很快执行完调用end_op因为<code>log.outstanding</code>非0而直接退出，只有C执行完后，<code>log.outstanding</code> 为0，才能执行提交操作。并且在执行提交操作期间，其他任何准备执行事务的进程都将阻塞在begin_op函数。这里体现了xv6文档当中提到的：任何时候只能有一个进程在一个会话之中，其他进程必须等待当前会话中的进程结束。因此同一时刻日志最多只记录一次会话。</p>\n<p>xv6 不允许并发会话，目的是为了避免下面几种问题。假设会话 X 把一个对 i 节点的修改写入了会话中。并发的会话 Y 从同一块中读出了另一个 i 节点，更新了它，把 i 节点块写入了日志并且提交。这就会导致可怕的后果：Y 的提交导致被 X 修改过的 i 节点块被写入磁盘，而 X 此时并没有提交它的修改。如果这时候发生崩溃会使得 X 的修改只应用了一部分而不是全部，从而打破会话是原子的这一性质。有一些复杂的办法可以解决这个问题，但 xv6 直接通过不允许并行的会话来回避这个问题。</p>\n<p>commit函数实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">commit</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">log</span>.lh.n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    write_log();     <span class=\"comment\">// Write modified blocks from cache to log</span></span><br><span class=\"line\">    write_head();    <span class=\"comment\">// Write header to disk -- the real commit</span></span><br><span class=\"line\">    install_trans(); <span class=\"comment\">// Now install writes to home locations</span></span><br><span class=\"line\">    <span class=\"built_in\">log</span>.lh.n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    write_head();    <span class=\"comment\">// Erase the transaction from the log</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从注释当中可以直观了解到，干了如下4件事：</p>\n<blockquote>\n<ol>\n<li>将被改动的文件缓存块<strong>同步追加到日志（磁盘）块</strong>当中。</li>\n<li>更新日志（磁盘）起始块logheader磁盘结构。</li>\n<li>将日志块同步到适合的文件（磁盘）数据块当中。</li>\n<li>清空日志块。</li>\n</ol>\n</blockquote>\n<p>xv6 使用固定量的磁盘空间来保存日志。系统调用写入日志的块的总大小不能大于日志的总大小。所以源码当中，会有很多预防日志过大导致空间不足的处理措施。比如限制每个进程每次事务操作最大写数量，或者在空间不足时，阻塞进程，直到有足够可用空间被唤醒。</p>\n<h2 id=\"虚拟文件系统实现层\"><a href=\"#虚拟文件系统实现层\" class=\"headerlink\" title=\"虚拟文件系统实现层\"></a>虚拟文件系统实现层</h2><p>本小节将借Onix Minix文件系统的实现，解答虚拟文件神秘的面纱。在此之前，你一定对linux的文件系统有许多疑惑：</p>\n<ul>\n<li>为什么一个int类型的fd能代表文件？</li>\n<li>都说fd代表进程内核文件描述数组的下标，那么文件描述数组类型本身是什么？</li>\n<li>一块256G的磁盘，linux怎么做到让每个文件打开，能从0开始顺序读写，就好像每个文件都占用了独立的磁盘一样？</li>\n<li>IO设备、网络套接字、管道等怎么被抽象成fd，可以使用统一的系统调用的？</li>\n</ul>\n<h3 id=\"i节点初步介绍\"><a href=\"#i节点初步介绍\" class=\"headerlink\" title=\"i节点初步介绍\"></a>i节点初步介绍</h3><p>这里从i节点作为切入。</p>\n<p>i 节点这个术语可以有两个的意思。（对于常规文件系统）它可以指的是磁盘上的记录文件类型、文件大小、数据块扇区号的数据结构。也可以指内存中的一个 i 节点代理，它包含了i节点（实体）描述符、文件系统类型、文件操作回调等。</p>\n<p>简单来说，一个i节点对应一个虚拟文件。并且，对于常规的文件系统，i节点分：内存结构、磁盘结构，这两种结构并不等同，内存i节点代理会引用磁盘上的i节点。</p>\n<p>超级快代理和i节点代理的内存结构，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">super_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *desc;           <span class=\"comment\">// 超级块描述符</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buffer_t</span> *<span class=\"title\">buf</span>;</span> <span class=\"comment\">// 超级块描述符 buffer</span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> dev;            <span class=\"comment\">// 设备号</span></span><br><span class=\"line\">    u32 count;            <span class=\"comment\">// 引用计数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> type;             <span class=\"comment\">// 文件系统类型</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> sector_size;   <span class=\"comment\">// 扇区大小</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> block_size;    <span class=\"comment\">// 块大小</span></span><br><span class=\"line\">    <span class=\"type\">list_t</span> inode_list;    <span class=\"comment\">// 使用中 inode 链表</span></span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *iroot;       <span class=\"comment\">// 根目录 inode</span></span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *imount;      <span class=\"comment\">// 安装到的 inode</span></span><br><span class=\"line\">&#125; <span class=\"type\">super_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">list_node_t</span> node; <span class=\"comment\">// 链表结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">void</span> *desc; <span class=\"comment\">// inode 描述符（可能是 磁盘i节点、套接字结构体、管道结构体等。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buffer_t</span> *<span class=\"title\">buf</span>;</span> <span class=\"comment\">// inode 描述符对应 buffer</span></span><br><span class=\"line\">        <span class=\"type\">void</span> *addr;           <span class=\"comment\">// pipe 缓冲地址</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> dev;  <span class=\"comment\">// 设备号</span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> rdev; <span class=\"comment\">// 虚拟设备号</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> nr;     <span class=\"comment\">// i 节点号</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> count; <span class=\"comment\">// 引用计数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">time_t</span> atime; <span class=\"comment\">// 访问时间</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span> mtime; <span class=\"comment\">// 修改时间</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span> ctime; <span class=\"comment\">// 创建时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> mount; <span class=\"comment\">// 安装设备</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">mode_t</span> mode; <span class=\"comment\">// 文件模式</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size; <span class=\"comment\">// 文件大小</span></span><br><span class=\"line\">    <span class=\"type\">int</span> type;    <span class=\"comment\">// 文件系统类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> uid; <span class=\"comment\">// 用户 id</span></span><br><span class=\"line\">    <span class=\"type\">int</span> gid; <span class=\"comment\">// 组 id</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">super_t</span> *<span class=\"title\">super</span>;</span>   <span class=\"comment\">// 超级块</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fs_op_t</span> *<span class=\"title\">op</span>;</span>      <span class=\"comment\">// 文件系统操作</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_t</span> *<span class=\"title\">rxwaiter</span>;</span> <span class=\"comment\">// 读等待进程</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_t</span> *<span class=\"title\">txwaiter</span>;</span> <span class=\"comment\">// 写等待进程</span></span><br><span class=\"line\">&#125; <span class=\"type\">inode_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>对于inode_t::type字段，onix当中有如下可选值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    FS_TYPE_NONE = <span class=\"number\">0</span>,</span><br><span class=\"line\">    FS_TYPE_PIPE,</span><br><span class=\"line\">    FS_TYPE_SOCKET,</span><br><span class=\"line\">    FS_TYPE_MINIX,</span><br><span class=\"line\">    FS_TYPE_NUM,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>虚拟文件系统将所有的IO操作都抽象成了这样一个i节点——inode_t。这里主要提一下 <code>inode_t::desc</code> 这个成员，如果i节点对应文件的话（FS_TYPE_MINIX），inode_t::desc会被赋值成 <code>minix_inode_t</code> 也就是i节点在磁盘上的数据结构；如果i节点对应网络套接字（FS_TYPE_SOCKET），那么inode_t::desc会被赋值成 <code>socket_t</code>。如果i节点对应管道（FS_TYPE_PIPE），那么inode_t::desc会被赋值成 <code>fifo_t</code>。</p>\n<p>本文主要介绍FS_TYPE_MINIX类型的i节点。minix文件系统初始化函数会向数组 <code>fs_ops</code> 当中注册一组minix文件系统专用回调函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">fs_op_t</span> minix_op = &#123;</span><br><span class=\"line\">    minix_mkfs,</span><br><span class=\"line\">    minix_super,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_open,</span><br><span class=\"line\">    minix_close,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_read,</span><br><span class=\"line\">    minix_write,</span><br><span class=\"line\">    minix_truncate,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_stat,</span><br><span class=\"line\">    minix_permission,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_namei,</span><br><span class=\"line\">    minix_mkdir,</span><br><span class=\"line\">    minix_rmdir,</span><br><span class=\"line\">    minix_link,</span><br><span class=\"line\">    minix_unlink,</span><br><span class=\"line\">    minix_mknod,</span><br><span class=\"line\">    minix_readdir,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">minix_init</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    fs_register_op(FS_TYPE_MINIX, &amp;minix_op);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果需要实现新的文件系统，仿照minix，只需实现上面所列的必要回调函数即可。使用minix文件系统创建的i节点inode_t::op都会被赋值成minix_op。</p>\n<p>下面可以先了解一下minix文件系统在磁盘上的结构：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio.png\"></p>\n<p>各字段起始位置和作用如下表：</p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">起始位置</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">超级块</td>\n<td align=\"center\">块1</td>\n<td align=\"center\">记录i节点位图所占块数、（磁盘数据块）逻辑块位图所占块数、第一个逻辑块号等解析文件系统的关键信息</td>\n</tr>\n<tr>\n<td align=\"center\">i节点位图</td>\n<td align=\"center\">块2</td>\n<td align=\"center\">管理磁盘i节点分配情况</td>\n</tr>\n<tr>\n<td align=\"center\">（磁盘数据块）逻辑块位图</td>\n<td align=\"center\">块2 + super-&gt;imap_blocks</td>\n<td align=\"center\">管理磁盘数据块分配情况</td>\n</tr>\n<tr>\n<td align=\"center\">i节点</td>\n<td align=\"center\">块2 + super-&gt;imap_blocks + super-&gt;zmap_blocks</td>\n<td align=\"center\">磁盘i节点数组</td>\n</tr>\n<tr>\n<td align=\"center\">（磁盘数据块）逻辑块</td>\n<td align=\"center\">minix_super_t::firstdatazone</td>\n<td align=\"center\">磁盘数据块数组</td>\n</tr>\n</tbody></table>\n</blockquote>\n<h3 id=\"i节点的分配与释放\"><a href=\"#i节点的分配与释放\" class=\"headerlink\" title=\"i节点的分配与释放\"></a>i节点的分配与释放</h3><p>上面提到，由于i节点在虚拟文件系统当中有两种存在形式，所以本小节i节点的分配与释放也是分为两种。当需要创建文件时我们需要分配一个i节点，当文件需要被删除（文件磁盘i节点引用计数减为零）时我们需要释放这一个i节点。</p>\n<p>首先对于磁盘i节点的分配与释放，磁盘i节点分配&#x2F;释放的管理由磁盘上 i节点位图 和 磁盘i节点数组 共同管理，它们的起始位置在上小结已给出。所有的磁盘上的 i 节点都被统一存放在一个称为 i 节点数组的连续区域中。每一个 i 节点的大小都是一样的，所以对于一个给定的数字n，很容易找到磁盘上对应的 i 节点。事实上这个给定的数字就是操作系统中 i 节点的编号。</p>\n<p>磁盘上的 i 节点由结构体 <code>minix_inode_t</code> 定义。<code>mode</code> 域用来区分文件、目录和特殊文件。nlink 域用来记录指向了这一个 i 节点的目录项，这是用于判断一个 i 节点是否应该被释放的。size 域记录了文件的字节数。<code>zone</code> 数组用于这个文件的数据块的块号。在后面 <strong>虚拟文件的打开&#x2F;读写&#x2F;关闭</strong> 小结就会看到，每个文件采用 <code>zone</code> 数组管理文件数据的方式非常巧妙，该数组就是每个文件都能从0偏移开始读取和写入，看起来像多块磁盘的原因。</p>\n<p>i节点和超级快磁盘结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minix_inode_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    u16 mode;    <span class=\"comment\">// 文件类型和属性(rwx 位)</span></span><br><span class=\"line\">    u16 uid;     <span class=\"comment\">// 用户id（文件拥有者标识符）</span></span><br><span class=\"line\">    u32 size;    <span class=\"comment\">// 文件大小（字节数）</span></span><br><span class=\"line\">    u32 mtime;   <span class=\"comment\">// 修改时间戳 这个时间戳应该用 UTC 时间，不然有瑕疵</span></span><br><span class=\"line\">    u8 gid;      <span class=\"comment\">// 组id(文件拥有者所在的组)</span></span><br><span class=\"line\">    u8 nlinks;   <span class=\"comment\">// 链接数（多少个文件目录项指向该i 节点）</span></span><br><span class=\"line\">    u16 zone[<span class=\"number\">9</span>]; <span class=\"comment\">// 直接 (0-6)、间接(7)或双重间接 (8) 逻辑块号</span></span><br><span class=\"line\">&#125; <span class=\"type\">minix_inode_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minix_super_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    u16 inodes;        <span class=\"comment\">// 节点数</span></span><br><span class=\"line\">    u16 zones;         <span class=\"comment\">// 逻辑块数</span></span><br><span class=\"line\">    u16 imap_blocks;   <span class=\"comment\">// i 节点位图所占用的数据块数</span></span><br><span class=\"line\">    u16 zmap_blocks;   <span class=\"comment\">// 逻辑块位图所占用的数据块数</span></span><br><span class=\"line\">    u16 firstdatazone; <span class=\"comment\">// 第一个数据逻辑块号</span></span><br><span class=\"line\">    u16 log_zone_size; <span class=\"comment\">// log2(每逻辑块数据块数)</span></span><br><span class=\"line\">    u32 max_size;      <span class=\"comment\">// 文件最大长度</span></span><br><span class=\"line\">    u16 magic;         <span class=\"comment\">// 文件系统魔数</span></span><br><span class=\"line\">&#125; <span class=\"type\">minix_super_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>磁盘i节点分配&#x2F;释放的核心函数是 <code>minix_ialloc</code> 和 <code>minix_ifree</code>。分配函数首先会从超级块当中定位i节点位图的起始位置和长度。然后遍历i节点位图，找到一个可用i节点编号，将位图置为true（占用）并返回。minix_ialloc只负责从磁盘上找到一个可用的i节点编号返回给调用者，其他的什么也不做。<code>minix_ifree</code> 就是 <code>minix_ialloc</code> 逆过程，将分配的i节点编号对应的位图置为false（可分配）。两函数代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分配一个文件系统 inode</span></span><br><span class=\"line\"><span class=\"type\">idx_t</span> <span class=\"title function_\">minix_ialloc</span><span class=\"params\">(<span class=\"type\">super_t</span> *super)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bit = EOF;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;imap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_BITS, i * BLOCK_BITS);</span><br><span class=\"line\">        bit = bitmap_scan(&amp;<span class=\"built_in\">map</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bit != EOF)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            assert(bit &lt; desc-&gt;inodes);</span><br><span class=\"line\">            buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo 调试期间强同步</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bit;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放一个文件系统 inode</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">minix_ifree</span><span class=\"params\">(<span class=\"type\">super_t</span> *super, <span class=\"type\">idx_t</span> idx)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    assert(idx &lt; desc-&gt;inodes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;imap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &gt; BLOCK_BITS * (i + <span class=\"number\">1</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_BITS, i * BLOCK_BITS);</span><br><span class=\"line\">        assert(bitmap_test(&amp;<span class=\"built_in\">map</span>, idx));</span><br><span class=\"line\">        bitmap_set(&amp;<span class=\"built_in\">map</span>, idx, <span class=\"number\">0</span>);</span><br><span class=\"line\">        buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo 调试期间强同步</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用者得到i节点编号后，可以通过 <code>iget</code> 函数<strong>将i节点编号转为i节点代理</strong>。它的逻辑是这样的，先尝试在现有内存i节点代理当中根据i节点编号查找i节点，如果查到了，就直接返回，否则调用 <code>get_free_inode</code> 函数先从空闲的i节点代理缓存当中获取一个空闲i节点代理，再将i节点编号转为磁盘i节点所在块号，然后将磁盘i节点所在磁盘块缓存到内存获取磁盘上的i节点，然后对空闲的i节点代理进行初始化。</p>\n<p>i节点代理的核心初始化步骤包括：</p>\n<blockquote>\n<ul>\n<li>将inode_t::desc填充成 磁盘i节点缓存地址。</li>\n<li>inode::buf填充成 磁盘i节点所在块缓存地址，inode::buf指向 磁盘i节点所在块缓存地址 这样能保证 磁盘i节点所在块缓存 的引用计数非零，防止inode_t::desc所指向的磁盘i节点缓存地址 因磁盘块的lru算法被置换出内存而失效。</li>\n<li>如果i节点对应的是IO设备，而非文件，将inode_t::rdev填充为minix_inode_t::zone[0]，对于设备文件，minix_inode_t::zone[0]表示IO设备的虚拟设备号。</li>\n<li>inode_t::super填充成所在设备的超级快。同一设备上的文件系统，超级快是相同的！</li>\n<li>inode_t::type设置成FS_TYPE_MINIX。</li>\n<li>并且inode_t::op安装成FS_TYPE_MINIX对应的回调。</li>\n</ul>\n</blockquote>\n<p>核心代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BLOCK_INODES (BLOCK_SIZE / sizeof(minix_inode_t))    <span class=\"comment\">// 1个磁盘块能容纳 inode的数量</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计算 inode nr 对应的块号</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">idx_t</span> <span class=\"title function_\">inode_block</span><span class=\"params\">(<span class=\"type\">minix_super_t</span> *desc, <span class=\"type\">idx_t</span> nr)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// inode 编号 从 1 开始</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> + desc-&gt;imap_blocks + desc-&gt;zmap_blocks + (nr - <span class=\"number\">1</span>) / BLOCK_INODES;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将i节点编号转为i节点代理</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">inode_t</span> *<span class=\"title function_\">iget</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">idx_t</span> nr)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *inode = find_inode(dev, nr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inode)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        inode-&gt;count++;</span><br><span class=\"line\">        inode-&gt;atime = time();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">super_t</span> *super = get_super(dev);</span><br><span class=\"line\">    assert(super);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(nr &lt;= desc-&gt;inodes);</span><br><span class=\"line\"></span><br><span class=\"line\">    inode = get_free_inode();</span><br><span class=\"line\">    inode-&gt;dev = dev;</span><br><span class=\"line\">    inode-&gt;nr = nr;</span><br><span class=\"line\">    inode-&gt;count++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加入超级块 inode 链表</span></span><br><span class=\"line\">    list_push(&amp;super-&gt;inode_list, &amp;inode-&gt;node);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> block = inode_block(desc, inode-&gt;nr);</span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = bread(inode-&gt;dev, block);</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;buf = buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将缓冲视为一个 inode 描述符数组，获取对应的指针；</span></span><br><span class=\"line\">    inode-&gt;desc = &amp;((<span class=\"type\">minix_inode_t</span> *)buf-&gt;data)[(inode-&gt;nr - <span class=\"number\">1</span>) % BLOCK_INODES];</span><br><span class=\"line\">    <span class=\"type\">minix_inode_t</span> *minode = (<span class=\"type\">minix_inode_t</span> *)inode-&gt;desc;</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;rdev = minode-&gt;zone[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;mode = minode-&gt;mode;</span><br><span class=\"line\">    inode-&gt;size = minode-&gt;size;</span><br><span class=\"line\">    inode-&gt;super = super;</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;type = FS_TYPE_MINIX;</span><br><span class=\"line\">    inode-&gt;op = fs_get_op(FS_TYPE_MINIX);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与iget对立的是iput函数，该函数定义在onix-dev&#x2F;src&#x2F;fs&#x2F;inode.c，函数iput用于将i节点代理进行释放，iput会借助 minix_close 函数，一旦inode_t::count成员减为零，就将inode::buf（磁盘i节点所在块缓存）释放，然后将i节点代理放回空闲缓存区。</p>\n<h3 id=\"磁盘数据块的分配与释放\"><a href=\"#磁盘数据块的分配与释放\" class=\"headerlink\" title=\"磁盘数据块的分配与释放\"></a>磁盘数据块的分配与释放</h3><p>onix当中，文件系统文件的数据存在于分散的磁盘数据块当中。文件使用磁盘上的i节点minix_inode_t::zone数组管理磁盘数据块。文件创建后，向里面不断顺序写入数据，一旦当前磁盘数据块写满了，文件系统就会调用 <code>minix_balloc</code> 函数给文件分配一块磁盘数据块。相反的，如果一个文件需要被删除，调用 <code>minix_bfree</code> 函数释放所有分配的磁盘数据块。磁盘块同样采用位图的方式去管理。</p>\n<p>磁盘数据块分配释放&#x2F;器的原理和 磁盘i节点分配&#x2F;释放器（<code>minix_ialloc</code> 和 <code>minix_ifree</code>）极其类似。磁盘数据块分配器首先会从超级块当中定位磁盘数据块位图的起始位置和长度。然后遍历磁盘数据块位图，找到一个可用磁盘数据块号，将位图置为true（占用）并返回。minix_ialloc只负责从磁盘上找到一个可用的磁盘数据块号返回给调用者，其他的什么也不做。<code>minix_bfree</code> 就是 <code>minix_balloc</code> 逆过程，将分配的磁盘数据块号对应的位图置为false（可分配）。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分配一个文件块</span></span><br><span class=\"line\"><span class=\"type\">idx_t</span> <span class=\"title function_\">minix_balloc</span><span class=\"params\">(<span class=\"type\">super_t</span> *super)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bit = EOF;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span> + desc-&gt;imap_blocks;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;zmap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将整个缓冲区作为位图</span></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_SIZE, i * BLOCK_BITS + desc-&gt;firstdatazone - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从位图中扫描一位</span></span><br><span class=\"line\">        bit = bitmap_scan(&amp;<span class=\"built_in\">map</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bit != EOF)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果扫描成功，则 标记缓冲区脏，中止查找</span></span><br><span class=\"line\">            assert(bit &lt; desc-&gt;zones);</span><br><span class=\"line\">            buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo 调试期间强同步</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bit;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放一个文件块</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">minix_bfree</span><span class=\"params\">(<span class=\"type\">super_t</span> *super, <span class=\"type\">idx_t</span> idx)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    assert(idx &lt; desc-&gt;zones);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span> + desc-&gt;imap_blocks;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;zmap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 跳过开始的块</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &gt; BLOCK_BITS * (i + <span class=\"number\">1</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将整个缓冲区作为位图</span></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_SIZE, BLOCK_BITS * i + desc-&gt;firstdatazone - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将 idx 对应的位图置位 0</span></span><br><span class=\"line\">        assert(bitmap_test(&amp;<span class=\"built_in\">map</span>, idx));</span><br><span class=\"line\">        bitmap_set(&amp;<span class=\"built_in\">map</span>, idx, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 标记缓冲区脏</span></span><br><span class=\"line\">        buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo 调试期间强同步</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"根文件系统的挂载\"><a href=\"#根文件系统的挂载\" class=\"headerlink\" title=\"根文件系统的挂载\"></a>根文件系统的挂载</h3><p>在onix初始化阶段在使用文件系统之前，必须先对根目录进行挂载。我们使用系统调用 <code>open</code> 函数打开的文件时，需要传入路径作为参数，而想要通过路径找到最终文件的i节点，必经过根目录的i节点。任何路径的解析，都以根目录为基础的。所以，分析onix根目录的挂载流程是很重要的。</p>\n<p>根文件系统挂载触发点位于super_init函数：</p>\n<ul>\n<li>super_init函数首先会初始化全局超级块表，为后续文件系统挂载做准备，每个超级块维护一个inode链表，用于管理该文件系统打开的文件节点，超级块表初始化完毕后，会调用mount_root函数。</li>\n<li>mount_root函数首先获取磁盘第一个分区的虚拟设备控制句柄，然后从设备控制句柄当中获取设备号dev（方便读写），然后调用read_super函数获取dev设备的超级快。最后将<strong>超级块和根目录i节点代理做绑定</strong>，方便将路径解析为i节点。  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 挂载根文件系统</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">mount_root</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    LOGK(<span class=\"string\">&quot;Mount root file system...\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 假设主硬盘第一个分区是根文件系统</span></span><br><span class=\"line\">    <span class=\"type\">device_t</span> *device = device_find(DEV_IDE_PART, <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(device);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 读根文件系统超级块</span></span><br><span class=\"line\">    root = read_super(device-&gt;dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 超级快和根目录i节点代理做绑定。</span></span><br><span class=\"line\">    root-&gt;imount = root-&gt;iroot;</span><br><span class=\"line\">    root-&gt;imount-&gt;count++;</span><br><span class=\"line\"></span><br><span class=\"line\">    root-&gt;iroot-&gt;mount = device-&gt;dev;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>read_super函数首先会尝试使用设备号dev从超级快列表当中直接获取超级快，但由于系统刚启动，正处在初始化阶段，所以，必然失败。然后read_super函数会尝试从超级块列表当中获取一个空闲的超级快，然后调用minix_super函数对空闲超级快进行初始化。  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读设备 dev 的超级块</span></span><br><span class=\"line\"><span class=\"type\">super_t</span> *<span class=\"title function_\">read_super</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">super_t</span> *super = get_super(dev);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (super) &#123;</span><br><span class=\"line\">        super-&gt;count++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> super;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOGK(<span class=\"string\">&quot;Reading super block of device %d\\n&quot;</span>, dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获得空闲超级块</span></span><br><span class=\"line\">    super = get_free_super();</span><br><span class=\"line\">    super-&gt;count++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">1</span>; i &lt; FS_TYPE_NUM; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">fs_op_t</span> *op = fs_get_op(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!op)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"comment\">// minix_super</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (op-&gt;super(dev, super) == EOK) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> super;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    put_super(super);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>minix_super函数实现较为简单，通过读取磁盘的 磁盘块1 （在前面的列出的磁盘分区结构图当中有列出，超级块位于1号磁盘块），将 磁盘超级快 读到内存当中，然后将磁盘超级块缓存填充到super_t::desc，当然为了避免磁盘超级块缓存被替换出磁盘，将磁盘超级快所在的磁盘块缓存填充给super_t::buf，最后调用 iget 函数获取根目录的i节点代理（按规定，根目录磁盘i节点的编号为1）。  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">minix_super</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">super_t</span> *super)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 读取超级块</span></span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = bread(dev, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!buf)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EFSUNK;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(buf);</span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)buf-&gt;data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (desc-&gt;magic != MINIX1_MAGIC) &#123;</span><br><span class=\"line\">        brelse(buf);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EFSUNK;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    super-&gt;buf = buf;</span><br><span class=\"line\">    super-&gt;desc = desc;</span><br><span class=\"line\">    super-&gt;dev = dev;</span><br><span class=\"line\">    super-&gt;type = FS_TYPE_MINIX;</span><br><span class=\"line\">    super-&gt;block_size = BLOCK_SIZE;</span><br><span class=\"line\">    super-&gt;sector_size = SECTOR_SIZE;</span><br><span class=\"line\">    super-&gt;iroot = iget(dev, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>注意 <code>super-&gt;iroot</code> 成员的初始化被放在了最后，这里是一定要放在最后。如果你深入阅读 iget 函数的代码就会发现 iget函数 里面需要用到超级块如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">inode_t</span> *<span class=\"title function_\">iget</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">idx_t</span> nr)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *inode = find_inode(dev, nr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inode) &#123;</span><br><span class=\"line\">        inode-&gt;count++;</span><br><span class=\"line\">        inode-&gt;atime = time();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">super_t</span> *super = get_super(dev);</span><br><span class=\"line\">    assert(super);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等等，我们正在初始化超级快，但是 iget 函数又用到了超级快，这样对吗？我的回答是没有任何毛病，因为 在minix_super超级快初始化函数当中最后一刻才调用了iget函数，此时超级快其实已经初始化的差不多了，并且iget函数内部也并没有用到 <code>super-&gt;iroot</code> 成员，所以逻辑并没有什么问题。</p>\n<h3 id=\"虚拟文件的打开-关闭\"><a href=\"#虚拟文件的打开-关闭\" class=\"headerlink\" title=\"虚拟文件的打开&#x2F;关闭\"></a>虚拟文件的打开&#x2F;关闭</h3><p>onix当中，使用open函数打开一个文件，如果要创建以一个文件，实际上使用的是带 <code>O_CREAT | O_TRUNC</code> 标志的open函数，我们只需要重点研究open系统调用 <code>sys_open</code> 的实现，伪代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">fd_t</span> <span class=\"title function_\">sys_open</span><span class=\"params\">(<span class=\"type\">char</span> *filename, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> mode)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *next;</span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *dir = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取filename父目录i节点代理，并且，将最后的文件名填到next当中。</span></span><br><span class=\"line\">    dir = named(filename, &amp;next);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果路径本身是目录（/a/b/）。跳过minix文件系统open回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*next) &#123;</span><br><span class=\"line\">        inode = dir;</span><br><span class=\"line\">        dir-&gt;count++;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> makeup;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 调用minix文件系统open回调。打开/创建文件。</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ret = dir-&gt;op-&gt;open(dir, next, flags, mode, &amp;inode);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从进程文件表（数组）当中获取一个空闲的文件描述符，并且初始化其元素file_t。</span></span><br><span class=\"line\">    <span class=\"type\">file_t</span> *file;</span><br><span class=\"line\">    <span class=\"type\">fd_t</span> fd = fd_get(&amp;file);</span><br><span class=\"line\"></span><br><span class=\"line\">    file-&gt;inode = inode;</span><br><span class=\"line\">    file-&gt;flags = flags;</span><br><span class=\"line\">    file-&gt;count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    file-&gt;offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 有追加参数就将file的偏移移到文件末尾。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags &amp; O_APPEND) &#123;</span><br><span class=\"line\">        file-&gt;offset = file-&gt;inode-&gt;size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>调用named函数，获取filename父目录i节点代理，并且，将最后的文件名填到next当中。</li>\n<li>如果路径本身是目录（&#x2F;a&#x2F;b&#x2F;）。跳过minix文件系统open回调。进入4。</li>\n<li>调用minix的open回调，打开&#x2F;创建文件。获取文件的i节点代理。</li>\n<li>从进程文件表（数组）当中获取一个空闲的文件描述符，并且初始化其元素file_t。</li>\n<li>如果flags标志包含 <code>O_APPEND</code> ，将file的偏移移到文件末尾。</li>\n</ol>\n</blockquote>\n<p>named函数的作用就是根据路径找到文件父目录的i节点，并且将最后的文件名填到next当中。named函数代码稍微有些复杂，特别是这一段：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取 pathname 对应的父目录 inode</span></span><br><span class=\"line\"><span class=\"type\">inode_t</span> *<span class=\"title function_\">named</span><span class=\"params\">(<span class=\"type\">char</span> *pathname, <span class=\"type\">char</span> **next)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回上一级目录且上一级目录是个挂载点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (match_name(name, <span class=\"string\">&quot;..&quot;</span>, next) &amp;&amp; dir == dir-&gt;super-&gt;iroot) &#123;</span><br><span class=\"line\">            <span class=\"type\">super_t</span> *super = dir-&gt;super;</span><br><span class=\"line\">            inode = super-&gt;imount;</span><br><span class=\"line\">            inode-&gt;count++;</span><br><span class=\"line\">            iput(dir);</span><br><span class=\"line\">            dir = inode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果路径 <code>name</code>（基于pathname经过预处理的路径） 解析到了 <code>..</code> 文件名并且（同一文件系统下）其父目录正好是设备的根节点，就会进入该if分支。因为linux当中一切皆文件的思想，（跨文件系统）父目录可能是作为子目录的挂载点而存在，导致父目录和子目录不在一个设备（文件系统）上。故我们在跨文件系统的情况下执行 <code>..</code> 目录回退操作时，必须执行这样一段 “换根” 代码。</p>\n<p>这段if换根代码强烈建议读者结合 <code>sys_mknod</code> 和 <code>sys_mount</code> 函数实现去理解。在onix当中（参考：onix-dev&#x2F;src&#x2F;fs&#x2F;dev.c），挂载一个设备首先要使用 sys_mknod 系统调用为设备创建一个设备文件，然后，在根文件系统下寻找一个目录作为挂载点，最后使用 sys_mount 系统调用挂载设备。</p>\n<p>下面深入介绍一下onix当中如何实现设备挂载的：</p>\n<p>挂载点内部数据结构链接细节如下图：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_mount.drawio.png\"></p>\n<p>sys_mknod会接收设备号作为参数。它的实现最终会调用minix_mknod函数，这会创建一个特殊的文件，我们称它为设备文件，然后文件的磁盘i节点当中zone数组只使用第一个元素，存放传入的设备号，在将磁盘i节点转成i节点代理过程当中，i节点代理的rdev成员就会被赋值成minode-&gt;zone[0]，minix_mknod伪代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">minix_mknod</span><span class=\"params\">(<span class=\"type\">inode_t</span> *dir, <span class=\"type\">char</span> *name, <span class=\"type\">int</span> mode, <span class=\"type\">int</span> dev)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 创建一个特殊的文件。</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ISBLK(mode) || ISCHR(mode))</span><br><span class=\"line\">        minode-&gt;zone[<span class=\"number\">0</span>] = dev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sys_mount函数负责将一个设备文件挂载到指定目录下。比如sd卡，一般来说，它的设备文件名为&#x2F;dev&#x2F;sdb1，当我们要访问sd卡时，需要执行命令 <code>mount /dev/sdb1 /mnt</code> 。<strong>这里需要注意的是，sd卡所有的文件系统 和 我们的根目录所挂载的文件系统一定是两个独立的互不相干的两个文件系统，他们各自拥有自己独立、自包含的i节点编号空间。在同一个Linux系统下，SD卡上文件的i节点号与根文件系统下文件的i节点号即使数字相同，也绝对不会发生冲突。系统能够清晰地区分它们。</strong> onix sys_mount函数实现伪代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sys_mount</span><span class=\"params\">(<span class=\"type\">char</span> *devname, <span class=\"type\">char</span> *dirname, <span class=\"type\">int</span> flags)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取设备文件i节点代理</span></span><br><span class=\"line\">    devinode = namei(devname);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取挂载点i节点代理</span></span><br><span class=\"line\">    dirinode = namei(dirname);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取设备超级块</span></span><br><span class=\"line\">    super = read_super(devinode-&gt;rdev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设备超级快指向挂载点</span></span><br><span class=\"line\">    super-&gt;imount = dirinode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 挂载点指向挂载的设备</span></span><br><span class=\"line\">    dirinode-&gt;mount = devinode-&gt;rdev;</span><br><span class=\"line\">    iput(devinode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>核心逻辑如下：</p>\n<blockquote>\n<ol>\n<li>获取设备文件i节点代理。</li>\n<li>获取挂载点i节点代理。</li>\n<li>获取设备超级块。</li>\n<li>将设备超级块指向挂载点。</li>\n<li>挂载点指向挂载的设备。</li>\n</ol>\n</blockquote>\n<p>sys_open当中核心函数还是中间调用的minix_open回调，它的伪代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">minix_open</span><span class=\"params\">(<span class=\"type\">inode_t</span> *dir, <span class=\"type\">char</span> *name, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> mode, <span class=\"type\">inode_t</span> **result)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">minix_dentry_t</span> *entry = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在dir下尝试查找name文件，并将目录项存到entry。</span></span><br><span class=\"line\">    buf = find_entry(dir, name, &amp;next, &amp;entry);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buf) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果找到了根据目录项将 i节点号转为i节点代理。iget函数是老朋友了，前面小结经常用到。</span></span><br><span class=\"line\">        inode = iget(dir-&gt;dev, entry-&gt;nr);</span><br><span class=\"line\">        assert(inode);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> makeup;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// 不存在</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 不带创建标志，返回文件不存在的错误。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(flags &amp; O_CREAT)) &#123;</span><br><span class=\"line\">        ret = -EEXIST;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 向父目录当中添加名为name的文件项。并且返回其文件项缓存块地址，确保entry有效。</span></span><br><span class=\"line\">    buf = add_entry(dir, name, &amp;entry);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 申请一个i节点号。</span></span><br><span class=\"line\">    entry-&gt;nr = minix_ialloc(dir-&gt;super);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化磁盘i节点和i节点代理。</span></span><br><span class=\"line\">    inode = new_inode(dir-&gt;dev, entry-&gt;nr);</span><br><span class=\"line\"></span><br><span class=\"line\">makeup:</span><br><span class=\"line\">    <span class=\"comment\">// 传给输出参数。</span></span><br><span class=\"line\">    *result = inode;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先明确：sys_open调用minix_open，传入的name是单个文件名，dir是name文件的父目录i节点。</p>\n<blockquote>\n<ol>\n<li>调用find_entry函数，首先在dir下尝试查找name文件，并将目录项存到entry。如果找到了，根据目录项将 i节点号转为i节点代理，并快进到 <code>makeup</code> 阶段。iget函数是老朋友了，前面小结经常用到。如果没找到，尝试去创建一个新文件。</li>\n<li>检测是否带 <code>O_CREAT</code> 标志，不带标志就返回文件不存在的错误。</li>\n<li>调用add_entry函数向父目录当中添加名为name的文件项。并且返回其文件项缓存块地址，确保entry有效。</li>\n<li>申请一个i节点号。</li>\n<li>初始化磁盘i节点和i节点代理。</li>\n</ol>\n</blockquote>\n<p>有关 <code>find_entry</code> 和 <code>add_entry</code> 函数，这两函数属于目录操作函数，在 <strong>目录的操作</strong> 小结将深入展开讲解。</p>\n<p>踪上，一个进程打开一个文件后，系统状态图如下：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio.png\"></p>\n<h3 id=\"虚拟文件的读-写\"><a href=\"#虚拟文件的读-写\" class=\"headerlink\" title=\"虚拟文件的读&#x2F;写\"></a>虚拟文件的读&#x2F;写</h3><p>如果说超级块是更高维度的能解析文件系统的磁盘结构，那么i节点其实可以理解成低维度的能解析文件的磁盘结构。</p>\n<p>在 <strong>i节点的分配与释放</strong> 小结已经列出过i节点的磁盘结构，但因为文章结构原因我们没有多费口舌去讲解它具体成员的作用。在本节，因为文件的操作是极度依赖i节点磁盘结构的。所以，下面用一张图片直观了解i节点的磁盘结构：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio.png\"></p>\n<p>一般的，i节点磁盘数据结构各个字段作用如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">i节点字段名</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">minix_inode_t::mode</td>\n<td align=\"center\">文件类型和属性位，onix支持的文件类型包含：常规文件、目录文件、字符设备文件、块设备文件。文件屬性包含：读、写、可执行。</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::uid</td>\n<td align=\"center\">用户id，也即文件拥有者标识符</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::size</td>\n<td align=\"center\">文件大小（Byte）</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::mtime</td>\n<td align=\"center\">最后修改的时间戳</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::gid</td>\n<td align=\"center\">用户所属组id</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::nlinks</td>\n<td align=\"center\">链接数，表示有多少目录项指向该i节点</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::zone</td>\n<td align=\"center\">长度为9的uint16_t类型数组，前7个元素代表直接块，直接指向磁盘数据块，第8个元素为一级间接块，第9个元素为二级间接块</td>\n</tr>\n</tbody></table>\n<p>磁盘i节点的设计非常精妙，前面部分存放文件属性，<strong>后面的数组 <code>minix_inode_t::zone</code> 是你打开每一个文件，都能从0偏移开始读取的根本原因</strong>。如果你有仔细研究过onix&#x2F;xv6内存管理当中内存虚拟内存机制，你会发现，i节点对文件数据块的管理 和 虚拟内存的页表-页框-页目录机制思想一模一样。</p>\n<p>尽管物理上磁盘只有一块，i节点磁盘数据结构这种 直接块-间接块-双重间接块 机制让虚拟文件系统当中的每个文件都像独占一块磁盘一样，使（实际上）非连续空间连续化，可以从偏移0位置开始顺序读写数据。同时，在这种机制的加持下，更便于磁盘块的管理，增加零散磁盘块的利用率。</p>\n<p>有了上面i节点管理数据块的理论知识，下面让我们一步步了解 <code>sys_read</code> 和 <code>sys_write</code> 系统调用的实现。</p>\n<p>首先是 <code>sys_read</code> 函数，伪代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sys_read</span><span class=\"params\">(<span class=\"type\">fd_t</span> fd, <span class=\"type\">char</span> *buf, <span class=\"type\">int</span> count)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((ret = fd_check(fd, &amp;file)) &lt; EOK)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *inode = file-&gt;inode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> len = inode-&gt;op-&gt;read(inode, buf, count, file-&gt;offset);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        file-&gt;offset += len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>首先将fd转换为文件表项 <code>file_t</code> 。</li>\n<li>由文件表项获得文件的i节点代理。</li>\n<li>调用 minix read 回调读取数据。</li>\n</ol>\n</blockquote>\n<p>直接来到了minix read 回调——minix_read。该函数根据传入的要读的数据长度len和文件偏移offset来来逐块读取数据。如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从 inode 的 offset 处，读 len 个字节到 buf</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">minix_read</span><span class=\"params\">(<span class=\"type\">inode_t</span> *inode, <span class=\"type\">char</span> *data, <span class=\"type\">int</span> len, <span class=\"type\">off_t</span> offset)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">minix_inode_t</span> *minode = (<span class=\"type\">minix_inode_t</span> *)inode-&gt;desc;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ISCHR(minode-&gt;mode)) &#123;</span><br><span class=\"line\">        assert(minode-&gt;zone[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> device_read(minode-&gt;zone[<span class=\"number\">0</span>], data, len, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ISBLK(minode-&gt;mode)) &#123;</span><br><span class=\"line\">        assert(minode-&gt;zone[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"type\">device_t</span> *device = device_get(minode-&gt;zone[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        assert(len % BLOCK_SIZE == <span class=\"number\">0</span>);</span><br><span class=\"line\">        assert(device_read(minode-&gt;zone[<span class=\"number\">0</span>], data, len / BLOCK_SIZE, offset / BLOCK_SIZE, <span class=\"number\">0</span>) == EOK);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(ISFILE(minode-&gt;mode) || ISDIR(minode-&gt;mode));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果偏移量超过文件大小，返回 EOF</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset &gt;= minode-&gt;size) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 开始读取的位置</span></span><br><span class=\"line\">    u32 begin = offset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 剩余字节数</span></span><br><span class=\"line\">    u32 left = MIN(len, minode-&gt;size - offset);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 找到对应的文件便宜，所在文件块</span></span><br><span class=\"line\">        <span class=\"type\">idx_t</span> nr = minix_bmap(inode, offset / BLOCK_SIZE, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        assert(nr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 读取文件块缓冲</span></span><br><span class=\"line\">        <span class=\"type\">buffer_t</span> *buf = bread(inode-&gt;dev, nr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 文件块中的偏移量</span></span><br><span class=\"line\">        u32 start = offset % BLOCK_SIZE;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 本次需要读取的字节数</span></span><br><span class=\"line\">        u32 chars = MIN(BLOCK_SIZE - start, left);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新 偏移量 和 剩余字节数</span></span><br><span class=\"line\">        offset += chars;</span><br><span class=\"line\">        left -= chars;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 文件块中的指针</span></span><br><span class=\"line\">        <span class=\"type\">char</span> *ptr = buf-&gt;data + start;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 拷贝内容</span></span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(data, ptr, chars);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新缓存位置</span></span><br><span class=\"line\">        data += chars;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 释放文件块缓冲</span></span><br><span class=\"line\">        brelse(buf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新访问时间</span></span><br><span class=\"line\">    inode-&gt;atime = time();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回读取数量</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> offset - begin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数逻辑如下：</p>\n<blockquote>\n<ol>\n<li>判断文件类型，如果是字符设备或者块设备，就根据minode-&gt;zone[0]获取到设备的设备号，然后调用虚拟设备回调函数，去读取数据并返回。如果是普通文件&#x2F;目录，继续下面步骤。</li>\n<li>普通文件的话，进入while循环，调用minix_bmap函数基于i节点的zone数组将offset转换为数据所在磁盘块。</li>\n<li>获取磁盘块缓存。</li>\n<li>读取 <code>MIN(BLOCK_SIZE - start, left)</code> 长的数据。</li>\n<li>如果读取的数据不够len字节，重复2~4步骤。</li>\n</ol>\n</blockquote>\n<p>那么，minix_bmap函数是怎么实现的呢？onix对minix_bmap稍微有些复杂。这里附上我的想法，我觉得可以重用 <a href=\"https://blog.csdn.net/m0_52566365/article/details/139525258\">这才是计科之 Onix &amp; XV6 源码分析（2、类Unix的内存管理）</a> 的做法。思想就是基于 i节点的磁盘结构图 对offset进行划分，如下：</p>\n<blockquote>\n<ul>\n<li>如果 offset 在直接块覆盖范围内，直接通过zone数组读取数据块即可。</li>\n<li>如果 offset 在一级间接块覆盖范围内。<ul>\n<li>首先将offset减去直接块所能表示的最大地址。</li>\n<li>将offset看成虚拟磁盘地址，然后由 <code>(offset &amp; 0x7FC00) &gt;&gt; 10</code> 公式获取虚拟磁盘地址高9位作为一级间接块的数组（元素为uint16_t）索引，然后取得磁盘数据块号后，将offset末尾的10位作为磁盘数据块内偏移。 获取块内偏移的公式：<code>offset &amp; 0x3FF</code> ，最终获得到物理磁盘地址。</li>\n</ul>\n</li>\n<li>如果 offset 在二级间接块覆盖范围内。<ul>\n<li>首先将offset减去直接块 + 一级间接块所能表示的最大地址。</li>\n<li>将offset看成虚拟磁盘地址，然后由 <code>(offset &amp; 0xFF80000) &gt;&gt; 10</code> 公式获取虚拟磁盘地址高9位作为一级间接块的数组（元素为uint16_t）索引，取得二级间接块号后，根据公式 <code>(offset &amp; 0x7FC00) &gt;&gt; 10</code> 得到二级间接块数组（元素同样为uint16_t）索引，取得磁盘数据块号后，将offset末尾的10位作为磁盘数据块内偏移。 获取块内偏移的公式：<code>offset &amp; 0x3FF</code> ，最终获得到物理磁盘地址。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>但是， <strong>由于onix规定zone数组元素类型为uint16_t，所以这决定了onix最大能表示的磁盘块号为2^16 - 1， 故onix的磁盘有效大小的上限为 64MB。</strong> 当然，作为学习操作系统，我们就不必太过于精益求精。</p>\n<p>文件系统的写，是读的逆过程，代码逻辑极其相似，行文至此，篇幅过多，这里就不带着大家读代码了，建议读者亲自去扒一扒onix的源码。</p>\n<h3 id=\"目录的操作\"><a href=\"#目录的操作\" class=\"headerlink\" title=\"目录的操作\"></a>目录的操作</h3><p>最后就是文件系统目录的操作，这里主要讲解两个函数：<code>find_entry</code> 和 <code>add_entry</code>。面对目录，只需要记住一点，目录其实就是一个 文件内容被规定死的 普通文件。目录文件会存放一个个目录条目，onix当中目录条目数据结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 文件目录项结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minix_dentry_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    u16 nr;              <span class=\"comment\">// i 节点</span></span><br><span class=\"line\">    <span class=\"type\">char</span> name[NAME_LEN]; <span class=\"comment\">// 文件名</span></span><br><span class=\"line\">&#125; <span class=\"type\">minix_dentry_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>目录项图解如下：</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_dentry.drawio.png\"></p>\n<p>在onix当中，find_entry函数为了找到目标目录项会使用for循环遍历传进来的目录的所有目录项。</p>\n<p>add_entry同样会遍历目录的目录项，直到找到一个 <code>nr</code> 成员为0的目录项，在onix当中，nr为0意味这该目录项未被占用。所以相应的，如果你想删除一个目录项，只需将对应的nr置为0即可。onix的minix_rmdir函数也正是这样做的。</p>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"这才是计科之 Onix & XV6 源码分析（3、Unix-like系统的进程调度模块）","date":"2024-06-08T04:00:00.000Z","_content":"\n## 前言\n\n前面已经分析了XV6的启动流程以及内存管理，接下来，我们探究进程调度的实现。与其说进程调度，我觉得可以顺应内存的虚拟化的叫法，将进程调度称为“CPU的虚拟化”更加贴切。\n\n首先明确目前XV6的cpu的状态如下：关中断 & 进入了保护模式 & 安装了包括【内核&用户】【代码&数据】段描述符 & BSP分配了一个4K的内核栈 & 开启了以kmap为基础的粒度为4K的内核分页。\n\nOnix相关链接：\n\n- [github仓库链接](https://github.com/StevenBaby/onix)。\n\n- [B站配套视频链接](https://www.bilibili.com/video/BV1qM4y127om/)。\n\nXV6-x86的github链接：\n\n- [链接](https://github.com/mit-pdos/xv6-public)。\n\n<!-- more -->\n\n## 中断机制\n\n对于中断的部分，这里会涉及大量硬件相关的知识，由于博主的目的是了解OS的基本框架，所以硬件相关的知识储备可能不会太深，如果你是想弄清某个硬件具体实现，这篇博客可能不适合你。\n\n这里总结一下我对中断的理解：\n\n引发中断的方式有三种：外中断、异常、软中断。\n\n- 外中断：就是由外部中断控制器通知 CPU 某个事件完成了，比如：磁盘寻道完成可以进行读写了、UART输入寄存器非空（可读）、UART输出寄存器为空（可写）、键盘缓冲有数据了（可读）等等。\n\n- 异常是 CPU 在执行过程中，因为出错而执行不下去了，比如：除零异常、因为虚拟页面还没映射发生缺页异常、对只读段进行写操作触发段错误异常等等。\n\n- 软中断，可以认为是应用程序和操作系统沟通的一种方式，运行在低优先级程序想要对硬件做IO，但是由于只有处于特权级的内核能够直接和设备打交道，从而低优先级程序必须通过某种机制来完成特权级转换，这种机制就是软中断。我们也可以将实现这种功能的函数称为系统调用。\n\n如有些教科书那样，我们也可以把异常和软中断统称为 内中断，也就是这个中断时 CPU 和 软件内部产生的，与外部硬件无关。\n\n### Onix单核处理器的中断原理\n\n单核PC机上，一般会采用（主从）两片 8259a PIC（programmable interrupt controller），将PIC的INT引脚接到CPU的一个引脚上，如下图，图片引用自onix的文档，如有侵权，可告知删除：\n\n![](./Scheduler/photo/scheduler/8259a.drawio.png)\n\n从图中可以看到有两个8259a，上面那个8259a是主PIC，它的INT引脚直接接到CPU上；下面那个8259a的INT引脚接到主PIC的IR2引脚，所以它是从PIC。 每一个PIC的引脚会接一个外设，（如果对应的引脚没被屏蔽的话）外设会通过PIC间接向CPU发中断。\n\n在PIC正式工作前，需要对其进行一系列初始化。初始化操作由cpu发送一系列的控制字完成。有两类控制字：\n\n- 初始化命令字 (Initialization Command Words, ICW), ICW 共 4 个， ICW1 ~ ICW4；\n\n- 操作命令字 (Operation Command Word, OCW), OCW 共 3 个， OCW1 ~ OCW3；\n\nICW 做初始化，用来确定是否需要级联，设置起始中断向量号，设置中断结束模式。因为某些设置之间是具有依赖性的，也许后面的某个设置会依赖前面某个 ICW 写入的设置，所以这部分要求严格的顺序，**必须依次写入** ICW1、ICW2、ICW3、ICW4；\n\nOCW 来操作控制 8259A，中断的屏蔽和中断处理结束就是通过往 8259A 端口发送 OCW 实现的。OCW 的发送顺序不固定，3 个之中先发送哪个都可以。\n\n**具体细节非常推荐读者去阅读一下Onix文档，讲的真的很细致**：https://github.com/StevenBaby/onix/blob/dev/docs/04%20%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F/033%20%E5%A4%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.md\n\n8259a中断控制器的初始化就是一种固定套路，截取Onix代码如下：\n\n```cpp\n#define PIC_M_CTRL 0x20 // 主片的控制端口\n#define PIC_M_DATA 0x21 // 主片的数据端口\n#define PIC_S_CTRL 0xa0 // 从片的控制端口\n#define PIC_S_DATA 0xa1 // 从片的数据端口\n#define PIC_EOI 0x20    // 通知中断控制器中断结束\n\n// 初始化中断控制器\nvoid pic_init()\n{\n    // 主PIC\n    outb(PIC_M_CTRL, 0b00010001); // ICW1: 边沿触发, 级联 8259, 需要ICW4.\n    outb(PIC_M_DATA, 0x20);       // ICW2: 起始中断向量号 0x20\n    outb(PIC_M_DATA, 0b00000100); // ICW3: IR2接从片.\n    outb(PIC_M_DATA, 0b00000001); // ICW4: 8086模式, 正常EOI\n\n    // 从PIC\n    outb(PIC_S_CTRL, 0b00010001); // ICW1: 边沿触发, 级联 8259, 需要ICW4.\n    outb(PIC_S_DATA, 0x28);       // ICW2: 起始中断向量号 0x28\n    outb(PIC_S_DATA, 2);          // ICW3: 设置从片连接到主片的 IR2 引脚\n    outb(PIC_S_DATA, 0b00000001); // ICW4: 8086模式, 正常EOI\n\n    outb(PIC_M_DATA, 0b11111111); // OCW1：屏蔽字，关闭主PIC所有中断，后面需要什么中断再依据需求打开。\n    outb(PIC_S_DATA, 0b11111111); // OCW1：屏蔽字，关闭从PIC所有中断，后面需要什么中断再依据需求打开。\n}\n```\n\nCPU在处理每个外中断后，需要向PIC发生一个结束字为的是通知PIC中断处理结束，具体中断结束方式由OCW2 来设置。代码如下：\n\n```cpp\n// 通知中断控制器，中断处理结束\nvoid send_eoi(int vector)\n{\n    if (vector >= 0x20 && vector < 0x28)\n    {\n        outb(PIC_M_CTRL, PIC_EOI);\n    }\n    if (vector >= 0x28 && vector < 0x30)\n    {\n        outb(PIC_M_CTRL, PIC_EOI);\n        outb(PIC_S_CTRL, PIC_EOI);\n    }\n}\n```\n\n至此单核OS中断的初始化到这里就结束了。\n\n### XV6多核处理的中断原理\n\n多核处理器中断控制器的结构更为复杂，因为偏向硬件，这里就只记录一下我对APIC的理解，理解不会太深，如果有错误，非常欢迎读者纠正！\n\n首先还是供上架构框图：\n\n![](./Scheduler/photo/scheduler/APICStructure.png)\n\n图片截取自：https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\n\n注释：\n\nBSP：bootstrap processor，可以简单理解为主处理器。\n\nAPx：application processors ，可以简单理解为从处理器。\n\n关于BSP和APx的关系这里先埋个伏笔。在【AP（从）处理器的启动】段落会进行详细叙述。\n\n从图中的上半部分可以了解到，每个CPU各自接着一个Local APIC（Advanced Programmable Interrupt Controller）。注意，**每个lapic和cpu是封装在一起的**（这里并不严谨，是否和cpu封装在一起其实和cpu的架构有关）。后面我们会看到，不止APIC，在多核cpu上，它的每一个cpu都有自己的一套cpu寄存器，比如：esp、eip、eflag等等。具体情况我们在“进程调度”段落进行详细讲解。\n\n从图的下半部分，我们可以了解到所有的lapic都接到了ICC（interrupt controller communications） Bus上，并且，总线上还接了一个IO APIC，这里的**ioapic是和cpu分离的**，它被接在cpu的外部。**ioapic会接收来自各个外设的中断。然后对各个外设发来的中断做一些判断和处理，再将中断的IRQ号和lapic的ID封装在一条“报文”中分发給对应的lapic**，具体发给哪些lapic，我们可以通过配置ioapic来进行设置。ioapic左边其实是有很多引脚（实际16个，如果级联了8259a可能会更多）每个引脚都可以接外设。有趣的是，从图中ioapic的左边可以看到，**ioapic的引脚还可以接8259a PIC控制器**，这非常完美的兼容了单核cpu的中断控制器的架构。\n\niopic是依据重定向表项 RTE(Redirection Table Entry)来构建“报文“，RTE对每一个中断都会有一项64位的entry。通过entry，可以单独设置ioapic在收到中断后对中断的操作。每一项entry描述：中断对应的中断向量？中断有没有使能？中断传输状态？发给哪个lapic？\n\n每个lapic都有一个唯一的ID，cpu可以在特定的内存（device space）上来查询自己所对应的lapic的ID号，lapic的ID其实也唯一标识了一个cpu。lapic会根据自己的ID从ICC Bus上接收属于自己的中断”报文“，然后经过一系列检查最后将中断发给cpu，当cpu处理完中断后，会反馈给自己的lapic，lapic收到cpu的回复后，同样将中断处理完毕的消息通知给ioapic，这点和单核架构中，cpu处理完中断后向master pic发送PIC_EOI是一样的道理。\n\n特别的是，lapic也可以像ioapic那样作为中断“源”（这里可能不严谨，但是可以类比去理解），向其他的lapic发送中断“报文”，这是通过ICR(Interrupt Command Register)寄存器实现，ICR的结构和ioapic的RTE表的entry结构类似，也有中断向量号、lapic的ID等字段。lapic主动向其他lapic发送中断“报文”最常见的场景就是BSP去启动其他APs，这一般通过会发送INIT or STARTUP IPI（interprocessor interrupts）。\n\n由于XV6中cpu对lapic、iopic初始化代码上，依赖于mpinit函数，而mpinit和多处理器内容相关，所以lapic、iopic初始化我们放到\"AP（从）处理器的启动\"段落进行讨论。\n\n关于Local APIC和IO APIIC详细内容可以参考博客：https://blog.csdn.net/weixin_46645613/article/details/119207945\n\n### 中断描述符表\n\n之前一直在介绍中断相关的外设，接下来我们看看cpu内部是怎么利用寄存器来定义中断的。\n\n因为中断不止一个，所以，和全局描述符类表似，中断表也是通过一个大的数组来记录每一个中断的属性。数组中每一个Entry格式如下图，每一个Entry同样是8个字节：\n\n![](./Scheduler/photo/scheduler/IDT_Entry.png)\n\n- Offset：记录中断门或陷阱门的处理函数的地址。\n\n- Selector：处理函数的段选择子。\n\n- Type：标记是中断门还是陷阱门。 **注意：中断门会自动清除eflag寄存器的FL_IF标志位，而陷阱门则保留eflag的FL_IF标志位。** 也即中断门会i自动关（外）中断，而陷阱门则不会有关中断的操作！\n\n- S：必须为0。\n\n- DPL：描述符可以被哪个特权级使用。对于中断门一般是0x0，对于陷阱门就是0x3（DPL_USER）。\n\n- P：是否有效，固定填1.\n\nXV6相关代码注释写的非常好，上面的中文注释也是参考XV6的注释写的，如下：\n\n```cpp\n// Gate descriptors for interrupts and traps\nstruct gatedesc {\n  uint off_15_0 : 16;   // low 16 bits of offset in segment\n  uint cs : 16;         // code segment selector\n  uint args : 5;        // # args, 0 for interrupt/trap gates\n  uint rsv1 : 3;        // reserved(should be zero I guess)\n  uint type : 4;        // type(STS_{IG32,TG32})\n  uint s : 1;           // must be 0 (system)\n  uint dpl : 2;         // descriptor(meaning new) privilege level\n  uint p : 1;           // Present\n  uint off_31_16 : 16;  // high bits of offset in segment\n};\n\n// Set up a normal interrupt/trap gate descriptor.\n// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.\n//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone\n// - sel: Code segment selector for interrupt/trap handler\n// - off: Offset in code segment for interrupt/trap handler\n// - dpl: Descriptor Privilege Level -\n//        the privilege level required for software to invoke\n//        this interrupt/trap gate explicitly using an int instruction.\n#define SETGATE(gate, istrap, sel, off, d)                \\\n{                                                         \\\n  (gate).off_15_0 = (uint)(off) & 0xffff;                \\\n  (gate).cs = (sel);                                      \\\n  (gate).args = 0;                                        \\\n  (gate).rsv1 = 0;                                        \\\n  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \\\n  (gate).s = 0;                                           \\\n  (gate).dpl = (d);                                       \\\n  (gate).p = 1;                                           \\\n  (gate).off_31_16 = (uint)(off) >> 16;                  \\\n}\n```\n\n中断描述符寄存器如下：\n\n高32位存放中断描述符表的基地址，低16位存放中断描述符表的大小（字节为单位）。\n\n![](./Scheduler/photo/scheduler/IDTR.png)\n\n## AP（从）处理器的启动\n\n首先还是回归main函数：\n\n```cpp\n// Bootstrap processor starts running C code here.\n// Allocate a real stack and switch to it, first\n// doing some setup required for memory allocator to work.\nint\nmain(void)\n{\n  kinit1(end, P2V(4*1024*1024)); // 内存内存管理已讲\n  kvmalloc();      // 内存内存管理已讲\n  mpinit();        // detect other processors\n  lapicinit();     // interrupt controller\n  seginit();       // 内存内存管理已讲\n  picinit();       // disable pic // 禁用单核架构下的8259A，实现很简单，这里就不去贴代码了\n  ioapicinit();    // another interrupt controller\n  // ...\n  pinit();         // process table // 实现很简单就是对自ptable的自旋锁进行一个初始化。读者可以自行阅读代码，这里就不过多赘述。\n  tvinit();        // trap vectors\n  // ...\n  startothers();   // start other processors\n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // 内存内存管理已讲\n  userinit();      // first user process // 就是对init进程的内核栈做一个初始化。利用了ROP（面向返回点编程）编程思想。因为这又是一个大主题，本文不会过多讲解。以后有机会在另开一篇博客专门讨论。\n  mpmain();        // finish this processor's setup // 进入mpmain\n}\n\n// Other AP CPUs jump here from entryother.S.\nstatic void\nmpenter(void)\n{\n  switchkvm();  // AP的内核页表换成kpgdir\n  seginit();    // 内存内存管理已讲\n  lapicinit();  // 作用同main函数中BSP核执行的lapicinit函数\n  mpmain();     // 进入mpmain\n}\n\n// BSP、APS最终都会进入改函数。\n// 主要工作就是\n//    1、加载中断描述表。\n//    2、设置状态，已启动。\n//    3、 进入调度循环。\n// Common CPU setup code.\nstatic void\nmpmain(void)\n{\n  cprintf(\"cpu%d: starting %d\\n\", cpuid(), cpuid());\n  idtinit();       // load idt register // 使用lidt命令加载中断描述符\n  xchg(&(mycpu()->started), 1); // tell startothers() we're up\n  scheduler();     // start running processes\n}\n```\n\n接下我们要从BSP执行的maiin函数开始，深入分析以上代码的作用。\n\n### mpinit：探测各个cpu\n\n该部分主要参考：[多处理器规范](https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf)，因为我英语也是很菜，所以硬着头皮捡重点去看了一部分。\n\n这里对多核处理器的启动流程做一个简单总结：我们可以理解为，多核CPU中，有一个CPU被设计成BSP，其他的CPU都被设计成AP。当然，在实际硬件设计上为了考虑容错性，任何一个CPU都能成为BSP核。 **系统最开始，BSP有对硬件的绝对控制权，包括去控制其他AP的启动和停止。为了启动其他AP核，BSP首先通过三种可能的方式搜索MP floating pointer structure，如果找到了一个有效的MP floating pointer structure就去遍历MP configuration table查询处理器信息和ioapic的信息；如果无法找到一个有效MP floating pointer structure，那就认为系统只有一个CPU——BSP。在所有CPU启动后，BSP就退化成AP，系统不存在BSP、AP之分。** 当然，我们需要要记录BSP CPU的lapic的ID（这个ID也唯一标识着CPU），这样我们才知道谁可以去其控制其他CPU的停止。在BSP启动其他AP前，因为AP CPU是暂停状态，所以其他AP无法执行OS代码，并且大部分中断都是被禁用，**但是INIT or STARTUP interprocessor interrupts (IPIs)不会被屏蔽，当AP收到来自BSP的INIT or STARTUP中断，就会启动它自己。** AP在收到BSP的启动中断后，也会进入保护模式、**有自己的独立的一套寄存器**、设置自己的全局描述符、开启分页、有自己的堆栈等。\n\n首先BSP会通过三种方式去搜索MP floating pointer structure，**三种搜索范围都在1M以内，因为MP floating pointer structure就是由BIOS提供，而BISO寻址范围就1M**：\n\n1. In the first kilobyte of Extended BIOS Data Area (EBDA), or\n2. Within the last kilobyte of system base memory, or\n3. In the BIOS ROM address space between 0F0000h and 0FFFFFh.\n\n低1M内存的内存映射参考：https://wiki.osdev.org/BDA#BIOS_Data_Area_.28BDA.29\n\nMP Configuration Data Structures整体框架如下图，图解了MP floating pointer structure、MP Configuration Table Header、Table Entries三者之间的一个关系，先了解一下大致的框架，接下来我门逐一剖析。\n\n![](./Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png)\n\nMP floating pointer structure图解如下：\n\n![](./Scheduler/photo/scheduler/MP_floating_pointer_structure.png)\n\n主要关注它的PHYSICAL ADDRESS POINTER，它指向MP config table的物理地址。\n\nMP Configuration Table Header结构如下：\n\n![](./Scheduler/photo/scheduler/MP_configuration_table_header.png)\n\n主要关注几个字段：\n- MEMORY-MAPPED ADDRESS OF LOCAL APIC：描述 cpu（**每个CPU都将它的lapic映射到了同一个物理地址**）的lapic的寄存器物理地址。注意这里是\"每个cpu\"，虽然是同一个物理地址，但是在每一个cpu去读的时候，分别映射到了各自的lapic的寄存器地址上了。\n\n- BASE TABLE LENGTH：整个table的长度，虽然存在扩展表长度，但是我们还用不到。\n\nMP Configuration Table Header后面会跟上各自类型的Base MP Configuration Table Entries，每个Entry的第一个字节会标明其类型，并且每种Entry的长度都各自固定，所以我们可以通过一个循环来遍历每个Entry，一共有5种类型的Entry，如下图：\n\n![](./Scheduler/photo/scheduler/entry_types.png)\n\nXV6中我们主要关注Processor Entries和I/O APIC两种类型的Entry。\n\nProcessor Entries结构如下：\n\n![](./Scheduler/photo/scheduler/processor_entry.png)\n\n主要关注LOCAL APIC ID，如该字段名字那样，就是代表和CPU绑定的lapic的ID，通过它我们也可以唯一标识一个CPU。\n\nI/O APIC Entries结构如下：\n\n![](./Scheduler/photo/scheduler/ioapic_entry.png)\n\n主要关注I/O APIC ID，代表I/O APIC的ID。\n\n然后上代码：\n\n```cpp\nvoid\nmpinit(void)\n{\n  uchar *p, *e;\n  int ismp;\n  struct mp *mp;              // 前面提到的MP floating pointer structure\n  struct mpconf *conf;        // 前面提到的MP Configuration Table Header\n  struct mpproc *proc;        // 前面提到的Processor Entries\n  struct mpioapic *ioapic;    // 前面提到的I/O APIC Entries\n\n  if((conf = mpconfig(&mp)) == 0)     // 用上面提到的三种方法寻找MP floating pointer structure，并且判断它的合法性，然后将结构体里面的PHYSICAL ADDRESS POINTER（指向MP Configuration Table Header）作为返回值\n    panic(\"Expect to run on an SMP\");\n  ismp = 1;\n  lapic = (uint*)conf->lapicaddr;     // 将lapic的寄存器地址放到全局变量lapic中\n  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){  // 依据MP Configuration Table Header遍历每一个Table Entry。\n    switch(*p){\n    case MPPROC:                      // Processor Entries\n      proc = (struct mpproc*)p;\n      if(ncpu < NCPU) {\n        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu // 保存cpu的lapic的id\n        ncpu++;                       // 找到一个CPU\n      }\n      p += sizeof(struct mpproc);\n      continue;\n    case MPIOAPIC:                    // I/O APIC Entries\n      ioapic = (struct mpioapic*)p;\n      ioapicid = ioapic->apicno;      // 将ioapicid存到全局变量，将来初始化的时候会用\n      p += sizeof(struct mpioapic);\n      continue;\n    case MPBUS:                       // 其他的不关注，加上他们的大小去找下一个Table Entry。\n    case MPIOINTR:\n    case MPLINTR:\n      p += 8;\n      continue;\n    default:\n      ismp = 0;\n      break;\n    }\n  }\n  if(!ismp)\n    panic(\"Didn't find a suitable machine\");\n\n  if(mp->imcrp){\n    // 如果之前是PIC Mode，就切换到APIC模式 \n    // interrupt mode configuration register --> IMCR\n    // Bochs doesn't support IMCR, so this doesn't run on Bochs.\n    // But it would on real hardware.\n    outb(0x22, 0x70);   // Select IMCR\n    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.  // 进入APIC模式\n  }\n}\n```\n\nmp->imcrp字段的解释如下：\n\n![](./Scheduler/photo/scheduler/imcrp.png)\n\n详细信息可以了解一下：[多处理器规范](https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf)\n\n### lapicinit：BSP初始化自己cpu的lapic\n\n这部分和硬件强相关，我也了解不是特别多，尽可能的讲清楚吧。硬件相关的初始化深入下去也是一个无底洞。如果读者感兴趣的话，可以去查intel 64 and IA-32 卷3开发手册。 \n\n```cpp\nvoid\nlapicinit(void)\n{\n  if(!lapic)    // lapic就是上面mpinit函数在MP Configuration Table Header中得到的lapic寄存器的物理映射地址，所以说初始化的顺序非常严格！\n    return;\n\n  // Enable local APIC; set spurious interrupt vector.\n  lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));      // 开启此cpu的APIC\n\n  // 配置时钟，属于lapic的本地中断\n  // The timer repeatedly counts down at bus frequency\n  // from lapic[TICR] and then issues an interrupt.\n  // If xv6 cared more about precise timekeeping,\n  // TICR would be calibrated using an external time source.\n  lapicw(TDCR, X1);                               // 分频系数为X1\n  lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER)); // 以PERIODIC为周期，映射到0x20中断\n  lapicw(TICR, 10000000);                         // 时钟频率\n\n  // Disable logical interrupt lines.\n  lapicw(LINT0, MASKED);                          // 屏蔽LINT0（lapic本地中断\n  lapicw(LINT1, MASKED);                          // 屏蔽LINT1（lapic本地中断\n\n  // Disable performance counter overflow interrupts\n  // on machines that provide that interrupt entry.\n  if(((lapic[VER]>>16) & 0xFF) >= 4)\n    lapicw(PCINT, MASKED);                        // 屏蔽PCINT（好像是废话？\n\n  // Map error interrupt to IRQ_ERROR.\n  lapicw(ERROR, T_IRQ0 + IRQ_ERROR);            // 0x20 + 0x13（ERROR）\n\n  // Clear error status register (requires back-to-back writes).\n  lapicw(ESR, 0);\n  lapicw(ESR, 0);\n\n  // Ack any outstanding interrupts.\n  lapicw(EOI, 0);                               // 向ioapic发送一个EOI，以免中断丢失\n\n  // Send an Init Level De-Assert to synchronise arbitration ID's.\n  lapicw(ICRHI, 0);                             // ？？？// 这里应该是向其他apic广播一条“报文”，通知“我”启动了\n  lapicw(ICRLO, BCAST | INIT | LEVEL);          // 广播的形式 & 传送模式为INIT & 水平触发\n  while(lapic[ICRLO] & DELIVS)                  // 中断的传输状态：是否已经发送？\n    ;\n\n  // Enable interrupts on the APIC (but not on the processor).\n  lapicw(TPR, 0);\n}\n```\n\n**以上代码就是初始化BSP的lapic，在其他AP启动后，都要执行一遍这段代码。**\n\n### ioapicinit：初始化ioapic\n\nioapic的作用和单核架构下master pic很像，但是对于ioapic的初始化步骤很简单，不需要发送一系列的控制字。对于ioapic的初始化就是简单的配置一下重定向表项 RTE(Redirection Table Entry)，给RTE的每一项一个初值，设置它的中断向量号（起始T_IRQ0，T_IRQ0 == 0x20），并且默认是中断屏蔽的。后续需要什么中断再对相应的Entry做配置即可，比如consoleinit为了使用键盘调用了ioapicenable去配置对应的Entry打开中断等。关于重定向表项 RTE(Redirection Table Entry)的解释，读者可以看一下这篇文章，讲的非常详细：https://blog.csdn.net/weixin_46645613/article/details/119207945\n\n```cpp\nvoid\nioapicinit(void)\n{\n  int i, id, maxintr;\n\n  ioapic = (volatile struct ioapic*)IOAPIC;           // 默认地址：0xFEC00000   // Default physical address of IO APIC\n  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;       // ioapic支持的最大中断号\n  id = ioapicread(REG_ID) >> 24;                      // 从寄存器读到的ioapic的ID\n  if(id != ioapicid)                                  // 必须一致\n    cprintf(\"ioapicinit: id isn't equal to ioapicid; not a MP\\n\");\n\n  // Mark all interrupts edge-triggered, active high, disabled,\n  // and not routed to any CPUs.\n  for(i = 0; i <= maxintr; i++){    // 初始化重定向表项 RTE(Redirection Table Entry)，这里和单核架构下主从PIC一样，先将所有的中断屏蔽掉，在后面初始化的时候再按需使能。\n    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));\n    ioapicwrite(REG_TABLE+2*i+1, 0);\n  }\n}\n```\n\n### tvinit：初始化中断向量表\n\n这里自顶向下介绍XV6的中断向量表是如何构造的。\n\n涉及到的变量如下：\n\n```cpp\n// Interrupt descriptor table (shared by all CPUs).\nstruct gatedesc idt[256];   // 中断描述符表\nextern uint vectors[];  // vectors的定义文件是：由vectors.pl生成的汇编代码文件。\n```\n\n首先是tvinit函数，它是最顶层负责构造中断向量表的函数，SETGATE宏在上面已经贴过它的实现，这里简单介绍一个各个参数的作用。\n\nSETGATE(gate, istrap, sel, off, d) ：\n\n- 参数1：对应idt[i]，表示每一项entry。\n\n- 参数2：标记是中断门还是陷阱门。\n\n- 参数3：段选择子。\n\n- 参数4：中断处理函数地址。\n\n- 参数5：中断描述符被哪个特权级使用。\n\n结合代码来看：\n\n```cpp\nvoid\ntvinit(void)\n{\n  int i;\n  // 构造中断描述符表\n  for(i = 0; i < 256; i++)\n    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);\n\n  // 初始化系统调用中断描述符，类型是陷阱门（发生中断不会关中断），特权级是DPL_USER。\n  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);\n\n  initlock(&tickslock, \"time\");\n}\n```\n\n然后是vectors.pl文件生成汇编代码的过程，pl我之前也没有了解过，不过从它的代码可以看出，有点像字符串拼接的处理语言，简化了重复性代码的编写，代码如下：\n\n```pl\n#!/usr/bin/perl -w\n\n# Generate vectors.S, the trap/interrupt entry points.\n# There has to be one entry point per interrupt number\n# since otherwise there's no way for trap() to discover\n# the interrupt number.\n\nprint \"# generated by vectors.pl - do not edit\\n\";\nprint \"# handlers\\n\";\nprint \".globl alltraps\\n\";\nfor(my $i = 0; $i < 256; $i++){\n    print \".globl vector$i\\n\";\n    print \"vector$i:\\n\";\n    if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){\n        # 这些中断cpu自动压入errcode参数，\n        # 为保证中断栈帧的统一，所以我们在\n        # 这些特殊中断手动压入0值，这样就能\n        # 统一使用trapret来恢复上下文。\n        print \"  pushl \\$0\\n\";\n    }\n    print \"  pushl \\$$i\\n\";\n    print \"  jmp alltraps\\n\";\n}\n\nprint \"\\n# vector table\\n\";\nprint \".data\\n\";\nprint \".globl vectors\\n\";\nprint \"vectors:\\n\";\nfor(my $i = 0; $i < 256; $i++){\n    print \"  .long vector$i\\n\";\n}\n```\n\n从pl代码上我们可以看到，就是利用for循环构造vectors数组，该数组专门存放中断处理函数。我们先来分析一下它如何构造vectors的，首先最上面有一个for循环，for循环中使用了一个if判断，因为有些中断cpu不会自动压入错误码，所以我们需要**手动压入一个占位值**，方便trapret的处理。在for循环下面最后压入了一个jmp指令，所以pl生成的汇编并不是中断处理函数最终代码，pl生成的中断处理函数会跳到alltraps，alltraps代码我们下面再进行分析。pl在最后生成的汇编代码定义了一个vectors数组，数组里面元素就是上面定义的256个vectori（i=1、2、...）。\n\n最后就是trapasm.S文件对alltraps的实现，常规的进行上下文保护：\n\n```asm\n#include \"mmu.h\"\n\n  # vectors.S sends all traps here.\n.globl alltraps\nalltraps:          # 保存上下文\n  # Build trap frame.\n  pushl %ds\n  pushl %es\n  pushl %fs\n  pushl %gs\n  pushal\n  \n  # Set up data segments.\n  movw $(SEG_KDATA<<3), %ax\n  movw %ax, %ds\n  movw %ax, %es\n\n  # Call trap(tf), where tf=%esp\n  pushl %esp\n  call trap       # 进入trap函数\n  addl $4, %esp\n\n  # Return falls through to trapret...\n.globl trapret\ntrapret:          # 恢复上下文\n  popal\n  popl %gs\n  popl %fs\n  popl %es\n  popl %ds\n  addl $0x8, %esp  # trapno and errcode\n  iret\n```\n\ntvinit、pl、alltraps三者之间的关系总览图如下：\n\n![](./Scheduler/photo/scheduler/trap__structure.png)\n\n\n关于中断帧，这里要注意，涉及特权级转换的中断帧和不涉及特权级转换的中断帧有些许不一样。如下：\n\n用户态触发中断（陷阱门或中断门）过程如下：\n\n0. 用户查询TSS（任务状态段）段，找到用户进程在内核态的栈段和栈顶指针（ss0、esp0）。\n\n1. **cpu将ss、esp压入（内核）栈中。**（硬件\n\n2. cpu将eflags、cs、eip压入栈中。**中断门还要关中断**，陷阱门不用。（硬件\n\n3. 执行用户中断处理函数**alltraps**的**上下文保护**的代码。（软件\n\n4. 调用trap函数，处理各种中断。\n\n5. 执行用户中断处理函数**trapret**的**上下文恢复**的代码。（软件\n\n6. 调用iret，cpu恢复eflags、cs、eip。（硬件\n\n7. cpu恢复ss、esp。（硬件\n\n而内核线程发生中断（**注意，内核态不会发生系统调用，这不应该也不合理**），过程如下：\n\n1. cpu将eflags、cs、eip压入栈中。**中断门还要关中断**，陷阱门不用。（硬件\n\n2. 执行用户中断处理函数**alltraps**的**上下文保护**的代码。（软件\n\n3. 调用trap函数，处理各种中断。\n\n4. 执行用户中断处理函数**trapret**的**上下文恢复**的代码。（软件\n\n5. 调用iret，cpu恢复eflags、cs、eip。（硬件\n\nXV6中定义的栈帧结构体如下：\n\n```cpp\n//PAGEBREAK: 36\n// Layout of the trap frame built on the stack by the\n// hardware and by trapasm.S, and passed to trap().\nstruct trapframe {\n  // registers as pushed by pusha\n  uint edi;\n  uint esi;\n  uint ebp;\n  uint oesp;      // useless & ignored\n  uint ebx;\n  uint edx;\n  uint ecx;\n  uint eax;\n\n  // rest of trap frame\n  ushort gs;\n  ushort padding1;\n  ushort fs;\n  ushort padding2;\n  ushort es;\n  ushort padding3;\n  ushort ds;\n  ushort padding4;\n  uint trapno;\n\n  // below here defined by x86 hardware\n  uint err;\n  uint eip;\n  ushort cs;\n  ushort padding5;\n  uint eflags;\n\n  // below here only when crossing rings, such as from user to kernel\n  uint esp;\n  ushort ss;\n  ushort padding6;\n};\n```\n\n中断帧如下图：\n\n![](./Scheduler/photo/scheduler/trap_frame.png)\n\n图片引用自：https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\n\n### startothers：激活其他AP处理器\n\n到这里终于要开始启动其他AP核了，AP核的启动也是一种固定套路，在[多处理器规范](https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf)中这种套路称为universal algorithm。XV6中这个算法实现在lapicstartap函数中。\n\n流程如下：\n\n![](./Scheduler/photo/scheduler/universal_algorithm.png)\n\nXV6代码启动其他AP处理器的核心流程如下：\n\n```cpp\n// Start the non-boot (AP) processors.\nstatic void\nstartothers(void)\n{\n  extern uchar _binary_entryother_start[], _binary_entryother_size[];\n  uchar *code;\n  struct cpu *c;\n  char *stack;\n\n  // Write entry code to unused memory at 0x7000.\n  // The linker has placed the image of entryother.S in\n  // _binary_entryother_start.\n  // AP核的entryother代码的入口点，entryother 就是 boot + entry的结合体\n  code = P2V(0x7000);\n\n  // 这里将entryother的代码移到物理地址0x7000处\n  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);\n\n  // BSP for循环向每个AP发送中断。\n  for(c = cpus; c < cpus+ncpu; c++){\n    if(c == mycpu())  // We've started already.\n      continue;\n\n    // Tell entryother.S what stack to use, where to enter, and what\n    // pgdir to use. We cannot use kpgdir yet, because the AP processor\n    // is running in low  memory, so we use entrypgdir for the APs too.\n    stack = kalloc();   // 为每个AP核分配一个执行scheduler函数的内核栈\n    *(void**)(code-4) = stack + KSTACKSIZE;\n    *(void(**)(void))(code-8) = mpenter;  // 指定AP特有main（mpenter）函数入口点。\n    // 同BSP刚启动一样，使用使用4M big page页表。\n    *(int**)(code-12) = (void *) V2P(entrypgdir);\n\n    // lapicstartap就是实现了universal algorithm，因为我也不太懂，这里就不贴了。\n    lapicstartap(c->apicid, V2P(code));   \n\n    // 等待AP初始化完毕\n    // wait for cpu to finish mpmain()\n    while(c->started == 0)  \n      ;\n  }\n}\n```\n\n在每个AP boot点和BSP的boot点类似，BSP是在0x7c00启动，AP是在0x7000启动。同样，0x7000也会执行一段汇编代码，这段汇编代码作用就是bootasm.S + entry.S代码的结合体。这里简单总结一下：\n\n1. 加载临时全局描述符，进入保护模式\n\n2. 使用entrypgdir开启分页。\n\n3. 切换到预分配的内核（scheduler）栈。\n\n4. 进入mpenter。\n\n考虑到文章太长，代码就不放了。文件是entryother.S，有兴趣的读者可自行研究。\n\nmpenter代码如下：\n\n```cpp\n// Other CPUs jump here from entryother.S.\nstatic void\nmpenter(void)\n{\n  switchkvm();    // 切换到粒度更小（4k）的内核页，kpgdir。\n  seginit();       //效果同BSP，在main中BSP也调用了该函数。就是第二次初始化段描述符。（第一次是在entryother.S\n  lapicinit();    // 效果同BSP\n  mpmain();       // 进入mpmain\n}\n```\n\n上面那段代码就是：AP会像BSP那样，调用一遍所有的和CPU相关初始化函数，最终进入mpmain。（BSP在main最后也会进入mpmain，前面提到过BSP启动其他后，也成为了一个AP）\n\nmpmain在加载中断描述符表后，最终就会进入scheduler，CPU正式开启操作系统的任务调度！\n\nmpmain如下：\n\n```cpp\n// Common CPU setup code.\nstatic void\nmpmain(void)\n{\n  cprintf(\"cpu%d: starting %d\\n\", cpuid(), cpuid());\n  idtinit();       // load idt register\n  xchg(&(mycpu()->started), 1); // tell startothers() we're up\n  scheduler();     // start running processes\n}\n```\n\n## 进程调度\n\n首先了解一下XV6对CPU的定义，注释写的非常详细：\n\n```cpp\n// Per-CPU state\nstruct cpu {\n  // lapci的id\n  uchar apicid;                // Local APIC ID\n  // 执行调度器栈指针\n  struct context *scheduler;   // swtch() here to enter scheduler\n  // 任务状态段、为进程从用户态陷入内核态切栈使用\n  struct taskstate ts;         // Used by x86 to find stack for interrupt\n  // 全局描述符\n  struct segdesc gdt[NSEGS];   // x86 global descriptor table\n  // 指示cpu是否启动\n  volatile uint started;       // Has the CPU started?\n  // 关中断的深度\n  int ncli;                    // Depth of pushcli nesting.\n  // 记录在cpu第一层关中断前，中断关闭情况\n  int intena;                  // Were interrupts enabled before pushcli?\n  // cpu当前运行的进程PCB\n  struct proc *proc;           // The process running on this cpu or null\n};\n\nextern struct cpu cpus[NCPU]; // 多个cpu\nextern int ncpu;              // cpu的个数\n```\n\n下面列出了各个CPU资源的共享情况，可以做一个参考：\n\n| 资源                                      |  共享     | 不共享  |\n| :-:                                       |  :-:      |  :-:    |\n| 中断描述符表                               |√         |         |\n| lapic（也指外中断，包括定时器等）           |           | √       |\n|ioapic                                     |√         |          |\n|cpu的各种寄存器，包括eip、esp、eflag等等     |          |√         |\n|全局描述符表（包括任务状态段）               |           |√        |\n|kpgdir（内核调度器使用的页表）               |√         |          |\n|物理内存                                   |√         |          |\n|任务队列（ptable）                          |√        |          |\n|调度器的执行栈                              |         |√         |\n|外设                                       |         |√         |\n\n接下来是XV6的PCB（进程控制块），之前老是在教科书上看到它，当时感觉很难理解，在分析过OS源码后，再回过头去看，就感觉特别通透。XV6的PCB就是一个结构体，里面存放了很多成员，XV6的PCB和进程的内核栈是分开的，PCB结构体是通过一个指针来指向进程的内核栈。相比之下，Onix的PCB和内核栈是连在一起的，内核栈的低地址就是存放的PDB结构体，因为esp是线下增长，所以esp指向高地址处，并且典型的内核栈大小是一页（4K）（于是esp指向页面的4K处）。\n\nXV6的PCB定义如下：\n\n```cpp\n// proc.h\nenum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };\n\n// Per-process state\nstruct proc {\n  // 进程（映射了页框的）虚拟内存大小\n  uint sz;                     // Size of process memory (bytes)\n  // 进程的页表\n  pde_t* pgdir;                // Page table\n  // 进程的内核栈\n  char *kstack;                // Bottom of kernel stack for this process\n  // 进程状态\n  enum procstate state;        // Process state\n  // 进程pid\n  int pid;                     // Process ID\n  // 进程的父进程\n  struct proc *parent;         // Parent process\n  // 调用系统调用时的栈帧\n  struct trapframe *tf;        // Trap frame for current syscall\n  // 内核态的上下文\n  struct context *context;     // swtch() here to run process\n  // 等待条件\n  void *chan;                  // If non-zero, sleeping on chan\n  // 是否被杀死\n  int killed;                  // If non-zero, have been killed\n  // 打开的文件\n  struct file *ofile[NOFILE];  // Open files\n  // 工作目录的inode\n  struct inode *cwd;           // Current directory\n  // 进程名\n  char name[16];               // Process name (debugging)\n};\n\n// proc.c\nstruct {\n  struct spinlock lock;       // 自旋锁\n  struct proc proc[NPROC];\n} ptable;                     // 多个cpu之间共享该结构\n\nstatic struct proc *initproc; // 存放init进程PCB\nint nextpid = 1;              // 分配唯一pid\n```\n\nXV6为进程定义了6种状态：UNUSED（PCB未使用）, EMBRYO（初始化中）, SLEEPING（阻塞休眠）, RUNNABLE（可调度）, RUNNING（运行中）, ZOMBIE（僵尸/待回收）。 这里特别说明一下PCB的chan成员，该成员一个进程的等待条件。XV6中一个进程可能会调用sleep、wait系統調用，或者在調用read系統調用时间接调用了sleeplock，这些函数都会使一个进程进入阻塞状态，XV6的阻塞状态统一使用SLEEPING来表示，阻塞就是为了等待某个条件发生，当等待的条件发生时，阻塞的进程就会被唤醒，但是ptable有那么多阻塞的进程，我应该唤醒ptable中的哪些进程呢？此时chan就起到关键作用，在进程进入阻塞之前，会将chan设置为某一个变量的地址，当条件满足XV6就是通过chan来唤醒对应的进程的，当然这个变量的选取是很有讲究的，比如在XV6中因为sleep而休眠的进程，它的chan会被设置成ticks（作用类似jefrris，定时器中断的计数器）的地址。具体细节就不深入讨论，感兴趣的读者可以看看XV6的源码。\n\n从AP（从）处理器的启动段落我们知道，BSP、AP最终都进入scheduler函数，铺垫了这么久，scheduler函数也是本文的主题，那么先来看看它的代码实现吧：\n\n```cpp\n//PAGEBREAK: 42\n// Per-CPU process scheduler.\n// Each CPU calls scheduler() after setting itself up.\n// Scheduler never returns.  It loops, doing:\n//  - choose a process to run\n//  - swtch to start running that process\n//  - eventually that process transfers control\n//      via swtch back to the scheduler.\nvoid\nscheduler(void)\n{\n  struct proc *p;\n  struct cpu *c = mycpu();  // 找到scheduler正运行在哪个cpu上\n  c->proc = 0;              // 将cpu结构体的当前运行的进程清零\n  \n  for(;;){\n    // Enable interrupts on this processor.\n    sti();                  // 打开中断、之前中断一直是关闭的！\n\n    // 这里pushcli保存的mycpu()->intena其实没有意义，在切换后会被外面的sched直接覆盖。\n    // Loop over process table looking for process to run.\n    acquire(&ptable.lock); // 共用ptable，所以需要获取自旋锁，互斥访问。\n    // 遍历ptable\n    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){\n      if(p->state != RUNNABLE)  // 进程状态不可运行\n        continue;\n      // else 找到了一个可运行的进程\n      // Switch to chosen process.  It is the process's job\n      // to release ptable.lock and then reacquire it\n      // before jumping back to us.\n      c->proc = p;  // 设置p为cpu当前运行进程\n      //  这个函数非常关键，主要做两个三个操作：\n      // 1、设置tss，并将其追加到全局描述符\n      // 2、设置tss的选择子\n      // 3、让cpu使用进程p的页表。\n      switchuvm(p);\n      p->state = RUNNING; // 设置p为运行状态\n\n      swtch(&(c->scheduler), p->context); // 正式开始切换，等到p放弃cpu才会返回\n      switchkvm();        // 切换回内核页表kpgdir\n\n      // Process is done running for now.\n      // It should have changed its p->state before coming back.\n      c->proc = 0;        // 当前运行的进程清零\n    }\n    release(&ptable.lock);  // 释放自旋锁\n\n  }\n}\n```\n\nXV6的调度算法非常简单，就是简单的round robin算法。主要精华是整个调度的过程，至于它具体的调度算法其实显得并不是特别重要。\n\nswitchuvm函数实现非常关键，它里面会设置tss，并且设置cpu使用进程p的页表。**tss全称是任务状态段，它可以帮助处于用户态的进程回到内核态**，因为一个进程有两个栈，一个是出于用户态使用，另外一个是处于内核态使用，进程从内核态转变成用户态容易。只需要将中断帧弹出恢复上下文即可，但是从用户态回到内核态就难了，因为进入用户态后，进程的用户态空间不会保留进程任何内核态信息，所以，我们需要一个东西来帮助处于用户态的进程在需要陷入内核态时，找到它的内核态的栈，这个东西就是TSS，TSS会记录一个进程的内核栈的栈指针esp和栈段ss，switchuvm函数正是完成了这样的功能。实现如下：\n\n```cpp\n// Switch TSS and h/w page table to correspond to process p.\nvoid\nswitchuvm(struct proc *p)\n{\n  if(p == 0)\n    panic(\"switchuvm: no process\");\n  if(p->kstack == 0)\n    panic(\"switchuvm: no kstack\");\n  if(p->pgdir == 0)\n    panic(\"switchuvm: no pgdir\");\n\n  pushcli();\n  // 因为tss也是一个段，所以向cpu的全局描述符中追加tss的描述符\n  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,\n                                sizeof(mycpu()->ts)-1, 0);\n  mycpu()->gdt[SEG_TSS].s = 0;\n  mycpu()->ts.ss0 = SEG_KDATA << 3;                 // 内核栈段\n  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;  // 内核栈指针\n  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit\n  // forbids I/O instructions (e.g., inb and outb) from user space\n  mycpu()->ts.iomb = (ushort) 0xFFFF;\n  ltr(SEG_TSS << 3);                                // tss段选择子\n  // 切换到p的页表\n  lcr3(V2P(p->pgdir));  // switch to process's address space\n  popcli();\n}\n```\n\n关于任务状态段的详情描述可以参考：https://github.com/StevenBaby/onix/blob/dev/docs/07%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/062%20%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E7%AE%80%E4%BB%8B.md\n\nswtch函数由汇编实现，是进程切换的核心函数，实现如下：\n\n```asm\n# Context switch\n#\n#   void swtch(struct context **old, struct context *new);\n# \n# Save the current registers on the stack, creating\n# a struct context, and save its address in *old.\n# Switch stacks to new and pop previously-saved registers.\n\n.globl swtch\nswtch:                # 这里有个pushl eip，cpu帮我们自动执行了\n  movl 4(%esp), %eax  # 第一个参数，struct context**\n  movl 8(%esp), %edx  # 第二个参数  struct context*\n\n  # Save old callee-saved registers\n  pushl %ebp\n  pushl %ebx\n  pushl %esi\n  pushl %edi\n\n  # Switch stacks\n  movl %esp, (%eax) # 加括号和在指针前面加*一个道理，这里保存当前内核栈指针到第一个参数上\n  movl %edx, %esp   # 将esp切换到第二个参数指向的内核栈上\n\n  # Load new callee-saved registers\n  popl %edi\n  popl %esi\n  popl %ebx\n  popl %ebp\n  ret\n```\n\nstruct context结构体定义如下：\n\n```cpp\nstruct context {\n  uint edi;\n  uint esi;\n  uint ebx;\n  uint ebp;\n  uint eip;\n};\n```\n\n一个进程在（因为时间片用完）需要放弃cpu执行权限，如何回到scheduler呢？答案就是使用sched函数，本文我们以普遍的事件来分析————因为时间片用完而放弃的cpu。处于**用户态的进程因为时间片用完会发生定时器中断**，定时器中断又会引发从用户态到内核态的切栈、保存上下文、执行trap函数，trap函数中最后调用了yield，yield最终会调用sched，trap函数伪代码如下：\n\n```cpp\nstruct spinlock tickslock;\nuint ticks;\n\n//PAGEBREAK: 41\nvoid\ntrap(struct trapframe *tf)\n{\n  if(tf->trapno == T_SYSCALL){  // 是系统调用\n    // ...\n    return;\n  }\n\n  switch(tf->trapno){\n  case T_IRQ0 + IRQ_TIMER:\n    if(cpuid() == 0){\n      acquire(&tickslock);\n      ticks++;            // 每次定时器中断都自增1\n      wakeup(&ticks);     // 唤醒sleeping进程，检查休眠是否到期\n      release(&tickslock);\n    }\n    lapiceoi();           // 通知lapic中断处理完毕\n    break;\n  // ...\n  }\n\n  // ...\n\n  // Force process to give up CPU on clock tick.\n  // If interrupts were on while locks held, would need to check nlock.\n  if(myproc() && myproc()->state == RUNNING &&\n     tf->trapno == T_IRQ0+IRQ_TIMER)\n    yield();    // 时间片用完，cpu让给下一个进程\n\n  // ...\n}\n```\n\nyield函数实现就是封装了一下sched函数，在调用sched之前，将进程的状态设置成了RUNNABLE状态：\n\n```cpp\n// Enter scheduler.  Must hold only ptable.lock\n// and have changed proc->state. Saves and restores\n// intena because intena is a property of this\n// kernel thread, not this CPU. It should\n// be proc->intena and proc->ncli, but that would\n// break in the few places where a lock is held but\n// there's no process.\nvoid\nsched(void)\n{\n  int intena;\n  struct proc *p = myproc();\n\n  if(!holding(&ptable.lock))\n    panic(\"sched ptable.lock\");\n  if(mycpu()->ncli != 1)        // 最多一层关中断\n    panic(\"sched locks\");\n  if(p->state == RUNNING)       // 在调用sched前，应该改变进程状态\n    panic(\"sched running\");\n  if(readeflags()&FL_IF)        // 中断必须被关闭！\n    panic(\"sched interruptible\");\n  intena = mycpu()->intena;     // intena是进程私有的\n  swtch(&p->context, mycpu()->scheduler); // 切换到scheduler\n  mycpu()->intena = intena;     // 还原intena\n}\n\n// Give up the CPU for one scheduling round.\nvoid\nyield(void)\n{\n  acquire(&ptable.lock);  //DOC: yieldlock\n  myproc()->state = RUNNABLE;\n  sched();\n  release(&ptable.lock);\n}\n```\n\nsched中保存intena状态到进程的内核栈中的做法，好像把intena变量放到PCB中更合适，但是XV6没有这么做。从shced函数注释中了解到，如果把intena变量放到PCB中的话，有些情况下会有问题。具体呢，就不去细究了（我也每深究），本文内容太长了，还是以调度为主。这里主要是想表达一个点：**scheduler函数给ptable.lock加锁时，pushcli保存的intena没有任何意义。因为最终在切换进程时，会被sched中进程的intena给覆盖掉。同样，在进程回到scheduler函数后，scheduler函数给ptable.lock解锁时，popcli还原的intena也没有任何意义，因为无论intena原来是否开中断，外层的for都会开中断！**\n\n最终，一个待调度的进程的内核栈帧就形成了：\n\n![](./Scheduler/photo/scheduler/task_stack.drawio.png)\n\n一张图片概括yield、scheduler的加锁关系。如下图，进程利用yield进入调度器时会获取ptable的自旋锁（自旋锁内部会关中断，并且将关中断之前的中断状态保存到intena中），在切换到scheduler后（可能）会由scheduler解锁。在从scheduler切换到下一个任务前，（可能）scheduler会获取ptable的自旋锁，在却换到下一个任务后，由任务进行解除ptable的自选锁，注意这里是可能，因为还有可能scheduler的内层循环还没有执行完，以至于内层循环还可以找到下一个待执行的日任务，此时ptable的锁，就是：老进程加锁，新进程解锁：\n\n![](./Scheduler/photo/scheduler/yield_scheduler.png)\n\n总的来说，XV6进程调度整体流程是：**每个cpu上都运行调度线程，调度线程运行sheduler函数，scheduler不断从ptable取进行任务，然后（swapIn）切换去执行进程任务，当进程任务用完时间片（通过定时器中断）就会放弃cpu的执行权限，（swapOut）切换到内核调度线程继续去调度下一个进程任务。**\n\n如果类比于用户态的协程的：**对称协程和非对称协程之分吗的话，结合非对称协程的特点：协程的切换需要经过调度协程，而由于XV6进程的调度都必须经内核的过调度线程，所以XV6的调度器模型更像一种“非对称进程”。**\n\n**作为对比，如果你阅读过Onix的代码，你会发现Onix的调度模型更像是一种”对称进程“，因为Onix的进程切换是两个进程之间直接进行，不存在中间的调度线程。**\n\n这里我可以用一张**类似sylar的协程调度器模型来总结XV6进程调度模型**：\n\n![](./Scheduler/photo/scheduler/scheduler.drawio.png)\n\n**其实CPU Pool和线程池非常像，XV6的每个CPU都互斥到ptable中去取进程，然后去消化进程。唯一的区别就是CPU要和很多寄存器、硬件打交道，但是最终整体的框架思想都是一同百通，**\n\n如果你看过sylar的源码，你会深有感触！ **sylar的协程调度器模型和XV6进程的调度模型不能说像，只能是真的一模一样！** sylar是一个C++的基于协程的网络框架。我之前也有写过sylar的博客，这里推荐大家去看看：https://blog.csdn.net/m0_52566365/article/details/135991331。\n\n## 总结\n\nXV6有很多地方写的很暴力，有很大的优化空间，比如：\n\n|                             |XV6做法                        |Onix做法                 |\n|:-:                          |:-:|:-:|\n|内存管理|不管是物理内存还是内核内存一股脑使用kalloc，用户页表所有的内容都靠kalloc|get_page（使用256个页管理4G物理页，专门给页表和页框分配内存/page） + alloc_kpage（专门给内核分配内核页所有的页目录都采用alloc_kpage/page） + kmalloc（使用了内存池专门管理内核中的小快内存/byte）|\n|内核对系统调用参数的获取       |直接访问用户栈空间               |使用ebp、edi、esi、edx、ecx、ebx寄存器获取系统调用参数|\n|软件定时器                     |没有实现软件定时器               |利用链表实现了软件定时器 |\n|内存探测                       |未实现内存探测                 |loader实现了内存探测     |\n|idle任务                     |没实现idle任务                   |实现了idle任务           |\n|...                          |...                             |...                     |\n\n从上表可以看到Onix每一项都是存在优势的。但是Onix唯一的缺点，也是我读了Onix源码又来读XV6源码的原因：Onix是一个**单核**OS。其实读完XV6了解了多核OS的实现后，也没感到很大的震撼，多核CPU无非就是比单核CPU多了几套eip、esp、eflag等cpu相关的寄存器，cpu访问共享资源的的时候注意加锁就好了。\n\n最后谈谈XV6调度模型的优化：从**XV6进程调度模型图**我们可以看到，XV6的调度模型可以参考Muduo的One loop per thread 思想（可能说Muduo的One loop per thread思想参考了现代Linux对CPU的调度模型更合适？），因为XV6进程调度模型非常暴力，所有cpu共享有一个任务池（ptable），锁的竞争非常激烈。我们可以考虑让每个cpu都拥有一个自己独立的ptable（当然里面还是有自旋锁），由一个cpu负责负载均衡，将任务均匀的分发给各个cpu，需要修改cpux内部数据结构时，其他cpu只需向cpux的回调队列中添加操作函数即可，具体的操作还是由cpux自己完成。**也即One loop per CPU**。如下图：\n\n![](./Scheduler/photo/scheduler/scheduler_pluse.drawio.png)\n\n终于4干完了这篇文章，字数预计上万了，第一次写这么长的文章，也是真的用心了。创作不易，赏个赞把！\n\n**参考资料**\n\n多处理器规范：https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\n\nXV6的官方中文文档：https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\n\nOnix单核操作系统：https://github.com/StevenBaby/onix/\n\nAPIC中断讲解比较好的范文：https://blog.csdn.net/weixin_46645613/article/details/119207945\n\n多核处理器启动博客1：https://zhuanlan.zhihu.com/p/394247844\n\n---\n\n**本章完结**\n\n","source":"_posts/xv6/Scheduler.md","raw":"---\ntitle: 这才是计科之 Onix & XV6 源码分析（3、Unix-like系统的进程调度模块）\ndate: 2024-06-08 12:00:00\ntags:\n  - 类Unix源码剖析\n---\n\n## 前言\n\n前面已经分析了XV6的启动流程以及内存管理，接下来，我们探究进程调度的实现。与其说进程调度，我觉得可以顺应内存的虚拟化的叫法，将进程调度称为“CPU的虚拟化”更加贴切。\n\n首先明确目前XV6的cpu的状态如下：关中断 & 进入了保护模式 & 安装了包括【内核&用户】【代码&数据】段描述符 & BSP分配了一个4K的内核栈 & 开启了以kmap为基础的粒度为4K的内核分页。\n\nOnix相关链接：\n\n- [github仓库链接](https://github.com/StevenBaby/onix)。\n\n- [B站配套视频链接](https://www.bilibili.com/video/BV1qM4y127om/)。\n\nXV6-x86的github链接：\n\n- [链接](https://github.com/mit-pdos/xv6-public)。\n\n<!-- more -->\n\n## 中断机制\n\n对于中断的部分，这里会涉及大量硬件相关的知识，由于博主的目的是了解OS的基本框架，所以硬件相关的知识储备可能不会太深，如果你是想弄清某个硬件具体实现，这篇博客可能不适合你。\n\n这里总结一下我对中断的理解：\n\n引发中断的方式有三种：外中断、异常、软中断。\n\n- 外中断：就是由外部中断控制器通知 CPU 某个事件完成了，比如：磁盘寻道完成可以进行读写了、UART输入寄存器非空（可读）、UART输出寄存器为空（可写）、键盘缓冲有数据了（可读）等等。\n\n- 异常是 CPU 在执行过程中，因为出错而执行不下去了，比如：除零异常、因为虚拟页面还没映射发生缺页异常、对只读段进行写操作触发段错误异常等等。\n\n- 软中断，可以认为是应用程序和操作系统沟通的一种方式，运行在低优先级程序想要对硬件做IO，但是由于只有处于特权级的内核能够直接和设备打交道，从而低优先级程序必须通过某种机制来完成特权级转换，这种机制就是软中断。我们也可以将实现这种功能的函数称为系统调用。\n\n如有些教科书那样，我们也可以把异常和软中断统称为 内中断，也就是这个中断时 CPU 和 软件内部产生的，与外部硬件无关。\n\n### Onix单核处理器的中断原理\n\n单核PC机上，一般会采用（主从）两片 8259a PIC（programmable interrupt controller），将PIC的INT引脚接到CPU的一个引脚上，如下图，图片引用自onix的文档，如有侵权，可告知删除：\n\n![](./Scheduler/photo/scheduler/8259a.drawio.png)\n\n从图中可以看到有两个8259a，上面那个8259a是主PIC，它的INT引脚直接接到CPU上；下面那个8259a的INT引脚接到主PIC的IR2引脚，所以它是从PIC。 每一个PIC的引脚会接一个外设，（如果对应的引脚没被屏蔽的话）外设会通过PIC间接向CPU发中断。\n\n在PIC正式工作前，需要对其进行一系列初始化。初始化操作由cpu发送一系列的控制字完成。有两类控制字：\n\n- 初始化命令字 (Initialization Command Words, ICW), ICW 共 4 个， ICW1 ~ ICW4；\n\n- 操作命令字 (Operation Command Word, OCW), OCW 共 3 个， OCW1 ~ OCW3；\n\nICW 做初始化，用来确定是否需要级联，设置起始中断向量号，设置中断结束模式。因为某些设置之间是具有依赖性的，也许后面的某个设置会依赖前面某个 ICW 写入的设置，所以这部分要求严格的顺序，**必须依次写入** ICW1、ICW2、ICW3、ICW4；\n\nOCW 来操作控制 8259A，中断的屏蔽和中断处理结束就是通过往 8259A 端口发送 OCW 实现的。OCW 的发送顺序不固定，3 个之中先发送哪个都可以。\n\n**具体细节非常推荐读者去阅读一下Onix文档，讲的真的很细致**：https://github.com/StevenBaby/onix/blob/dev/docs/04%20%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F/033%20%E5%A4%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.md\n\n8259a中断控制器的初始化就是一种固定套路，截取Onix代码如下：\n\n```cpp\n#define PIC_M_CTRL 0x20 // 主片的控制端口\n#define PIC_M_DATA 0x21 // 主片的数据端口\n#define PIC_S_CTRL 0xa0 // 从片的控制端口\n#define PIC_S_DATA 0xa1 // 从片的数据端口\n#define PIC_EOI 0x20    // 通知中断控制器中断结束\n\n// 初始化中断控制器\nvoid pic_init()\n{\n    // 主PIC\n    outb(PIC_M_CTRL, 0b00010001); // ICW1: 边沿触发, 级联 8259, 需要ICW4.\n    outb(PIC_M_DATA, 0x20);       // ICW2: 起始中断向量号 0x20\n    outb(PIC_M_DATA, 0b00000100); // ICW3: IR2接从片.\n    outb(PIC_M_DATA, 0b00000001); // ICW4: 8086模式, 正常EOI\n\n    // 从PIC\n    outb(PIC_S_CTRL, 0b00010001); // ICW1: 边沿触发, 级联 8259, 需要ICW4.\n    outb(PIC_S_DATA, 0x28);       // ICW2: 起始中断向量号 0x28\n    outb(PIC_S_DATA, 2);          // ICW3: 设置从片连接到主片的 IR2 引脚\n    outb(PIC_S_DATA, 0b00000001); // ICW4: 8086模式, 正常EOI\n\n    outb(PIC_M_DATA, 0b11111111); // OCW1：屏蔽字，关闭主PIC所有中断，后面需要什么中断再依据需求打开。\n    outb(PIC_S_DATA, 0b11111111); // OCW1：屏蔽字，关闭从PIC所有中断，后面需要什么中断再依据需求打开。\n}\n```\n\nCPU在处理每个外中断后，需要向PIC发生一个结束字为的是通知PIC中断处理结束，具体中断结束方式由OCW2 来设置。代码如下：\n\n```cpp\n// 通知中断控制器，中断处理结束\nvoid send_eoi(int vector)\n{\n    if (vector >= 0x20 && vector < 0x28)\n    {\n        outb(PIC_M_CTRL, PIC_EOI);\n    }\n    if (vector >= 0x28 && vector < 0x30)\n    {\n        outb(PIC_M_CTRL, PIC_EOI);\n        outb(PIC_S_CTRL, PIC_EOI);\n    }\n}\n```\n\n至此单核OS中断的初始化到这里就结束了。\n\n### XV6多核处理的中断原理\n\n多核处理器中断控制器的结构更为复杂，因为偏向硬件，这里就只记录一下我对APIC的理解，理解不会太深，如果有错误，非常欢迎读者纠正！\n\n首先还是供上架构框图：\n\n![](./Scheduler/photo/scheduler/APICStructure.png)\n\n图片截取自：https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\n\n注释：\n\nBSP：bootstrap processor，可以简单理解为主处理器。\n\nAPx：application processors ，可以简单理解为从处理器。\n\n关于BSP和APx的关系这里先埋个伏笔。在【AP（从）处理器的启动】段落会进行详细叙述。\n\n从图中的上半部分可以了解到，每个CPU各自接着一个Local APIC（Advanced Programmable Interrupt Controller）。注意，**每个lapic和cpu是封装在一起的**（这里并不严谨，是否和cpu封装在一起其实和cpu的架构有关）。后面我们会看到，不止APIC，在多核cpu上，它的每一个cpu都有自己的一套cpu寄存器，比如：esp、eip、eflag等等。具体情况我们在“进程调度”段落进行详细讲解。\n\n从图的下半部分，我们可以了解到所有的lapic都接到了ICC（interrupt controller communications） Bus上，并且，总线上还接了一个IO APIC，这里的**ioapic是和cpu分离的**，它被接在cpu的外部。**ioapic会接收来自各个外设的中断。然后对各个外设发来的中断做一些判断和处理，再将中断的IRQ号和lapic的ID封装在一条“报文”中分发給对应的lapic**，具体发给哪些lapic，我们可以通过配置ioapic来进行设置。ioapic左边其实是有很多引脚（实际16个，如果级联了8259a可能会更多）每个引脚都可以接外设。有趣的是，从图中ioapic的左边可以看到，**ioapic的引脚还可以接8259a PIC控制器**，这非常完美的兼容了单核cpu的中断控制器的架构。\n\niopic是依据重定向表项 RTE(Redirection Table Entry)来构建“报文“，RTE对每一个中断都会有一项64位的entry。通过entry，可以单独设置ioapic在收到中断后对中断的操作。每一项entry描述：中断对应的中断向量？中断有没有使能？中断传输状态？发给哪个lapic？\n\n每个lapic都有一个唯一的ID，cpu可以在特定的内存（device space）上来查询自己所对应的lapic的ID号，lapic的ID其实也唯一标识了一个cpu。lapic会根据自己的ID从ICC Bus上接收属于自己的中断”报文“，然后经过一系列检查最后将中断发给cpu，当cpu处理完中断后，会反馈给自己的lapic，lapic收到cpu的回复后，同样将中断处理完毕的消息通知给ioapic，这点和单核架构中，cpu处理完中断后向master pic发送PIC_EOI是一样的道理。\n\n特别的是，lapic也可以像ioapic那样作为中断“源”（这里可能不严谨，但是可以类比去理解），向其他的lapic发送中断“报文”，这是通过ICR(Interrupt Command Register)寄存器实现，ICR的结构和ioapic的RTE表的entry结构类似，也有中断向量号、lapic的ID等字段。lapic主动向其他lapic发送中断“报文”最常见的场景就是BSP去启动其他APs，这一般通过会发送INIT or STARTUP IPI（interprocessor interrupts）。\n\n由于XV6中cpu对lapic、iopic初始化代码上，依赖于mpinit函数，而mpinit和多处理器内容相关，所以lapic、iopic初始化我们放到\"AP（从）处理器的启动\"段落进行讨论。\n\n关于Local APIC和IO APIIC详细内容可以参考博客：https://blog.csdn.net/weixin_46645613/article/details/119207945\n\n### 中断描述符表\n\n之前一直在介绍中断相关的外设，接下来我们看看cpu内部是怎么利用寄存器来定义中断的。\n\n因为中断不止一个，所以，和全局描述符类表似，中断表也是通过一个大的数组来记录每一个中断的属性。数组中每一个Entry格式如下图，每一个Entry同样是8个字节：\n\n![](./Scheduler/photo/scheduler/IDT_Entry.png)\n\n- Offset：记录中断门或陷阱门的处理函数的地址。\n\n- Selector：处理函数的段选择子。\n\n- Type：标记是中断门还是陷阱门。 **注意：中断门会自动清除eflag寄存器的FL_IF标志位，而陷阱门则保留eflag的FL_IF标志位。** 也即中断门会i自动关（外）中断，而陷阱门则不会有关中断的操作！\n\n- S：必须为0。\n\n- DPL：描述符可以被哪个特权级使用。对于中断门一般是0x0，对于陷阱门就是0x3（DPL_USER）。\n\n- P：是否有效，固定填1.\n\nXV6相关代码注释写的非常好，上面的中文注释也是参考XV6的注释写的，如下：\n\n```cpp\n// Gate descriptors for interrupts and traps\nstruct gatedesc {\n  uint off_15_0 : 16;   // low 16 bits of offset in segment\n  uint cs : 16;         // code segment selector\n  uint args : 5;        // # args, 0 for interrupt/trap gates\n  uint rsv1 : 3;        // reserved(should be zero I guess)\n  uint type : 4;        // type(STS_{IG32,TG32})\n  uint s : 1;           // must be 0 (system)\n  uint dpl : 2;         // descriptor(meaning new) privilege level\n  uint p : 1;           // Present\n  uint off_31_16 : 16;  // high bits of offset in segment\n};\n\n// Set up a normal interrupt/trap gate descriptor.\n// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.\n//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone\n// - sel: Code segment selector for interrupt/trap handler\n// - off: Offset in code segment for interrupt/trap handler\n// - dpl: Descriptor Privilege Level -\n//        the privilege level required for software to invoke\n//        this interrupt/trap gate explicitly using an int instruction.\n#define SETGATE(gate, istrap, sel, off, d)                \\\n{                                                         \\\n  (gate).off_15_0 = (uint)(off) & 0xffff;                \\\n  (gate).cs = (sel);                                      \\\n  (gate).args = 0;                                        \\\n  (gate).rsv1 = 0;                                        \\\n  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \\\n  (gate).s = 0;                                           \\\n  (gate).dpl = (d);                                       \\\n  (gate).p = 1;                                           \\\n  (gate).off_31_16 = (uint)(off) >> 16;                  \\\n}\n```\n\n中断描述符寄存器如下：\n\n高32位存放中断描述符表的基地址，低16位存放中断描述符表的大小（字节为单位）。\n\n![](./Scheduler/photo/scheduler/IDTR.png)\n\n## AP（从）处理器的启动\n\n首先还是回归main函数：\n\n```cpp\n// Bootstrap processor starts running C code here.\n// Allocate a real stack and switch to it, first\n// doing some setup required for memory allocator to work.\nint\nmain(void)\n{\n  kinit1(end, P2V(4*1024*1024)); // 内存内存管理已讲\n  kvmalloc();      // 内存内存管理已讲\n  mpinit();        // detect other processors\n  lapicinit();     // interrupt controller\n  seginit();       // 内存内存管理已讲\n  picinit();       // disable pic // 禁用单核架构下的8259A，实现很简单，这里就不去贴代码了\n  ioapicinit();    // another interrupt controller\n  // ...\n  pinit();         // process table // 实现很简单就是对自ptable的自旋锁进行一个初始化。读者可以自行阅读代码，这里就不过多赘述。\n  tvinit();        // trap vectors\n  // ...\n  startothers();   // start other processors\n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // 内存内存管理已讲\n  userinit();      // first user process // 就是对init进程的内核栈做一个初始化。利用了ROP（面向返回点编程）编程思想。因为这又是一个大主题，本文不会过多讲解。以后有机会在另开一篇博客专门讨论。\n  mpmain();        // finish this processor's setup // 进入mpmain\n}\n\n// Other AP CPUs jump here from entryother.S.\nstatic void\nmpenter(void)\n{\n  switchkvm();  // AP的内核页表换成kpgdir\n  seginit();    // 内存内存管理已讲\n  lapicinit();  // 作用同main函数中BSP核执行的lapicinit函数\n  mpmain();     // 进入mpmain\n}\n\n// BSP、APS最终都会进入改函数。\n// 主要工作就是\n//    1、加载中断描述表。\n//    2、设置状态，已启动。\n//    3、 进入调度循环。\n// Common CPU setup code.\nstatic void\nmpmain(void)\n{\n  cprintf(\"cpu%d: starting %d\\n\", cpuid(), cpuid());\n  idtinit();       // load idt register // 使用lidt命令加载中断描述符\n  xchg(&(mycpu()->started), 1); // tell startothers() we're up\n  scheduler();     // start running processes\n}\n```\n\n接下我们要从BSP执行的maiin函数开始，深入分析以上代码的作用。\n\n### mpinit：探测各个cpu\n\n该部分主要参考：[多处理器规范](https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf)，因为我英语也是很菜，所以硬着头皮捡重点去看了一部分。\n\n这里对多核处理器的启动流程做一个简单总结：我们可以理解为，多核CPU中，有一个CPU被设计成BSP，其他的CPU都被设计成AP。当然，在实际硬件设计上为了考虑容错性，任何一个CPU都能成为BSP核。 **系统最开始，BSP有对硬件的绝对控制权，包括去控制其他AP的启动和停止。为了启动其他AP核，BSP首先通过三种可能的方式搜索MP floating pointer structure，如果找到了一个有效的MP floating pointer structure就去遍历MP configuration table查询处理器信息和ioapic的信息；如果无法找到一个有效MP floating pointer structure，那就认为系统只有一个CPU——BSP。在所有CPU启动后，BSP就退化成AP，系统不存在BSP、AP之分。** 当然，我们需要要记录BSP CPU的lapic的ID（这个ID也唯一标识着CPU），这样我们才知道谁可以去其控制其他CPU的停止。在BSP启动其他AP前，因为AP CPU是暂停状态，所以其他AP无法执行OS代码，并且大部分中断都是被禁用，**但是INIT or STARTUP interprocessor interrupts (IPIs)不会被屏蔽，当AP收到来自BSP的INIT or STARTUP中断，就会启动它自己。** AP在收到BSP的启动中断后，也会进入保护模式、**有自己的独立的一套寄存器**、设置自己的全局描述符、开启分页、有自己的堆栈等。\n\n首先BSP会通过三种方式去搜索MP floating pointer structure，**三种搜索范围都在1M以内，因为MP floating pointer structure就是由BIOS提供，而BISO寻址范围就1M**：\n\n1. In the first kilobyte of Extended BIOS Data Area (EBDA), or\n2. Within the last kilobyte of system base memory, or\n3. In the BIOS ROM address space between 0F0000h and 0FFFFFh.\n\n低1M内存的内存映射参考：https://wiki.osdev.org/BDA#BIOS_Data_Area_.28BDA.29\n\nMP Configuration Data Structures整体框架如下图，图解了MP floating pointer structure、MP Configuration Table Header、Table Entries三者之间的一个关系，先了解一下大致的框架，接下来我门逐一剖析。\n\n![](./Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png)\n\nMP floating pointer structure图解如下：\n\n![](./Scheduler/photo/scheduler/MP_floating_pointer_structure.png)\n\n主要关注它的PHYSICAL ADDRESS POINTER，它指向MP config table的物理地址。\n\nMP Configuration Table Header结构如下：\n\n![](./Scheduler/photo/scheduler/MP_configuration_table_header.png)\n\n主要关注几个字段：\n- MEMORY-MAPPED ADDRESS OF LOCAL APIC：描述 cpu（**每个CPU都将它的lapic映射到了同一个物理地址**）的lapic的寄存器物理地址。注意这里是\"每个cpu\"，虽然是同一个物理地址，但是在每一个cpu去读的时候，分别映射到了各自的lapic的寄存器地址上了。\n\n- BASE TABLE LENGTH：整个table的长度，虽然存在扩展表长度，但是我们还用不到。\n\nMP Configuration Table Header后面会跟上各自类型的Base MP Configuration Table Entries，每个Entry的第一个字节会标明其类型，并且每种Entry的长度都各自固定，所以我们可以通过一个循环来遍历每个Entry，一共有5种类型的Entry，如下图：\n\n![](./Scheduler/photo/scheduler/entry_types.png)\n\nXV6中我们主要关注Processor Entries和I/O APIC两种类型的Entry。\n\nProcessor Entries结构如下：\n\n![](./Scheduler/photo/scheduler/processor_entry.png)\n\n主要关注LOCAL APIC ID，如该字段名字那样，就是代表和CPU绑定的lapic的ID，通过它我们也可以唯一标识一个CPU。\n\nI/O APIC Entries结构如下：\n\n![](./Scheduler/photo/scheduler/ioapic_entry.png)\n\n主要关注I/O APIC ID，代表I/O APIC的ID。\n\n然后上代码：\n\n```cpp\nvoid\nmpinit(void)\n{\n  uchar *p, *e;\n  int ismp;\n  struct mp *mp;              // 前面提到的MP floating pointer structure\n  struct mpconf *conf;        // 前面提到的MP Configuration Table Header\n  struct mpproc *proc;        // 前面提到的Processor Entries\n  struct mpioapic *ioapic;    // 前面提到的I/O APIC Entries\n\n  if((conf = mpconfig(&mp)) == 0)     // 用上面提到的三种方法寻找MP floating pointer structure，并且判断它的合法性，然后将结构体里面的PHYSICAL ADDRESS POINTER（指向MP Configuration Table Header）作为返回值\n    panic(\"Expect to run on an SMP\");\n  ismp = 1;\n  lapic = (uint*)conf->lapicaddr;     // 将lapic的寄存器地址放到全局变量lapic中\n  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){  // 依据MP Configuration Table Header遍历每一个Table Entry。\n    switch(*p){\n    case MPPROC:                      // Processor Entries\n      proc = (struct mpproc*)p;\n      if(ncpu < NCPU) {\n        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu // 保存cpu的lapic的id\n        ncpu++;                       // 找到一个CPU\n      }\n      p += sizeof(struct mpproc);\n      continue;\n    case MPIOAPIC:                    // I/O APIC Entries\n      ioapic = (struct mpioapic*)p;\n      ioapicid = ioapic->apicno;      // 将ioapicid存到全局变量，将来初始化的时候会用\n      p += sizeof(struct mpioapic);\n      continue;\n    case MPBUS:                       // 其他的不关注，加上他们的大小去找下一个Table Entry。\n    case MPIOINTR:\n    case MPLINTR:\n      p += 8;\n      continue;\n    default:\n      ismp = 0;\n      break;\n    }\n  }\n  if(!ismp)\n    panic(\"Didn't find a suitable machine\");\n\n  if(mp->imcrp){\n    // 如果之前是PIC Mode，就切换到APIC模式 \n    // interrupt mode configuration register --> IMCR\n    // Bochs doesn't support IMCR, so this doesn't run on Bochs.\n    // But it would on real hardware.\n    outb(0x22, 0x70);   // Select IMCR\n    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.  // 进入APIC模式\n  }\n}\n```\n\nmp->imcrp字段的解释如下：\n\n![](./Scheduler/photo/scheduler/imcrp.png)\n\n详细信息可以了解一下：[多处理器规范](https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf)\n\n### lapicinit：BSP初始化自己cpu的lapic\n\n这部分和硬件强相关，我也了解不是特别多，尽可能的讲清楚吧。硬件相关的初始化深入下去也是一个无底洞。如果读者感兴趣的话，可以去查intel 64 and IA-32 卷3开发手册。 \n\n```cpp\nvoid\nlapicinit(void)\n{\n  if(!lapic)    // lapic就是上面mpinit函数在MP Configuration Table Header中得到的lapic寄存器的物理映射地址，所以说初始化的顺序非常严格！\n    return;\n\n  // Enable local APIC; set spurious interrupt vector.\n  lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));      // 开启此cpu的APIC\n\n  // 配置时钟，属于lapic的本地中断\n  // The timer repeatedly counts down at bus frequency\n  // from lapic[TICR] and then issues an interrupt.\n  // If xv6 cared more about precise timekeeping,\n  // TICR would be calibrated using an external time source.\n  lapicw(TDCR, X1);                               // 分频系数为X1\n  lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER)); // 以PERIODIC为周期，映射到0x20中断\n  lapicw(TICR, 10000000);                         // 时钟频率\n\n  // Disable logical interrupt lines.\n  lapicw(LINT0, MASKED);                          // 屏蔽LINT0（lapic本地中断\n  lapicw(LINT1, MASKED);                          // 屏蔽LINT1（lapic本地中断\n\n  // Disable performance counter overflow interrupts\n  // on machines that provide that interrupt entry.\n  if(((lapic[VER]>>16) & 0xFF) >= 4)\n    lapicw(PCINT, MASKED);                        // 屏蔽PCINT（好像是废话？\n\n  // Map error interrupt to IRQ_ERROR.\n  lapicw(ERROR, T_IRQ0 + IRQ_ERROR);            // 0x20 + 0x13（ERROR）\n\n  // Clear error status register (requires back-to-back writes).\n  lapicw(ESR, 0);\n  lapicw(ESR, 0);\n\n  // Ack any outstanding interrupts.\n  lapicw(EOI, 0);                               // 向ioapic发送一个EOI，以免中断丢失\n\n  // Send an Init Level De-Assert to synchronise arbitration ID's.\n  lapicw(ICRHI, 0);                             // ？？？// 这里应该是向其他apic广播一条“报文”，通知“我”启动了\n  lapicw(ICRLO, BCAST | INIT | LEVEL);          // 广播的形式 & 传送模式为INIT & 水平触发\n  while(lapic[ICRLO] & DELIVS)                  // 中断的传输状态：是否已经发送？\n    ;\n\n  // Enable interrupts on the APIC (but not on the processor).\n  lapicw(TPR, 0);\n}\n```\n\n**以上代码就是初始化BSP的lapic，在其他AP启动后，都要执行一遍这段代码。**\n\n### ioapicinit：初始化ioapic\n\nioapic的作用和单核架构下master pic很像，但是对于ioapic的初始化步骤很简单，不需要发送一系列的控制字。对于ioapic的初始化就是简单的配置一下重定向表项 RTE(Redirection Table Entry)，给RTE的每一项一个初值，设置它的中断向量号（起始T_IRQ0，T_IRQ0 == 0x20），并且默认是中断屏蔽的。后续需要什么中断再对相应的Entry做配置即可，比如consoleinit为了使用键盘调用了ioapicenable去配置对应的Entry打开中断等。关于重定向表项 RTE(Redirection Table Entry)的解释，读者可以看一下这篇文章，讲的非常详细：https://blog.csdn.net/weixin_46645613/article/details/119207945\n\n```cpp\nvoid\nioapicinit(void)\n{\n  int i, id, maxintr;\n\n  ioapic = (volatile struct ioapic*)IOAPIC;           // 默认地址：0xFEC00000   // Default physical address of IO APIC\n  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;       // ioapic支持的最大中断号\n  id = ioapicread(REG_ID) >> 24;                      // 从寄存器读到的ioapic的ID\n  if(id != ioapicid)                                  // 必须一致\n    cprintf(\"ioapicinit: id isn't equal to ioapicid; not a MP\\n\");\n\n  // Mark all interrupts edge-triggered, active high, disabled,\n  // and not routed to any CPUs.\n  for(i = 0; i <= maxintr; i++){    // 初始化重定向表项 RTE(Redirection Table Entry)，这里和单核架构下主从PIC一样，先将所有的中断屏蔽掉，在后面初始化的时候再按需使能。\n    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));\n    ioapicwrite(REG_TABLE+2*i+1, 0);\n  }\n}\n```\n\n### tvinit：初始化中断向量表\n\n这里自顶向下介绍XV6的中断向量表是如何构造的。\n\n涉及到的变量如下：\n\n```cpp\n// Interrupt descriptor table (shared by all CPUs).\nstruct gatedesc idt[256];   // 中断描述符表\nextern uint vectors[];  // vectors的定义文件是：由vectors.pl生成的汇编代码文件。\n```\n\n首先是tvinit函数，它是最顶层负责构造中断向量表的函数，SETGATE宏在上面已经贴过它的实现，这里简单介绍一个各个参数的作用。\n\nSETGATE(gate, istrap, sel, off, d) ：\n\n- 参数1：对应idt[i]，表示每一项entry。\n\n- 参数2：标记是中断门还是陷阱门。\n\n- 参数3：段选择子。\n\n- 参数4：中断处理函数地址。\n\n- 参数5：中断描述符被哪个特权级使用。\n\n结合代码来看：\n\n```cpp\nvoid\ntvinit(void)\n{\n  int i;\n  // 构造中断描述符表\n  for(i = 0; i < 256; i++)\n    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);\n\n  // 初始化系统调用中断描述符，类型是陷阱门（发生中断不会关中断），特权级是DPL_USER。\n  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);\n\n  initlock(&tickslock, \"time\");\n}\n```\n\n然后是vectors.pl文件生成汇编代码的过程，pl我之前也没有了解过，不过从它的代码可以看出，有点像字符串拼接的处理语言，简化了重复性代码的编写，代码如下：\n\n```pl\n#!/usr/bin/perl -w\n\n# Generate vectors.S, the trap/interrupt entry points.\n# There has to be one entry point per interrupt number\n# since otherwise there's no way for trap() to discover\n# the interrupt number.\n\nprint \"# generated by vectors.pl - do not edit\\n\";\nprint \"# handlers\\n\";\nprint \".globl alltraps\\n\";\nfor(my $i = 0; $i < 256; $i++){\n    print \".globl vector$i\\n\";\n    print \"vector$i:\\n\";\n    if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){\n        # 这些中断cpu自动压入errcode参数，\n        # 为保证中断栈帧的统一，所以我们在\n        # 这些特殊中断手动压入0值，这样就能\n        # 统一使用trapret来恢复上下文。\n        print \"  pushl \\$0\\n\";\n    }\n    print \"  pushl \\$$i\\n\";\n    print \"  jmp alltraps\\n\";\n}\n\nprint \"\\n# vector table\\n\";\nprint \".data\\n\";\nprint \".globl vectors\\n\";\nprint \"vectors:\\n\";\nfor(my $i = 0; $i < 256; $i++){\n    print \"  .long vector$i\\n\";\n}\n```\n\n从pl代码上我们可以看到，就是利用for循环构造vectors数组，该数组专门存放中断处理函数。我们先来分析一下它如何构造vectors的，首先最上面有一个for循环，for循环中使用了一个if判断，因为有些中断cpu不会自动压入错误码，所以我们需要**手动压入一个占位值**，方便trapret的处理。在for循环下面最后压入了一个jmp指令，所以pl生成的汇编并不是中断处理函数最终代码，pl生成的中断处理函数会跳到alltraps，alltraps代码我们下面再进行分析。pl在最后生成的汇编代码定义了一个vectors数组，数组里面元素就是上面定义的256个vectori（i=1、2、...）。\n\n最后就是trapasm.S文件对alltraps的实现，常规的进行上下文保护：\n\n```asm\n#include \"mmu.h\"\n\n  # vectors.S sends all traps here.\n.globl alltraps\nalltraps:          # 保存上下文\n  # Build trap frame.\n  pushl %ds\n  pushl %es\n  pushl %fs\n  pushl %gs\n  pushal\n  \n  # Set up data segments.\n  movw $(SEG_KDATA<<3), %ax\n  movw %ax, %ds\n  movw %ax, %es\n\n  # Call trap(tf), where tf=%esp\n  pushl %esp\n  call trap       # 进入trap函数\n  addl $4, %esp\n\n  # Return falls through to trapret...\n.globl trapret\ntrapret:          # 恢复上下文\n  popal\n  popl %gs\n  popl %fs\n  popl %es\n  popl %ds\n  addl $0x8, %esp  # trapno and errcode\n  iret\n```\n\ntvinit、pl、alltraps三者之间的关系总览图如下：\n\n![](./Scheduler/photo/scheduler/trap__structure.png)\n\n\n关于中断帧，这里要注意，涉及特权级转换的中断帧和不涉及特权级转换的中断帧有些许不一样。如下：\n\n用户态触发中断（陷阱门或中断门）过程如下：\n\n0. 用户查询TSS（任务状态段）段，找到用户进程在内核态的栈段和栈顶指针（ss0、esp0）。\n\n1. **cpu将ss、esp压入（内核）栈中。**（硬件\n\n2. cpu将eflags、cs、eip压入栈中。**中断门还要关中断**，陷阱门不用。（硬件\n\n3. 执行用户中断处理函数**alltraps**的**上下文保护**的代码。（软件\n\n4. 调用trap函数，处理各种中断。\n\n5. 执行用户中断处理函数**trapret**的**上下文恢复**的代码。（软件\n\n6. 调用iret，cpu恢复eflags、cs、eip。（硬件\n\n7. cpu恢复ss、esp。（硬件\n\n而内核线程发生中断（**注意，内核态不会发生系统调用，这不应该也不合理**），过程如下：\n\n1. cpu将eflags、cs、eip压入栈中。**中断门还要关中断**，陷阱门不用。（硬件\n\n2. 执行用户中断处理函数**alltraps**的**上下文保护**的代码。（软件\n\n3. 调用trap函数，处理各种中断。\n\n4. 执行用户中断处理函数**trapret**的**上下文恢复**的代码。（软件\n\n5. 调用iret，cpu恢复eflags、cs、eip。（硬件\n\nXV6中定义的栈帧结构体如下：\n\n```cpp\n//PAGEBREAK: 36\n// Layout of the trap frame built on the stack by the\n// hardware and by trapasm.S, and passed to trap().\nstruct trapframe {\n  // registers as pushed by pusha\n  uint edi;\n  uint esi;\n  uint ebp;\n  uint oesp;      // useless & ignored\n  uint ebx;\n  uint edx;\n  uint ecx;\n  uint eax;\n\n  // rest of trap frame\n  ushort gs;\n  ushort padding1;\n  ushort fs;\n  ushort padding2;\n  ushort es;\n  ushort padding3;\n  ushort ds;\n  ushort padding4;\n  uint trapno;\n\n  // below here defined by x86 hardware\n  uint err;\n  uint eip;\n  ushort cs;\n  ushort padding5;\n  uint eflags;\n\n  // below here only when crossing rings, such as from user to kernel\n  uint esp;\n  ushort ss;\n  ushort padding6;\n};\n```\n\n中断帧如下图：\n\n![](./Scheduler/photo/scheduler/trap_frame.png)\n\n图片引用自：https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\n\n### startothers：激活其他AP处理器\n\n到这里终于要开始启动其他AP核了，AP核的启动也是一种固定套路，在[多处理器规范](https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf)中这种套路称为universal algorithm。XV6中这个算法实现在lapicstartap函数中。\n\n流程如下：\n\n![](./Scheduler/photo/scheduler/universal_algorithm.png)\n\nXV6代码启动其他AP处理器的核心流程如下：\n\n```cpp\n// Start the non-boot (AP) processors.\nstatic void\nstartothers(void)\n{\n  extern uchar _binary_entryother_start[], _binary_entryother_size[];\n  uchar *code;\n  struct cpu *c;\n  char *stack;\n\n  // Write entry code to unused memory at 0x7000.\n  // The linker has placed the image of entryother.S in\n  // _binary_entryother_start.\n  // AP核的entryother代码的入口点，entryother 就是 boot + entry的结合体\n  code = P2V(0x7000);\n\n  // 这里将entryother的代码移到物理地址0x7000处\n  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);\n\n  // BSP for循环向每个AP发送中断。\n  for(c = cpus; c < cpus+ncpu; c++){\n    if(c == mycpu())  // We've started already.\n      continue;\n\n    // Tell entryother.S what stack to use, where to enter, and what\n    // pgdir to use. We cannot use kpgdir yet, because the AP processor\n    // is running in low  memory, so we use entrypgdir for the APs too.\n    stack = kalloc();   // 为每个AP核分配一个执行scheduler函数的内核栈\n    *(void**)(code-4) = stack + KSTACKSIZE;\n    *(void(**)(void))(code-8) = mpenter;  // 指定AP特有main（mpenter）函数入口点。\n    // 同BSP刚启动一样，使用使用4M big page页表。\n    *(int**)(code-12) = (void *) V2P(entrypgdir);\n\n    // lapicstartap就是实现了universal algorithm，因为我也不太懂，这里就不贴了。\n    lapicstartap(c->apicid, V2P(code));   \n\n    // 等待AP初始化完毕\n    // wait for cpu to finish mpmain()\n    while(c->started == 0)  \n      ;\n  }\n}\n```\n\n在每个AP boot点和BSP的boot点类似，BSP是在0x7c00启动，AP是在0x7000启动。同样，0x7000也会执行一段汇编代码，这段汇编代码作用就是bootasm.S + entry.S代码的结合体。这里简单总结一下：\n\n1. 加载临时全局描述符，进入保护模式\n\n2. 使用entrypgdir开启分页。\n\n3. 切换到预分配的内核（scheduler）栈。\n\n4. 进入mpenter。\n\n考虑到文章太长，代码就不放了。文件是entryother.S，有兴趣的读者可自行研究。\n\nmpenter代码如下：\n\n```cpp\n// Other CPUs jump here from entryother.S.\nstatic void\nmpenter(void)\n{\n  switchkvm();    // 切换到粒度更小（4k）的内核页，kpgdir。\n  seginit();       //效果同BSP，在main中BSP也调用了该函数。就是第二次初始化段描述符。（第一次是在entryother.S\n  lapicinit();    // 效果同BSP\n  mpmain();       // 进入mpmain\n}\n```\n\n上面那段代码就是：AP会像BSP那样，调用一遍所有的和CPU相关初始化函数，最终进入mpmain。（BSP在main最后也会进入mpmain，前面提到过BSP启动其他后，也成为了一个AP）\n\nmpmain在加载中断描述符表后，最终就会进入scheduler，CPU正式开启操作系统的任务调度！\n\nmpmain如下：\n\n```cpp\n// Common CPU setup code.\nstatic void\nmpmain(void)\n{\n  cprintf(\"cpu%d: starting %d\\n\", cpuid(), cpuid());\n  idtinit();       // load idt register\n  xchg(&(mycpu()->started), 1); // tell startothers() we're up\n  scheduler();     // start running processes\n}\n```\n\n## 进程调度\n\n首先了解一下XV6对CPU的定义，注释写的非常详细：\n\n```cpp\n// Per-CPU state\nstruct cpu {\n  // lapci的id\n  uchar apicid;                // Local APIC ID\n  // 执行调度器栈指针\n  struct context *scheduler;   // swtch() here to enter scheduler\n  // 任务状态段、为进程从用户态陷入内核态切栈使用\n  struct taskstate ts;         // Used by x86 to find stack for interrupt\n  // 全局描述符\n  struct segdesc gdt[NSEGS];   // x86 global descriptor table\n  // 指示cpu是否启动\n  volatile uint started;       // Has the CPU started?\n  // 关中断的深度\n  int ncli;                    // Depth of pushcli nesting.\n  // 记录在cpu第一层关中断前，中断关闭情况\n  int intena;                  // Were interrupts enabled before pushcli?\n  // cpu当前运行的进程PCB\n  struct proc *proc;           // The process running on this cpu or null\n};\n\nextern struct cpu cpus[NCPU]; // 多个cpu\nextern int ncpu;              // cpu的个数\n```\n\n下面列出了各个CPU资源的共享情况，可以做一个参考：\n\n| 资源                                      |  共享     | 不共享  |\n| :-:                                       |  :-:      |  :-:    |\n| 中断描述符表                               |√         |         |\n| lapic（也指外中断，包括定时器等）           |           | √       |\n|ioapic                                     |√         |          |\n|cpu的各种寄存器，包括eip、esp、eflag等等     |          |√         |\n|全局描述符表（包括任务状态段）               |           |√        |\n|kpgdir（内核调度器使用的页表）               |√         |          |\n|物理内存                                   |√         |          |\n|任务队列（ptable）                          |√        |          |\n|调度器的执行栈                              |         |√         |\n|外设                                       |         |√         |\n\n接下来是XV6的PCB（进程控制块），之前老是在教科书上看到它，当时感觉很难理解，在分析过OS源码后，再回过头去看，就感觉特别通透。XV6的PCB就是一个结构体，里面存放了很多成员，XV6的PCB和进程的内核栈是分开的，PCB结构体是通过一个指针来指向进程的内核栈。相比之下，Onix的PCB和内核栈是连在一起的，内核栈的低地址就是存放的PDB结构体，因为esp是线下增长，所以esp指向高地址处，并且典型的内核栈大小是一页（4K）（于是esp指向页面的4K处）。\n\nXV6的PCB定义如下：\n\n```cpp\n// proc.h\nenum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };\n\n// Per-process state\nstruct proc {\n  // 进程（映射了页框的）虚拟内存大小\n  uint sz;                     // Size of process memory (bytes)\n  // 进程的页表\n  pde_t* pgdir;                // Page table\n  // 进程的内核栈\n  char *kstack;                // Bottom of kernel stack for this process\n  // 进程状态\n  enum procstate state;        // Process state\n  // 进程pid\n  int pid;                     // Process ID\n  // 进程的父进程\n  struct proc *parent;         // Parent process\n  // 调用系统调用时的栈帧\n  struct trapframe *tf;        // Trap frame for current syscall\n  // 内核态的上下文\n  struct context *context;     // swtch() here to run process\n  // 等待条件\n  void *chan;                  // If non-zero, sleeping on chan\n  // 是否被杀死\n  int killed;                  // If non-zero, have been killed\n  // 打开的文件\n  struct file *ofile[NOFILE];  // Open files\n  // 工作目录的inode\n  struct inode *cwd;           // Current directory\n  // 进程名\n  char name[16];               // Process name (debugging)\n};\n\n// proc.c\nstruct {\n  struct spinlock lock;       // 自旋锁\n  struct proc proc[NPROC];\n} ptable;                     // 多个cpu之间共享该结构\n\nstatic struct proc *initproc; // 存放init进程PCB\nint nextpid = 1;              // 分配唯一pid\n```\n\nXV6为进程定义了6种状态：UNUSED（PCB未使用）, EMBRYO（初始化中）, SLEEPING（阻塞休眠）, RUNNABLE（可调度）, RUNNING（运行中）, ZOMBIE（僵尸/待回收）。 这里特别说明一下PCB的chan成员，该成员一个进程的等待条件。XV6中一个进程可能会调用sleep、wait系統調用，或者在調用read系統調用时间接调用了sleeplock，这些函数都会使一个进程进入阻塞状态，XV6的阻塞状态统一使用SLEEPING来表示，阻塞就是为了等待某个条件发生，当等待的条件发生时，阻塞的进程就会被唤醒，但是ptable有那么多阻塞的进程，我应该唤醒ptable中的哪些进程呢？此时chan就起到关键作用，在进程进入阻塞之前，会将chan设置为某一个变量的地址，当条件满足XV6就是通过chan来唤醒对应的进程的，当然这个变量的选取是很有讲究的，比如在XV6中因为sleep而休眠的进程，它的chan会被设置成ticks（作用类似jefrris，定时器中断的计数器）的地址。具体细节就不深入讨论，感兴趣的读者可以看看XV6的源码。\n\n从AP（从）处理器的启动段落我们知道，BSP、AP最终都进入scheduler函数，铺垫了这么久，scheduler函数也是本文的主题，那么先来看看它的代码实现吧：\n\n```cpp\n//PAGEBREAK: 42\n// Per-CPU process scheduler.\n// Each CPU calls scheduler() after setting itself up.\n// Scheduler never returns.  It loops, doing:\n//  - choose a process to run\n//  - swtch to start running that process\n//  - eventually that process transfers control\n//      via swtch back to the scheduler.\nvoid\nscheduler(void)\n{\n  struct proc *p;\n  struct cpu *c = mycpu();  // 找到scheduler正运行在哪个cpu上\n  c->proc = 0;              // 将cpu结构体的当前运行的进程清零\n  \n  for(;;){\n    // Enable interrupts on this processor.\n    sti();                  // 打开中断、之前中断一直是关闭的！\n\n    // 这里pushcli保存的mycpu()->intena其实没有意义，在切换后会被外面的sched直接覆盖。\n    // Loop over process table looking for process to run.\n    acquire(&ptable.lock); // 共用ptable，所以需要获取自旋锁，互斥访问。\n    // 遍历ptable\n    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){\n      if(p->state != RUNNABLE)  // 进程状态不可运行\n        continue;\n      // else 找到了一个可运行的进程\n      // Switch to chosen process.  It is the process's job\n      // to release ptable.lock and then reacquire it\n      // before jumping back to us.\n      c->proc = p;  // 设置p为cpu当前运行进程\n      //  这个函数非常关键，主要做两个三个操作：\n      // 1、设置tss，并将其追加到全局描述符\n      // 2、设置tss的选择子\n      // 3、让cpu使用进程p的页表。\n      switchuvm(p);\n      p->state = RUNNING; // 设置p为运行状态\n\n      swtch(&(c->scheduler), p->context); // 正式开始切换，等到p放弃cpu才会返回\n      switchkvm();        // 切换回内核页表kpgdir\n\n      // Process is done running for now.\n      // It should have changed its p->state before coming back.\n      c->proc = 0;        // 当前运行的进程清零\n    }\n    release(&ptable.lock);  // 释放自旋锁\n\n  }\n}\n```\n\nXV6的调度算法非常简单，就是简单的round robin算法。主要精华是整个调度的过程，至于它具体的调度算法其实显得并不是特别重要。\n\nswitchuvm函数实现非常关键，它里面会设置tss，并且设置cpu使用进程p的页表。**tss全称是任务状态段，它可以帮助处于用户态的进程回到内核态**，因为一个进程有两个栈，一个是出于用户态使用，另外一个是处于内核态使用，进程从内核态转变成用户态容易。只需要将中断帧弹出恢复上下文即可，但是从用户态回到内核态就难了，因为进入用户态后，进程的用户态空间不会保留进程任何内核态信息，所以，我们需要一个东西来帮助处于用户态的进程在需要陷入内核态时，找到它的内核态的栈，这个东西就是TSS，TSS会记录一个进程的内核栈的栈指针esp和栈段ss，switchuvm函数正是完成了这样的功能。实现如下：\n\n```cpp\n// Switch TSS and h/w page table to correspond to process p.\nvoid\nswitchuvm(struct proc *p)\n{\n  if(p == 0)\n    panic(\"switchuvm: no process\");\n  if(p->kstack == 0)\n    panic(\"switchuvm: no kstack\");\n  if(p->pgdir == 0)\n    panic(\"switchuvm: no pgdir\");\n\n  pushcli();\n  // 因为tss也是一个段，所以向cpu的全局描述符中追加tss的描述符\n  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,\n                                sizeof(mycpu()->ts)-1, 0);\n  mycpu()->gdt[SEG_TSS].s = 0;\n  mycpu()->ts.ss0 = SEG_KDATA << 3;                 // 内核栈段\n  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;  // 内核栈指针\n  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit\n  // forbids I/O instructions (e.g., inb and outb) from user space\n  mycpu()->ts.iomb = (ushort) 0xFFFF;\n  ltr(SEG_TSS << 3);                                // tss段选择子\n  // 切换到p的页表\n  lcr3(V2P(p->pgdir));  // switch to process's address space\n  popcli();\n}\n```\n\n关于任务状态段的详情描述可以参考：https://github.com/StevenBaby/onix/blob/dev/docs/07%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/062%20%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E7%AE%80%E4%BB%8B.md\n\nswtch函数由汇编实现，是进程切换的核心函数，实现如下：\n\n```asm\n# Context switch\n#\n#   void swtch(struct context **old, struct context *new);\n# \n# Save the current registers on the stack, creating\n# a struct context, and save its address in *old.\n# Switch stacks to new and pop previously-saved registers.\n\n.globl swtch\nswtch:                # 这里有个pushl eip，cpu帮我们自动执行了\n  movl 4(%esp), %eax  # 第一个参数，struct context**\n  movl 8(%esp), %edx  # 第二个参数  struct context*\n\n  # Save old callee-saved registers\n  pushl %ebp\n  pushl %ebx\n  pushl %esi\n  pushl %edi\n\n  # Switch stacks\n  movl %esp, (%eax) # 加括号和在指针前面加*一个道理，这里保存当前内核栈指针到第一个参数上\n  movl %edx, %esp   # 将esp切换到第二个参数指向的内核栈上\n\n  # Load new callee-saved registers\n  popl %edi\n  popl %esi\n  popl %ebx\n  popl %ebp\n  ret\n```\n\nstruct context结构体定义如下：\n\n```cpp\nstruct context {\n  uint edi;\n  uint esi;\n  uint ebx;\n  uint ebp;\n  uint eip;\n};\n```\n\n一个进程在（因为时间片用完）需要放弃cpu执行权限，如何回到scheduler呢？答案就是使用sched函数，本文我们以普遍的事件来分析————因为时间片用完而放弃的cpu。处于**用户态的进程因为时间片用完会发生定时器中断**，定时器中断又会引发从用户态到内核态的切栈、保存上下文、执行trap函数，trap函数中最后调用了yield，yield最终会调用sched，trap函数伪代码如下：\n\n```cpp\nstruct spinlock tickslock;\nuint ticks;\n\n//PAGEBREAK: 41\nvoid\ntrap(struct trapframe *tf)\n{\n  if(tf->trapno == T_SYSCALL){  // 是系统调用\n    // ...\n    return;\n  }\n\n  switch(tf->trapno){\n  case T_IRQ0 + IRQ_TIMER:\n    if(cpuid() == 0){\n      acquire(&tickslock);\n      ticks++;            // 每次定时器中断都自增1\n      wakeup(&ticks);     // 唤醒sleeping进程，检查休眠是否到期\n      release(&tickslock);\n    }\n    lapiceoi();           // 通知lapic中断处理完毕\n    break;\n  // ...\n  }\n\n  // ...\n\n  // Force process to give up CPU on clock tick.\n  // If interrupts were on while locks held, would need to check nlock.\n  if(myproc() && myproc()->state == RUNNING &&\n     tf->trapno == T_IRQ0+IRQ_TIMER)\n    yield();    // 时间片用完，cpu让给下一个进程\n\n  // ...\n}\n```\n\nyield函数实现就是封装了一下sched函数，在调用sched之前，将进程的状态设置成了RUNNABLE状态：\n\n```cpp\n// Enter scheduler.  Must hold only ptable.lock\n// and have changed proc->state. Saves and restores\n// intena because intena is a property of this\n// kernel thread, not this CPU. It should\n// be proc->intena and proc->ncli, but that would\n// break in the few places where a lock is held but\n// there's no process.\nvoid\nsched(void)\n{\n  int intena;\n  struct proc *p = myproc();\n\n  if(!holding(&ptable.lock))\n    panic(\"sched ptable.lock\");\n  if(mycpu()->ncli != 1)        // 最多一层关中断\n    panic(\"sched locks\");\n  if(p->state == RUNNING)       // 在调用sched前，应该改变进程状态\n    panic(\"sched running\");\n  if(readeflags()&FL_IF)        // 中断必须被关闭！\n    panic(\"sched interruptible\");\n  intena = mycpu()->intena;     // intena是进程私有的\n  swtch(&p->context, mycpu()->scheduler); // 切换到scheduler\n  mycpu()->intena = intena;     // 还原intena\n}\n\n// Give up the CPU for one scheduling round.\nvoid\nyield(void)\n{\n  acquire(&ptable.lock);  //DOC: yieldlock\n  myproc()->state = RUNNABLE;\n  sched();\n  release(&ptable.lock);\n}\n```\n\nsched中保存intena状态到进程的内核栈中的做法，好像把intena变量放到PCB中更合适，但是XV6没有这么做。从shced函数注释中了解到，如果把intena变量放到PCB中的话，有些情况下会有问题。具体呢，就不去细究了（我也每深究），本文内容太长了，还是以调度为主。这里主要是想表达一个点：**scheduler函数给ptable.lock加锁时，pushcli保存的intena没有任何意义。因为最终在切换进程时，会被sched中进程的intena给覆盖掉。同样，在进程回到scheduler函数后，scheduler函数给ptable.lock解锁时，popcli还原的intena也没有任何意义，因为无论intena原来是否开中断，外层的for都会开中断！**\n\n最终，一个待调度的进程的内核栈帧就形成了：\n\n![](./Scheduler/photo/scheduler/task_stack.drawio.png)\n\n一张图片概括yield、scheduler的加锁关系。如下图，进程利用yield进入调度器时会获取ptable的自旋锁（自旋锁内部会关中断，并且将关中断之前的中断状态保存到intena中），在切换到scheduler后（可能）会由scheduler解锁。在从scheduler切换到下一个任务前，（可能）scheduler会获取ptable的自旋锁，在却换到下一个任务后，由任务进行解除ptable的自选锁，注意这里是可能，因为还有可能scheduler的内层循环还没有执行完，以至于内层循环还可以找到下一个待执行的日任务，此时ptable的锁，就是：老进程加锁，新进程解锁：\n\n![](./Scheduler/photo/scheduler/yield_scheduler.png)\n\n总的来说，XV6进程调度整体流程是：**每个cpu上都运行调度线程，调度线程运行sheduler函数，scheduler不断从ptable取进行任务，然后（swapIn）切换去执行进程任务，当进程任务用完时间片（通过定时器中断）就会放弃cpu的执行权限，（swapOut）切换到内核调度线程继续去调度下一个进程任务。**\n\n如果类比于用户态的协程的：**对称协程和非对称协程之分吗的话，结合非对称协程的特点：协程的切换需要经过调度协程，而由于XV6进程的调度都必须经内核的过调度线程，所以XV6的调度器模型更像一种“非对称进程”。**\n\n**作为对比，如果你阅读过Onix的代码，你会发现Onix的调度模型更像是一种”对称进程“，因为Onix的进程切换是两个进程之间直接进行，不存在中间的调度线程。**\n\n这里我可以用一张**类似sylar的协程调度器模型来总结XV6进程调度模型**：\n\n![](./Scheduler/photo/scheduler/scheduler.drawio.png)\n\n**其实CPU Pool和线程池非常像，XV6的每个CPU都互斥到ptable中去取进程，然后去消化进程。唯一的区别就是CPU要和很多寄存器、硬件打交道，但是最终整体的框架思想都是一同百通，**\n\n如果你看过sylar的源码，你会深有感触！ **sylar的协程调度器模型和XV6进程的调度模型不能说像，只能是真的一模一样！** sylar是一个C++的基于协程的网络框架。我之前也有写过sylar的博客，这里推荐大家去看看：https://blog.csdn.net/m0_52566365/article/details/135991331。\n\n## 总结\n\nXV6有很多地方写的很暴力，有很大的优化空间，比如：\n\n|                             |XV6做法                        |Onix做法                 |\n|:-:                          |:-:|:-:|\n|内存管理|不管是物理内存还是内核内存一股脑使用kalloc，用户页表所有的内容都靠kalloc|get_page（使用256个页管理4G物理页，专门给页表和页框分配内存/page） + alloc_kpage（专门给内核分配内核页所有的页目录都采用alloc_kpage/page） + kmalloc（使用了内存池专门管理内核中的小快内存/byte）|\n|内核对系统调用参数的获取       |直接访问用户栈空间               |使用ebp、edi、esi、edx、ecx、ebx寄存器获取系统调用参数|\n|软件定时器                     |没有实现软件定时器               |利用链表实现了软件定时器 |\n|内存探测                       |未实现内存探测                 |loader实现了内存探测     |\n|idle任务                     |没实现idle任务                   |实现了idle任务           |\n|...                          |...                             |...                     |\n\n从上表可以看到Onix每一项都是存在优势的。但是Onix唯一的缺点，也是我读了Onix源码又来读XV6源码的原因：Onix是一个**单核**OS。其实读完XV6了解了多核OS的实现后，也没感到很大的震撼，多核CPU无非就是比单核CPU多了几套eip、esp、eflag等cpu相关的寄存器，cpu访问共享资源的的时候注意加锁就好了。\n\n最后谈谈XV6调度模型的优化：从**XV6进程调度模型图**我们可以看到，XV6的调度模型可以参考Muduo的One loop per thread 思想（可能说Muduo的One loop per thread思想参考了现代Linux对CPU的调度模型更合适？），因为XV6进程调度模型非常暴力，所有cpu共享有一个任务池（ptable），锁的竞争非常激烈。我们可以考虑让每个cpu都拥有一个自己独立的ptable（当然里面还是有自旋锁），由一个cpu负责负载均衡，将任务均匀的分发给各个cpu，需要修改cpux内部数据结构时，其他cpu只需向cpux的回调队列中添加操作函数即可，具体的操作还是由cpux自己完成。**也即One loop per CPU**。如下图：\n\n![](./Scheduler/photo/scheduler/scheduler_pluse.drawio.png)\n\n终于4干完了这篇文章，字数预计上万了，第一次写这么长的文章，也是真的用心了。创作不易，赏个赞把！\n\n**参考资料**\n\n多处理器规范：https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\n\nXV6的官方中文文档：https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\n\nOnix单核操作系统：https://github.com/StevenBaby/onix/\n\nAPIC中断讲解比较好的范文：https://blog.csdn.net/weixin_46645613/article/details/119207945\n\n多核处理器启动博客1：https://zhuanlan.zhihu.com/p/394247844\n\n---\n\n**本章完结**\n\n","slug":"xv6/Scheduler","published":1,"updated":"2025-09-28T09:41:08.734Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9u0016q8ws8p1n16tx","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前面已经分析了XV6的启动流程以及内存管理，接下来，我们探究进程调度的实现。与其说进程调度，我觉得可以顺应内存的虚拟化的叫法，将进程调度称为“CPU的虚拟化”更加贴切。</p>\n<p>首先明确目前XV6的cpu的状态如下：关中断 &amp; 进入了保护模式 &amp; 安装了包括【内核&amp;用户】【代码&amp;数据】段描述符 &amp; BSP分配了一个4K的内核栈 &amp; 开启了以kmap为基础的粒度为4K的内核分页。</p>\n<p>Onix相关链接：</p>\n<ul>\n<li><p><a href=\"https://github.com/StevenBaby/onix\">github仓库链接</a>。</p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/BV1qM4y127om/\">B站配套视频链接</a>。</p>\n</li>\n</ul>\n<p>XV6-x86的github链接：</p>\n<ul>\n<li><a href=\"https://github.com/mit-pdos/xv6-public\">链接</a>。</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"中断机制\"><a href=\"#中断机制\" class=\"headerlink\" title=\"中断机制\"></a>中断机制</h2><p>对于中断的部分，这里会涉及大量硬件相关的知识，由于博主的目的是了解OS的基本框架，所以硬件相关的知识储备可能不会太深，如果你是想弄清某个硬件具体实现，这篇博客可能不适合你。</p>\n<p>这里总结一下我对中断的理解：</p>\n<p>引发中断的方式有三种：外中断、异常、软中断。</p>\n<ul>\n<li><p>外中断：就是由外部中断控制器通知 CPU 某个事件完成了，比如：磁盘寻道完成可以进行读写了、UART输入寄存器非空（可读）、UART输出寄存器为空（可写）、键盘缓冲有数据了（可读）等等。</p>\n</li>\n<li><p>异常是 CPU 在执行过程中，因为出错而执行不下去了，比如：除零异常、因为虚拟页面还没映射发生缺页异常、对只读段进行写操作触发段错误异常等等。</p>\n</li>\n<li><p>软中断，可以认为是应用程序和操作系统沟通的一种方式，运行在低优先级程序想要对硬件做IO，但是由于只有处于特权级的内核能够直接和设备打交道，从而低优先级程序必须通过某种机制来完成特权级转换，这种机制就是软中断。我们也可以将实现这种功能的函数称为系统调用。</p>\n</li>\n</ul>\n<p>如有些教科书那样，我们也可以把异常和软中断统称为 内中断，也就是这个中断时 CPU 和 软件内部产生的，与外部硬件无关。</p>\n<h3 id=\"Onix单核处理器的中断原理\"><a href=\"#Onix单核处理器的中断原理\" class=\"headerlink\" title=\"Onix单核处理器的中断原理\"></a>Onix单核处理器的中断原理</h3><p>单核PC机上，一般会采用（主从）两片 8259a PIC（programmable interrupt controller），将PIC的INT引脚接到CPU的一个引脚上，如下图，图片引用自onix的文档，如有侵权，可告知删除：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/8259a.drawio.png\"></p>\n<p>从图中可以看到有两个8259a，上面那个8259a是主PIC，它的INT引脚直接接到CPU上；下面那个8259a的INT引脚接到主PIC的IR2引脚，所以它是从PIC。 每一个PIC的引脚会接一个外设，（如果对应的引脚没被屏蔽的话）外设会通过PIC间接向CPU发中断。</p>\n<p>在PIC正式工作前，需要对其进行一系列初始化。初始化操作由cpu发送一系列的控制字完成。有两类控制字：</p>\n<ul>\n<li><p>初始化命令字 (Initialization Command Words, ICW), ICW 共 4 个， ICW1 ~ ICW4；</p>\n</li>\n<li><p>操作命令字 (Operation Command Word, OCW), OCW 共 3 个， OCW1 ~ OCW3；</p>\n</li>\n</ul>\n<p>ICW 做初始化，用来确定是否需要级联，设置起始中断向量号，设置中断结束模式。因为某些设置之间是具有依赖性的，也许后面的某个设置会依赖前面某个 ICW 写入的设置，所以这部分要求严格的顺序，<strong>必须依次写入</strong> ICW1、ICW2、ICW3、ICW4；</p>\n<p>OCW 来操作控制 8259A，中断的屏蔽和中断处理结束就是通过往 8259A 端口发送 OCW 实现的。OCW 的发送顺序不固定，3 个之中先发送哪个都可以。</p>\n<p><strong>具体细节非常推荐读者去阅读一下Onix文档，讲的真的很细致</strong>：<a href=\"https://github.com/StevenBaby/onix/blob/dev/docs/04%20%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F/033%20%E5%A4%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.md\">https://github.com/StevenBaby/onix/blob/dev/docs/04%20%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F/033%20%E5%A4%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.md</a></p>\n<p>8259a中断控制器的初始化就是一种固定套路，截取Onix代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_M_CTRL 0x20 <span class=\"comment\">// 主片的控制端口</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_M_DATA 0x21 <span class=\"comment\">// 主片的数据端口</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_S_CTRL 0xa0 <span class=\"comment\">// 从片的控制端口</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_S_DATA 0xa1 <span class=\"comment\">// 从片的数据端口</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_EOI 0x20    <span class=\"comment\">// 通知中断控制器中断结束</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化中断控制器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pic_init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 主PIC</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_CTRL, <span class=\"number\">0b00010001</span>); <span class=\"comment\">// ICW1: 边沿触发, 级联 8259, 需要ICW4.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0x20</span>);       <span class=\"comment\">// ICW2: 起始中断向量号 0x20</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0b00000100</span>); <span class=\"comment\">// ICW3: IR2接从片.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0b00000001</span>); <span class=\"comment\">// ICW4: 8086模式, 正常EOI</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从PIC</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_CTRL, <span class=\"number\">0b00010001</span>); <span class=\"comment\">// ICW1: 边沿触发, 级联 8259, 需要ICW4.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">0x28</span>);       <span class=\"comment\">// ICW2: 起始中断向量号 0x28</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">2</span>);          <span class=\"comment\">// ICW3: 设置从片连接到主片的 IR2 引脚</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">0b00000001</span>); <span class=\"comment\">// ICW4: 8086模式, 正常EOI</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0b11111111</span>); <span class=\"comment\">// OCW1：屏蔽字，关闭主PIC所有中断，后面需要什么中断再依据需求打开。</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">0b11111111</span>); <span class=\"comment\">// OCW1：屏蔽字，关闭从PIC所有中断，后面需要什么中断再依据需求打开。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CPU在处理每个外中断后，需要向PIC发生一个结束字为的是通知PIC中断处理结束，具体中断结束方式由OCW2 来设置。代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通知中断控制器，中断处理结束</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">send_eoi</span><span class=\"params\">(<span class=\"type\">int</span> vector)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vector &gt;= <span class=\"number\">0x20</span> &amp;&amp; vector &lt; <span class=\"number\">0x28</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">outb</span>(PIC_M_CTRL, PIC_EOI);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vector &gt;= <span class=\"number\">0x28</span> &amp;&amp; vector &lt; <span class=\"number\">0x30</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">outb</span>(PIC_M_CTRL, PIC_EOI);</span><br><span class=\"line\">        <span class=\"built_in\">outb</span>(PIC_S_CTRL, PIC_EOI);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此单核OS中断的初始化到这里就结束了。</p>\n<h3 id=\"XV6多核处理的中断原理\"><a href=\"#XV6多核处理的中断原理\" class=\"headerlink\" title=\"XV6多核处理的中断原理\"></a>XV6多核处理的中断原理</h3><p>多核处理器中断控制器的结构更为复杂，因为偏向硬件，这里就只记录一下我对APIC的理解，理解不会太深，如果有错误，非常欢迎读者纠正！</p>\n<p>首先还是供上架构框图：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/APICStructure.png\"></p>\n<p>图片截取自：<a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\">https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf</a></p>\n<p>注释：</p>\n<p>BSP：bootstrap processor，可以简单理解为主处理器。</p>\n<p>APx：application processors ，可以简单理解为从处理器。</p>\n<p>关于BSP和APx的关系这里先埋个伏笔。在【AP（从）处理器的启动】段落会进行详细叙述。</p>\n<p>从图中的上半部分可以了解到，每个CPU各自接着一个Local APIC（Advanced Programmable Interrupt Controller）。注意，<strong>每个lapic和cpu是封装在一起的</strong>（这里并不严谨，是否和cpu封装在一起其实和cpu的架构有关）。后面我们会看到，不止APIC，在多核cpu上，它的每一个cpu都有自己的一套cpu寄存器，比如：esp、eip、eflag等等。具体情况我们在“进程调度”段落进行详细讲解。</p>\n<p>从图的下半部分，我们可以了解到所有的lapic都接到了ICC（interrupt controller communications） Bus上，并且，总线上还接了一个IO APIC，这里的<strong>ioapic是和cpu分离的</strong>，它被接在cpu的外部。<strong>ioapic会接收来自各个外设的中断。然后对各个外设发来的中断做一些判断和处理，再将中断的IRQ号和lapic的ID封装在一条“报文”中分发給对应的lapic</strong>，具体发给哪些lapic，我们可以通过配置ioapic来进行设置。ioapic左边其实是有很多引脚（实际16个，如果级联了8259a可能会更多）每个引脚都可以接外设。有趣的是，从图中ioapic的左边可以看到，<strong>ioapic的引脚还可以接8259a PIC控制器</strong>，这非常完美的兼容了单核cpu的中断控制器的架构。</p>\n<p>iopic是依据重定向表项 RTE(Redirection Table Entry)来构建“报文“，RTE对每一个中断都会有一项64位的entry。通过entry，可以单独设置ioapic在收到中断后对中断的操作。每一项entry描述：中断对应的中断向量？中断有没有使能？中断传输状态？发给哪个lapic？</p>\n<p>每个lapic都有一个唯一的ID，cpu可以在特定的内存（device space）上来查询自己所对应的lapic的ID号，lapic的ID其实也唯一标识了一个cpu。lapic会根据自己的ID从ICC Bus上接收属于自己的中断”报文“，然后经过一系列检查最后将中断发给cpu，当cpu处理完中断后，会反馈给自己的lapic，lapic收到cpu的回复后，同样将中断处理完毕的消息通知给ioapic，这点和单核架构中，cpu处理完中断后向master pic发送PIC_EOI是一样的道理。</p>\n<p>特别的是，lapic也可以像ioapic那样作为中断“源”（这里可能不严谨，但是可以类比去理解），向其他的lapic发送中断“报文”，这是通过ICR(Interrupt Command Register)寄存器实现，ICR的结构和ioapic的RTE表的entry结构类似，也有中断向量号、lapic的ID等字段。lapic主动向其他lapic发送中断“报文”最常见的场景就是BSP去启动其他APs，这一般通过会发送INIT or STARTUP IPI（interprocessor interrupts）。</p>\n<p>由于XV6中cpu对lapic、iopic初始化代码上，依赖于mpinit函数，而mpinit和多处理器内容相关，所以lapic、iopic初始化我们放到”AP（从）处理器的启动”段落进行讨论。</p>\n<p>关于Local APIC和IO APIIC详细内容可以参考博客：<a href=\"https://blog.csdn.net/weixin_46645613/article/details/119207945\">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>\n<h3 id=\"中断描述符表\"><a href=\"#中断描述符表\" class=\"headerlink\" title=\"中断描述符表\"></a>中断描述符表</h3><p>之前一直在介绍中断相关的外设，接下来我们看看cpu内部是怎么利用寄存器来定义中断的。</p>\n<p>因为中断不止一个，所以，和全局描述符类表似，中断表也是通过一个大的数组来记录每一个中断的属性。数组中每一个Entry格式如下图，每一个Entry同样是8个字节：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/IDT_Entry.png\"></p>\n<ul>\n<li><p>Offset：记录中断门或陷阱门的处理函数的地址。</p>\n</li>\n<li><p>Selector：处理函数的段选择子。</p>\n</li>\n<li><p>Type：标记是中断门还是陷阱门。 <strong>注意：中断门会自动清除eflag寄存器的FL_IF标志位，而陷阱门则保留eflag的FL_IF标志位。</strong> 也即中断门会i自动关（外）中断，而陷阱门则不会有关中断的操作！</p>\n</li>\n<li><p>S：必须为0。</p>\n</li>\n<li><p>DPL：描述符可以被哪个特权级使用。对于中断门一般是0x0，对于陷阱门就是0x3（DPL_USER）。</p>\n</li>\n<li><p>P：是否有效，固定填1.</p>\n</li>\n</ul>\n<p>XV6相关代码注释写的非常好，上面的中文注释也是参考XV6的注释写的，如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Gate descriptors for interrupts and traps</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">gatedesc</span> &#123;</span><br><span class=\"line\">  uint off_15_0 : <span class=\"number\">16</span>;   <span class=\"comment\">// low 16 bits of offset in segment</span></span><br><span class=\"line\">  uint cs : <span class=\"number\">16</span>;         <span class=\"comment\">// code segment selector</span></span><br><span class=\"line\">  uint args : <span class=\"number\">5</span>;        <span class=\"comment\">// # args, 0 for interrupt/trap gates</span></span><br><span class=\"line\">  uint rsv1 : <span class=\"number\">3</span>;        <span class=\"comment\">// reserved(should be zero I guess)</span></span><br><span class=\"line\">  uint type : <span class=\"number\">4</span>;        <span class=\"comment\">// type(STS_&#123;IG32,TG32&#125;)</span></span><br><span class=\"line\">  uint s : <span class=\"number\">1</span>;           <span class=\"comment\">// must be 0 (system)</span></span><br><span class=\"line\">  uint dpl : <span class=\"number\">2</span>;         <span class=\"comment\">// descriptor(meaning new) privilege level</span></span><br><span class=\"line\">  uint p : <span class=\"number\">1</span>;           <span class=\"comment\">// Present</span></span><br><span class=\"line\">  uint off_31_16 : <span class=\"number\">16</span>;  <span class=\"comment\">// high bits of offset in segment</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set up a normal interrupt/trap gate descriptor.</span></span><br><span class=\"line\"><span class=\"comment\">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span></span><br><span class=\"line\"><span class=\"comment\">//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone</span></span><br><span class=\"line\"><span class=\"comment\">// - sel: Code segment selector for interrupt/trap handler</span></span><br><span class=\"line\"><span class=\"comment\">// - off: Offset in code segment for interrupt/trap handler</span></span><br><span class=\"line\"><span class=\"comment\">// - dpl: Descriptor Privilege Level -</span></span><br><span class=\"line\"><span class=\"comment\">//        the privilege level required for software to invoke</span></span><br><span class=\"line\"><span class=\"comment\">//        this interrupt/trap gate explicitly using an int instruction.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SETGATE(gate, istrap, sel, off, d)                \\</span></span><br><span class=\"line\"><span class=\"meta\">&#123;                                                         \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).off_15_0 = (uint)(off) &amp; 0xffff;                \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).cs = (sel);                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).args = 0;                                        \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).rsv1 = 0;                                        \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).s = 0;                                           \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).dpl = (d);                                       \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).p = 1;                                           \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).off_31_16 = (uint)(off) &gt;&gt; 16;                  \\</span></span><br><span class=\"line\"><span class=\"meta\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>中断描述符寄存器如下：</p>\n<p>高32位存放中断描述符表的基地址，低16位存放中断描述符表的大小（字节为单位）。</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/IDTR.png\"></p>\n<h2 id=\"AP（从）处理器的启动\"><a href=\"#AP（从）处理器的启动\" class=\"headerlink\" title=\"AP（从）处理器的启动\"></a>AP（从）处理器的启动</h2><p>首先还是回归main函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Bootstrap processor starts running C code here.</span></span><br><span class=\"line\"><span class=\"comment\">// Allocate a real stack and switch to it, first</span></span><br><span class=\"line\"><span class=\"comment\">// doing some setup required for memory allocator to work.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">kinit1</span>(end, <span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>)); <span class=\"comment\">// 内存内存管理已讲</span></span><br><span class=\"line\">  <span class=\"built_in\">kvmalloc</span>();      <span class=\"comment\">// 内存内存管理已讲</span></span><br><span class=\"line\">  <span class=\"built_in\">mpinit</span>();        <span class=\"comment\">// detect other processors</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicinit</span>();     <span class=\"comment\">// interrupt controller</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();       <span class=\"comment\">// 内存内存管理已讲</span></span><br><span class=\"line\">  <span class=\"built_in\">picinit</span>();       <span class=\"comment\">// disable pic // 禁用单核架构下的8259A，实现很简单，这里就不去贴代码了</span></span><br><span class=\"line\">  <span class=\"built_in\">ioapicinit</span>();    <span class=\"comment\">// another interrupt controller</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">pinit</span>();         <span class=\"comment\">// process table // 实现很简单就是对自ptable的自旋锁进行一个初始化。读者可以自行阅读代码，这里就不过多赘述。</span></span><br><span class=\"line\">  <span class=\"built_in\">tvinit</span>();        <span class=\"comment\">// trap vectors</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">startothers</span>();   <span class=\"comment\">// start other processors</span></span><br><span class=\"line\">  <span class=\"built_in\">kinit2</span>(<span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>), <span class=\"built_in\">P2V</span>(PHYSTOP)); <span class=\"comment\">// 内存内存管理已讲</span></span><br><span class=\"line\">  <span class=\"built_in\">userinit</span>();      <span class=\"comment\">// first user process // 就是对init进程的内核栈做一个初始化。利用了ROP（面向返回点编程）编程思想。因为这又是一个大主题，本文不会过多讲解。以后有机会在另开一篇博客专门讨论。</span></span><br><span class=\"line\">  <span class=\"built_in\">mpmain</span>();        <span class=\"comment\">// finish this processor&#x27;s setup // 进入mpmain</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Other AP CPUs jump here from entryother.S.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpenter</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  switchkvm();  <span class=\"comment\">// AP的内核页表换成kpgdir</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();    <span class=\"comment\">// 内存内存管理已讲</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicinit</span>();  <span class=\"comment\">// 作用同main函数中BSP核执行的lapicinit函数</span></span><br><span class=\"line\">  <span class=\"built_in\">mpmain</span>();     <span class=\"comment\">// 进入mpmain</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BSP、APS最终都会进入改函数。</span></span><br><span class=\"line\"><span class=\"comment\">// 主要工作就是</span></span><br><span class=\"line\"><span class=\"comment\">//    1、加载中断描述表。</span></span><br><span class=\"line\"><span class=\"comment\">//    2、设置状态，已启动。</span></span><br><span class=\"line\"><span class=\"comment\">//    3、 进入调度循环。</span></span><br><span class=\"line\"><span class=\"comment\">// Common CPU setup code.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpmain</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cprintf</span>(<span class=\"string\">&quot;cpu%d: starting %d\\n&quot;</span>, <span class=\"built_in\">cpuid</span>(), <span class=\"built_in\">cpuid</span>());</span><br><span class=\"line\">  <span class=\"built_in\">idtinit</span>();       <span class=\"comment\">// load idt register // 使用lidt命令加载中断描述符</span></span><br><span class=\"line\">  <span class=\"built_in\">xchg</span>(&amp;(<span class=\"built_in\">mycpu</span>()-&gt;started), <span class=\"number\">1</span>); <span class=\"comment\">// tell startothers() we&#x27;re up</span></span><br><span class=\"line\">  <span class=\"built_in\">scheduler</span>();     <span class=\"comment\">// start running processes</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下我们要从BSP执行的maiin函数开始，深入分析以上代码的作用。</p>\n<h3 id=\"mpinit：探测各个cpu\"><a href=\"#mpinit：探测各个cpu\" class=\"headerlink\" title=\"mpinit：探测各个cpu\"></a>mpinit：探测各个cpu</h3><p>该部分主要参考：<a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\">多处理器规范</a>，因为我英语也是很菜，所以硬着头皮捡重点去看了一部分。</p>\n<p>这里对多核处理器的启动流程做一个简单总结：我们可以理解为，多核CPU中，有一个CPU被设计成BSP，其他的CPU都被设计成AP。当然，在实际硬件设计上为了考虑容错性，任何一个CPU都能成为BSP核。 <strong>系统最开始，BSP有对硬件的绝对控制权，包括去控制其他AP的启动和停止。为了启动其他AP核，BSP首先通过三种可能的方式搜索MP floating pointer structure，如果找到了一个有效的MP floating pointer structure就去遍历MP configuration table查询处理器信息和ioapic的信息；如果无法找到一个有效MP floating pointer structure，那就认为系统只有一个CPU——BSP。在所有CPU启动后，BSP就退化成AP，系统不存在BSP、AP之分。</strong> 当然，我们需要要记录BSP CPU的lapic的ID（这个ID也唯一标识着CPU），这样我们才知道谁可以去其控制其他CPU的停止。在BSP启动其他AP前，因为AP CPU是暂停状态，所以其他AP无法执行OS代码，并且大部分中断都是被禁用，<strong>但是INIT or STARTUP interprocessor interrupts (IPIs)不会被屏蔽，当AP收到来自BSP的INIT or STARTUP中断，就会启动它自己。</strong> AP在收到BSP的启动中断后，也会进入保护模式、<strong>有自己的独立的一套寄存器</strong>、设置自己的全局描述符、开启分页、有自己的堆栈等。</p>\n<p>首先BSP会通过三种方式去搜索MP floating pointer structure，<strong>三种搜索范围都在1M以内，因为MP floating pointer structure就是由BIOS提供，而BISO寻址范围就1M</strong>：</p>\n<ol>\n<li>In the first kilobyte of Extended BIOS Data Area (EBDA), or</li>\n<li>Within the last kilobyte of system base memory, or</li>\n<li>In the BIOS ROM address space between 0F0000h and 0FFFFFh.</li>\n</ol>\n<p>低1M内存的内存映射参考：<a href=\"https://wiki.osdev.org/BDA#BIOS_Data_Area_.28BDA.29\">https://wiki.osdev.org/BDA#BIOS_Data_Area_.28BDA.29</a></p>\n<p>MP Configuration Data Structures整体框架如下图，图解了MP floating pointer structure、MP Configuration Table Header、Table Entries三者之间的一个关系，先了解一下大致的框架，接下来我门逐一剖析。</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png\"></p>\n<p>MP floating pointer structure图解如下：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/MP_floating_pointer_structure.png\"></p>\n<p>主要关注它的PHYSICAL ADDRESS POINTER，它指向MP config table的物理地址。</p>\n<p>MP Configuration Table Header结构如下：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/MP_configuration_table_header.png\"></p>\n<p>主要关注几个字段：</p>\n<ul>\n<li><p>MEMORY-MAPPED ADDRESS OF LOCAL APIC：描述 cpu（<strong>每个CPU都将它的lapic映射到了同一个物理地址</strong>）的lapic的寄存器物理地址。注意这里是”每个cpu”，虽然是同一个物理地址，但是在每一个cpu去读的时候，分别映射到了各自的lapic的寄存器地址上了。</p>\n</li>\n<li><p>BASE TABLE LENGTH：整个table的长度，虽然存在扩展表长度，但是我们还用不到。</p>\n</li>\n</ul>\n<p>MP Configuration Table Header后面会跟上各自类型的Base MP Configuration Table Entries，每个Entry的第一个字节会标明其类型，并且每种Entry的长度都各自固定，所以我们可以通过一个循环来遍历每个Entry，一共有5种类型的Entry，如下图：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/entry_types.png\"></p>\n<p>XV6中我们主要关注Processor Entries和I&#x2F;O APIC两种类型的Entry。</p>\n<p>Processor Entries结构如下：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/processor_entry.png\"></p>\n<p>主要关注LOCAL APIC ID，如该字段名字那样，就是代表和CPU绑定的lapic的ID，通过它我们也可以唯一标识一个CPU。</p>\n<p>I&#x2F;O APIC Entries结构如下：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/ioapic_entry.png\"></p>\n<p>主要关注I&#x2F;O APIC ID，代表I&#x2F;O APIC的ID。</p>\n<p>然后上代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  uchar *p, *e;</span><br><span class=\"line\">  <span class=\"type\">int</span> ismp;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mp</span> *mp;              <span class=\"comment\">// 前面提到的MP floating pointer structure</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mpconf</span> *conf;        <span class=\"comment\">// 前面提到的MP Configuration Table Header</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mpproc</span> *proc;        <span class=\"comment\">// 前面提到的Processor Entries</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mpioapic</span> *ioapic;    <span class=\"comment\">// 前面提到的I/O APIC Entries</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((conf = <span class=\"built_in\">mpconfig</span>(&amp;mp)) == <span class=\"number\">0</span>)     <span class=\"comment\">// 用上面提到的三种方法寻找MP floating pointer structure，并且判断它的合法性，然后将结构体里面的PHYSICAL ADDRESS POINTER（指向MP Configuration Table Header）作为返回值</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;Expect to run on an SMP&quot;</span>);</span><br><span class=\"line\">  ismp = <span class=\"number\">1</span>;</span><br><span class=\"line\">  lapic = (uint*)conf-&gt;lapicaddr;     <span class=\"comment\">// 将lapic的寄存器地址放到全局变量lapic中</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(p=(uchar*)(conf<span class=\"number\">+1</span>), e=(uchar*)conf+conf-&gt;length; p&lt;e; )&#123;  <span class=\"comment\">// 依据MP Configuration Table Header遍历每一个Table Entry。</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(*p)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPPROC:                      <span class=\"comment\">// Processor Entries</span></span><br><span class=\"line\">      proc = (<span class=\"keyword\">struct</span> mpproc*)p;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(ncpu &lt; NCPU) &#123;</span><br><span class=\"line\">        cpus[ncpu].apicid = proc-&gt;apicid;  <span class=\"comment\">// apicid may differ from ncpu // 保存cpu的lapic的id</span></span><br><span class=\"line\">        ncpu++;                       <span class=\"comment\">// 找到一个CPU</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      p += <span class=\"built_in\">sizeof</span>(<span class=\"keyword\">struct</span> mpproc);</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPIOAPIC:                    <span class=\"comment\">// I/O APIC Entries</span></span><br><span class=\"line\">      ioapic = (<span class=\"keyword\">struct</span> mpioapic*)p;</span><br><span class=\"line\">      ioapicid = ioapic-&gt;apicno;      <span class=\"comment\">// 将ioapicid存到全局变量，将来初始化的时候会用</span></span><br><span class=\"line\">      p += <span class=\"built_in\">sizeof</span>(<span class=\"keyword\">struct</span> mpioapic);</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPBUS:                       <span class=\"comment\">// 其他的不关注，加上他们的大小去找下一个Table Entry。</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPIOINTR:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPLINTR:</span><br><span class=\"line\">      p += <span class=\"number\">8</span>;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      ismp = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!ismp)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;Didn&#x27;t find a suitable machine&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(mp-&gt;imcrp)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果之前是PIC Mode，就切换到APIC模式 </span></span><br><span class=\"line\">    <span class=\"comment\">// interrupt mode configuration register --&gt; IMCR</span></span><br><span class=\"line\">    <span class=\"comment\">// Bochs doesn&#x27;t support IMCR, so this doesn&#x27;t run on Bochs.</span></span><br><span class=\"line\">    <span class=\"comment\">// But it would on real hardware.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(<span class=\"number\">0x22</span>, <span class=\"number\">0x70</span>);   <span class=\"comment\">// Select IMCR</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(<span class=\"number\">0x23</span>, <span class=\"built_in\">inb</span>(<span class=\"number\">0x23</span>) | <span class=\"number\">1</span>);  <span class=\"comment\">// Mask external interrupts.  // 进入APIC模式</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mp-&gt;imcrp字段的解释如下：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/imcrp.png\"></p>\n<p>详细信息可以了解一下：<a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\">多处理器规范</a></p>\n<h3 id=\"lapicinit：BSP初始化自己cpu的lapic\"><a href=\"#lapicinit：BSP初始化自己cpu的lapic\" class=\"headerlink\" title=\"lapicinit：BSP初始化自己cpu的lapic\"></a>lapicinit：BSP初始化自己cpu的lapic</h3><p>这部分和硬件强相关，我也了解不是特别多，尽可能的讲清楚吧。硬件相关的初始化深入下去也是一个无底洞。如果读者感兴趣的话，可以去查intel 64 and IA-32 卷3开发手册。 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">lapicinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!lapic)    <span class=\"comment\">// lapic就是上面mpinit函数在MP Configuration Table Header中得到的lapic寄存器的物理映射地址，所以说初始化的顺序非常严格！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Enable local APIC; set spurious interrupt vector.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));      <span class=\"comment\">// 开启此cpu的APIC</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 配置时钟，属于lapic的本地中断</span></span><br><span class=\"line\">  <span class=\"comment\">// The timer repeatedly counts down at bus frequency</span></span><br><span class=\"line\">  <span class=\"comment\">// from lapic[TICR] and then issues an interrupt.</span></span><br><span class=\"line\">  <span class=\"comment\">// If xv6 cared more about precise timekeeping,</span></span><br><span class=\"line\">  <span class=\"comment\">// TICR would be calibrated using an external time source.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TDCR, X1);                               <span class=\"comment\">// 分频系数为X1</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER)); <span class=\"comment\">// 以PERIODIC为周期，映射到0x20中断</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TICR, <span class=\"number\">10000000</span>);                         <span class=\"comment\">// 时钟频率</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Disable logical interrupt lines.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(LINT0, MASKED);                          <span class=\"comment\">// 屏蔽LINT0（lapic本地中断</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(LINT1, MASKED);                          <span class=\"comment\">// 屏蔽LINT1（lapic本地中断</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Disable performance counter overflow interrupts</span></span><br><span class=\"line\">  <span class=\"comment\">// on machines that provide that interrupt entry.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(((lapic[VER]&gt;&gt;<span class=\"number\">16</span>) &amp; <span class=\"number\">0xFF</span>) &gt;= <span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"built_in\">lapicw</span>(PCINT, MASKED);                        <span class=\"comment\">// 屏蔽PCINT（好像是废话？</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Map error interrupt to IRQ_ERROR.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ERROR, T_IRQ0 + IRQ_ERROR);            <span class=\"comment\">// 0x20 + 0x13（ERROR）</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Clear error status register (requires back-to-back writes).</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ESR, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ESR, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Ack any outstanding interrupts.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(EOI, <span class=\"number\">0</span>);                               <span class=\"comment\">// 向ioapic发送一个EOI，以免中断丢失</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Send an Init Level De-Assert to synchronise arbitration ID&#x27;s.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ICRHI, <span class=\"number\">0</span>);                             <span class=\"comment\">// ？？？// 这里应该是向其他apic广播一条“报文”，通知“我”启动了</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ICRLO, BCAST | INIT | LEVEL);          <span class=\"comment\">// 广播的形式 &amp; 传送模式为INIT &amp; 水平触发</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(lapic[ICRLO] &amp; DELIVS)                  <span class=\"comment\">// 中断的传输状态：是否已经发送？</span></span><br><span class=\"line\">    ;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Enable interrupts on the APIC (but not on the processor).</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TPR, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>以上代码就是初始化BSP的lapic，在其他AP启动后，都要执行一遍这段代码。</strong></p>\n<h3 id=\"ioapicinit：初始化ioapic\"><a href=\"#ioapicinit：初始化ioapic\" class=\"headerlink\" title=\"ioapicinit：初始化ioapic\"></a>ioapicinit：初始化ioapic</h3><p>ioapic的作用和单核架构下master pic很像，但是对于ioapic的初始化步骤很简单，不需要发送一系列的控制字。对于ioapic的初始化就是简单的配置一下重定向表项 RTE(Redirection Table Entry)，给RTE的每一项一个初值，设置它的中断向量号（起始T_IRQ0，T_IRQ0 &#x3D;&#x3D; 0x20），并且默认是中断屏蔽的。后续需要什么中断再对相应的Entry做配置即可，比如consoleinit为了使用键盘调用了ioapicenable去配置对应的Entry打开中断等。关于重定向表项 RTE(Redirection Table Entry)的解释，读者可以看一下这篇文章，讲的非常详细：<a href=\"https://blog.csdn.net/weixin_46645613/article/details/119207945\">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">ioapicinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i, id, maxintr;</span><br><span class=\"line\"></span><br><span class=\"line\">  ioapic = (<span class=\"keyword\">volatile</span> <span class=\"keyword\">struct</span> ioapic*)IOAPIC;           <span class=\"comment\">// 默认地址：0xFEC00000   // Default physical address of IO APIC</span></span><br><span class=\"line\">  maxintr = (<span class=\"built_in\">ioapicread</span>(REG_VER) &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xFF</span>;       <span class=\"comment\">// ioapic支持的最大中断号</span></span><br><span class=\"line\">  id = <span class=\"built_in\">ioapicread</span>(REG_ID) &gt;&gt; <span class=\"number\">24</span>;                      <span class=\"comment\">// 从寄存器读到的ioapic的ID</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(id != ioapicid)                                  <span class=\"comment\">// 必须一致</span></span><br><span class=\"line\">    <span class=\"built_in\">cprintf</span>(<span class=\"string\">&quot;ioapicinit: id isn&#x27;t equal to ioapicid; not a MP\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Mark all interrupts edge-triggered, active high, disabled,</span></span><br><span class=\"line\">  <span class=\"comment\">// and not routed to any CPUs.</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt;= maxintr; i++)&#123;    <span class=\"comment\">// 初始化重定向表项 RTE(Redirection Table Entry)，这里和单核架构下主从PIC一样，先将所有的中断屏蔽掉，在后面初始化的时候再按需使能。</span></span><br><span class=\"line\">    <span class=\"built_in\">ioapicwrite</span>(REG_TABLE<span class=\"number\">+2</span>*i, INT_DISABLED | (T_IRQ0 + i));</span><br><span class=\"line\">    <span class=\"built_in\">ioapicwrite</span>(REG_TABLE<span class=\"number\">+2</span>*i<span class=\"number\">+1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"tvinit：初始化中断向量表\"><a href=\"#tvinit：初始化中断向量表\" class=\"headerlink\" title=\"tvinit：初始化中断向量表\"></a>tvinit：初始化中断向量表</h3><p>这里自顶向下介绍XV6的中断向量表是如何构造的。</p>\n<p>涉及到的变量如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Interrupt descriptor table (shared by all CPUs).</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">gatedesc</span> idt[<span class=\"number\">256</span>];   <span class=\"comment\">// 中断描述符表</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> uint vectors[];  <span class=\"comment\">// vectors的定义文件是：由vectors.pl生成的汇编代码文件。</span></span><br></pre></td></tr></table></figure>\n\n<p>首先是tvinit函数，它是最顶层负责构造中断向量表的函数，SETGATE宏在上面已经贴过它的实现，这里简单介绍一个各个参数的作用。</p>\n<p>SETGATE(gate, istrap, sel, off, d) ：</p>\n<ul>\n<li><p>参数1：对应idt[i]，表示每一项entry。</p>\n</li>\n<li><p>参数2：标记是中断门还是陷阱门。</p>\n</li>\n<li><p>参数3：段选择子。</p>\n</li>\n<li><p>参数4：中断处理函数地址。</p>\n</li>\n<li><p>参数5：中断描述符被哪个特权级使用。</p>\n</li>\n</ul>\n<p>结合代码来看：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">tvinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i;</span><br><span class=\"line\">  <span class=\"comment\">// 构造中断描述符表</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">256</span>; i++)</span><br><span class=\"line\">    <span class=\"built_in\">SETGATE</span>(idt[i], <span class=\"number\">0</span>, SEG_KCODE&lt;&lt;<span class=\"number\">3</span>, vectors[i], <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化系统调用中断描述符，类型是陷阱门（发生中断不会关中断），特权级是DPL_USER。</span></span><br><span class=\"line\">  <span class=\"built_in\">SETGATE</span>(idt[T_SYSCALL], <span class=\"number\">1</span>, SEG_KCODE&lt;&lt;<span class=\"number\">3</span>, vectors[T_SYSCALL], DPL_USER);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">initlock</span>(&amp;tickslock, <span class=\"string\">&quot;time&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是vectors.pl文件生成汇编代码的过程，pl我之前也没有了解过，不过从它的代码可以看出，有点像字符串拼接的处理语言，简化了重复性代码的编写，代码如下：</p>\n<figure class=\"highlight pl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/perl -w</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Generate vectors.S, the trap/interrupt entry points.</span></span><br><span class=\"line\"><span class=\"comment\"># There has to be one entry point per interrupt number</span></span><br><span class=\"line\"><span class=\"comment\"># since otherwise there&#x27;s no way for trap() to discover</span></span><br><span class=\"line\"><span class=\"comment\"># the interrupt number.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;# generated by vectors.pl - do not edit\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;# handlers\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;.globl alltraps\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">my</span> <span class=\"variable\">$i</span> = <span class=\"number\">0</span>; <span class=\"variable\">$i</span> &lt; <span class=\"number\">256</span>; <span class=\"variable\">$i</span>++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;.globl vector<span class=\"variable\">$i</span>\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;vector<span class=\"variable\">$i</span>:\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(<span class=\"variable\">$i</span> == <span class=\"number\">8</span> || (<span class=\"variable\">$i</span> &gt;= <span class=\"number\">10</span> &amp;&amp; <span class=\"variable\">$i</span> &lt;= <span class=\"number\">14</span>) || <span class=\"variable\">$i</span> == <span class=\"number\">17</span>))&#123;</span><br><span class=\"line\">        <span class=\"comment\"># 这些中断cpu自动压入errcode参数，</span></span><br><span class=\"line\">        <span class=\"comment\"># 为保证中断栈帧的统一，所以我们在</span></span><br><span class=\"line\">        <span class=\"comment\"># 这些特殊中断手动压入0值，这样就能</span></span><br><span class=\"line\">        <span class=\"comment\"># 统一使用trapret来恢复上下文。</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">&quot;  pushl \\$0\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;  pushl \\$<span class=\"variable\">$i</span>\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;  jmp alltraps\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;\\n# vector table\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;.data\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;.globl vectors\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;vectors:\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">my</span> <span class=\"variable\">$i</span> = <span class=\"number\">0</span>; <span class=\"variable\">$i</span> &lt; <span class=\"number\">256</span>; <span class=\"variable\">$i</span>++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;  .long vector<span class=\"variable\">$i</span>\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从pl代码上我们可以看到，就是利用for循环构造vectors数组，该数组专门存放中断处理函数。我们先来分析一下它如何构造vectors的，首先最上面有一个for循环，for循环中使用了一个if判断，因为有些中断cpu不会自动压入错误码，所以我们需要<strong>手动压入一个占位值</strong>，方便trapret的处理。在for循环下面最后压入了一个jmp指令，所以pl生成的汇编并不是中断处理函数最终代码，pl生成的中断处理函数会跳到alltraps，alltraps代码我们下面再进行分析。pl在最后生成的汇编代码定义了一个vectors数组，数组里面元素就是上面定义的256个vectori（i&#x3D;1、2、…）。</p>\n<p>最后就是trapasm.S文件对alltraps的实现，常规的进行上下文保护：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;mmu.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">  # vectors.S sends all traps here.</span><br><span class=\"line\">.globl alltraps</span><br><span class=\"line\">alltraps:          # 保存上下文</span><br><span class=\"line\">  # Build trap frame.</span><br><span class=\"line\">  pushl %ds</span><br><span class=\"line\">  pushl %es</span><br><span class=\"line\">  pushl %fs</span><br><span class=\"line\">  pushl %gs</span><br><span class=\"line\">  pushal</span><br><span class=\"line\">  </span><br><span class=\"line\">  # Set up data segments.</span><br><span class=\"line\">  movw $(SEG_KDATA&lt;&lt;3), %ax</span><br><span class=\"line\">  movw %ax, %ds</span><br><span class=\"line\">  movw %ax, %es</span><br><span class=\"line\"></span><br><span class=\"line\">  # Call trap(tf), where tf=%esp</span><br><span class=\"line\">  pushl %esp</span><br><span class=\"line\">  call trap       # 进入trap函数</span><br><span class=\"line\">  addl $4, %esp</span><br><span class=\"line\"></span><br><span class=\"line\">  # Return falls through to trapret...</span><br><span class=\"line\">.globl trapret</span><br><span class=\"line\">trapret:          # 恢复上下文</span><br><span class=\"line\">  popal</span><br><span class=\"line\">  popl %gs</span><br><span class=\"line\">  popl %fs</span><br><span class=\"line\">  popl %es</span><br><span class=\"line\">  popl %ds</span><br><span class=\"line\">  addl $0x8, %esp  # trapno and errcode</span><br><span class=\"line\">  iret</span><br></pre></td></tr></table></figure>\n\n<p>tvinit、pl、alltraps三者之间的关系总览图如下：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/trap__structure.png\"></p>\n<p>关于中断帧，这里要注意，涉及特权级转换的中断帧和不涉及特权级转换的中断帧有些许不一样。如下：</p>\n<p>用户态触发中断（陷阱门或中断门）过程如下：</p>\n<ol start=\"0\">\n<li><p>用户查询TSS（任务状态段）段，找到用户进程在内核态的栈段和栈顶指针（ss0、esp0）。</p>\n</li>\n<li><p><strong>cpu将ss、esp压入（内核）栈中。</strong>（硬件</p>\n</li>\n<li><p>cpu将eflags、cs、eip压入栈中。<strong>中断门还要关中断</strong>，陷阱门不用。（硬件</p>\n</li>\n<li><p>执行用户中断处理函数<strong>alltraps</strong>的<strong>上下文保护</strong>的代码。（软件</p>\n</li>\n<li><p>调用trap函数，处理各种中断。</p>\n</li>\n<li><p>执行用户中断处理函数<strong>trapret</strong>的<strong>上下文恢复</strong>的代码。（软件</p>\n</li>\n<li><p>调用iret，cpu恢复eflags、cs、eip。（硬件</p>\n</li>\n<li><p>cpu恢复ss、esp。（硬件</p>\n</li>\n</ol>\n<p>而内核线程发生中断（<strong>注意，内核态不会发生系统调用，这不应该也不合理</strong>），过程如下：</p>\n<ol>\n<li><p>cpu将eflags、cs、eip压入栈中。<strong>中断门还要关中断</strong>，陷阱门不用。（硬件</p>\n</li>\n<li><p>执行用户中断处理函数<strong>alltraps</strong>的<strong>上下文保护</strong>的代码。（软件</p>\n</li>\n<li><p>调用trap函数，处理各种中断。</p>\n</li>\n<li><p>执行用户中断处理函数<strong>trapret</strong>的<strong>上下文恢复</strong>的代码。（软件</p>\n</li>\n<li><p>调用iret，cpu恢复eflags、cs、eip。（硬件</p>\n</li>\n</ol>\n<p>XV6中定义的栈帧结构体如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PAGEBREAK: 36</span></span><br><span class=\"line\"><span class=\"comment\">// Layout of the trap frame built on the stack by the</span></span><br><span class=\"line\"><span class=\"comment\">// hardware and by trapasm.S, and passed to trap().</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">trapframe</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// registers as pushed by pusha</span></span><br><span class=\"line\">  uint edi;</span><br><span class=\"line\">  uint esi;</span><br><span class=\"line\">  uint ebp;</span><br><span class=\"line\">  uint oesp;      <span class=\"comment\">// useless &amp; ignored</span></span><br><span class=\"line\">  uint ebx;</span><br><span class=\"line\">  uint edx;</span><br><span class=\"line\">  uint ecx;</span><br><span class=\"line\">  uint eax;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// rest of trap frame</span></span><br><span class=\"line\">  ushort gs;</span><br><span class=\"line\">  ushort padding1;</span><br><span class=\"line\">  ushort fs;</span><br><span class=\"line\">  ushort padding2;</span><br><span class=\"line\">  ushort es;</span><br><span class=\"line\">  ushort padding3;</span><br><span class=\"line\">  ushort ds;</span><br><span class=\"line\">  ushort padding4;</span><br><span class=\"line\">  uint trapno;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// below here defined by x86 hardware</span></span><br><span class=\"line\">  uint err;</span><br><span class=\"line\">  uint eip;</span><br><span class=\"line\">  ushort cs;</span><br><span class=\"line\">  ushort padding5;</span><br><span class=\"line\">  uint eflags;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// below here only when crossing rings, such as from user to kernel</span></span><br><span class=\"line\">  uint esp;</span><br><span class=\"line\">  ushort ss;</span><br><span class=\"line\">  ushort padding6;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>中断帧如下图：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/trap_frame.png\"></p>\n<p>图片引用自：<a href=\"https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\">https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf</a></p>\n<h3 id=\"startothers：激活其他AP处理器\"><a href=\"#startothers：激活其他AP处理器\" class=\"headerlink\" title=\"startothers：激活其他AP处理器\"></a>startothers：激活其他AP处理器</h3><p>到这里终于要开始启动其他AP核了，AP核的启动也是一种固定套路，在<a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\">多处理器规范</a>中这种套路称为universal algorithm。XV6中这个算法实现在lapicstartap函数中。</p>\n<p>流程如下：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/universal_algorithm.png\"></p>\n<p>XV6代码启动其他AP处理器的核心流程如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Start the non-boot (AP) processors.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">startothers</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">extern</span> uchar _binary_entryother_start[], _binary_entryother_size[];</span><br><span class=\"line\">  uchar *code;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> *c;</span><br><span class=\"line\">  <span class=\"type\">char</span> *stack;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Write entry code to unused memory at 0x7000.</span></span><br><span class=\"line\">  <span class=\"comment\">// The linker has placed the image of entryother.S in</span></span><br><span class=\"line\">  <span class=\"comment\">// _binary_entryother_start.</span></span><br><span class=\"line\">  <span class=\"comment\">// AP核的entryother代码的入口点，entryother 就是 boot + entry的结合体</span></span><br><span class=\"line\">  code = <span class=\"built_in\">P2V</span>(<span class=\"number\">0x7000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 这里将entryother的代码移到物理地址0x7000处</span></span><br><span class=\"line\">  <span class=\"built_in\">memmove</span>(code, _binary_entryother_start, (uint)_binary_entryother_size);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// BSP for循环向每个AP发送中断。</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(c = cpus; c &lt; cpus+ncpu; c++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c == <span class=\"built_in\">mycpu</span>())  <span class=\"comment\">// We&#x27;ve started already.</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Tell entryother.S what stack to use, where to enter, and what</span></span><br><span class=\"line\">    <span class=\"comment\">// pgdir to use. We cannot use kpgdir yet, because the AP processor</span></span><br><span class=\"line\">    <span class=\"comment\">// is running in low  memory, so we use entrypgdir for the APs too.</span></span><br><span class=\"line\">    stack = <span class=\"built_in\">kalloc</span>();   <span class=\"comment\">// 为每个AP核分配一个执行scheduler函数的内核栈</span></span><br><span class=\"line\">    *(<span class=\"type\">void</span>**)(code<span class=\"number\">-4</span>) = stack + KSTACKSIZE;</span><br><span class=\"line\">    *(<span class=\"built_in\">void</span>(**)(<span class=\"type\">void</span>))(code<span class=\"number\">-8</span>) = mpenter;  <span class=\"comment\">// 指定AP特有main（mpenter）函数入口点。</span></span><br><span class=\"line\">    <span class=\"comment\">// 同BSP刚启动一样，使用使用4M big page页表。</span></span><br><span class=\"line\">    *(<span class=\"type\">int</span>**)(code<span class=\"number\">-12</span>) = (<span class=\"type\">void</span> *) <span class=\"built_in\">V2P</span>(entrypgdir);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// lapicstartap就是实现了universal algorithm，因为我也不太懂，这里就不贴了。</span></span><br><span class=\"line\">    <span class=\"built_in\">lapicstartap</span>(c-&gt;apicid, <span class=\"built_in\">V2P</span>(code));   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待AP初始化完毕</span></span><br><span class=\"line\">    <span class=\"comment\">// wait for cpu to finish mpmain()</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c-&gt;started == <span class=\"number\">0</span>)  </span><br><span class=\"line\">      ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在每个AP boot点和BSP的boot点类似，BSP是在0x7c00启动，AP是在0x7000启动。同样，0x7000也会执行一段汇编代码，这段汇编代码作用就是bootasm.S + entry.S代码的结合体。这里简单总结一下：</p>\n<ol>\n<li><p>加载临时全局描述符，进入保护模式</p>\n</li>\n<li><p>使用entrypgdir开启分页。</p>\n</li>\n<li><p>切换到预分配的内核（scheduler）栈。</p>\n</li>\n<li><p>进入mpenter。</p>\n</li>\n</ol>\n<p>考虑到文章太长，代码就不放了。文件是entryother.S，有兴趣的读者可自行研究。</p>\n<p>mpenter代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Other CPUs jump here from entryother.S.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpenter</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  switchkvm();    <span class=\"comment\">// 切换到粒度更小（4k）的内核页，kpgdir。</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();       <span class=\"comment\">//效果同BSP，在main中BSP也调用了该函数。就是第二次初始化段描述符。（第一次是在entryother.S</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicinit</span>();    <span class=\"comment\">// 效果同BSP</span></span><br><span class=\"line\">  <span class=\"built_in\">mpmain</span>();       <span class=\"comment\">// 进入mpmain</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面那段代码就是：AP会像BSP那样，调用一遍所有的和CPU相关初始化函数，最终进入mpmain。（BSP在main最后也会进入mpmain，前面提到过BSP启动其他后，也成为了一个AP）</p>\n<p>mpmain在加载中断描述符表后，最终就会进入scheduler，CPU正式开启操作系统的任务调度！</p>\n<p>mpmain如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Common CPU setup code.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpmain</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cprintf</span>(<span class=\"string\">&quot;cpu%d: starting %d\\n&quot;</span>, <span class=\"built_in\">cpuid</span>(), <span class=\"built_in\">cpuid</span>());</span><br><span class=\"line\">  <span class=\"built_in\">idtinit</span>();       <span class=\"comment\">// load idt register</span></span><br><span class=\"line\">  <span class=\"built_in\">xchg</span>(&amp;(<span class=\"built_in\">mycpu</span>()-&gt;started), <span class=\"number\">1</span>); <span class=\"comment\">// tell startothers() we&#x27;re up</span></span><br><span class=\"line\">  <span class=\"built_in\">scheduler</span>();     <span class=\"comment\">// start running processes</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进程调度\"><a href=\"#进程调度\" class=\"headerlink\" title=\"进程调度\"></a>进程调度</h2><p>首先了解一下XV6对CPU的定义，注释写的非常详细：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Per-CPU state</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// lapci的id</span></span><br><span class=\"line\">  uchar apicid;                <span class=\"comment\">// Local APIC ID</span></span><br><span class=\"line\">  <span class=\"comment\">// 执行调度器栈指针</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">context</span> *scheduler;   <span class=\"comment\">// swtch() here to enter scheduler</span></span><br><span class=\"line\">  <span class=\"comment\">// 任务状态段、为进程从用户态陷入内核态切栈使用</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">taskstate</span> ts;         <span class=\"comment\">// Used by x86 to find stack for interrupt</span></span><br><span class=\"line\">  <span class=\"comment\">// 全局描述符</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">segdesc</span> gdt[NSEGS];   <span class=\"comment\">// x86 global descriptor table</span></span><br><span class=\"line\">  <span class=\"comment\">// 指示cpu是否启动</span></span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> uint started;       <span class=\"comment\">// Has the CPU started?</span></span><br><span class=\"line\">  <span class=\"comment\">// 关中断的深度</span></span><br><span class=\"line\">  <span class=\"type\">int</span> ncli;                    <span class=\"comment\">// Depth of pushcli nesting.</span></span><br><span class=\"line\">  <span class=\"comment\">// 记录在cpu第一层关中断前，中断关闭情况</span></span><br><span class=\"line\">  <span class=\"type\">int</span> intena;                  <span class=\"comment\">// Were interrupts enabled before pushcli?</span></span><br><span class=\"line\">  <span class=\"comment\">// cpu当前运行的进程PCB</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *proc;           <span class=\"comment\">// The process running on this cpu or null</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> cpus[NCPU]; <span class=\"comment\">// 多个cpu</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> ncpu;              <span class=\"comment\">// cpu的个数</span></span><br></pre></td></tr></table></figure>\n\n<p>下面列出了各个CPU资源的共享情况，可以做一个参考：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">资源</th>\n<th align=\"center\">共享</th>\n<th align=\"center\">不共享</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">中断描述符表</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">lapic（也指外中断，包括定时器等）</td>\n<td align=\"center\"></td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">ioapic</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">cpu的各种寄存器，包括eip、esp、eflag等等</td>\n<td align=\"center\"></td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">全局描述符表（包括任务状态段）</td>\n<td align=\"center\"></td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">kpgdir（内核调度器使用的页表）</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">物理内存</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">任务队列（ptable）</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">调度器的执行栈</td>\n<td align=\"center\"></td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">外设</td>\n<td align=\"center\"></td>\n<td align=\"center\">√</td>\n</tr>\n</tbody></table>\n<p>接下来是XV6的PCB（进程控制块），之前老是在教科书上看到它，当时感觉很难理解，在分析过OS源码后，再回过头去看，就感觉特别通透。XV6的PCB就是一个结构体，里面存放了很多成员，XV6的PCB和进程的内核栈是分开的，PCB结构体是通过一个指针来指向进程的内核栈。相比之下，Onix的PCB和内核栈是连在一起的，内核栈的低地址就是存放的PDB结构体，因为esp是线下增长，所以esp指向高地址处，并且典型的内核栈大小是一页（4K）（于是esp指向页面的4K处）。</p>\n<p>XV6的PCB定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// proc.h</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">procstate</span> &#123; UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Per-process state</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 进程（映射了页框的）虚拟内存大小</span></span><br><span class=\"line\">  uint sz;                     <span class=\"comment\">// Size of process memory (bytes)</span></span><br><span class=\"line\">  <span class=\"comment\">// 进程的页表</span></span><br><span class=\"line\">  <span class=\"type\">pde_t</span>* pgdir;                <span class=\"comment\">// Page table</span></span><br><span class=\"line\">  <span class=\"comment\">// 进程的内核栈</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *kstack;                <span class=\"comment\">// Bottom of kernel stack for this process</span></span><br><span class=\"line\">  <span class=\"comment\">// 进程状态</span></span><br><span class=\"line\">  <span class=\"keyword\">enum</span> <span class=\"title class_\">procstate</span> state;        <span class=\"comment\">// Process state</span></span><br><span class=\"line\">  <span class=\"comment\">// 进程pid</span></span><br><span class=\"line\">  <span class=\"type\">int</span> pid;                     <span class=\"comment\">// Process ID</span></span><br><span class=\"line\">  <span class=\"comment\">// 进程的父进程</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *parent;         <span class=\"comment\">// Parent process</span></span><br><span class=\"line\">  <span class=\"comment\">// 调用系统调用时的栈帧</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">trapframe</span> *tf;        <span class=\"comment\">// Trap frame for current syscall</span></span><br><span class=\"line\">  <span class=\"comment\">// 内核态的上下文</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">context</span> *context;     <span class=\"comment\">// swtch() here to run process</span></span><br><span class=\"line\">  <span class=\"comment\">// 等待条件</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *chan;                  <span class=\"comment\">// If non-zero, sleeping on chan</span></span><br><span class=\"line\">  <span class=\"comment\">// 是否被杀死</span></span><br><span class=\"line\">  <span class=\"type\">int</span> killed;                  <span class=\"comment\">// If non-zero, have been killed</span></span><br><span class=\"line\">  <span class=\"comment\">// 打开的文件</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">file</span> *ofile[NOFILE];  <span class=\"comment\">// Open files</span></span><br><span class=\"line\">  <span class=\"comment\">// 工作目录的inode</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">inode</span> *cwd;           <span class=\"comment\">// Current directory</span></span><br><span class=\"line\">  <span class=\"comment\">// 进程名</span></span><br><span class=\"line\">  <span class=\"type\">char</span> name[<span class=\"number\">16</span>];               <span class=\"comment\">// Process name (debugging)</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// proc.c</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">spinlock</span> lock;       <span class=\"comment\">// 自旋锁</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> proc[NPROC];</span><br><span class=\"line\">&#125; ptable;                     <span class=\"comment\">// 多个cpu之间共享该结构</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *initproc; <span class=\"comment\">// 存放init进程PCB</span></span><br><span class=\"line\"><span class=\"type\">int</span> nextpid = <span class=\"number\">1</span>;              <span class=\"comment\">// 分配唯一pid</span></span><br></pre></td></tr></table></figure>\n\n<p>XV6为进程定义了6种状态：UNUSED（PCB未使用）, EMBRYO（初始化中）, SLEEPING（阻塞休眠）, RUNNABLE（可调度）, RUNNING（运行中）, ZOMBIE（僵尸&#x2F;待回收）。 这里特别说明一下PCB的chan成员，该成员一个进程的等待条件。XV6中一个进程可能会调用sleep、wait系統調用，或者在調用read系統調用时间接调用了sleeplock，这些函数都会使一个进程进入阻塞状态，XV6的阻塞状态统一使用SLEEPING来表示，阻塞就是为了等待某个条件发生，当等待的条件发生时，阻塞的进程就会被唤醒，但是ptable有那么多阻塞的进程，我应该唤醒ptable中的哪些进程呢？此时chan就起到关键作用，在进程进入阻塞之前，会将chan设置为某一个变量的地址，当条件满足XV6就是通过chan来唤醒对应的进程的，当然这个变量的选取是很有讲究的，比如在XV6中因为sleep而休眠的进程，它的chan会被设置成ticks（作用类似jefrris，定时器中断的计数器）的地址。具体细节就不深入讨论，感兴趣的读者可以看看XV6的源码。</p>\n<p>从AP（从）处理器的启动段落我们知道，BSP、AP最终都进入scheduler函数，铺垫了这么久，scheduler函数也是本文的主题，那么先来看看它的代码实现吧：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PAGEBREAK: 42</span></span><br><span class=\"line\"><span class=\"comment\">// Per-CPU process scheduler.</span></span><br><span class=\"line\"><span class=\"comment\">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class=\"line\"><span class=\"comment\">// Scheduler never returns.  It loops, doing:</span></span><br><span class=\"line\"><span class=\"comment\">//  - choose a process to run</span></span><br><span class=\"line\"><span class=\"comment\">//  - swtch to start running that process</span></span><br><span class=\"line\"><span class=\"comment\">//  - eventually that process transfers control</span></span><br><span class=\"line\"><span class=\"comment\">//      via swtch back to the scheduler.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">scheduler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *p;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> *c = <span class=\"built_in\">mycpu</span>();  <span class=\"comment\">// 找到scheduler正运行在哪个cpu上</span></span><br><span class=\"line\">  c-&gt;proc = <span class=\"number\">0</span>;              <span class=\"comment\">// 将cpu结构体的当前运行的进程清零</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Enable interrupts on this processor.</span></span><br><span class=\"line\">    <span class=\"built_in\">sti</span>();                  <span class=\"comment\">// 打开中断、之前中断一直是关闭的！</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里pushcli保存的mycpu()-&gt;intena其实没有意义，在切换后会被外面的sched直接覆盖。</span></span><br><span class=\"line\">    <span class=\"comment\">// Loop over process table looking for process to run.</span></span><br><span class=\"line\">    <span class=\"built_in\">acquire</span>(&amp;ptable.lock); <span class=\"comment\">// 共用ptable，所以需要获取自旋锁，互斥访问。</span></span><br><span class=\"line\">    <span class=\"comment\">// 遍历ptable</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(p-&gt;state != RUNNABLE)  <span class=\"comment\">// 进程状态不可运行</span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      <span class=\"comment\">// else 找到了一个可运行的进程</span></span><br><span class=\"line\">      <span class=\"comment\">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class=\"line\">      <span class=\"comment\">// to release ptable.lock and then reacquire it</span></span><br><span class=\"line\">      <span class=\"comment\">// before jumping back to us.</span></span><br><span class=\"line\">      c-&gt;proc = p;  <span class=\"comment\">// 设置p为cpu当前运行进程</span></span><br><span class=\"line\">      <span class=\"comment\">//  这个函数非常关键，主要做两个三个操作：</span></span><br><span class=\"line\">      <span class=\"comment\">// 1、设置tss，并将其追加到全局描述符</span></span><br><span class=\"line\">      <span class=\"comment\">// 2、设置tss的选择子</span></span><br><span class=\"line\">      <span class=\"comment\">// 3、让cpu使用进程p的页表。</span></span><br><span class=\"line\">      switchuvm(p);</span><br><span class=\"line\">      p-&gt;state = RUNNING; <span class=\"comment\">// 设置p为运行状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">swtch</span>(&amp;(c-&gt;scheduler), p-&gt;context); <span class=\"comment\">// 正式开始切换，等到p放弃cpu才会返回</span></span><br><span class=\"line\">      switchkvm();        <span class=\"comment\">// 切换回内核页表kpgdir</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Process is done running for now.</span></span><br><span class=\"line\">      <span class=\"comment\">// It should have changed its p-&gt;state before coming back.</span></span><br><span class=\"line\">      c-&gt;proc = <span class=\"number\">0</span>;        <span class=\"comment\">// 当前运行的进程清零</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">release</span>(&amp;ptable.lock);  <span class=\"comment\">// 释放自旋锁</span></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>XV6的调度算法非常简单，就是简单的round robin算法。主要精华是整个调度的过程，至于它具体的调度算法其实显得并不是特别重要。</p>\n<p>switchuvm函数实现非常关键，它里面会设置tss，并且设置cpu使用进程p的页表。<strong>tss全称是任务状态段，它可以帮助处于用户态的进程回到内核态</strong>，因为一个进程有两个栈，一个是出于用户态使用，另外一个是处于内核态使用，进程从内核态转变成用户态容易。只需要将中断帧弹出恢复上下文即可，但是从用户态回到内核态就难了，因为进入用户态后，进程的用户态空间不会保留进程任何内核态信息，所以，我们需要一个东西来帮助处于用户态的进程在需要陷入内核态时，找到它的内核态的栈，这个东西就是TSS，TSS会记录一个进程的内核栈的栈指针esp和栈段ss，switchuvm函数正是完成了这样的功能。实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Switch TSS and h/w page table to correspond to process p.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">switchuvm</span><span class=\"params\">(<span class=\"keyword\">struct</span> proc *p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;switchuvm: no process&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;kstack == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;switchuvm: no kstack&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;pgdir == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;switchuvm: no pgdir&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">pushcli</span>();</span><br><span class=\"line\">  <span class=\"comment\">// 因为tss也是一个段，所以向cpu的全局描述符中追加tss的描述符</span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;gdt[SEG_TSS] = <span class=\"built_in\">SEG16</span>(STS_T32A, &amp;<span class=\"built_in\">mycpu</span>()-&gt;ts,</span><br><span class=\"line\">                                <span class=\"built_in\">sizeof</span>(<span class=\"built_in\">mycpu</span>()-&gt;ts)<span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;gdt[SEG_TSS].s = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;ts.ss0 = SEG_KDATA &lt;&lt; <span class=\"number\">3</span>;                 <span class=\"comment\">// 内核栈段</span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;ts.esp0 = (uint)p-&gt;kstack + KSTACKSIZE;  <span class=\"comment\">// 内核栈指针</span></span><br><span class=\"line\">  <span class=\"comment\">// setting IOPL=0 in eflags *and* iomb beyond the tss segment limit</span></span><br><span class=\"line\">  <span class=\"comment\">// forbids I/O instructions (e.g., inb and outb) from user space</span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;ts.iomb = (ushort) <span class=\"number\">0xFFFF</span>;</span><br><span class=\"line\">  <span class=\"built_in\">ltr</span>(SEG_TSS &lt;&lt; <span class=\"number\">3</span>);                                <span class=\"comment\">// tss段选择子</span></span><br><span class=\"line\">  <span class=\"comment\">// 切换到p的页表</span></span><br><span class=\"line\">  <span class=\"built_in\">lcr3</span>(<span class=\"built_in\">V2P</span>(p-&gt;pgdir));  <span class=\"comment\">// switch to process&#x27;s address space</span></span><br><span class=\"line\">  <span class=\"built_in\">popcli</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于任务状态段的详情描述可以参考：<a href=\"https://github.com/StevenBaby/onix/blob/dev/docs/07%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/062%20%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E7%AE%80%E4%BB%8B.md\">https://github.com/StevenBaby/onix/blob/dev/docs/07%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/062%20%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E7%AE%80%E4%BB%8B.md</a></p>\n<p>swtch函数由汇编实现，是进程切换的核心函数，实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Context switch</span><br><span class=\"line\">#</span><br><span class=\"line\">#   void swtch(struct context **old, struct context *new);</span><br><span class=\"line\"># </span><br><span class=\"line\"># Save the current registers on the stack, creating</span><br><span class=\"line\"># a struct context, and save its address in *old.</span><br><span class=\"line\"># Switch stacks to new and pop previously-saved registers.</span><br><span class=\"line\"></span><br><span class=\"line\">.globl swtch</span><br><span class=\"line\">swtch:                # 这里有个pushl eip，cpu帮我们自动执行了</span><br><span class=\"line\">  movl 4(%esp), %eax  # 第一个参数，struct context**</span><br><span class=\"line\">  movl 8(%esp), %edx  # 第二个参数  struct context*</span><br><span class=\"line\"></span><br><span class=\"line\">  # Save old callee-saved registers</span><br><span class=\"line\">  pushl %ebp</span><br><span class=\"line\">  pushl %ebx</span><br><span class=\"line\">  pushl %esi</span><br><span class=\"line\">  pushl %edi</span><br><span class=\"line\"></span><br><span class=\"line\">  # Switch stacks</span><br><span class=\"line\">  movl %esp, (%eax) # 加括号和在指针前面加*一个道理，这里保存当前内核栈指针到第一个参数上</span><br><span class=\"line\">  movl %edx, %esp   # 将esp切换到第二个参数指向的内核栈上</span><br><span class=\"line\"></span><br><span class=\"line\">  # Load new callee-saved registers</span><br><span class=\"line\">  popl %edi</span><br><span class=\"line\">  popl %esi</span><br><span class=\"line\">  popl %ebx</span><br><span class=\"line\">  popl %ebp</span><br><span class=\"line\">  ret</span><br></pre></td></tr></table></figure>\n\n<p>struct context结构体定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">context</span> &#123;</span><br><span class=\"line\">  uint edi;</span><br><span class=\"line\">  uint esi;</span><br><span class=\"line\">  uint ebx;</span><br><span class=\"line\">  uint ebp;</span><br><span class=\"line\">  uint eip;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一个进程在（因为时间片用完）需要放弃cpu执行权限，如何回到scheduler呢？答案就是使用sched函数，本文我们以普遍的事件来分析————因为时间片用完而放弃的cpu。处于<strong>用户态的进程因为时间片用完会发生定时器中断</strong>，定时器中断又会引发从用户态到内核态的切栈、保存上下文、执行trap函数，trap函数中最后调用了yield，yield最终会调用sched，trap函数伪代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">spinlock</span> tickslock;</span><br><span class=\"line\">uint ticks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//PAGEBREAK: 41</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">trap</span><span class=\"params\">(<span class=\"keyword\">struct</span> trapframe *tf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(tf-&gt;trapno == T_SYSCALL)&#123;  <span class=\"comment\">// 是系统调用</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(tf-&gt;trapno)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">cpuid</span>() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">acquire</span>(&amp;tickslock);</span><br><span class=\"line\">      ticks++;            <span class=\"comment\">// 每次定时器中断都自增1</span></span><br><span class=\"line\">      <span class=\"built_in\">wakeup</span>(&amp;ticks);     <span class=\"comment\">// 唤醒sleeping进程，检查休眠是否到期</span></span><br><span class=\"line\">      <span class=\"built_in\">release</span>(&amp;tickslock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">lapiceoi</span>();           <span class=\"comment\">// 通知lapic中断处理完毕</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Force process to give up CPU on clock tick.</span></span><br><span class=\"line\">  <span class=\"comment\">// If interrupts were on while locks held, would need to check nlock.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">myproc</span>() &amp;&amp; <span class=\"built_in\">myproc</span>()-&gt;state == RUNNING &amp;&amp;</span><br><span class=\"line\">     tf-&gt;trapno == T_IRQ0+IRQ_TIMER)</span><br><span class=\"line\">    <span class=\"built_in\">yield</span>();    <span class=\"comment\">// 时间片用完，cpu让给下一个进程</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>yield函数实现就是封装了一下sched函数，在调用sched之前，将进程的状态设置成了RUNNABLE状态：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Enter scheduler.  Must hold only ptable.lock</span></span><br><span class=\"line\"><span class=\"comment\">// and have changed proc-&gt;state. Saves and restores</span></span><br><span class=\"line\"><span class=\"comment\">// intena because intena is a property of this</span></span><br><span class=\"line\"><span class=\"comment\">// kernel thread, not this CPU. It should</span></span><br><span class=\"line\"><span class=\"comment\">// be proc-&gt;intena and proc-&gt;ncli, but that would</span></span><br><span class=\"line\"><span class=\"comment\">// break in the few places where a lock is held but</span></span><br><span class=\"line\"><span class=\"comment\">// there&#x27;s no process.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sched</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> intena;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *p = <span class=\"built_in\">myproc</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"built_in\">holding</span>(&amp;ptable.lock))</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched ptable.lock&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">mycpu</span>()-&gt;ncli != <span class=\"number\">1</span>)        <span class=\"comment\">// 最多一层关中断</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched locks&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;state == RUNNING)       <span class=\"comment\">// 在调用sched前，应该改变进程状态</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched running&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">readeflags</span>()&amp;FL_IF)        <span class=\"comment\">// 中断必须被关闭！</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched interruptible&quot;</span>);</span><br><span class=\"line\">  intena = <span class=\"built_in\">mycpu</span>()-&gt;intena;     <span class=\"comment\">// intena是进程私有的</span></span><br><span class=\"line\">  <span class=\"built_in\">swtch</span>(&amp;p-&gt;context, <span class=\"built_in\">mycpu</span>()-&gt;scheduler); <span class=\"comment\">// 切换到scheduler</span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;intena = intena;     <span class=\"comment\">// 还原intena</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Give up the CPU for one scheduling round.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">yield</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">acquire</span>(&amp;ptable.lock);  <span class=\"comment\">//DOC: yieldlock</span></span><br><span class=\"line\">  <span class=\"built_in\">myproc</span>()-&gt;state = RUNNABLE;</span><br><span class=\"line\">  <span class=\"built_in\">sched</span>();</span><br><span class=\"line\">  <span class=\"built_in\">release</span>(&amp;ptable.lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sched中保存intena状态到进程的内核栈中的做法，好像把intena变量放到PCB中更合适，但是XV6没有这么做。从shced函数注释中了解到，如果把intena变量放到PCB中的话，有些情况下会有问题。具体呢，就不去细究了（我也每深究），本文内容太长了，还是以调度为主。这里主要是想表达一个点：<strong>scheduler函数给ptable.lock加锁时，pushcli保存的intena没有任何意义。因为最终在切换进程时，会被sched中进程的intena给覆盖掉。同样，在进程回到scheduler函数后，scheduler函数给ptable.lock解锁时，popcli还原的intena也没有任何意义，因为无论intena原来是否开中断，外层的for都会开中断！</strong></p>\n<p>最终，一个待调度的进程的内核栈帧就形成了：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/task_stack.drawio.png\"></p>\n<p>一张图片概括yield、scheduler的加锁关系。如下图，进程利用yield进入调度器时会获取ptable的自旋锁（自旋锁内部会关中断，并且将关中断之前的中断状态保存到intena中），在切换到scheduler后（可能）会由scheduler解锁。在从scheduler切换到下一个任务前，（可能）scheduler会获取ptable的自旋锁，在却换到下一个任务后，由任务进行解除ptable的自选锁，注意这里是可能，因为还有可能scheduler的内层循环还没有执行完，以至于内层循环还可以找到下一个待执行的日任务，此时ptable的锁，就是：老进程加锁，新进程解锁：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/yield_scheduler.png\"></p>\n<p>总的来说，XV6进程调度整体流程是：<strong>每个cpu上都运行调度线程，调度线程运行sheduler函数，scheduler不断从ptable取进行任务，然后（swapIn）切换去执行进程任务，当进程任务用完时间片（通过定时器中断）就会放弃cpu的执行权限，（swapOut）切换到内核调度线程继续去调度下一个进程任务。</strong></p>\n<p>如果类比于用户态的协程的：<strong>对称协程和非对称协程之分吗的话，结合非对称协程的特点：协程的切换需要经过调度协程，而由于XV6进程的调度都必须经内核的过调度线程，所以XV6的调度器模型更像一种“非对称进程”。</strong></p>\n<p><strong>作为对比，如果你阅读过Onix的代码，你会发现Onix的调度模型更像是一种”对称进程“，因为Onix的进程切换是两个进程之间直接进行，不存在中间的调度线程。</strong></p>\n<p>这里我可以用一张<strong>类似sylar的协程调度器模型来总结XV6进程调度模型</strong>：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler.drawio.png\"></p>\n<p><strong>其实CPU Pool和线程池非常像，XV6的每个CPU都互斥到ptable中去取进程，然后去消化进程。唯一的区别就是CPU要和很多寄存器、硬件打交道，但是最终整体的框架思想都是一同百通，</strong></p>\n<p>如果你看过sylar的源码，你会深有感触！ <strong>sylar的协程调度器模型和XV6进程的调度模型不能说像，只能是真的一模一样！</strong> sylar是一个C++的基于协程的网络框架。我之前也有写过sylar的博客，这里推荐大家去看看：<a href=\"https://blog.csdn.net/m0_52566365/article/details/135991331%E3%80%82\">https://blog.csdn.net/m0_52566365/article/details/135991331。</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>XV6有很多地方写的很暴力，有很大的优化空间，比如：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">XV6做法</th>\n<th align=\"center\">Onix做法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">内存管理</td>\n<td align=\"center\">不管是物理内存还是内核内存一股脑使用kalloc，用户页表所有的内容都靠kalloc</td>\n<td align=\"center\">get_page（使用256个页管理4G物理页，专门给页表和页框分配内存&#x2F;page） + alloc_kpage（专门给内核分配内核页所有的页目录都采用alloc_kpage&#x2F;page） + kmalloc（使用了内存池专门管理内核中的小快内存&#x2F;byte）</td>\n</tr>\n<tr>\n<td align=\"center\">内核对系统调用参数的获取</td>\n<td align=\"center\">直接访问用户栈空间</td>\n<td align=\"center\">使用ebp、edi、esi、edx、ecx、ebx寄存器获取系统调用参数</td>\n</tr>\n<tr>\n<td align=\"center\">软件定时器</td>\n<td align=\"center\">没有实现软件定时器</td>\n<td align=\"center\">利用链表实现了软件定时器</td>\n</tr>\n<tr>\n<td align=\"center\">内存探测</td>\n<td align=\"center\">未实现内存探测</td>\n<td align=\"center\">loader实现了内存探测</td>\n</tr>\n<tr>\n<td align=\"center\">idle任务</td>\n<td align=\"center\">没实现idle任务</td>\n<td align=\"center\">实现了idle任务</td>\n</tr>\n<tr>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n</tr>\n</tbody></table>\n<p>从上表可以看到Onix每一项都是存在优势的。但是Onix唯一的缺点，也是我读了Onix源码又来读XV6源码的原因：Onix是一个<strong>单核</strong>OS。其实读完XV6了解了多核OS的实现后，也没感到很大的震撼，多核CPU无非就是比单核CPU多了几套eip、esp、eflag等cpu相关的寄存器，cpu访问共享资源的的时候注意加锁就好了。</p>\n<p>最后谈谈XV6调度模型的优化：从<strong>XV6进程调度模型图</strong>我们可以看到，XV6的调度模型可以参考Muduo的One loop per thread 思想（可能说Muduo的One loop per thread思想参考了现代Linux对CPU的调度模型更合适？），因为XV6进程调度模型非常暴力，所有cpu共享有一个任务池（ptable），锁的竞争非常激烈。我们可以考虑让每个cpu都拥有一个自己独立的ptable（当然里面还是有自旋锁），由一个cpu负责负载均衡，将任务均匀的分发给各个cpu，需要修改cpux内部数据结构时，其他cpu只需向cpux的回调队列中添加操作函数即可，具体的操作还是由cpux自己完成。<strong>也即One loop per CPU</strong>。如下图：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler_pluse.drawio.png\"></p>\n<p>终于4干完了这篇文章，字数预计上万了，第一次写这么长的文章，也是真的用心了。创作不易，赏个赞把！</p>\n<p><strong>参考资料</strong></p>\n<p>多处理器规范：<a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\">https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf</a></p>\n<p>XV6的官方中文文档：<a href=\"https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\">https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf</a></p>\n<p>Onix单核操作系统：<a href=\"https://github.com/StevenBaby/onix/\">https://github.com/StevenBaby/onix/</a></p>\n<p>APIC中断讲解比较好的范文：<a href=\"https://blog.csdn.net/weixin_46645613/article/details/119207945\">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>\n<p>多核处理器启动博客1：<a href=\"https://zhuanlan.zhihu.com/p/394247844\">https://zhuanlan.zhihu.com/p/394247844</a></p>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前面已经分析了XV6的启动流程以及内存管理，接下来，我们探究进程调度的实现。与其说进程调度，我觉得可以顺应内存的虚拟化的叫法，将进程调度称为“CPU的虚拟化”更加贴切。</p>\n<p>首先明确目前XV6的cpu的状态如下：关中断 &amp; 进入了保护模式 &amp; 安装了包括【内核&amp;用户】【代码&amp;数据】段描述符 &amp; BSP分配了一个4K的内核栈 &amp; 开启了以kmap为基础的粒度为4K的内核分页。</p>\n<p>Onix相关链接：</p>\n<ul>\n<li><p><a href=\"https://github.com/StevenBaby/onix\">github仓库链接</a>。</p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/BV1qM4y127om/\">B站配套视频链接</a>。</p>\n</li>\n</ul>\n<p>XV6-x86的github链接：</p>\n<ul>\n<li><a href=\"https://github.com/mit-pdos/xv6-public\">链接</a>。</li>\n</ul>","more":"<h2 id=\"中断机制\"><a href=\"#中断机制\" class=\"headerlink\" title=\"中断机制\"></a>中断机制</h2><p>对于中断的部分，这里会涉及大量硬件相关的知识，由于博主的目的是了解OS的基本框架，所以硬件相关的知识储备可能不会太深，如果你是想弄清某个硬件具体实现，这篇博客可能不适合你。</p>\n<p>这里总结一下我对中断的理解：</p>\n<p>引发中断的方式有三种：外中断、异常、软中断。</p>\n<ul>\n<li><p>外中断：就是由外部中断控制器通知 CPU 某个事件完成了，比如：磁盘寻道完成可以进行读写了、UART输入寄存器非空（可读）、UART输出寄存器为空（可写）、键盘缓冲有数据了（可读）等等。</p>\n</li>\n<li><p>异常是 CPU 在执行过程中，因为出错而执行不下去了，比如：除零异常、因为虚拟页面还没映射发生缺页异常、对只读段进行写操作触发段错误异常等等。</p>\n</li>\n<li><p>软中断，可以认为是应用程序和操作系统沟通的一种方式，运行在低优先级程序想要对硬件做IO，但是由于只有处于特权级的内核能够直接和设备打交道，从而低优先级程序必须通过某种机制来完成特权级转换，这种机制就是软中断。我们也可以将实现这种功能的函数称为系统调用。</p>\n</li>\n</ul>\n<p>如有些教科书那样，我们也可以把异常和软中断统称为 内中断，也就是这个中断时 CPU 和 软件内部产生的，与外部硬件无关。</p>\n<h3 id=\"Onix单核处理器的中断原理\"><a href=\"#Onix单核处理器的中断原理\" class=\"headerlink\" title=\"Onix单核处理器的中断原理\"></a>Onix单核处理器的中断原理</h3><p>单核PC机上，一般会采用（主从）两片 8259a PIC（programmable interrupt controller），将PIC的INT引脚接到CPU的一个引脚上，如下图，图片引用自onix的文档，如有侵权，可告知删除：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/8259a.drawio.png\"></p>\n<p>从图中可以看到有两个8259a，上面那个8259a是主PIC，它的INT引脚直接接到CPU上；下面那个8259a的INT引脚接到主PIC的IR2引脚，所以它是从PIC。 每一个PIC的引脚会接一个外设，（如果对应的引脚没被屏蔽的话）外设会通过PIC间接向CPU发中断。</p>\n<p>在PIC正式工作前，需要对其进行一系列初始化。初始化操作由cpu发送一系列的控制字完成。有两类控制字：</p>\n<ul>\n<li><p>初始化命令字 (Initialization Command Words, ICW), ICW 共 4 个， ICW1 ~ ICW4；</p>\n</li>\n<li><p>操作命令字 (Operation Command Word, OCW), OCW 共 3 个， OCW1 ~ OCW3；</p>\n</li>\n</ul>\n<p>ICW 做初始化，用来确定是否需要级联，设置起始中断向量号，设置中断结束模式。因为某些设置之间是具有依赖性的，也许后面的某个设置会依赖前面某个 ICW 写入的设置，所以这部分要求严格的顺序，<strong>必须依次写入</strong> ICW1、ICW2、ICW3、ICW4；</p>\n<p>OCW 来操作控制 8259A，中断的屏蔽和中断处理结束就是通过往 8259A 端口发送 OCW 实现的。OCW 的发送顺序不固定，3 个之中先发送哪个都可以。</p>\n<p><strong>具体细节非常推荐读者去阅读一下Onix文档，讲的真的很细致</strong>：<a href=\"https://github.com/StevenBaby/onix/blob/dev/docs/04%20%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F/033%20%E5%A4%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.md\">https://github.com/StevenBaby/onix/blob/dev/docs/04%20%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F/033%20%E5%A4%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.md</a></p>\n<p>8259a中断控制器的初始化就是一种固定套路，截取Onix代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_M_CTRL 0x20 <span class=\"comment\">// 主片的控制端口</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_M_DATA 0x21 <span class=\"comment\">// 主片的数据端口</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_S_CTRL 0xa0 <span class=\"comment\">// 从片的控制端口</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_S_DATA 0xa1 <span class=\"comment\">// 从片的数据端口</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_EOI 0x20    <span class=\"comment\">// 通知中断控制器中断结束</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化中断控制器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pic_init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 主PIC</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_CTRL, <span class=\"number\">0b00010001</span>); <span class=\"comment\">// ICW1: 边沿触发, 级联 8259, 需要ICW4.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0x20</span>);       <span class=\"comment\">// ICW2: 起始中断向量号 0x20</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0b00000100</span>); <span class=\"comment\">// ICW3: IR2接从片.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0b00000001</span>); <span class=\"comment\">// ICW4: 8086模式, 正常EOI</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从PIC</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_CTRL, <span class=\"number\">0b00010001</span>); <span class=\"comment\">// ICW1: 边沿触发, 级联 8259, 需要ICW4.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">0x28</span>);       <span class=\"comment\">// ICW2: 起始中断向量号 0x28</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">2</span>);          <span class=\"comment\">// ICW3: 设置从片连接到主片的 IR2 引脚</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">0b00000001</span>); <span class=\"comment\">// ICW4: 8086模式, 正常EOI</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0b11111111</span>); <span class=\"comment\">// OCW1：屏蔽字，关闭主PIC所有中断，后面需要什么中断再依据需求打开。</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">0b11111111</span>); <span class=\"comment\">// OCW1：屏蔽字，关闭从PIC所有中断，后面需要什么中断再依据需求打开。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CPU在处理每个外中断后，需要向PIC发生一个结束字为的是通知PIC中断处理结束，具体中断结束方式由OCW2 来设置。代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通知中断控制器，中断处理结束</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">send_eoi</span><span class=\"params\">(<span class=\"type\">int</span> vector)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vector &gt;= <span class=\"number\">0x20</span> &amp;&amp; vector &lt; <span class=\"number\">0x28</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">outb</span>(PIC_M_CTRL, PIC_EOI);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vector &gt;= <span class=\"number\">0x28</span> &amp;&amp; vector &lt; <span class=\"number\">0x30</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">outb</span>(PIC_M_CTRL, PIC_EOI);</span><br><span class=\"line\">        <span class=\"built_in\">outb</span>(PIC_S_CTRL, PIC_EOI);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此单核OS中断的初始化到这里就结束了。</p>\n<h3 id=\"XV6多核处理的中断原理\"><a href=\"#XV6多核处理的中断原理\" class=\"headerlink\" title=\"XV6多核处理的中断原理\"></a>XV6多核处理的中断原理</h3><p>多核处理器中断控制器的结构更为复杂，因为偏向硬件，这里就只记录一下我对APIC的理解，理解不会太深，如果有错误，非常欢迎读者纠正！</p>\n<p>首先还是供上架构框图：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/APICStructure.png\"></p>\n<p>图片截取自：<a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\">https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf</a></p>\n<p>注释：</p>\n<p>BSP：bootstrap processor，可以简单理解为主处理器。</p>\n<p>APx：application processors ，可以简单理解为从处理器。</p>\n<p>关于BSP和APx的关系这里先埋个伏笔。在【AP（从）处理器的启动】段落会进行详细叙述。</p>\n<p>从图中的上半部分可以了解到，每个CPU各自接着一个Local APIC（Advanced Programmable Interrupt Controller）。注意，<strong>每个lapic和cpu是封装在一起的</strong>（这里并不严谨，是否和cpu封装在一起其实和cpu的架构有关）。后面我们会看到，不止APIC，在多核cpu上，它的每一个cpu都有自己的一套cpu寄存器，比如：esp、eip、eflag等等。具体情况我们在“进程调度”段落进行详细讲解。</p>\n<p>从图的下半部分，我们可以了解到所有的lapic都接到了ICC（interrupt controller communications） Bus上，并且，总线上还接了一个IO APIC，这里的<strong>ioapic是和cpu分离的</strong>，它被接在cpu的外部。<strong>ioapic会接收来自各个外设的中断。然后对各个外设发来的中断做一些判断和处理，再将中断的IRQ号和lapic的ID封装在一条“报文”中分发給对应的lapic</strong>，具体发给哪些lapic，我们可以通过配置ioapic来进行设置。ioapic左边其实是有很多引脚（实际16个，如果级联了8259a可能会更多）每个引脚都可以接外设。有趣的是，从图中ioapic的左边可以看到，<strong>ioapic的引脚还可以接8259a PIC控制器</strong>，这非常完美的兼容了单核cpu的中断控制器的架构。</p>\n<p>iopic是依据重定向表项 RTE(Redirection Table Entry)来构建“报文“，RTE对每一个中断都会有一项64位的entry。通过entry，可以单独设置ioapic在收到中断后对中断的操作。每一项entry描述：中断对应的中断向量？中断有没有使能？中断传输状态？发给哪个lapic？</p>\n<p>每个lapic都有一个唯一的ID，cpu可以在特定的内存（device space）上来查询自己所对应的lapic的ID号，lapic的ID其实也唯一标识了一个cpu。lapic会根据自己的ID从ICC Bus上接收属于自己的中断”报文“，然后经过一系列检查最后将中断发给cpu，当cpu处理完中断后，会反馈给自己的lapic，lapic收到cpu的回复后，同样将中断处理完毕的消息通知给ioapic，这点和单核架构中，cpu处理完中断后向master pic发送PIC_EOI是一样的道理。</p>\n<p>特别的是，lapic也可以像ioapic那样作为中断“源”（这里可能不严谨，但是可以类比去理解），向其他的lapic发送中断“报文”，这是通过ICR(Interrupt Command Register)寄存器实现，ICR的结构和ioapic的RTE表的entry结构类似，也有中断向量号、lapic的ID等字段。lapic主动向其他lapic发送中断“报文”最常见的场景就是BSP去启动其他APs，这一般通过会发送INIT or STARTUP IPI（interprocessor interrupts）。</p>\n<p>由于XV6中cpu对lapic、iopic初始化代码上，依赖于mpinit函数，而mpinit和多处理器内容相关，所以lapic、iopic初始化我们放到”AP（从）处理器的启动”段落进行讨论。</p>\n<p>关于Local APIC和IO APIIC详细内容可以参考博客：<a href=\"https://blog.csdn.net/weixin_46645613/article/details/119207945\">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>\n<h3 id=\"中断描述符表\"><a href=\"#中断描述符表\" class=\"headerlink\" title=\"中断描述符表\"></a>中断描述符表</h3><p>之前一直在介绍中断相关的外设，接下来我们看看cpu内部是怎么利用寄存器来定义中断的。</p>\n<p>因为中断不止一个，所以，和全局描述符类表似，中断表也是通过一个大的数组来记录每一个中断的属性。数组中每一个Entry格式如下图，每一个Entry同样是8个字节：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/IDT_Entry.png\"></p>\n<ul>\n<li><p>Offset：记录中断门或陷阱门的处理函数的地址。</p>\n</li>\n<li><p>Selector：处理函数的段选择子。</p>\n</li>\n<li><p>Type：标记是中断门还是陷阱门。 <strong>注意：中断门会自动清除eflag寄存器的FL_IF标志位，而陷阱门则保留eflag的FL_IF标志位。</strong> 也即中断门会i自动关（外）中断，而陷阱门则不会有关中断的操作！</p>\n</li>\n<li><p>S：必须为0。</p>\n</li>\n<li><p>DPL：描述符可以被哪个特权级使用。对于中断门一般是0x0，对于陷阱门就是0x3（DPL_USER）。</p>\n</li>\n<li><p>P：是否有效，固定填1.</p>\n</li>\n</ul>\n<p>XV6相关代码注释写的非常好，上面的中文注释也是参考XV6的注释写的，如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Gate descriptors for interrupts and traps</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">gatedesc</span> &#123;</span><br><span class=\"line\">  uint off_15_0 : <span class=\"number\">16</span>;   <span class=\"comment\">// low 16 bits of offset in segment</span></span><br><span class=\"line\">  uint cs : <span class=\"number\">16</span>;         <span class=\"comment\">// code segment selector</span></span><br><span class=\"line\">  uint args : <span class=\"number\">5</span>;        <span class=\"comment\">// # args, 0 for interrupt/trap gates</span></span><br><span class=\"line\">  uint rsv1 : <span class=\"number\">3</span>;        <span class=\"comment\">// reserved(should be zero I guess)</span></span><br><span class=\"line\">  uint type : <span class=\"number\">4</span>;        <span class=\"comment\">// type(STS_&#123;IG32,TG32&#125;)</span></span><br><span class=\"line\">  uint s : <span class=\"number\">1</span>;           <span class=\"comment\">// must be 0 (system)</span></span><br><span class=\"line\">  uint dpl : <span class=\"number\">2</span>;         <span class=\"comment\">// descriptor(meaning new) privilege level</span></span><br><span class=\"line\">  uint p : <span class=\"number\">1</span>;           <span class=\"comment\">// Present</span></span><br><span class=\"line\">  uint off_31_16 : <span class=\"number\">16</span>;  <span class=\"comment\">// high bits of offset in segment</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set up a normal interrupt/trap gate descriptor.</span></span><br><span class=\"line\"><span class=\"comment\">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span></span><br><span class=\"line\"><span class=\"comment\">//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone</span></span><br><span class=\"line\"><span class=\"comment\">// - sel: Code segment selector for interrupt/trap handler</span></span><br><span class=\"line\"><span class=\"comment\">// - off: Offset in code segment for interrupt/trap handler</span></span><br><span class=\"line\"><span class=\"comment\">// - dpl: Descriptor Privilege Level -</span></span><br><span class=\"line\"><span class=\"comment\">//        the privilege level required for software to invoke</span></span><br><span class=\"line\"><span class=\"comment\">//        this interrupt/trap gate explicitly using an int instruction.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SETGATE(gate, istrap, sel, off, d)                \\</span></span><br><span class=\"line\"><span class=\"meta\">&#123;                                                         \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).off_15_0 = (uint)(off) &amp; 0xffff;                \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).cs = (sel);                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).args = 0;                                        \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).rsv1 = 0;                                        \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).s = 0;                                           \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).dpl = (d);                                       \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).p = 1;                                           \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).off_31_16 = (uint)(off) &gt;&gt; 16;                  \\</span></span><br><span class=\"line\"><span class=\"meta\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>中断描述符寄存器如下：</p>\n<p>高32位存放中断描述符表的基地址，低16位存放中断描述符表的大小（字节为单位）。</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/IDTR.png\"></p>\n<h2 id=\"AP（从）处理器的启动\"><a href=\"#AP（从）处理器的启动\" class=\"headerlink\" title=\"AP（从）处理器的启动\"></a>AP（从）处理器的启动</h2><p>首先还是回归main函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Bootstrap processor starts running C code here.</span></span><br><span class=\"line\"><span class=\"comment\">// Allocate a real stack and switch to it, first</span></span><br><span class=\"line\"><span class=\"comment\">// doing some setup required for memory allocator to work.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">kinit1</span>(end, <span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>)); <span class=\"comment\">// 内存内存管理已讲</span></span><br><span class=\"line\">  <span class=\"built_in\">kvmalloc</span>();      <span class=\"comment\">// 内存内存管理已讲</span></span><br><span class=\"line\">  <span class=\"built_in\">mpinit</span>();        <span class=\"comment\">// detect other processors</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicinit</span>();     <span class=\"comment\">// interrupt controller</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();       <span class=\"comment\">// 内存内存管理已讲</span></span><br><span class=\"line\">  <span class=\"built_in\">picinit</span>();       <span class=\"comment\">// disable pic // 禁用单核架构下的8259A，实现很简单，这里就不去贴代码了</span></span><br><span class=\"line\">  <span class=\"built_in\">ioapicinit</span>();    <span class=\"comment\">// another interrupt controller</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">pinit</span>();         <span class=\"comment\">// process table // 实现很简单就是对自ptable的自旋锁进行一个初始化。读者可以自行阅读代码，这里就不过多赘述。</span></span><br><span class=\"line\">  <span class=\"built_in\">tvinit</span>();        <span class=\"comment\">// trap vectors</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">startothers</span>();   <span class=\"comment\">// start other processors</span></span><br><span class=\"line\">  <span class=\"built_in\">kinit2</span>(<span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>), <span class=\"built_in\">P2V</span>(PHYSTOP)); <span class=\"comment\">// 内存内存管理已讲</span></span><br><span class=\"line\">  <span class=\"built_in\">userinit</span>();      <span class=\"comment\">// first user process // 就是对init进程的内核栈做一个初始化。利用了ROP（面向返回点编程）编程思想。因为这又是一个大主题，本文不会过多讲解。以后有机会在另开一篇博客专门讨论。</span></span><br><span class=\"line\">  <span class=\"built_in\">mpmain</span>();        <span class=\"comment\">// finish this processor&#x27;s setup // 进入mpmain</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Other AP CPUs jump here from entryother.S.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpenter</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  switchkvm();  <span class=\"comment\">// AP的内核页表换成kpgdir</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();    <span class=\"comment\">// 内存内存管理已讲</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicinit</span>();  <span class=\"comment\">// 作用同main函数中BSP核执行的lapicinit函数</span></span><br><span class=\"line\">  <span class=\"built_in\">mpmain</span>();     <span class=\"comment\">// 进入mpmain</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BSP、APS最终都会进入改函数。</span></span><br><span class=\"line\"><span class=\"comment\">// 主要工作就是</span></span><br><span class=\"line\"><span class=\"comment\">//    1、加载中断描述表。</span></span><br><span class=\"line\"><span class=\"comment\">//    2、设置状态，已启动。</span></span><br><span class=\"line\"><span class=\"comment\">//    3、 进入调度循环。</span></span><br><span class=\"line\"><span class=\"comment\">// Common CPU setup code.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpmain</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cprintf</span>(<span class=\"string\">&quot;cpu%d: starting %d\\n&quot;</span>, <span class=\"built_in\">cpuid</span>(), <span class=\"built_in\">cpuid</span>());</span><br><span class=\"line\">  <span class=\"built_in\">idtinit</span>();       <span class=\"comment\">// load idt register // 使用lidt命令加载中断描述符</span></span><br><span class=\"line\">  <span class=\"built_in\">xchg</span>(&amp;(<span class=\"built_in\">mycpu</span>()-&gt;started), <span class=\"number\">1</span>); <span class=\"comment\">// tell startothers() we&#x27;re up</span></span><br><span class=\"line\">  <span class=\"built_in\">scheduler</span>();     <span class=\"comment\">// start running processes</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下我们要从BSP执行的maiin函数开始，深入分析以上代码的作用。</p>\n<h3 id=\"mpinit：探测各个cpu\"><a href=\"#mpinit：探测各个cpu\" class=\"headerlink\" title=\"mpinit：探测各个cpu\"></a>mpinit：探测各个cpu</h3><p>该部分主要参考：<a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\">多处理器规范</a>，因为我英语也是很菜，所以硬着头皮捡重点去看了一部分。</p>\n<p>这里对多核处理器的启动流程做一个简单总结：我们可以理解为，多核CPU中，有一个CPU被设计成BSP，其他的CPU都被设计成AP。当然，在实际硬件设计上为了考虑容错性，任何一个CPU都能成为BSP核。 <strong>系统最开始，BSP有对硬件的绝对控制权，包括去控制其他AP的启动和停止。为了启动其他AP核，BSP首先通过三种可能的方式搜索MP floating pointer structure，如果找到了一个有效的MP floating pointer structure就去遍历MP configuration table查询处理器信息和ioapic的信息；如果无法找到一个有效MP floating pointer structure，那就认为系统只有一个CPU——BSP。在所有CPU启动后，BSP就退化成AP，系统不存在BSP、AP之分。</strong> 当然，我们需要要记录BSP CPU的lapic的ID（这个ID也唯一标识着CPU），这样我们才知道谁可以去其控制其他CPU的停止。在BSP启动其他AP前，因为AP CPU是暂停状态，所以其他AP无法执行OS代码，并且大部分中断都是被禁用，<strong>但是INIT or STARTUP interprocessor interrupts (IPIs)不会被屏蔽，当AP收到来自BSP的INIT or STARTUP中断，就会启动它自己。</strong> AP在收到BSP的启动中断后，也会进入保护模式、<strong>有自己的独立的一套寄存器</strong>、设置自己的全局描述符、开启分页、有自己的堆栈等。</p>\n<p>首先BSP会通过三种方式去搜索MP floating pointer structure，<strong>三种搜索范围都在1M以内，因为MP floating pointer structure就是由BIOS提供，而BISO寻址范围就1M</strong>：</p>\n<ol>\n<li>In the first kilobyte of Extended BIOS Data Area (EBDA), or</li>\n<li>Within the last kilobyte of system base memory, or</li>\n<li>In the BIOS ROM address space between 0F0000h and 0FFFFFh.</li>\n</ol>\n<p>低1M内存的内存映射参考：<a href=\"https://wiki.osdev.org/BDA#BIOS_Data_Area_.28BDA.29\">https://wiki.osdev.org/BDA#BIOS_Data_Area_.28BDA.29</a></p>\n<p>MP Configuration Data Structures整体框架如下图，图解了MP floating pointer structure、MP Configuration Table Header、Table Entries三者之间的一个关系，先了解一下大致的框架，接下来我门逐一剖析。</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png\"></p>\n<p>MP floating pointer structure图解如下：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/MP_floating_pointer_structure.png\"></p>\n<p>主要关注它的PHYSICAL ADDRESS POINTER，它指向MP config table的物理地址。</p>\n<p>MP Configuration Table Header结构如下：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/MP_configuration_table_header.png\"></p>\n<p>主要关注几个字段：</p>\n<ul>\n<li><p>MEMORY-MAPPED ADDRESS OF LOCAL APIC：描述 cpu（<strong>每个CPU都将它的lapic映射到了同一个物理地址</strong>）的lapic的寄存器物理地址。注意这里是”每个cpu”，虽然是同一个物理地址，但是在每一个cpu去读的时候，分别映射到了各自的lapic的寄存器地址上了。</p>\n</li>\n<li><p>BASE TABLE LENGTH：整个table的长度，虽然存在扩展表长度，但是我们还用不到。</p>\n</li>\n</ul>\n<p>MP Configuration Table Header后面会跟上各自类型的Base MP Configuration Table Entries，每个Entry的第一个字节会标明其类型，并且每种Entry的长度都各自固定，所以我们可以通过一个循环来遍历每个Entry，一共有5种类型的Entry，如下图：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/entry_types.png\"></p>\n<p>XV6中我们主要关注Processor Entries和I&#x2F;O APIC两种类型的Entry。</p>\n<p>Processor Entries结构如下：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/processor_entry.png\"></p>\n<p>主要关注LOCAL APIC ID，如该字段名字那样，就是代表和CPU绑定的lapic的ID，通过它我们也可以唯一标识一个CPU。</p>\n<p>I&#x2F;O APIC Entries结构如下：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/ioapic_entry.png\"></p>\n<p>主要关注I&#x2F;O APIC ID，代表I&#x2F;O APIC的ID。</p>\n<p>然后上代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  uchar *p, *e;</span><br><span class=\"line\">  <span class=\"type\">int</span> ismp;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mp</span> *mp;              <span class=\"comment\">// 前面提到的MP floating pointer structure</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mpconf</span> *conf;        <span class=\"comment\">// 前面提到的MP Configuration Table Header</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mpproc</span> *proc;        <span class=\"comment\">// 前面提到的Processor Entries</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mpioapic</span> *ioapic;    <span class=\"comment\">// 前面提到的I/O APIC Entries</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((conf = <span class=\"built_in\">mpconfig</span>(&amp;mp)) == <span class=\"number\">0</span>)     <span class=\"comment\">// 用上面提到的三种方法寻找MP floating pointer structure，并且判断它的合法性，然后将结构体里面的PHYSICAL ADDRESS POINTER（指向MP Configuration Table Header）作为返回值</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;Expect to run on an SMP&quot;</span>);</span><br><span class=\"line\">  ismp = <span class=\"number\">1</span>;</span><br><span class=\"line\">  lapic = (uint*)conf-&gt;lapicaddr;     <span class=\"comment\">// 将lapic的寄存器地址放到全局变量lapic中</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(p=(uchar*)(conf<span class=\"number\">+1</span>), e=(uchar*)conf+conf-&gt;length; p&lt;e; )&#123;  <span class=\"comment\">// 依据MP Configuration Table Header遍历每一个Table Entry。</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(*p)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPPROC:                      <span class=\"comment\">// Processor Entries</span></span><br><span class=\"line\">      proc = (<span class=\"keyword\">struct</span> mpproc*)p;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(ncpu &lt; NCPU) &#123;</span><br><span class=\"line\">        cpus[ncpu].apicid = proc-&gt;apicid;  <span class=\"comment\">// apicid may differ from ncpu // 保存cpu的lapic的id</span></span><br><span class=\"line\">        ncpu++;                       <span class=\"comment\">// 找到一个CPU</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      p += <span class=\"built_in\">sizeof</span>(<span class=\"keyword\">struct</span> mpproc);</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPIOAPIC:                    <span class=\"comment\">// I/O APIC Entries</span></span><br><span class=\"line\">      ioapic = (<span class=\"keyword\">struct</span> mpioapic*)p;</span><br><span class=\"line\">      ioapicid = ioapic-&gt;apicno;      <span class=\"comment\">// 将ioapicid存到全局变量，将来初始化的时候会用</span></span><br><span class=\"line\">      p += <span class=\"built_in\">sizeof</span>(<span class=\"keyword\">struct</span> mpioapic);</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPBUS:                       <span class=\"comment\">// 其他的不关注，加上他们的大小去找下一个Table Entry。</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPIOINTR:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPLINTR:</span><br><span class=\"line\">      p += <span class=\"number\">8</span>;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      ismp = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!ismp)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;Didn&#x27;t find a suitable machine&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(mp-&gt;imcrp)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果之前是PIC Mode，就切换到APIC模式 </span></span><br><span class=\"line\">    <span class=\"comment\">// interrupt mode configuration register --&gt; IMCR</span></span><br><span class=\"line\">    <span class=\"comment\">// Bochs doesn&#x27;t support IMCR, so this doesn&#x27;t run on Bochs.</span></span><br><span class=\"line\">    <span class=\"comment\">// But it would on real hardware.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(<span class=\"number\">0x22</span>, <span class=\"number\">0x70</span>);   <span class=\"comment\">// Select IMCR</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(<span class=\"number\">0x23</span>, <span class=\"built_in\">inb</span>(<span class=\"number\">0x23</span>) | <span class=\"number\">1</span>);  <span class=\"comment\">// Mask external interrupts.  // 进入APIC模式</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mp-&gt;imcrp字段的解释如下：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/imcrp.png\"></p>\n<p>详细信息可以了解一下：<a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\">多处理器规范</a></p>\n<h3 id=\"lapicinit：BSP初始化自己cpu的lapic\"><a href=\"#lapicinit：BSP初始化自己cpu的lapic\" class=\"headerlink\" title=\"lapicinit：BSP初始化自己cpu的lapic\"></a>lapicinit：BSP初始化自己cpu的lapic</h3><p>这部分和硬件强相关，我也了解不是特别多，尽可能的讲清楚吧。硬件相关的初始化深入下去也是一个无底洞。如果读者感兴趣的话，可以去查intel 64 and IA-32 卷3开发手册。 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">lapicinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!lapic)    <span class=\"comment\">// lapic就是上面mpinit函数在MP Configuration Table Header中得到的lapic寄存器的物理映射地址，所以说初始化的顺序非常严格！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Enable local APIC; set spurious interrupt vector.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));      <span class=\"comment\">// 开启此cpu的APIC</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 配置时钟，属于lapic的本地中断</span></span><br><span class=\"line\">  <span class=\"comment\">// The timer repeatedly counts down at bus frequency</span></span><br><span class=\"line\">  <span class=\"comment\">// from lapic[TICR] and then issues an interrupt.</span></span><br><span class=\"line\">  <span class=\"comment\">// If xv6 cared more about precise timekeeping,</span></span><br><span class=\"line\">  <span class=\"comment\">// TICR would be calibrated using an external time source.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TDCR, X1);                               <span class=\"comment\">// 分频系数为X1</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER)); <span class=\"comment\">// 以PERIODIC为周期，映射到0x20中断</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TICR, <span class=\"number\">10000000</span>);                         <span class=\"comment\">// 时钟频率</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Disable logical interrupt lines.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(LINT0, MASKED);                          <span class=\"comment\">// 屏蔽LINT0（lapic本地中断</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(LINT1, MASKED);                          <span class=\"comment\">// 屏蔽LINT1（lapic本地中断</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Disable performance counter overflow interrupts</span></span><br><span class=\"line\">  <span class=\"comment\">// on machines that provide that interrupt entry.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(((lapic[VER]&gt;&gt;<span class=\"number\">16</span>) &amp; <span class=\"number\">0xFF</span>) &gt;= <span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"built_in\">lapicw</span>(PCINT, MASKED);                        <span class=\"comment\">// 屏蔽PCINT（好像是废话？</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Map error interrupt to IRQ_ERROR.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ERROR, T_IRQ0 + IRQ_ERROR);            <span class=\"comment\">// 0x20 + 0x13（ERROR）</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Clear error status register (requires back-to-back writes).</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ESR, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ESR, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Ack any outstanding interrupts.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(EOI, <span class=\"number\">0</span>);                               <span class=\"comment\">// 向ioapic发送一个EOI，以免中断丢失</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Send an Init Level De-Assert to synchronise arbitration ID&#x27;s.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ICRHI, <span class=\"number\">0</span>);                             <span class=\"comment\">// ？？？// 这里应该是向其他apic广播一条“报文”，通知“我”启动了</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ICRLO, BCAST | INIT | LEVEL);          <span class=\"comment\">// 广播的形式 &amp; 传送模式为INIT &amp; 水平触发</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(lapic[ICRLO] &amp; DELIVS)                  <span class=\"comment\">// 中断的传输状态：是否已经发送？</span></span><br><span class=\"line\">    ;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Enable interrupts on the APIC (but not on the processor).</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TPR, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>以上代码就是初始化BSP的lapic，在其他AP启动后，都要执行一遍这段代码。</strong></p>\n<h3 id=\"ioapicinit：初始化ioapic\"><a href=\"#ioapicinit：初始化ioapic\" class=\"headerlink\" title=\"ioapicinit：初始化ioapic\"></a>ioapicinit：初始化ioapic</h3><p>ioapic的作用和单核架构下master pic很像，但是对于ioapic的初始化步骤很简单，不需要发送一系列的控制字。对于ioapic的初始化就是简单的配置一下重定向表项 RTE(Redirection Table Entry)，给RTE的每一项一个初值，设置它的中断向量号（起始T_IRQ0，T_IRQ0 &#x3D;&#x3D; 0x20），并且默认是中断屏蔽的。后续需要什么中断再对相应的Entry做配置即可，比如consoleinit为了使用键盘调用了ioapicenable去配置对应的Entry打开中断等。关于重定向表项 RTE(Redirection Table Entry)的解释，读者可以看一下这篇文章，讲的非常详细：<a href=\"https://blog.csdn.net/weixin_46645613/article/details/119207945\">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">ioapicinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i, id, maxintr;</span><br><span class=\"line\"></span><br><span class=\"line\">  ioapic = (<span class=\"keyword\">volatile</span> <span class=\"keyword\">struct</span> ioapic*)IOAPIC;           <span class=\"comment\">// 默认地址：0xFEC00000   // Default physical address of IO APIC</span></span><br><span class=\"line\">  maxintr = (<span class=\"built_in\">ioapicread</span>(REG_VER) &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xFF</span>;       <span class=\"comment\">// ioapic支持的最大中断号</span></span><br><span class=\"line\">  id = <span class=\"built_in\">ioapicread</span>(REG_ID) &gt;&gt; <span class=\"number\">24</span>;                      <span class=\"comment\">// 从寄存器读到的ioapic的ID</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(id != ioapicid)                                  <span class=\"comment\">// 必须一致</span></span><br><span class=\"line\">    <span class=\"built_in\">cprintf</span>(<span class=\"string\">&quot;ioapicinit: id isn&#x27;t equal to ioapicid; not a MP\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Mark all interrupts edge-triggered, active high, disabled,</span></span><br><span class=\"line\">  <span class=\"comment\">// and not routed to any CPUs.</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt;= maxintr; i++)&#123;    <span class=\"comment\">// 初始化重定向表项 RTE(Redirection Table Entry)，这里和单核架构下主从PIC一样，先将所有的中断屏蔽掉，在后面初始化的时候再按需使能。</span></span><br><span class=\"line\">    <span class=\"built_in\">ioapicwrite</span>(REG_TABLE<span class=\"number\">+2</span>*i, INT_DISABLED | (T_IRQ0 + i));</span><br><span class=\"line\">    <span class=\"built_in\">ioapicwrite</span>(REG_TABLE<span class=\"number\">+2</span>*i<span class=\"number\">+1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"tvinit：初始化中断向量表\"><a href=\"#tvinit：初始化中断向量表\" class=\"headerlink\" title=\"tvinit：初始化中断向量表\"></a>tvinit：初始化中断向量表</h3><p>这里自顶向下介绍XV6的中断向量表是如何构造的。</p>\n<p>涉及到的变量如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Interrupt descriptor table (shared by all CPUs).</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">gatedesc</span> idt[<span class=\"number\">256</span>];   <span class=\"comment\">// 中断描述符表</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> uint vectors[];  <span class=\"comment\">// vectors的定义文件是：由vectors.pl生成的汇编代码文件。</span></span><br></pre></td></tr></table></figure>\n\n<p>首先是tvinit函数，它是最顶层负责构造中断向量表的函数，SETGATE宏在上面已经贴过它的实现，这里简单介绍一个各个参数的作用。</p>\n<p>SETGATE(gate, istrap, sel, off, d) ：</p>\n<ul>\n<li><p>参数1：对应idt[i]，表示每一项entry。</p>\n</li>\n<li><p>参数2：标记是中断门还是陷阱门。</p>\n</li>\n<li><p>参数3：段选择子。</p>\n</li>\n<li><p>参数4：中断处理函数地址。</p>\n</li>\n<li><p>参数5：中断描述符被哪个特权级使用。</p>\n</li>\n</ul>\n<p>结合代码来看：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">tvinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i;</span><br><span class=\"line\">  <span class=\"comment\">// 构造中断描述符表</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">256</span>; i++)</span><br><span class=\"line\">    <span class=\"built_in\">SETGATE</span>(idt[i], <span class=\"number\">0</span>, SEG_KCODE&lt;&lt;<span class=\"number\">3</span>, vectors[i], <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化系统调用中断描述符，类型是陷阱门（发生中断不会关中断），特权级是DPL_USER。</span></span><br><span class=\"line\">  <span class=\"built_in\">SETGATE</span>(idt[T_SYSCALL], <span class=\"number\">1</span>, SEG_KCODE&lt;&lt;<span class=\"number\">3</span>, vectors[T_SYSCALL], DPL_USER);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">initlock</span>(&amp;tickslock, <span class=\"string\">&quot;time&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是vectors.pl文件生成汇编代码的过程，pl我之前也没有了解过，不过从它的代码可以看出，有点像字符串拼接的处理语言，简化了重复性代码的编写，代码如下：</p>\n<figure class=\"highlight pl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/perl -w</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Generate vectors.S, the trap/interrupt entry points.</span></span><br><span class=\"line\"><span class=\"comment\"># There has to be one entry point per interrupt number</span></span><br><span class=\"line\"><span class=\"comment\"># since otherwise there&#x27;s no way for trap() to discover</span></span><br><span class=\"line\"><span class=\"comment\"># the interrupt number.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;# generated by vectors.pl - do not edit\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;# handlers\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;.globl alltraps\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">my</span> <span class=\"variable\">$i</span> = <span class=\"number\">0</span>; <span class=\"variable\">$i</span> &lt; <span class=\"number\">256</span>; <span class=\"variable\">$i</span>++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;.globl vector<span class=\"variable\">$i</span>\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;vector<span class=\"variable\">$i</span>:\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(<span class=\"variable\">$i</span> == <span class=\"number\">8</span> || (<span class=\"variable\">$i</span> &gt;= <span class=\"number\">10</span> &amp;&amp; <span class=\"variable\">$i</span> &lt;= <span class=\"number\">14</span>) || <span class=\"variable\">$i</span> == <span class=\"number\">17</span>))&#123;</span><br><span class=\"line\">        <span class=\"comment\"># 这些中断cpu自动压入errcode参数，</span></span><br><span class=\"line\">        <span class=\"comment\"># 为保证中断栈帧的统一，所以我们在</span></span><br><span class=\"line\">        <span class=\"comment\"># 这些特殊中断手动压入0值，这样就能</span></span><br><span class=\"line\">        <span class=\"comment\"># 统一使用trapret来恢复上下文。</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">&quot;  pushl \\$0\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;  pushl \\$<span class=\"variable\">$i</span>\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;  jmp alltraps\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;\\n# vector table\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;.data\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;.globl vectors\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;vectors:\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">my</span> <span class=\"variable\">$i</span> = <span class=\"number\">0</span>; <span class=\"variable\">$i</span> &lt; <span class=\"number\">256</span>; <span class=\"variable\">$i</span>++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;  .long vector<span class=\"variable\">$i</span>\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从pl代码上我们可以看到，就是利用for循环构造vectors数组，该数组专门存放中断处理函数。我们先来分析一下它如何构造vectors的，首先最上面有一个for循环，for循环中使用了一个if判断，因为有些中断cpu不会自动压入错误码，所以我们需要<strong>手动压入一个占位值</strong>，方便trapret的处理。在for循环下面最后压入了一个jmp指令，所以pl生成的汇编并不是中断处理函数最终代码，pl生成的中断处理函数会跳到alltraps，alltraps代码我们下面再进行分析。pl在最后生成的汇编代码定义了一个vectors数组，数组里面元素就是上面定义的256个vectori（i&#x3D;1、2、…）。</p>\n<p>最后就是trapasm.S文件对alltraps的实现，常规的进行上下文保护：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;mmu.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">  # vectors.S sends all traps here.</span><br><span class=\"line\">.globl alltraps</span><br><span class=\"line\">alltraps:          # 保存上下文</span><br><span class=\"line\">  # Build trap frame.</span><br><span class=\"line\">  pushl %ds</span><br><span class=\"line\">  pushl %es</span><br><span class=\"line\">  pushl %fs</span><br><span class=\"line\">  pushl %gs</span><br><span class=\"line\">  pushal</span><br><span class=\"line\">  </span><br><span class=\"line\">  # Set up data segments.</span><br><span class=\"line\">  movw $(SEG_KDATA&lt;&lt;3), %ax</span><br><span class=\"line\">  movw %ax, %ds</span><br><span class=\"line\">  movw %ax, %es</span><br><span class=\"line\"></span><br><span class=\"line\">  # Call trap(tf), where tf=%esp</span><br><span class=\"line\">  pushl %esp</span><br><span class=\"line\">  call trap       # 进入trap函数</span><br><span class=\"line\">  addl $4, %esp</span><br><span class=\"line\"></span><br><span class=\"line\">  # Return falls through to trapret...</span><br><span class=\"line\">.globl trapret</span><br><span class=\"line\">trapret:          # 恢复上下文</span><br><span class=\"line\">  popal</span><br><span class=\"line\">  popl %gs</span><br><span class=\"line\">  popl %fs</span><br><span class=\"line\">  popl %es</span><br><span class=\"line\">  popl %ds</span><br><span class=\"line\">  addl $0x8, %esp  # trapno and errcode</span><br><span class=\"line\">  iret</span><br></pre></td></tr></table></figure>\n\n<p>tvinit、pl、alltraps三者之间的关系总览图如下：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/trap__structure.png\"></p>\n<p>关于中断帧，这里要注意，涉及特权级转换的中断帧和不涉及特权级转换的中断帧有些许不一样。如下：</p>\n<p>用户态触发中断（陷阱门或中断门）过程如下：</p>\n<ol start=\"0\">\n<li><p>用户查询TSS（任务状态段）段，找到用户进程在内核态的栈段和栈顶指针（ss0、esp0）。</p>\n</li>\n<li><p><strong>cpu将ss、esp压入（内核）栈中。</strong>（硬件</p>\n</li>\n<li><p>cpu将eflags、cs、eip压入栈中。<strong>中断门还要关中断</strong>，陷阱门不用。（硬件</p>\n</li>\n<li><p>执行用户中断处理函数<strong>alltraps</strong>的<strong>上下文保护</strong>的代码。（软件</p>\n</li>\n<li><p>调用trap函数，处理各种中断。</p>\n</li>\n<li><p>执行用户中断处理函数<strong>trapret</strong>的<strong>上下文恢复</strong>的代码。（软件</p>\n</li>\n<li><p>调用iret，cpu恢复eflags、cs、eip。（硬件</p>\n</li>\n<li><p>cpu恢复ss、esp。（硬件</p>\n</li>\n</ol>\n<p>而内核线程发生中断（<strong>注意，内核态不会发生系统调用，这不应该也不合理</strong>），过程如下：</p>\n<ol>\n<li><p>cpu将eflags、cs、eip压入栈中。<strong>中断门还要关中断</strong>，陷阱门不用。（硬件</p>\n</li>\n<li><p>执行用户中断处理函数<strong>alltraps</strong>的<strong>上下文保护</strong>的代码。（软件</p>\n</li>\n<li><p>调用trap函数，处理各种中断。</p>\n</li>\n<li><p>执行用户中断处理函数<strong>trapret</strong>的<strong>上下文恢复</strong>的代码。（软件</p>\n</li>\n<li><p>调用iret，cpu恢复eflags、cs、eip。（硬件</p>\n</li>\n</ol>\n<p>XV6中定义的栈帧结构体如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PAGEBREAK: 36</span></span><br><span class=\"line\"><span class=\"comment\">// Layout of the trap frame built on the stack by the</span></span><br><span class=\"line\"><span class=\"comment\">// hardware and by trapasm.S, and passed to trap().</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">trapframe</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// registers as pushed by pusha</span></span><br><span class=\"line\">  uint edi;</span><br><span class=\"line\">  uint esi;</span><br><span class=\"line\">  uint ebp;</span><br><span class=\"line\">  uint oesp;      <span class=\"comment\">// useless &amp; ignored</span></span><br><span class=\"line\">  uint ebx;</span><br><span class=\"line\">  uint edx;</span><br><span class=\"line\">  uint ecx;</span><br><span class=\"line\">  uint eax;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// rest of trap frame</span></span><br><span class=\"line\">  ushort gs;</span><br><span class=\"line\">  ushort padding1;</span><br><span class=\"line\">  ushort fs;</span><br><span class=\"line\">  ushort padding2;</span><br><span class=\"line\">  ushort es;</span><br><span class=\"line\">  ushort padding3;</span><br><span class=\"line\">  ushort ds;</span><br><span class=\"line\">  ushort padding4;</span><br><span class=\"line\">  uint trapno;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// below here defined by x86 hardware</span></span><br><span class=\"line\">  uint err;</span><br><span class=\"line\">  uint eip;</span><br><span class=\"line\">  ushort cs;</span><br><span class=\"line\">  ushort padding5;</span><br><span class=\"line\">  uint eflags;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// below here only when crossing rings, such as from user to kernel</span></span><br><span class=\"line\">  uint esp;</span><br><span class=\"line\">  ushort ss;</span><br><span class=\"line\">  ushort padding6;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>中断帧如下图：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/trap_frame.png\"></p>\n<p>图片引用自：<a href=\"https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\">https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf</a></p>\n<h3 id=\"startothers：激活其他AP处理器\"><a href=\"#startothers：激活其他AP处理器\" class=\"headerlink\" title=\"startothers：激活其他AP处理器\"></a>startothers：激活其他AP处理器</h3><p>到这里终于要开始启动其他AP核了，AP核的启动也是一种固定套路，在<a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\">多处理器规范</a>中这种套路称为universal algorithm。XV6中这个算法实现在lapicstartap函数中。</p>\n<p>流程如下：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/universal_algorithm.png\"></p>\n<p>XV6代码启动其他AP处理器的核心流程如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Start the non-boot (AP) processors.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">startothers</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">extern</span> uchar _binary_entryother_start[], _binary_entryother_size[];</span><br><span class=\"line\">  uchar *code;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> *c;</span><br><span class=\"line\">  <span class=\"type\">char</span> *stack;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Write entry code to unused memory at 0x7000.</span></span><br><span class=\"line\">  <span class=\"comment\">// The linker has placed the image of entryother.S in</span></span><br><span class=\"line\">  <span class=\"comment\">// _binary_entryother_start.</span></span><br><span class=\"line\">  <span class=\"comment\">// AP核的entryother代码的入口点，entryother 就是 boot + entry的结合体</span></span><br><span class=\"line\">  code = <span class=\"built_in\">P2V</span>(<span class=\"number\">0x7000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 这里将entryother的代码移到物理地址0x7000处</span></span><br><span class=\"line\">  <span class=\"built_in\">memmove</span>(code, _binary_entryother_start, (uint)_binary_entryother_size);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// BSP for循环向每个AP发送中断。</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(c = cpus; c &lt; cpus+ncpu; c++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c == <span class=\"built_in\">mycpu</span>())  <span class=\"comment\">// We&#x27;ve started already.</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Tell entryother.S what stack to use, where to enter, and what</span></span><br><span class=\"line\">    <span class=\"comment\">// pgdir to use. We cannot use kpgdir yet, because the AP processor</span></span><br><span class=\"line\">    <span class=\"comment\">// is running in low  memory, so we use entrypgdir for the APs too.</span></span><br><span class=\"line\">    stack = <span class=\"built_in\">kalloc</span>();   <span class=\"comment\">// 为每个AP核分配一个执行scheduler函数的内核栈</span></span><br><span class=\"line\">    *(<span class=\"type\">void</span>**)(code<span class=\"number\">-4</span>) = stack + KSTACKSIZE;</span><br><span class=\"line\">    *(<span class=\"built_in\">void</span>(**)(<span class=\"type\">void</span>))(code<span class=\"number\">-8</span>) = mpenter;  <span class=\"comment\">// 指定AP特有main（mpenter）函数入口点。</span></span><br><span class=\"line\">    <span class=\"comment\">// 同BSP刚启动一样，使用使用4M big page页表。</span></span><br><span class=\"line\">    *(<span class=\"type\">int</span>**)(code<span class=\"number\">-12</span>) = (<span class=\"type\">void</span> *) <span class=\"built_in\">V2P</span>(entrypgdir);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// lapicstartap就是实现了universal algorithm，因为我也不太懂，这里就不贴了。</span></span><br><span class=\"line\">    <span class=\"built_in\">lapicstartap</span>(c-&gt;apicid, <span class=\"built_in\">V2P</span>(code));   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待AP初始化完毕</span></span><br><span class=\"line\">    <span class=\"comment\">// wait for cpu to finish mpmain()</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c-&gt;started == <span class=\"number\">0</span>)  </span><br><span class=\"line\">      ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在每个AP boot点和BSP的boot点类似，BSP是在0x7c00启动，AP是在0x7000启动。同样，0x7000也会执行一段汇编代码，这段汇编代码作用就是bootasm.S + entry.S代码的结合体。这里简单总结一下：</p>\n<ol>\n<li><p>加载临时全局描述符，进入保护模式</p>\n</li>\n<li><p>使用entrypgdir开启分页。</p>\n</li>\n<li><p>切换到预分配的内核（scheduler）栈。</p>\n</li>\n<li><p>进入mpenter。</p>\n</li>\n</ol>\n<p>考虑到文章太长，代码就不放了。文件是entryother.S，有兴趣的读者可自行研究。</p>\n<p>mpenter代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Other CPUs jump here from entryother.S.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpenter</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  switchkvm();    <span class=\"comment\">// 切换到粒度更小（4k）的内核页，kpgdir。</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();       <span class=\"comment\">//效果同BSP，在main中BSP也调用了该函数。就是第二次初始化段描述符。（第一次是在entryother.S</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicinit</span>();    <span class=\"comment\">// 效果同BSP</span></span><br><span class=\"line\">  <span class=\"built_in\">mpmain</span>();       <span class=\"comment\">// 进入mpmain</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面那段代码就是：AP会像BSP那样，调用一遍所有的和CPU相关初始化函数，最终进入mpmain。（BSP在main最后也会进入mpmain，前面提到过BSP启动其他后，也成为了一个AP）</p>\n<p>mpmain在加载中断描述符表后，最终就会进入scheduler，CPU正式开启操作系统的任务调度！</p>\n<p>mpmain如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Common CPU setup code.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpmain</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cprintf</span>(<span class=\"string\">&quot;cpu%d: starting %d\\n&quot;</span>, <span class=\"built_in\">cpuid</span>(), <span class=\"built_in\">cpuid</span>());</span><br><span class=\"line\">  <span class=\"built_in\">idtinit</span>();       <span class=\"comment\">// load idt register</span></span><br><span class=\"line\">  <span class=\"built_in\">xchg</span>(&amp;(<span class=\"built_in\">mycpu</span>()-&gt;started), <span class=\"number\">1</span>); <span class=\"comment\">// tell startothers() we&#x27;re up</span></span><br><span class=\"line\">  <span class=\"built_in\">scheduler</span>();     <span class=\"comment\">// start running processes</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进程调度\"><a href=\"#进程调度\" class=\"headerlink\" title=\"进程调度\"></a>进程调度</h2><p>首先了解一下XV6对CPU的定义，注释写的非常详细：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Per-CPU state</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// lapci的id</span></span><br><span class=\"line\">  uchar apicid;                <span class=\"comment\">// Local APIC ID</span></span><br><span class=\"line\">  <span class=\"comment\">// 执行调度器栈指针</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">context</span> *scheduler;   <span class=\"comment\">// swtch() here to enter scheduler</span></span><br><span class=\"line\">  <span class=\"comment\">// 任务状态段、为进程从用户态陷入内核态切栈使用</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">taskstate</span> ts;         <span class=\"comment\">// Used by x86 to find stack for interrupt</span></span><br><span class=\"line\">  <span class=\"comment\">// 全局描述符</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">segdesc</span> gdt[NSEGS];   <span class=\"comment\">// x86 global descriptor table</span></span><br><span class=\"line\">  <span class=\"comment\">// 指示cpu是否启动</span></span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> uint started;       <span class=\"comment\">// Has the CPU started?</span></span><br><span class=\"line\">  <span class=\"comment\">// 关中断的深度</span></span><br><span class=\"line\">  <span class=\"type\">int</span> ncli;                    <span class=\"comment\">// Depth of pushcli nesting.</span></span><br><span class=\"line\">  <span class=\"comment\">// 记录在cpu第一层关中断前，中断关闭情况</span></span><br><span class=\"line\">  <span class=\"type\">int</span> intena;                  <span class=\"comment\">// Were interrupts enabled before pushcli?</span></span><br><span class=\"line\">  <span class=\"comment\">// cpu当前运行的进程PCB</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *proc;           <span class=\"comment\">// The process running on this cpu or null</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> cpus[NCPU]; <span class=\"comment\">// 多个cpu</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> ncpu;              <span class=\"comment\">// cpu的个数</span></span><br></pre></td></tr></table></figure>\n\n<p>下面列出了各个CPU资源的共享情况，可以做一个参考：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">资源</th>\n<th align=\"center\">共享</th>\n<th align=\"center\">不共享</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">中断描述符表</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">lapic（也指外中断，包括定时器等）</td>\n<td align=\"center\"></td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">ioapic</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">cpu的各种寄存器，包括eip、esp、eflag等等</td>\n<td align=\"center\"></td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">全局描述符表（包括任务状态段）</td>\n<td align=\"center\"></td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">kpgdir（内核调度器使用的页表）</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">物理内存</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">任务队列（ptable）</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">调度器的执行栈</td>\n<td align=\"center\"></td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">外设</td>\n<td align=\"center\"></td>\n<td align=\"center\">√</td>\n</tr>\n</tbody></table>\n<p>接下来是XV6的PCB（进程控制块），之前老是在教科书上看到它，当时感觉很难理解，在分析过OS源码后，再回过头去看，就感觉特别通透。XV6的PCB就是一个结构体，里面存放了很多成员，XV6的PCB和进程的内核栈是分开的，PCB结构体是通过一个指针来指向进程的内核栈。相比之下，Onix的PCB和内核栈是连在一起的，内核栈的低地址就是存放的PDB结构体，因为esp是线下增长，所以esp指向高地址处，并且典型的内核栈大小是一页（4K）（于是esp指向页面的4K处）。</p>\n<p>XV6的PCB定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// proc.h</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">procstate</span> &#123; UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Per-process state</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 进程（映射了页框的）虚拟内存大小</span></span><br><span class=\"line\">  uint sz;                     <span class=\"comment\">// Size of process memory (bytes)</span></span><br><span class=\"line\">  <span class=\"comment\">// 进程的页表</span></span><br><span class=\"line\">  <span class=\"type\">pde_t</span>* pgdir;                <span class=\"comment\">// Page table</span></span><br><span class=\"line\">  <span class=\"comment\">// 进程的内核栈</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *kstack;                <span class=\"comment\">// Bottom of kernel stack for this process</span></span><br><span class=\"line\">  <span class=\"comment\">// 进程状态</span></span><br><span class=\"line\">  <span class=\"keyword\">enum</span> <span class=\"title class_\">procstate</span> state;        <span class=\"comment\">// Process state</span></span><br><span class=\"line\">  <span class=\"comment\">// 进程pid</span></span><br><span class=\"line\">  <span class=\"type\">int</span> pid;                     <span class=\"comment\">// Process ID</span></span><br><span class=\"line\">  <span class=\"comment\">// 进程的父进程</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *parent;         <span class=\"comment\">// Parent process</span></span><br><span class=\"line\">  <span class=\"comment\">// 调用系统调用时的栈帧</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">trapframe</span> *tf;        <span class=\"comment\">// Trap frame for current syscall</span></span><br><span class=\"line\">  <span class=\"comment\">// 内核态的上下文</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">context</span> *context;     <span class=\"comment\">// swtch() here to run process</span></span><br><span class=\"line\">  <span class=\"comment\">// 等待条件</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *chan;                  <span class=\"comment\">// If non-zero, sleeping on chan</span></span><br><span class=\"line\">  <span class=\"comment\">// 是否被杀死</span></span><br><span class=\"line\">  <span class=\"type\">int</span> killed;                  <span class=\"comment\">// If non-zero, have been killed</span></span><br><span class=\"line\">  <span class=\"comment\">// 打开的文件</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">file</span> *ofile[NOFILE];  <span class=\"comment\">// Open files</span></span><br><span class=\"line\">  <span class=\"comment\">// 工作目录的inode</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">inode</span> *cwd;           <span class=\"comment\">// Current directory</span></span><br><span class=\"line\">  <span class=\"comment\">// 进程名</span></span><br><span class=\"line\">  <span class=\"type\">char</span> name[<span class=\"number\">16</span>];               <span class=\"comment\">// Process name (debugging)</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// proc.c</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">spinlock</span> lock;       <span class=\"comment\">// 自旋锁</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> proc[NPROC];</span><br><span class=\"line\">&#125; ptable;                     <span class=\"comment\">// 多个cpu之间共享该结构</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *initproc; <span class=\"comment\">// 存放init进程PCB</span></span><br><span class=\"line\"><span class=\"type\">int</span> nextpid = <span class=\"number\">1</span>;              <span class=\"comment\">// 分配唯一pid</span></span><br></pre></td></tr></table></figure>\n\n<p>XV6为进程定义了6种状态：UNUSED（PCB未使用）, EMBRYO（初始化中）, SLEEPING（阻塞休眠）, RUNNABLE（可调度）, RUNNING（运行中）, ZOMBIE（僵尸&#x2F;待回收）。 这里特别说明一下PCB的chan成员，该成员一个进程的等待条件。XV6中一个进程可能会调用sleep、wait系統調用，或者在調用read系統調用时间接调用了sleeplock，这些函数都会使一个进程进入阻塞状态，XV6的阻塞状态统一使用SLEEPING来表示，阻塞就是为了等待某个条件发生，当等待的条件发生时，阻塞的进程就会被唤醒，但是ptable有那么多阻塞的进程，我应该唤醒ptable中的哪些进程呢？此时chan就起到关键作用，在进程进入阻塞之前，会将chan设置为某一个变量的地址，当条件满足XV6就是通过chan来唤醒对应的进程的，当然这个变量的选取是很有讲究的，比如在XV6中因为sleep而休眠的进程，它的chan会被设置成ticks（作用类似jefrris，定时器中断的计数器）的地址。具体细节就不深入讨论，感兴趣的读者可以看看XV6的源码。</p>\n<p>从AP（从）处理器的启动段落我们知道，BSP、AP最终都进入scheduler函数，铺垫了这么久，scheduler函数也是本文的主题，那么先来看看它的代码实现吧：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PAGEBREAK: 42</span></span><br><span class=\"line\"><span class=\"comment\">// Per-CPU process scheduler.</span></span><br><span class=\"line\"><span class=\"comment\">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class=\"line\"><span class=\"comment\">// Scheduler never returns.  It loops, doing:</span></span><br><span class=\"line\"><span class=\"comment\">//  - choose a process to run</span></span><br><span class=\"line\"><span class=\"comment\">//  - swtch to start running that process</span></span><br><span class=\"line\"><span class=\"comment\">//  - eventually that process transfers control</span></span><br><span class=\"line\"><span class=\"comment\">//      via swtch back to the scheduler.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">scheduler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *p;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> *c = <span class=\"built_in\">mycpu</span>();  <span class=\"comment\">// 找到scheduler正运行在哪个cpu上</span></span><br><span class=\"line\">  c-&gt;proc = <span class=\"number\">0</span>;              <span class=\"comment\">// 将cpu结构体的当前运行的进程清零</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Enable interrupts on this processor.</span></span><br><span class=\"line\">    <span class=\"built_in\">sti</span>();                  <span class=\"comment\">// 打开中断、之前中断一直是关闭的！</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里pushcli保存的mycpu()-&gt;intena其实没有意义，在切换后会被外面的sched直接覆盖。</span></span><br><span class=\"line\">    <span class=\"comment\">// Loop over process table looking for process to run.</span></span><br><span class=\"line\">    <span class=\"built_in\">acquire</span>(&amp;ptable.lock); <span class=\"comment\">// 共用ptable，所以需要获取自旋锁，互斥访问。</span></span><br><span class=\"line\">    <span class=\"comment\">// 遍历ptable</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(p-&gt;state != RUNNABLE)  <span class=\"comment\">// 进程状态不可运行</span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      <span class=\"comment\">// else 找到了一个可运行的进程</span></span><br><span class=\"line\">      <span class=\"comment\">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class=\"line\">      <span class=\"comment\">// to release ptable.lock and then reacquire it</span></span><br><span class=\"line\">      <span class=\"comment\">// before jumping back to us.</span></span><br><span class=\"line\">      c-&gt;proc = p;  <span class=\"comment\">// 设置p为cpu当前运行进程</span></span><br><span class=\"line\">      <span class=\"comment\">//  这个函数非常关键，主要做两个三个操作：</span></span><br><span class=\"line\">      <span class=\"comment\">// 1、设置tss，并将其追加到全局描述符</span></span><br><span class=\"line\">      <span class=\"comment\">// 2、设置tss的选择子</span></span><br><span class=\"line\">      <span class=\"comment\">// 3、让cpu使用进程p的页表。</span></span><br><span class=\"line\">      switchuvm(p);</span><br><span class=\"line\">      p-&gt;state = RUNNING; <span class=\"comment\">// 设置p为运行状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">swtch</span>(&amp;(c-&gt;scheduler), p-&gt;context); <span class=\"comment\">// 正式开始切换，等到p放弃cpu才会返回</span></span><br><span class=\"line\">      switchkvm();        <span class=\"comment\">// 切换回内核页表kpgdir</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Process is done running for now.</span></span><br><span class=\"line\">      <span class=\"comment\">// It should have changed its p-&gt;state before coming back.</span></span><br><span class=\"line\">      c-&gt;proc = <span class=\"number\">0</span>;        <span class=\"comment\">// 当前运行的进程清零</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">release</span>(&amp;ptable.lock);  <span class=\"comment\">// 释放自旋锁</span></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>XV6的调度算法非常简单，就是简单的round robin算法。主要精华是整个调度的过程，至于它具体的调度算法其实显得并不是特别重要。</p>\n<p>switchuvm函数实现非常关键，它里面会设置tss，并且设置cpu使用进程p的页表。<strong>tss全称是任务状态段，它可以帮助处于用户态的进程回到内核态</strong>，因为一个进程有两个栈，一个是出于用户态使用，另外一个是处于内核态使用，进程从内核态转变成用户态容易。只需要将中断帧弹出恢复上下文即可，但是从用户态回到内核态就难了，因为进入用户态后，进程的用户态空间不会保留进程任何内核态信息，所以，我们需要一个东西来帮助处于用户态的进程在需要陷入内核态时，找到它的内核态的栈，这个东西就是TSS，TSS会记录一个进程的内核栈的栈指针esp和栈段ss，switchuvm函数正是完成了这样的功能。实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Switch TSS and h/w page table to correspond to process p.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">switchuvm</span><span class=\"params\">(<span class=\"keyword\">struct</span> proc *p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;switchuvm: no process&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;kstack == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;switchuvm: no kstack&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;pgdir == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;switchuvm: no pgdir&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">pushcli</span>();</span><br><span class=\"line\">  <span class=\"comment\">// 因为tss也是一个段，所以向cpu的全局描述符中追加tss的描述符</span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;gdt[SEG_TSS] = <span class=\"built_in\">SEG16</span>(STS_T32A, &amp;<span class=\"built_in\">mycpu</span>()-&gt;ts,</span><br><span class=\"line\">                                <span class=\"built_in\">sizeof</span>(<span class=\"built_in\">mycpu</span>()-&gt;ts)<span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;gdt[SEG_TSS].s = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;ts.ss0 = SEG_KDATA &lt;&lt; <span class=\"number\">3</span>;                 <span class=\"comment\">// 内核栈段</span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;ts.esp0 = (uint)p-&gt;kstack + KSTACKSIZE;  <span class=\"comment\">// 内核栈指针</span></span><br><span class=\"line\">  <span class=\"comment\">// setting IOPL=0 in eflags *and* iomb beyond the tss segment limit</span></span><br><span class=\"line\">  <span class=\"comment\">// forbids I/O instructions (e.g., inb and outb) from user space</span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;ts.iomb = (ushort) <span class=\"number\">0xFFFF</span>;</span><br><span class=\"line\">  <span class=\"built_in\">ltr</span>(SEG_TSS &lt;&lt; <span class=\"number\">3</span>);                                <span class=\"comment\">// tss段选择子</span></span><br><span class=\"line\">  <span class=\"comment\">// 切换到p的页表</span></span><br><span class=\"line\">  <span class=\"built_in\">lcr3</span>(<span class=\"built_in\">V2P</span>(p-&gt;pgdir));  <span class=\"comment\">// switch to process&#x27;s address space</span></span><br><span class=\"line\">  <span class=\"built_in\">popcli</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于任务状态段的详情描述可以参考：<a href=\"https://github.com/StevenBaby/onix/blob/dev/docs/07%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/062%20%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E7%AE%80%E4%BB%8B.md\">https://github.com/StevenBaby/onix/blob/dev/docs/07%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/062%20%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E7%AE%80%E4%BB%8B.md</a></p>\n<p>swtch函数由汇编实现，是进程切换的核心函数，实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Context switch</span><br><span class=\"line\">#</span><br><span class=\"line\">#   void swtch(struct context **old, struct context *new);</span><br><span class=\"line\"># </span><br><span class=\"line\"># Save the current registers on the stack, creating</span><br><span class=\"line\"># a struct context, and save its address in *old.</span><br><span class=\"line\"># Switch stacks to new and pop previously-saved registers.</span><br><span class=\"line\"></span><br><span class=\"line\">.globl swtch</span><br><span class=\"line\">swtch:                # 这里有个pushl eip，cpu帮我们自动执行了</span><br><span class=\"line\">  movl 4(%esp), %eax  # 第一个参数，struct context**</span><br><span class=\"line\">  movl 8(%esp), %edx  # 第二个参数  struct context*</span><br><span class=\"line\"></span><br><span class=\"line\">  # Save old callee-saved registers</span><br><span class=\"line\">  pushl %ebp</span><br><span class=\"line\">  pushl %ebx</span><br><span class=\"line\">  pushl %esi</span><br><span class=\"line\">  pushl %edi</span><br><span class=\"line\"></span><br><span class=\"line\">  # Switch stacks</span><br><span class=\"line\">  movl %esp, (%eax) # 加括号和在指针前面加*一个道理，这里保存当前内核栈指针到第一个参数上</span><br><span class=\"line\">  movl %edx, %esp   # 将esp切换到第二个参数指向的内核栈上</span><br><span class=\"line\"></span><br><span class=\"line\">  # Load new callee-saved registers</span><br><span class=\"line\">  popl %edi</span><br><span class=\"line\">  popl %esi</span><br><span class=\"line\">  popl %ebx</span><br><span class=\"line\">  popl %ebp</span><br><span class=\"line\">  ret</span><br></pre></td></tr></table></figure>\n\n<p>struct context结构体定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">context</span> &#123;</span><br><span class=\"line\">  uint edi;</span><br><span class=\"line\">  uint esi;</span><br><span class=\"line\">  uint ebx;</span><br><span class=\"line\">  uint ebp;</span><br><span class=\"line\">  uint eip;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一个进程在（因为时间片用完）需要放弃cpu执行权限，如何回到scheduler呢？答案就是使用sched函数，本文我们以普遍的事件来分析————因为时间片用完而放弃的cpu。处于<strong>用户态的进程因为时间片用完会发生定时器中断</strong>，定时器中断又会引发从用户态到内核态的切栈、保存上下文、执行trap函数，trap函数中最后调用了yield，yield最终会调用sched，trap函数伪代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">spinlock</span> tickslock;</span><br><span class=\"line\">uint ticks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//PAGEBREAK: 41</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">trap</span><span class=\"params\">(<span class=\"keyword\">struct</span> trapframe *tf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(tf-&gt;trapno == T_SYSCALL)&#123;  <span class=\"comment\">// 是系统调用</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(tf-&gt;trapno)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">cpuid</span>() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">acquire</span>(&amp;tickslock);</span><br><span class=\"line\">      ticks++;            <span class=\"comment\">// 每次定时器中断都自增1</span></span><br><span class=\"line\">      <span class=\"built_in\">wakeup</span>(&amp;ticks);     <span class=\"comment\">// 唤醒sleeping进程，检查休眠是否到期</span></span><br><span class=\"line\">      <span class=\"built_in\">release</span>(&amp;tickslock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">lapiceoi</span>();           <span class=\"comment\">// 通知lapic中断处理完毕</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Force process to give up CPU on clock tick.</span></span><br><span class=\"line\">  <span class=\"comment\">// If interrupts were on while locks held, would need to check nlock.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">myproc</span>() &amp;&amp; <span class=\"built_in\">myproc</span>()-&gt;state == RUNNING &amp;&amp;</span><br><span class=\"line\">     tf-&gt;trapno == T_IRQ0+IRQ_TIMER)</span><br><span class=\"line\">    <span class=\"built_in\">yield</span>();    <span class=\"comment\">// 时间片用完，cpu让给下一个进程</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>yield函数实现就是封装了一下sched函数，在调用sched之前，将进程的状态设置成了RUNNABLE状态：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Enter scheduler.  Must hold only ptable.lock</span></span><br><span class=\"line\"><span class=\"comment\">// and have changed proc-&gt;state. Saves and restores</span></span><br><span class=\"line\"><span class=\"comment\">// intena because intena is a property of this</span></span><br><span class=\"line\"><span class=\"comment\">// kernel thread, not this CPU. It should</span></span><br><span class=\"line\"><span class=\"comment\">// be proc-&gt;intena and proc-&gt;ncli, but that would</span></span><br><span class=\"line\"><span class=\"comment\">// break in the few places where a lock is held but</span></span><br><span class=\"line\"><span class=\"comment\">// there&#x27;s no process.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sched</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> intena;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *p = <span class=\"built_in\">myproc</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"built_in\">holding</span>(&amp;ptable.lock))</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched ptable.lock&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">mycpu</span>()-&gt;ncli != <span class=\"number\">1</span>)        <span class=\"comment\">// 最多一层关中断</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched locks&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;state == RUNNING)       <span class=\"comment\">// 在调用sched前，应该改变进程状态</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched running&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">readeflags</span>()&amp;FL_IF)        <span class=\"comment\">// 中断必须被关闭！</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched interruptible&quot;</span>);</span><br><span class=\"line\">  intena = <span class=\"built_in\">mycpu</span>()-&gt;intena;     <span class=\"comment\">// intena是进程私有的</span></span><br><span class=\"line\">  <span class=\"built_in\">swtch</span>(&amp;p-&gt;context, <span class=\"built_in\">mycpu</span>()-&gt;scheduler); <span class=\"comment\">// 切换到scheduler</span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;intena = intena;     <span class=\"comment\">// 还原intena</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Give up the CPU for one scheduling round.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">yield</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">acquire</span>(&amp;ptable.lock);  <span class=\"comment\">//DOC: yieldlock</span></span><br><span class=\"line\">  <span class=\"built_in\">myproc</span>()-&gt;state = RUNNABLE;</span><br><span class=\"line\">  <span class=\"built_in\">sched</span>();</span><br><span class=\"line\">  <span class=\"built_in\">release</span>(&amp;ptable.lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sched中保存intena状态到进程的内核栈中的做法，好像把intena变量放到PCB中更合适，但是XV6没有这么做。从shced函数注释中了解到，如果把intena变量放到PCB中的话，有些情况下会有问题。具体呢，就不去细究了（我也每深究），本文内容太长了，还是以调度为主。这里主要是想表达一个点：<strong>scheduler函数给ptable.lock加锁时，pushcli保存的intena没有任何意义。因为最终在切换进程时，会被sched中进程的intena给覆盖掉。同样，在进程回到scheduler函数后，scheduler函数给ptable.lock解锁时，popcli还原的intena也没有任何意义，因为无论intena原来是否开中断，外层的for都会开中断！</strong></p>\n<p>最终，一个待调度的进程的内核栈帧就形成了：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/task_stack.drawio.png\"></p>\n<p>一张图片概括yield、scheduler的加锁关系。如下图，进程利用yield进入调度器时会获取ptable的自旋锁（自旋锁内部会关中断，并且将关中断之前的中断状态保存到intena中），在切换到scheduler后（可能）会由scheduler解锁。在从scheduler切换到下一个任务前，（可能）scheduler会获取ptable的自旋锁，在却换到下一个任务后，由任务进行解除ptable的自选锁，注意这里是可能，因为还有可能scheduler的内层循环还没有执行完，以至于内层循环还可以找到下一个待执行的日任务，此时ptable的锁，就是：老进程加锁，新进程解锁：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/yield_scheduler.png\"></p>\n<p>总的来说，XV6进程调度整体流程是：<strong>每个cpu上都运行调度线程，调度线程运行sheduler函数，scheduler不断从ptable取进行任务，然后（swapIn）切换去执行进程任务，当进程任务用完时间片（通过定时器中断）就会放弃cpu的执行权限，（swapOut）切换到内核调度线程继续去调度下一个进程任务。</strong></p>\n<p>如果类比于用户态的协程的：<strong>对称协程和非对称协程之分吗的话，结合非对称协程的特点：协程的切换需要经过调度协程，而由于XV6进程的调度都必须经内核的过调度线程，所以XV6的调度器模型更像一种“非对称进程”。</strong></p>\n<p><strong>作为对比，如果你阅读过Onix的代码，你会发现Onix的调度模型更像是一种”对称进程“，因为Onix的进程切换是两个进程之间直接进行，不存在中间的调度线程。</strong></p>\n<p>这里我可以用一张<strong>类似sylar的协程调度器模型来总结XV6进程调度模型</strong>：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler.drawio.png\"></p>\n<p><strong>其实CPU Pool和线程池非常像，XV6的每个CPU都互斥到ptable中去取进程，然后去消化进程。唯一的区别就是CPU要和很多寄存器、硬件打交道，但是最终整体的框架思想都是一同百通，</strong></p>\n<p>如果你看过sylar的源码，你会深有感触！ <strong>sylar的协程调度器模型和XV6进程的调度模型不能说像，只能是真的一模一样！</strong> sylar是一个C++的基于协程的网络框架。我之前也有写过sylar的博客，这里推荐大家去看看：<a href=\"https://blog.csdn.net/m0_52566365/article/details/135991331%E3%80%82\">https://blog.csdn.net/m0_52566365/article/details/135991331。</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>XV6有很多地方写的很暴力，有很大的优化空间，比如：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">XV6做法</th>\n<th align=\"center\">Onix做法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">内存管理</td>\n<td align=\"center\">不管是物理内存还是内核内存一股脑使用kalloc，用户页表所有的内容都靠kalloc</td>\n<td align=\"center\">get_page（使用256个页管理4G物理页，专门给页表和页框分配内存&#x2F;page） + alloc_kpage（专门给内核分配内核页所有的页目录都采用alloc_kpage&#x2F;page） + kmalloc（使用了内存池专门管理内核中的小快内存&#x2F;byte）</td>\n</tr>\n<tr>\n<td align=\"center\">内核对系统调用参数的获取</td>\n<td align=\"center\">直接访问用户栈空间</td>\n<td align=\"center\">使用ebp、edi、esi、edx、ecx、ebx寄存器获取系统调用参数</td>\n</tr>\n<tr>\n<td align=\"center\">软件定时器</td>\n<td align=\"center\">没有实现软件定时器</td>\n<td align=\"center\">利用链表实现了软件定时器</td>\n</tr>\n<tr>\n<td align=\"center\">内存探测</td>\n<td align=\"center\">未实现内存探测</td>\n<td align=\"center\">loader实现了内存探测</td>\n</tr>\n<tr>\n<td align=\"center\">idle任务</td>\n<td align=\"center\">没实现idle任务</td>\n<td align=\"center\">实现了idle任务</td>\n</tr>\n<tr>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n</tr>\n</tbody></table>\n<p>从上表可以看到Onix每一项都是存在优势的。但是Onix唯一的缺点，也是我读了Onix源码又来读XV6源码的原因：Onix是一个<strong>单核</strong>OS。其实读完XV6了解了多核OS的实现后，也没感到很大的震撼，多核CPU无非就是比单核CPU多了几套eip、esp、eflag等cpu相关的寄存器，cpu访问共享资源的的时候注意加锁就好了。</p>\n<p>最后谈谈XV6调度模型的优化：从<strong>XV6进程调度模型图</strong>我们可以看到，XV6的调度模型可以参考Muduo的One loop per thread 思想（可能说Muduo的One loop per thread思想参考了现代Linux对CPU的调度模型更合适？），因为XV6进程调度模型非常暴力，所有cpu共享有一个任务池（ptable），锁的竞争非常激烈。我们可以考虑让每个cpu都拥有一个自己独立的ptable（当然里面还是有自旋锁），由一个cpu负责负载均衡，将任务均匀的分发给各个cpu，需要修改cpux内部数据结构时，其他cpu只需向cpux的回调队列中添加操作函数即可，具体的操作还是由cpux自己完成。<strong>也即One loop per CPU</strong>。如下图：</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler_pluse.drawio.png\"></p>\n<p>终于4干完了这篇文章，字数预计上万了，第一次写这么长的文章，也是真的用心了。创作不易，赏个赞把！</p>\n<p><strong>参考资料</strong></p>\n<p>多处理器规范：<a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\">https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf</a></p>\n<p>XV6的官方中文文档：<a href=\"https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\">https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf</a></p>\n<p>Onix单核操作系统：<a href=\"https://github.com/StevenBaby/onix/\">https://github.com/StevenBaby/onix/</a></p>\n<p>APIC中断讲解比较好的范文：<a href=\"https://blog.csdn.net/weixin_46645613/article/details/119207945\">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>\n<p>多核处理器启动博客1：<a href=\"https://zhuanlan.zhihu.com/p/394247844\">https://zhuanlan.zhihu.com/p/394247844</a></p>\n<hr>\n<p><strong>本章完结</strong></p>"},{"title":"这才是计科之 Onix & XV6 源码分析（1、XV6-x86的启动）","date":"2024-06-07T04:00:00.000Z","_content":"\n## 前言\n\nOnix是一款相对于XV6来说功能更为健全的单核OS，由于功能更加完善，Onix也更加复杂。代码阅读起来会比较绕。\n\nXV6是一款简单易读的多核操作系统，但其功能相对Onix来说更为简陋，比如Onix对物理内存的管理采用了位图、内核内存和进程相关的内存进行了分开管理，页目录使用单独的内核内存，没有和页表、页框混用等。而XV6显得非常简陋。尽管XV6的实验可以弥补部分缺陷。\n\nOnix操作系统也实现了bootloader，对于将OS加载到内存的操作，Onix是采用汇编进行内核加载，并且在加载内核前，还会进行一个内存探测的操作，所以Onix的bootloader稍微有些复杂。而XV6操作系统的启动操作写的非常简洁，加载内核的操作采用的是C语言的形式，非常利于阅读学习，但是XV6不会进行内存探测。为求方便，本文主要叙述XV6的启动流程。\n\nOnix相关链接：\n\n- [github仓库链接](https://github.com/StevenBaby/onix)\n\n- [B站配套视频链接](https://www.bilibili.com/video/BV1qM4y127om/)\n\nXV6-x86的github链接：\n\n- [链接](https://github.com/mit-pdos/xv6-public)\n\n<!-- more -->\n\n## Makefile & kernel.ld文件的分析\n\n首先科普一个概念 —— 引导扇区\n\n**引导扇区：是计算机启动过程中 BIOS 读取的第一个磁盘扇区（通常为 512 字节），用于加载操作系统或更复杂的引导程序（如 GRUB）。**\n\nBISO规定引导扇区有如下要求：\n\n1. 引导扇区的代码被加载到内存的0x7c00位置执行\n2. 引导扇区有且仅有512字节。\n3. 引导扇区的魔数在最后两个字节的位置，值0x55aa。\n\n在叙述os启动前，必须要了解其Makefile是怎么写的。同时，在了解bootmain从镜像中加载os的代码到内存中前，因为os是elf格式，所以我们需要了解os的link脚本是怎么布局的。以便我们能更好掌握os的内存布局。\n\n### Makefile\n\n这里贴出makefile比较关键的代码：\n\n```makefile\n# 利用dd命令制作OS镜像，依赖bootblock和kernel，\n# 首先划分了10000个扇区\n# 然后将bootblock写到了第0号扇区\n# 最后从1号扇区开始，填入OS的代码文件。\nxv6.img: bootblock kernel\n\tdd if=/dev/zero of=xv6.img count=10000\n\tdd if=bootblock of=xv6.img conv=notrunc\n\tdd if=kernel of=xv6.img seek=1 conv=notrunc\n\n# 单独产生os的bootloader模块，并且该模块是使用$(OBJCOPY)产生，\n# 所以没有elf文件头信息，只是单纯的二进制可执行文件。并且$(LD)规定\n# 代码的入口点是start、并且从地址0x7C00（物理地址）开始，最终的文件名是bootblock\n# 最后一步，调用pl脚本对引导扇区进行签名，在512字节引导扇区最后两字节写入0x55aa\nbootblock: bootasm.S bootmain.c\n\t$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c\n\t$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S\n\t$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o\n\t$(OBJDUMP) -S bootblock.o > bootblock.asm\n\t$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock\n\t./sign.pl bootblock\n\n# 产生AP cpu的boot代码\n# 指定程序的加载地址是0x7000（物理地址）\n# 可执行代码的格式和bootblock相同，纯粹的二进制程序，没有elf的头部信息\n# 但最终输出的entryother会和kernel合并\nentryother: entryother.S\n\t$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S\n\t$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o\n\t$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother\n\t$(OBJDUMP) -S bootblockother.o > entryother.asm\n\n# 产生第一个进程，init进程的boot代码\n# 同样以$(OBJCOPY)提取纯粹的可执行代码，没有elf头部信息，输出文件名为initcode\n# 指定程序的加载地址是0（虚拟地址）\ninitcode: initcode.S\n\t$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S\n\t$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o\n\t$(OBJCOPY) -S -O binary initcode.out initcode\n\t$(OBJDUMP) -S initcode.o > initcode.asm\n\n# 产生内核的elf可执行文件\nkernel: $(OBJS) entry.o entryother initcode kernel.ld\n\t$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother\n\t$(OBJDUMP) -S kernel > kernel.asm\n\t$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym\n\n```\n\n这里编译器、链接器的选项具体作用读者可以自行百度，这里只阐述比较关键的部分。\n\n首先是利用dd命令制作xv6.img镜像，从代码中可以很清楚的看到，bootblock填到了第0号扇区、kernel填到了1号以及之后的扇区。bootblock作用就是使cpu从实时模式转换为保护模式，然后将kernel从磁盘上加载到内存。这里要注意一个特殊的数字0x7C00，它出现在生成bootblock二进制文件的\\$(LD)阶段，这里暗示了bootblock代码在加载进内存时应该被放在0x7C00的位置。事实也是如此，**在BIOS完成硬件初始化后，就会将第0号扇区（一个扇区一般就是512字节）的512字节代码加载到内存的0x7C00的位置，然后BIOS就会让eip指向0x7C00的位置，去执行bootasm.S里面的汇编代码。**\n\n这里有个关键点：在使用\\$(LD)命令生成bootblock.o时，命令参数部分bootasm.o放在bootmain.o前面，会导致链接时，bootasm.o代码就会靠前，这样在eip执行0x7C00位置的代码时，一定是从start开始。\n\nbootblock是由\\$(OBJCOPY)生成，\\$(OBJCOPY)的作用就是去除elf文件中的各种头部，因为BIOS只负责从第0号扇区加载bootblock，不会解析elf文件，所以，\\$(OBJCOPY)去提取纯粹的二进制是非常有必要的！\n\nbootblock具体细节下面会详细探讨\n\n### kernel.ld\n\n这里贴出kernel.ld比较关键的代码：\n\n```link\nOUTPUT_FORMAT(\"elf32-i386\", \"elf32-i386\", \"elf32-i386\")\nOUTPUT_ARCH(i386)\nENTRY(_start)\n\nSECTIONS\n{\n\t/* Link the kernel at this address: \".\" means the current address */\n        /* Must be equal to KERNLINK */\n\t. = 0x80100000; // 定义代码起始的虚拟地址\n\n\t.text : AT(0x100000) {  // 定义了起始加载地址\n\t\t*(.text .stub .text.* .gnu.linkonce.t.*)\n\t}\n\n  /*\n    省略...\n  */\n}\n```\n\n从kernel的链接脚本我们可以看到，kernel的起始虚拟内存地址是0x8010 0000，内核实际加载的物理地址是x100000，由AT定义。这里我反复标注了 虚拟地址 / 物理地址 ，这两者一定要分清！\n\n## 从实时模式到保护模式\n\n本段代码实现位于xv6的bootasm.S文件。具体细节如下，xv6使用的AT&T的汇编，还是比较好懂的，读者有疑问的话，可以百度去搜相关指令的作用。英文注释已经非常详细，我就直接引用了。\n\n```arm\n#include \"asm.h\"\n#include \"memlayout.h\"\n#include \"mmu.h\"\n\n# Start the first CPU: switch to 32-bit protected mode, jump into C.\n# The BIOS loads this code from the first sector of the hard disk into\n# memory at physical address 0x7c00 and starts executing in real mode\n# with %cs=0 %ip=7c00.\n\n.code16                       # Assemble for 16-bit mode\n.globl start\nstart:\n  cli                         # BIOS enabled interrupts; disable\n\n  # Zero data segment registers DS, ES, and SS.\n  xorw    %ax,%ax             # Set %ax to zero\n  movw    %ax,%ds             # -> Data Segment\n  movw    %ax,%es             # -> Extra Segment\n  movw    %ax,%ss             # -> Stack Segment\n\n  # 硬件相关，主线是OS的启动，该部分不深究也没影响，其实就是一个固定步骤。\n  # Physical address line A20 is tied to zero so that the first PCs \n  # with 2 MB would run software that assumed 1 MB.  Undo that.\nseta20.1:\n  inb     $0x64,%al               # Wait for not busy\n  testb   $0x2,%al\n  jnz     seta20.1\n\n  movb    $0xd1,%al               # 0xd1 -> port 0x64\n  outb    %al,$0x64\n\nseta20.2:\n  inb     $0x64,%al               # Wait for not busy\n  testb   $0x2,%al\n  jnz     seta20.2\n\n  movb    $0xdf,%al               # 0xdf -> port 0x60\n  outb    %al,$0x60\n\n  # Switch from real to protected mode.  Use a bootstrap GDT that makes\n  # virtual addresses map directly to physical addresses so that the\n  # effective memory map doesn't change during the transition.\n  lgdt    gdtdesc\n  movl    %cr0, %eax\n  orl     $CR0_PE, %eax\n  movl    %eax, %cr0\n ########################### 以下正式进入32位保护模式\n//PAGEBREAK!\n  # Complete the transition to 32-bit protected mode by using a long jmp\n  # to reload %cs and %eip.  The segment descriptors are set up with no\n  # translation, so that the mapping is still the identity mapping.\n  ljmp    $(SEG_KCODE<<3), $start32\n\n.code32  # Tell assembler to generate 32-bit code now.\nstart32:\n  # Set up the protected-mode data segment registers\n  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector\n  movw    %ax, %ds                # -> DS: Data Segment\n  movw    %ax, %es                # -> ES: Extra Segment\n  movw    %ax, %ss                # -> SS: Stack Segment\n  movw    $0, %ax                 # Zero segments not ready for use\n  movw    %ax, %fs                # -> FS\n  movw    %ax, %gs                # -> GS\n\n  # Set up the stack pointer and call into C.\n  movl    $start, %esp            # 这里将esp栈设置到了start，由于栈向低地址处增长，所以刚好和bootasm文件的代码背道而驰。\n  call    bootmain\n\n  # If bootmain returns (it shouldn't), trigger a Bochs\n  # breakpoint if running under Bochs, then loop.\n  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00\n  movw    %ax, %dx\n  outw    %ax, %dx\n  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00\n  outw    %ax, %dx\nspin:\n  jmp     spin\n\n# Bootstrap GDT\n.p2align 2                                # force 4 byte alignment\ngdt:\n  SEG_NULLASM                             # null seg\n  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg\n  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg\n\ngdtdesc:\n  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1\n  .long   gdt                             # address gdt\n\n```\n\n这里先普及一下实时模式和保护模式的区别：\n\n- 实时模式：为兼容以前的PC。特点是：寄存器都是16位。寻址方式：16位的段寄存器 + 16位的偏移寄存器，最大寻址范围是20位。\n\n- 保护模式：现代CPU的寻址方式。特点是：寄存器有16位、32为、64位。寻址方式：段描述符 + 32位偏移寄存器。最大寻址范围4G+。\n\nbootasm.S是操作系统被加载内存前，最先开始执行的代码。BIOS是运行在实时模式下的程序，只拥有1M的寻址空间（**boot代码被加载到0x7C00 < 1M 就能证明存在1M的限制**），所以在cpu拥有4G寻址空间前，还需要进行一些初始化操作，\n\n从实时模式 -> 保护模式的转变流程非常固定，在xv6的bootasm中实现如下：\n\n0. 对于多核处理器，最先启动的CPU（我们称为BSP（bootstrap processor）），BSP一上电就是实时模式。其余的从处理器（我们称为AP）在后面的内核初始化阶段会被BSP依次唤醒并初始化。\n\n1. 关中断。清空各种段寄存器，包括ds、es、ss。\n\n2. 打开A20地址线.\n\n3. 加载全局描述符表。即使用lgdt指令将表的地址和大小放在GDTR中。（这里的全局描述符表是临时的，后面内核初始化会更换一张gdt表，那张表更加完善。\n\n4. 将CR0寄存器第0位设置为1（PE位），此时正式转换成保护模式。\n\n5. 使用ljmp（长跳转指令）指令刷新段寄存器，跳到start32。\n\n    ```\n    # xv6对ljmp的注释如下：\n    # Complete the transition to 32-bit protected mode by using a long jmp\n    # to reload %cs and %eip. \n    ```\n\n6. 初始化数据段、栈段寄存器，将esp设置到0x7C00处，跳到bootmain函数中，该函数会将XV6 OS加载到内存。\n\n相关的结构如下：\n\n段描述符（Descriptor），描述一段地址的特性，包括基地址、范围、权限、粒度（范围以字节为单位还是以4K为单位）、类型（代码/数据）等信息：\n\n![](./Boot/photo/start/SegmentDescriptor.png)\n\n全局描述符表，由许多个8字节段描述符组成的表：\n\n![](./Boot/photo/start/GDT.png)\n\n全局描述符表寄存器，其**基地址**的内容是全局描述符表的首地址，**界限**是全局描述符表的大小：\n\n![](./Boot/photo/start/GDTR.png)\n\n段选择子，【代码、数据、栈等】段使用了哪个段描述符，索引号指使用段描述符在全局描述符表的偏移（8字节为单位），第2位指明是全局描述符还是局部描述符，0~1位指示段的特权级：\n\n![](./Boot/photo/start/SegmentSelector.png)\n\n从低特权级的段空间 跳到 高特权级的段空间就会发生cpu特权级的切换，cpu就是通过全局描述符表来确定一个段的特权级。最典型的就是用户进程调用系统调用产生的特权级切换，这中间涉及查tss段、切栈等复杂操作，我们后面在进行详细的讨论。\n\n对于GDT的详细描述，这里推荐两篇博客，这两篇博客写的真的非常好！相信阅读之后，对全局描述符会有一个清晰的认识，全局描述符的几幅图片也是取自这两篇文章，如有侵权，可告知删除：\n\n[详细介绍了段描述符各个位的作用](https://blog.csdn.net/abc123lzf/article/details/109289567)\n\n[可以作为扩展，里面介绍了局部描述符的作用](https://blog.csdn.net/me1171115772/article/details/51750442)\n\n## 正式将XV6加载到内存\n\n分析该部分细节前，先需要了解一下elf文件的格式，我们重点关注elf文件的ELF header和Program header table。直接上各个字段的描述：\n\n引用自博客[https://zhuanlan.zhihu.com/p/165336511](https://zhuanlan.zhihu.com/p/165336511)如有侵权，可告知删除：\n\n```cpp\n#define ELF_MAGIC 0x464C457FU  // \"\\x7FELF\" in little endian\n\n// ELF 文件的头部\nstruct elfhdr {\n  uint magic;       // 4 字节，为 0x464C457FU（大端模式）或 0x7felf（小端模式）\n                      // 表明该文件是个 ELF 格式文件\n\n  uchar elf[12];    // 12 字节，每字节对应意义如下：\n                    //     0 : 1 = 32 位程序；2 = 64 位程序\n                    //     1 : 数据编码方式，0 = 无效；1 = 小端模式；2 = 大端模式\n                    //     2 : 只是版本，固定为 0x1\n                    //     3 : 目标操作系统架构\n                    //     4 : 目标操作系统版本\n                    //     5 ~ 11 : 固定为 0\n\n  ushort type;      // 2 字节，表明该文件类型，意义如下：\n                    //     0x0 : 未知目标文件格式\n                    //     0x1 : 可重定位文件\n                    //     0x2 : 可执行文件\n                    //     0x3 : 共享目标文件\n                    //     0x4 : 转储文件\n                    //     0xff00 : 特定处理器文件\n                    //     0xffff : 特定处理器文件\n\n  ushort machine;   // 2 字节，表明运行该程序需要的计算机体系架构，\n                    // 这里我们只需要知道 0x0 为未指定；0x3 为 x86 架构\n\n  uint version;     // 4 字节，表示该文件的版本号\n\n  uint entry;       // 4 字节，该文件的入口地址，没有入口（非可执行文件）则为 0\n\n  uint phoff;       // 4 字节，表示该文件的“程序头部表”相对于文件的位置，单位是字节\n\n  uint shoff;       // 4 字节，表示该文件的“节区头部表”相对于文件的位置，单位是字节\n\n  uint flags;       // 4 字节，特定处理器标志\n\n  ushort ehsize;    // 2 字节，ELF文件头部的大小，单位是字节\n\n  ushort phentsize; // 2 字节，表示程序头部表中一个入口的大小，单位是字节\n\n  ushort phnum;     // 2 字节，表示程序头部表的入口个数，\n                    // phnum * phentsize = 程序头部表大小（单位是字节）\n\n  ushort shentsize; // 2 字节，节区头部表入口大小，单位是字节\n\n  ushort shnum;     // 2 字节，节区头部表入口个数，\n                    // shnum * shentsize = 节区头部表大小（单位是字节）\n\n  ushort shstrndx;  // 2 字节，表示字符表相关入口的节区头部表索引\n};\n\n// 程序头表\nstruct proghdr {\n  uint type;        // 4 字节， 段类型\n                    //         1 PT_LOAD : 可载入的段\n                    //         2 PT_DYNAMIC : 动态链接信息\n                    //         3 PT_INTERP : 指定要作为解释程序调用的以空字符结尾的路径名的位置和大小\n                    //         4 PT_NOTE : 指定辅助信息的位置和大小\n                    //         5 PT_SHLIB : 保留类型，但具有未指定的语义\n                    //         6 PT_PHDR : 指定程序头表在文件及程序内存映像中的位置和大小\n                    //         7 PT_TLS : 指定线程局部存储模板\n  uint off;         // 4 字节， 段的第一个字节在文件中的偏移\n  uint vaddr;       // 4 字节， 段的第一个字节在内存中的虚拟地址\n  uint paddr;       // 4 字节， 段的第一个字节在内存中的物理地址(适用于物理内存定位型的系统)\n  uint filesz;      // 4 字节， 段在文件中的长度\n  uint memsz;       // 4 字节， 段在内存中的长度\n  uint flags;       // 4 字节， 段标志\n                    //         1 : 可执行\n                    //         2 : 可写入\n                    //         4 : 可读取\n  uint align;       // 4 字节， 段在文件及内存中如何对齐\n};\n```\n\n如果感兴趣的话，可以参考文章：[ELF文件格式的详解](https://blog.csdn.net/pingxiaozhao/article/details/109239221)，这篇文章讲解的更为详细，但是对于现阶段来说，可以不用了解太仔细，知道elf文件的ELF header和Program header table各个字段的作用就足够你继续学习XV6操作系统。\n\n对kernel elf文件解析的主流程：\n\n```cpp\nvoid\nbootmain(void)\n{\n  struct elfhdr *elf;\n  struct proghdr *ph, *eph;\n  void (*entry)(void);\n  uchar* pa;\n  // 预留足够空间\n  // 46K\n  elf = (struct elfhdr*)0x10000;  // scratch space\n\n  // 以0为偏移读4096个字节，读elf文件头\n  // Read 1st page off disk\n  readseg((uchar*)elf, 4096, 0);\n\n  // 判断elf文件魔数。\n  // Is this an ELF executable?\n  if(elf->magic != ELF_MAGIC)\n    return;  // let bootasm.S handle error\n\n  // 定位到Program header table\n  // Load each program segment (ignores ph flags).\n  ph = (struct proghdr*)((uchar*)elf + elf->phoff);\n  // 程序头部表个数\n  eph = ph + elf->phnum;\n\n  // 一个段一个段的读\n  for(; ph < eph; ph++){  // 以struct proghdr为单位自增。\n    // 应该加载到的物理内存，xv6中是0x100000\n    pa = (uchar*)ph->paddr;\n    // 读取整个段到pa中\n    readseg(pa, ph->filesz, ph->off);\n    if(ph->memsz > ph->filesz)\n      // mem大小比file大小大，多余的补零\n      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);\n  }\n\n  // Call the entry point from the ELF header.\n  // Does not return!\n  entry = (void(*)(void))(elf->entry);  // 在xv6的kernel.ld中描述为_start\n  entry();\n}\n```\n\n前半部分做的操作就是不断从kernel的elf文件中按照程序头将各个段读取到内存。后面通过elf头中的entry，该字段保存内核入口点_start（这可以通过阅读kernel.ld文件来证明），去执行_start开始的代码，这里要提醒读者的是，到目前为止，对cpu来说状态是：保护模式 & 已经装填了全局描述符 & **一切地址皆是物理地址**。而kernel的elf文件中代码都是使用的（0x8010 0000开始的）虚拟地址，所以我们后面在entry.S中会看到，在给_start赋值前，会通过一个宏将真正的入口地址的虚拟地址转换为XV6加载到内存的物理地址。从而我们在物理地址寻址模式下，可以利用_start准确跳转到xv6的入口代码。\n\n需要注意的是：**在执行bootasm汇编代码时，esp的位置是不确定的，唯一能确定的是esp在1M空间之内。在bootasm汇编最后才会将esp挪到0x7c00的位置！**\n\n在bootmain执行完毕后，内存布局如下：\n\n![](./Boot/photo/start/boot.drawio.png)\n\n接下来深入分析一下从磁盘读取文件的细节，这些内容都是和硬件相关的，通过操作硬件寄存器来实现读写磁盘，这部分深入下去也是挺让人头大的，作者也是菜鸟一个，也就力所能及的叙述一些自己明白的东西吧。\n\n```cpp\nvoid\nwaitdisk(void)\n{\n  // Wait for disk ready.\n  while((inb(0x1F7) & 0xC0) != 0x40)\n    ;\n}\n\n// readsect也引用自https://zhuanlan.zhihu.com/p/165336511，如有侵权，可联系我删除\n// Read a single sector at offset into dst.\nvoid\nreadsect(void *dst, uint offset)\n{\n  // Issue command.\n  waitdisk();\n  outb(0x1F2, 1);   // count = 1          // 要读取的扇区数量 count = 1\n  outb(0x1F3, offset);                    // 扇区 LBA 地址的 0-7 位\n  outb(0x1F4, offset >> 8);               // 扇区 LBA 地址的 8-15 位\n  outb(0x1F5, offset >> 16);              // 扇区 LBA 地址的 16-23 位\n  outb(0x1F6, (offset >> 24) | 0xE0);     // offset | 11100000 保证高三位恒为 1\n                                          //         第7位     恒为1\n                                          //         第6位     LBA模式的开关，置1为LBA模式\n                                          //         第5位     恒为1\n                                          //         第4位     为0代表主硬盘、为1代表从硬盘\n                                          //         第3~0位   扇区 LBA 地址的 24-27 位\n  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors  // 20h为读，30h为写\n\n  // Read data.\n  waitdisk();\n  insl(0x1F0, dst, SECTSIZE/4); // 读的时候以4字节位单位读，所以需要扇区除以4，代表要读的次数\n}\n\n// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.\n// Might copy more than asked.\nvoid\nreadseg(uchar* pa, uint count, uint offset)\n{\n  uchar* epa; // end phy addr\n\n  epa = pa + count; // 结束地址\n\n  // 这里将起始物理地址回退了offset的SECTSIZE（512）余数个Byte\n  // 因为在从磁盘上读数据的时候，以512字节进行读取。所以offset会以512为单位向下取整，\n  // 被换算成扇区号的偏移。如果offset原来不是SECTSIZE的整数倍，向下取整会导致offset截断，\n  // 记换算后的offset为ofs，此时如果直接读取ofs扇区会多读offset % SECTSIZE个字节，\n  // 所以需要提前将pa的地址减去offset % SECTSIZE个字节来排除offset被截断的多余的字节。\n  // Round down to sector boundary.\n  pa -= offset % SECTSIZE;    \n\n  // 将offset换算成扇区号\n  // Translate from bytes to sectors; kernel starts at sector 1.\n  offset = (offset / SECTSIZE) + 1; \n\n  // 依次读取每个扇区，最后一个扇区多读了也没关系。\n  for(; pa < epa; pa += SECTSIZE, offset++)\n    readsect(pa, offset);\n}\n```\n\n仔细推敲readseg函数中pa回滚的操作，总感觉这样贸然回滚，会覆盖之前已经被加载到内存中的代码。既然xv6敢这样写，八成说明是没有问题的，具体的原因，作者实在琢磨不透，如果有了解的朋友，可以在评论区交流一下。\n\n## 跳到_start，正式进入内核前的预初始化\n\n相关代码文件是entry.S\n\n```arm\n#include \"asm.h\"\n#include \"memlayout.h\"\n#include \"mmu.h\"\n#include \"param.h\"\n\n# Multiboot header.  Data to direct multiboot loader.\n.p2align 2\n.text\n.globl multiboot_header\nmultiboot_header:\n  #define magic 0x1badb002\n  #define flags 0\n  .long magic\n  .long flags\n  .long (-magic-flags)\n  \n# 这里就能看到，因为elf描述的一些标签是使用的虚拟地址，\n# 而在进入entry开启分页前都是使用的物理地址，所以使用了\n# V2P_WO宏将entry转换成了物理地址。方便bootmain跳转到entry.\n# V2P_WO展开就是将输入的地址减去 0x8000 0000 的偏移。\n.globl _start\n_start = V2P_WO(entry)\n\n# Entering xv6 on boot processor, with paging off.\n.globl entry\nentry:\n  # 打开4M big page开关\n  # Turn on page size extension for 4Mbyte pages\n  movl    %cr4, %eax\n  orl     $(CR4_PSE), %eax\n  movl    %eax, %cr4\n\n  # 将页目录设置为entrypgdir，同样由于在启用虚拟内存前，\n  # 需要将虚拟地址entrypgdir转换为物理地址，有关entrypgdir\n  # 的定义在内存管理章节进行详细叙述。\n  # Set page directory\n  movl    $(V2P_WO(entrypgdir)), %eax\n  movl    %eax, %cr3\n\n  # 开启分页\n  # Turn on paging.\n  movl    %cr0, %eax\n  orl     $(CR0_PG|CR0_WP), %eax\n  movl    %eax, %cr0\n\n  ########################### 以下正式进入分页模式，地址皆是虚拟地址\n  # 再一次修改esp指针，将esp移到内核代码范围中\n  # Set up the stack pointer.\n  movl $(stack + KSTACKSIZE), %esp\n\n  # 真正进入内核main函数，开始各种初始化。\n  mov $main, %eax\n  jmp *%eax\n\n.comm stack, KSTACKSIZE\n```\n\n该部分代码负责进入main函数前的初始化，主要工作如下：\n\n1. 打开4M big page分页开关，让cpu支持4M大页。entrypgdir会将内核区域与映射为物理地址低4M的大页，我们后面会详细进行讨论，entrypgdir的生命周期非常短，在main函数中初始化过程中，会另外产生一个粒度更小的页表kpgdir（4K为一页），该页表会一直作为xv6的内核页表。\n\n2. 设置entrypgdir为BSP（booststrap processor）的页目录。\n\n3. 开启分页。\n\n4. 修改esp。指向内核自己分配的4K大小的栈上。\n\n5. 进入main。\n\n在entry.S代码执行完后，cpu开启分页模式，所有的地址都将以虚拟地址的形式存在。此时内存布局如下：\n\n![](./Boot/photo/start/entry.drawio.png)\n\n至此，cpu的预初始化进行完毕。下面几章将围绕内核的初始化去讲解类unix操作系统的内存管理、进程调度、文件系统子模块。\n\n---\n\n**本章完结**\n\n","source":"_posts/xv6/Boot.md","raw":"---\ntitle: 这才是计科之 Onix & XV6 源码分析（1、XV6-x86的启动）\ndate: 2024-06-07 12:00:00\ntags:\n  - 类Unix源码剖析\n---\n\n## 前言\n\nOnix是一款相对于XV6来说功能更为健全的单核OS，由于功能更加完善，Onix也更加复杂。代码阅读起来会比较绕。\n\nXV6是一款简单易读的多核操作系统，但其功能相对Onix来说更为简陋，比如Onix对物理内存的管理采用了位图、内核内存和进程相关的内存进行了分开管理，页目录使用单独的内核内存，没有和页表、页框混用等。而XV6显得非常简陋。尽管XV6的实验可以弥补部分缺陷。\n\nOnix操作系统也实现了bootloader，对于将OS加载到内存的操作，Onix是采用汇编进行内核加载，并且在加载内核前，还会进行一个内存探测的操作，所以Onix的bootloader稍微有些复杂。而XV6操作系统的启动操作写的非常简洁，加载内核的操作采用的是C语言的形式，非常利于阅读学习，但是XV6不会进行内存探测。为求方便，本文主要叙述XV6的启动流程。\n\nOnix相关链接：\n\n- [github仓库链接](https://github.com/StevenBaby/onix)\n\n- [B站配套视频链接](https://www.bilibili.com/video/BV1qM4y127om/)\n\nXV6-x86的github链接：\n\n- [链接](https://github.com/mit-pdos/xv6-public)\n\n<!-- more -->\n\n## Makefile & kernel.ld文件的分析\n\n首先科普一个概念 —— 引导扇区\n\n**引导扇区：是计算机启动过程中 BIOS 读取的第一个磁盘扇区（通常为 512 字节），用于加载操作系统或更复杂的引导程序（如 GRUB）。**\n\nBISO规定引导扇区有如下要求：\n\n1. 引导扇区的代码被加载到内存的0x7c00位置执行\n2. 引导扇区有且仅有512字节。\n3. 引导扇区的魔数在最后两个字节的位置，值0x55aa。\n\n在叙述os启动前，必须要了解其Makefile是怎么写的。同时，在了解bootmain从镜像中加载os的代码到内存中前，因为os是elf格式，所以我们需要了解os的link脚本是怎么布局的。以便我们能更好掌握os的内存布局。\n\n### Makefile\n\n这里贴出makefile比较关键的代码：\n\n```makefile\n# 利用dd命令制作OS镜像，依赖bootblock和kernel，\n# 首先划分了10000个扇区\n# 然后将bootblock写到了第0号扇区\n# 最后从1号扇区开始，填入OS的代码文件。\nxv6.img: bootblock kernel\n\tdd if=/dev/zero of=xv6.img count=10000\n\tdd if=bootblock of=xv6.img conv=notrunc\n\tdd if=kernel of=xv6.img seek=1 conv=notrunc\n\n# 单独产生os的bootloader模块，并且该模块是使用$(OBJCOPY)产生，\n# 所以没有elf文件头信息，只是单纯的二进制可执行文件。并且$(LD)规定\n# 代码的入口点是start、并且从地址0x7C00（物理地址）开始，最终的文件名是bootblock\n# 最后一步，调用pl脚本对引导扇区进行签名，在512字节引导扇区最后两字节写入0x55aa\nbootblock: bootasm.S bootmain.c\n\t$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c\n\t$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S\n\t$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o\n\t$(OBJDUMP) -S bootblock.o > bootblock.asm\n\t$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock\n\t./sign.pl bootblock\n\n# 产生AP cpu的boot代码\n# 指定程序的加载地址是0x7000（物理地址）\n# 可执行代码的格式和bootblock相同，纯粹的二进制程序，没有elf的头部信息\n# 但最终输出的entryother会和kernel合并\nentryother: entryother.S\n\t$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S\n\t$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o\n\t$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother\n\t$(OBJDUMP) -S bootblockother.o > entryother.asm\n\n# 产生第一个进程，init进程的boot代码\n# 同样以$(OBJCOPY)提取纯粹的可执行代码，没有elf头部信息，输出文件名为initcode\n# 指定程序的加载地址是0（虚拟地址）\ninitcode: initcode.S\n\t$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S\n\t$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o\n\t$(OBJCOPY) -S -O binary initcode.out initcode\n\t$(OBJDUMP) -S initcode.o > initcode.asm\n\n# 产生内核的elf可执行文件\nkernel: $(OBJS) entry.o entryother initcode kernel.ld\n\t$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother\n\t$(OBJDUMP) -S kernel > kernel.asm\n\t$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym\n\n```\n\n这里编译器、链接器的选项具体作用读者可以自行百度，这里只阐述比较关键的部分。\n\n首先是利用dd命令制作xv6.img镜像，从代码中可以很清楚的看到，bootblock填到了第0号扇区、kernel填到了1号以及之后的扇区。bootblock作用就是使cpu从实时模式转换为保护模式，然后将kernel从磁盘上加载到内存。这里要注意一个特殊的数字0x7C00，它出现在生成bootblock二进制文件的\\$(LD)阶段，这里暗示了bootblock代码在加载进内存时应该被放在0x7C00的位置。事实也是如此，**在BIOS完成硬件初始化后，就会将第0号扇区（一个扇区一般就是512字节）的512字节代码加载到内存的0x7C00的位置，然后BIOS就会让eip指向0x7C00的位置，去执行bootasm.S里面的汇编代码。**\n\n这里有个关键点：在使用\\$(LD)命令生成bootblock.o时，命令参数部分bootasm.o放在bootmain.o前面，会导致链接时，bootasm.o代码就会靠前，这样在eip执行0x7C00位置的代码时，一定是从start开始。\n\nbootblock是由\\$(OBJCOPY)生成，\\$(OBJCOPY)的作用就是去除elf文件中的各种头部，因为BIOS只负责从第0号扇区加载bootblock，不会解析elf文件，所以，\\$(OBJCOPY)去提取纯粹的二进制是非常有必要的！\n\nbootblock具体细节下面会详细探讨\n\n### kernel.ld\n\n这里贴出kernel.ld比较关键的代码：\n\n```link\nOUTPUT_FORMAT(\"elf32-i386\", \"elf32-i386\", \"elf32-i386\")\nOUTPUT_ARCH(i386)\nENTRY(_start)\n\nSECTIONS\n{\n\t/* Link the kernel at this address: \".\" means the current address */\n        /* Must be equal to KERNLINK */\n\t. = 0x80100000; // 定义代码起始的虚拟地址\n\n\t.text : AT(0x100000) {  // 定义了起始加载地址\n\t\t*(.text .stub .text.* .gnu.linkonce.t.*)\n\t}\n\n  /*\n    省略...\n  */\n}\n```\n\n从kernel的链接脚本我们可以看到，kernel的起始虚拟内存地址是0x8010 0000，内核实际加载的物理地址是x100000，由AT定义。这里我反复标注了 虚拟地址 / 物理地址 ，这两者一定要分清！\n\n## 从实时模式到保护模式\n\n本段代码实现位于xv6的bootasm.S文件。具体细节如下，xv6使用的AT&T的汇编，还是比较好懂的，读者有疑问的话，可以百度去搜相关指令的作用。英文注释已经非常详细，我就直接引用了。\n\n```arm\n#include \"asm.h\"\n#include \"memlayout.h\"\n#include \"mmu.h\"\n\n# Start the first CPU: switch to 32-bit protected mode, jump into C.\n# The BIOS loads this code from the first sector of the hard disk into\n# memory at physical address 0x7c00 and starts executing in real mode\n# with %cs=0 %ip=7c00.\n\n.code16                       # Assemble for 16-bit mode\n.globl start\nstart:\n  cli                         # BIOS enabled interrupts; disable\n\n  # Zero data segment registers DS, ES, and SS.\n  xorw    %ax,%ax             # Set %ax to zero\n  movw    %ax,%ds             # -> Data Segment\n  movw    %ax,%es             # -> Extra Segment\n  movw    %ax,%ss             # -> Stack Segment\n\n  # 硬件相关，主线是OS的启动，该部分不深究也没影响，其实就是一个固定步骤。\n  # Physical address line A20 is tied to zero so that the first PCs \n  # with 2 MB would run software that assumed 1 MB.  Undo that.\nseta20.1:\n  inb     $0x64,%al               # Wait for not busy\n  testb   $0x2,%al\n  jnz     seta20.1\n\n  movb    $0xd1,%al               # 0xd1 -> port 0x64\n  outb    %al,$0x64\n\nseta20.2:\n  inb     $0x64,%al               # Wait for not busy\n  testb   $0x2,%al\n  jnz     seta20.2\n\n  movb    $0xdf,%al               # 0xdf -> port 0x60\n  outb    %al,$0x60\n\n  # Switch from real to protected mode.  Use a bootstrap GDT that makes\n  # virtual addresses map directly to physical addresses so that the\n  # effective memory map doesn't change during the transition.\n  lgdt    gdtdesc\n  movl    %cr0, %eax\n  orl     $CR0_PE, %eax\n  movl    %eax, %cr0\n ########################### 以下正式进入32位保护模式\n//PAGEBREAK!\n  # Complete the transition to 32-bit protected mode by using a long jmp\n  # to reload %cs and %eip.  The segment descriptors are set up with no\n  # translation, so that the mapping is still the identity mapping.\n  ljmp    $(SEG_KCODE<<3), $start32\n\n.code32  # Tell assembler to generate 32-bit code now.\nstart32:\n  # Set up the protected-mode data segment registers\n  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector\n  movw    %ax, %ds                # -> DS: Data Segment\n  movw    %ax, %es                # -> ES: Extra Segment\n  movw    %ax, %ss                # -> SS: Stack Segment\n  movw    $0, %ax                 # Zero segments not ready for use\n  movw    %ax, %fs                # -> FS\n  movw    %ax, %gs                # -> GS\n\n  # Set up the stack pointer and call into C.\n  movl    $start, %esp            # 这里将esp栈设置到了start，由于栈向低地址处增长，所以刚好和bootasm文件的代码背道而驰。\n  call    bootmain\n\n  # If bootmain returns (it shouldn't), trigger a Bochs\n  # breakpoint if running under Bochs, then loop.\n  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00\n  movw    %ax, %dx\n  outw    %ax, %dx\n  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00\n  outw    %ax, %dx\nspin:\n  jmp     spin\n\n# Bootstrap GDT\n.p2align 2                                # force 4 byte alignment\ngdt:\n  SEG_NULLASM                             # null seg\n  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg\n  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg\n\ngdtdesc:\n  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1\n  .long   gdt                             # address gdt\n\n```\n\n这里先普及一下实时模式和保护模式的区别：\n\n- 实时模式：为兼容以前的PC。特点是：寄存器都是16位。寻址方式：16位的段寄存器 + 16位的偏移寄存器，最大寻址范围是20位。\n\n- 保护模式：现代CPU的寻址方式。特点是：寄存器有16位、32为、64位。寻址方式：段描述符 + 32位偏移寄存器。最大寻址范围4G+。\n\nbootasm.S是操作系统被加载内存前，最先开始执行的代码。BIOS是运行在实时模式下的程序，只拥有1M的寻址空间（**boot代码被加载到0x7C00 < 1M 就能证明存在1M的限制**），所以在cpu拥有4G寻址空间前，还需要进行一些初始化操作，\n\n从实时模式 -> 保护模式的转变流程非常固定，在xv6的bootasm中实现如下：\n\n0. 对于多核处理器，最先启动的CPU（我们称为BSP（bootstrap processor）），BSP一上电就是实时模式。其余的从处理器（我们称为AP）在后面的内核初始化阶段会被BSP依次唤醒并初始化。\n\n1. 关中断。清空各种段寄存器，包括ds、es、ss。\n\n2. 打开A20地址线.\n\n3. 加载全局描述符表。即使用lgdt指令将表的地址和大小放在GDTR中。（这里的全局描述符表是临时的，后面内核初始化会更换一张gdt表，那张表更加完善。\n\n4. 将CR0寄存器第0位设置为1（PE位），此时正式转换成保护模式。\n\n5. 使用ljmp（长跳转指令）指令刷新段寄存器，跳到start32。\n\n    ```\n    # xv6对ljmp的注释如下：\n    # Complete the transition to 32-bit protected mode by using a long jmp\n    # to reload %cs and %eip. \n    ```\n\n6. 初始化数据段、栈段寄存器，将esp设置到0x7C00处，跳到bootmain函数中，该函数会将XV6 OS加载到内存。\n\n相关的结构如下：\n\n段描述符（Descriptor），描述一段地址的特性，包括基地址、范围、权限、粒度（范围以字节为单位还是以4K为单位）、类型（代码/数据）等信息：\n\n![](./Boot/photo/start/SegmentDescriptor.png)\n\n全局描述符表，由许多个8字节段描述符组成的表：\n\n![](./Boot/photo/start/GDT.png)\n\n全局描述符表寄存器，其**基地址**的内容是全局描述符表的首地址，**界限**是全局描述符表的大小：\n\n![](./Boot/photo/start/GDTR.png)\n\n段选择子，【代码、数据、栈等】段使用了哪个段描述符，索引号指使用段描述符在全局描述符表的偏移（8字节为单位），第2位指明是全局描述符还是局部描述符，0~1位指示段的特权级：\n\n![](./Boot/photo/start/SegmentSelector.png)\n\n从低特权级的段空间 跳到 高特权级的段空间就会发生cpu特权级的切换，cpu就是通过全局描述符表来确定一个段的特权级。最典型的就是用户进程调用系统调用产生的特权级切换，这中间涉及查tss段、切栈等复杂操作，我们后面在进行详细的讨论。\n\n对于GDT的详细描述，这里推荐两篇博客，这两篇博客写的真的非常好！相信阅读之后，对全局描述符会有一个清晰的认识，全局描述符的几幅图片也是取自这两篇文章，如有侵权，可告知删除：\n\n[详细介绍了段描述符各个位的作用](https://blog.csdn.net/abc123lzf/article/details/109289567)\n\n[可以作为扩展，里面介绍了局部描述符的作用](https://blog.csdn.net/me1171115772/article/details/51750442)\n\n## 正式将XV6加载到内存\n\n分析该部分细节前，先需要了解一下elf文件的格式，我们重点关注elf文件的ELF header和Program header table。直接上各个字段的描述：\n\n引用自博客[https://zhuanlan.zhihu.com/p/165336511](https://zhuanlan.zhihu.com/p/165336511)如有侵权，可告知删除：\n\n```cpp\n#define ELF_MAGIC 0x464C457FU  // \"\\x7FELF\" in little endian\n\n// ELF 文件的头部\nstruct elfhdr {\n  uint magic;       // 4 字节，为 0x464C457FU（大端模式）或 0x7felf（小端模式）\n                      // 表明该文件是个 ELF 格式文件\n\n  uchar elf[12];    // 12 字节，每字节对应意义如下：\n                    //     0 : 1 = 32 位程序；2 = 64 位程序\n                    //     1 : 数据编码方式，0 = 无效；1 = 小端模式；2 = 大端模式\n                    //     2 : 只是版本，固定为 0x1\n                    //     3 : 目标操作系统架构\n                    //     4 : 目标操作系统版本\n                    //     5 ~ 11 : 固定为 0\n\n  ushort type;      // 2 字节，表明该文件类型，意义如下：\n                    //     0x0 : 未知目标文件格式\n                    //     0x1 : 可重定位文件\n                    //     0x2 : 可执行文件\n                    //     0x3 : 共享目标文件\n                    //     0x4 : 转储文件\n                    //     0xff00 : 特定处理器文件\n                    //     0xffff : 特定处理器文件\n\n  ushort machine;   // 2 字节，表明运行该程序需要的计算机体系架构，\n                    // 这里我们只需要知道 0x0 为未指定；0x3 为 x86 架构\n\n  uint version;     // 4 字节，表示该文件的版本号\n\n  uint entry;       // 4 字节，该文件的入口地址，没有入口（非可执行文件）则为 0\n\n  uint phoff;       // 4 字节，表示该文件的“程序头部表”相对于文件的位置，单位是字节\n\n  uint shoff;       // 4 字节，表示该文件的“节区头部表”相对于文件的位置，单位是字节\n\n  uint flags;       // 4 字节，特定处理器标志\n\n  ushort ehsize;    // 2 字节，ELF文件头部的大小，单位是字节\n\n  ushort phentsize; // 2 字节，表示程序头部表中一个入口的大小，单位是字节\n\n  ushort phnum;     // 2 字节，表示程序头部表的入口个数，\n                    // phnum * phentsize = 程序头部表大小（单位是字节）\n\n  ushort shentsize; // 2 字节，节区头部表入口大小，单位是字节\n\n  ushort shnum;     // 2 字节，节区头部表入口个数，\n                    // shnum * shentsize = 节区头部表大小（单位是字节）\n\n  ushort shstrndx;  // 2 字节，表示字符表相关入口的节区头部表索引\n};\n\n// 程序头表\nstruct proghdr {\n  uint type;        // 4 字节， 段类型\n                    //         1 PT_LOAD : 可载入的段\n                    //         2 PT_DYNAMIC : 动态链接信息\n                    //         3 PT_INTERP : 指定要作为解释程序调用的以空字符结尾的路径名的位置和大小\n                    //         4 PT_NOTE : 指定辅助信息的位置和大小\n                    //         5 PT_SHLIB : 保留类型，但具有未指定的语义\n                    //         6 PT_PHDR : 指定程序头表在文件及程序内存映像中的位置和大小\n                    //         7 PT_TLS : 指定线程局部存储模板\n  uint off;         // 4 字节， 段的第一个字节在文件中的偏移\n  uint vaddr;       // 4 字节， 段的第一个字节在内存中的虚拟地址\n  uint paddr;       // 4 字节， 段的第一个字节在内存中的物理地址(适用于物理内存定位型的系统)\n  uint filesz;      // 4 字节， 段在文件中的长度\n  uint memsz;       // 4 字节， 段在内存中的长度\n  uint flags;       // 4 字节， 段标志\n                    //         1 : 可执行\n                    //         2 : 可写入\n                    //         4 : 可读取\n  uint align;       // 4 字节， 段在文件及内存中如何对齐\n};\n```\n\n如果感兴趣的话，可以参考文章：[ELF文件格式的详解](https://blog.csdn.net/pingxiaozhao/article/details/109239221)，这篇文章讲解的更为详细，但是对于现阶段来说，可以不用了解太仔细，知道elf文件的ELF header和Program header table各个字段的作用就足够你继续学习XV6操作系统。\n\n对kernel elf文件解析的主流程：\n\n```cpp\nvoid\nbootmain(void)\n{\n  struct elfhdr *elf;\n  struct proghdr *ph, *eph;\n  void (*entry)(void);\n  uchar* pa;\n  // 预留足够空间\n  // 46K\n  elf = (struct elfhdr*)0x10000;  // scratch space\n\n  // 以0为偏移读4096个字节，读elf文件头\n  // Read 1st page off disk\n  readseg((uchar*)elf, 4096, 0);\n\n  // 判断elf文件魔数。\n  // Is this an ELF executable?\n  if(elf->magic != ELF_MAGIC)\n    return;  // let bootasm.S handle error\n\n  // 定位到Program header table\n  // Load each program segment (ignores ph flags).\n  ph = (struct proghdr*)((uchar*)elf + elf->phoff);\n  // 程序头部表个数\n  eph = ph + elf->phnum;\n\n  // 一个段一个段的读\n  for(; ph < eph; ph++){  // 以struct proghdr为单位自增。\n    // 应该加载到的物理内存，xv6中是0x100000\n    pa = (uchar*)ph->paddr;\n    // 读取整个段到pa中\n    readseg(pa, ph->filesz, ph->off);\n    if(ph->memsz > ph->filesz)\n      // mem大小比file大小大，多余的补零\n      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);\n  }\n\n  // Call the entry point from the ELF header.\n  // Does not return!\n  entry = (void(*)(void))(elf->entry);  // 在xv6的kernel.ld中描述为_start\n  entry();\n}\n```\n\n前半部分做的操作就是不断从kernel的elf文件中按照程序头将各个段读取到内存。后面通过elf头中的entry，该字段保存内核入口点_start（这可以通过阅读kernel.ld文件来证明），去执行_start开始的代码，这里要提醒读者的是，到目前为止，对cpu来说状态是：保护模式 & 已经装填了全局描述符 & **一切地址皆是物理地址**。而kernel的elf文件中代码都是使用的（0x8010 0000开始的）虚拟地址，所以我们后面在entry.S中会看到，在给_start赋值前，会通过一个宏将真正的入口地址的虚拟地址转换为XV6加载到内存的物理地址。从而我们在物理地址寻址模式下，可以利用_start准确跳转到xv6的入口代码。\n\n需要注意的是：**在执行bootasm汇编代码时，esp的位置是不确定的，唯一能确定的是esp在1M空间之内。在bootasm汇编最后才会将esp挪到0x7c00的位置！**\n\n在bootmain执行完毕后，内存布局如下：\n\n![](./Boot/photo/start/boot.drawio.png)\n\n接下来深入分析一下从磁盘读取文件的细节，这些内容都是和硬件相关的，通过操作硬件寄存器来实现读写磁盘，这部分深入下去也是挺让人头大的，作者也是菜鸟一个，也就力所能及的叙述一些自己明白的东西吧。\n\n```cpp\nvoid\nwaitdisk(void)\n{\n  // Wait for disk ready.\n  while((inb(0x1F7) & 0xC0) != 0x40)\n    ;\n}\n\n// readsect也引用自https://zhuanlan.zhihu.com/p/165336511，如有侵权，可联系我删除\n// Read a single sector at offset into dst.\nvoid\nreadsect(void *dst, uint offset)\n{\n  // Issue command.\n  waitdisk();\n  outb(0x1F2, 1);   // count = 1          // 要读取的扇区数量 count = 1\n  outb(0x1F3, offset);                    // 扇区 LBA 地址的 0-7 位\n  outb(0x1F4, offset >> 8);               // 扇区 LBA 地址的 8-15 位\n  outb(0x1F5, offset >> 16);              // 扇区 LBA 地址的 16-23 位\n  outb(0x1F6, (offset >> 24) | 0xE0);     // offset | 11100000 保证高三位恒为 1\n                                          //         第7位     恒为1\n                                          //         第6位     LBA模式的开关，置1为LBA模式\n                                          //         第5位     恒为1\n                                          //         第4位     为0代表主硬盘、为1代表从硬盘\n                                          //         第3~0位   扇区 LBA 地址的 24-27 位\n  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors  // 20h为读，30h为写\n\n  // Read data.\n  waitdisk();\n  insl(0x1F0, dst, SECTSIZE/4); // 读的时候以4字节位单位读，所以需要扇区除以4，代表要读的次数\n}\n\n// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.\n// Might copy more than asked.\nvoid\nreadseg(uchar* pa, uint count, uint offset)\n{\n  uchar* epa; // end phy addr\n\n  epa = pa + count; // 结束地址\n\n  // 这里将起始物理地址回退了offset的SECTSIZE（512）余数个Byte\n  // 因为在从磁盘上读数据的时候，以512字节进行读取。所以offset会以512为单位向下取整，\n  // 被换算成扇区号的偏移。如果offset原来不是SECTSIZE的整数倍，向下取整会导致offset截断，\n  // 记换算后的offset为ofs，此时如果直接读取ofs扇区会多读offset % SECTSIZE个字节，\n  // 所以需要提前将pa的地址减去offset % SECTSIZE个字节来排除offset被截断的多余的字节。\n  // Round down to sector boundary.\n  pa -= offset % SECTSIZE;    \n\n  // 将offset换算成扇区号\n  // Translate from bytes to sectors; kernel starts at sector 1.\n  offset = (offset / SECTSIZE) + 1; \n\n  // 依次读取每个扇区，最后一个扇区多读了也没关系。\n  for(; pa < epa; pa += SECTSIZE, offset++)\n    readsect(pa, offset);\n}\n```\n\n仔细推敲readseg函数中pa回滚的操作，总感觉这样贸然回滚，会覆盖之前已经被加载到内存中的代码。既然xv6敢这样写，八成说明是没有问题的，具体的原因，作者实在琢磨不透，如果有了解的朋友，可以在评论区交流一下。\n\n## 跳到_start，正式进入内核前的预初始化\n\n相关代码文件是entry.S\n\n```arm\n#include \"asm.h\"\n#include \"memlayout.h\"\n#include \"mmu.h\"\n#include \"param.h\"\n\n# Multiboot header.  Data to direct multiboot loader.\n.p2align 2\n.text\n.globl multiboot_header\nmultiboot_header:\n  #define magic 0x1badb002\n  #define flags 0\n  .long magic\n  .long flags\n  .long (-magic-flags)\n  \n# 这里就能看到，因为elf描述的一些标签是使用的虚拟地址，\n# 而在进入entry开启分页前都是使用的物理地址，所以使用了\n# V2P_WO宏将entry转换成了物理地址。方便bootmain跳转到entry.\n# V2P_WO展开就是将输入的地址减去 0x8000 0000 的偏移。\n.globl _start\n_start = V2P_WO(entry)\n\n# Entering xv6 on boot processor, with paging off.\n.globl entry\nentry:\n  # 打开4M big page开关\n  # Turn on page size extension for 4Mbyte pages\n  movl    %cr4, %eax\n  orl     $(CR4_PSE), %eax\n  movl    %eax, %cr4\n\n  # 将页目录设置为entrypgdir，同样由于在启用虚拟内存前，\n  # 需要将虚拟地址entrypgdir转换为物理地址，有关entrypgdir\n  # 的定义在内存管理章节进行详细叙述。\n  # Set page directory\n  movl    $(V2P_WO(entrypgdir)), %eax\n  movl    %eax, %cr3\n\n  # 开启分页\n  # Turn on paging.\n  movl    %cr0, %eax\n  orl     $(CR0_PG|CR0_WP), %eax\n  movl    %eax, %cr0\n\n  ########################### 以下正式进入分页模式，地址皆是虚拟地址\n  # 再一次修改esp指针，将esp移到内核代码范围中\n  # Set up the stack pointer.\n  movl $(stack + KSTACKSIZE), %esp\n\n  # 真正进入内核main函数，开始各种初始化。\n  mov $main, %eax\n  jmp *%eax\n\n.comm stack, KSTACKSIZE\n```\n\n该部分代码负责进入main函数前的初始化，主要工作如下：\n\n1. 打开4M big page分页开关，让cpu支持4M大页。entrypgdir会将内核区域与映射为物理地址低4M的大页，我们后面会详细进行讨论，entrypgdir的生命周期非常短，在main函数中初始化过程中，会另外产生一个粒度更小的页表kpgdir（4K为一页），该页表会一直作为xv6的内核页表。\n\n2. 设置entrypgdir为BSP（booststrap processor）的页目录。\n\n3. 开启分页。\n\n4. 修改esp。指向内核自己分配的4K大小的栈上。\n\n5. 进入main。\n\n在entry.S代码执行完后，cpu开启分页模式，所有的地址都将以虚拟地址的形式存在。此时内存布局如下：\n\n![](./Boot/photo/start/entry.drawio.png)\n\n至此，cpu的预初始化进行完毕。下面几章将围绕内核的初始化去讲解类unix操作系统的内存管理、进程调度、文件系统子模块。\n\n---\n\n**本章完结**\n\n","slug":"xv6/Boot","published":1,"updated":"2025-09-28T09:40:45.876Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9v0017q8wseafudr8p","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Onix是一款相对于XV6来说功能更为健全的单核OS，由于功能更加完善，Onix也更加复杂。代码阅读起来会比较绕。</p>\n<p>XV6是一款简单易读的多核操作系统，但其功能相对Onix来说更为简陋，比如Onix对物理内存的管理采用了位图、内核内存和进程相关的内存进行了分开管理，页目录使用单独的内核内存，没有和页表、页框混用等。而XV6显得非常简陋。尽管XV6的实验可以弥补部分缺陷。</p>\n<p>Onix操作系统也实现了bootloader，对于将OS加载到内存的操作，Onix是采用汇编进行内核加载，并且在加载内核前，还会进行一个内存探测的操作，所以Onix的bootloader稍微有些复杂。而XV6操作系统的启动操作写的非常简洁，加载内核的操作采用的是C语言的形式，非常利于阅读学习，但是XV6不会进行内存探测。为求方便，本文主要叙述XV6的启动流程。</p>\n<p>Onix相关链接：</p>\n<ul>\n<li><p><a href=\"https://github.com/StevenBaby/onix\">github仓库链接</a></p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/BV1qM4y127om/\">B站配套视频链接</a></p>\n</li>\n</ul>\n<p>XV6-x86的github链接：</p>\n<ul>\n<li><a href=\"https://github.com/mit-pdos/xv6-public\">链接</a></li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"Makefile-kernel-ld文件的分析\"><a href=\"#Makefile-kernel-ld文件的分析\" class=\"headerlink\" title=\"Makefile &amp; kernel.ld文件的分析\"></a>Makefile &amp; kernel.ld文件的分析</h2><p>首先科普一个概念 —— 引导扇区</p>\n<p><strong>引导扇区：是计算机启动过程中 BIOS 读取的第一个磁盘扇区（通常为 512 字节），用于加载操作系统或更复杂的引导程序（如 GRUB）。</strong></p>\n<p>BISO规定引导扇区有如下要求：</p>\n<ol>\n<li>引导扇区的代码被加载到内存的0x7c00位置执行</li>\n<li>引导扇区有且仅有512字节。</li>\n<li>引导扇区的魔数在最后两个字节的位置，值0x55aa。</li>\n</ol>\n<p>在叙述os启动前，必须要了解其Makefile是怎么写的。同时，在了解bootmain从镜像中加载os的代码到内存中前，因为os是elf格式，所以我们需要了解os的link脚本是怎么布局的。以便我们能更好掌握os的内存布局。</p>\n<h3 id=\"Makefile\"><a href=\"#Makefile\" class=\"headerlink\" title=\"Makefile\"></a>Makefile</h3><p>这里贴出makefile比较关键的代码：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 利用dd命令制作OS镜像，依赖bootblock和kernel，</span></span><br><span class=\"line\"><span class=\"comment\"># 首先划分了10000个扇区</span></span><br><span class=\"line\"><span class=\"comment\"># 然后将bootblock写到了第0号扇区</span></span><br><span class=\"line\"><span class=\"comment\"># 最后从1号扇区开始，填入OS的代码文件。</span></span><br><span class=\"line\"><span class=\"section\">xv6.img: bootblock kernel</span></span><br><span class=\"line\">\tdd if=/dev/zero of=xv6.img count=10000</span><br><span class=\"line\">\tdd if=bootblock of=xv6.img conv=notrunc</span><br><span class=\"line\">\tdd if=kernel of=xv6.img seek=1 conv=notrunc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 单独产生os的bootloader模块，并且该模块是使用$(OBJCOPY)产生，</span></span><br><span class=\"line\"><span class=\"comment\"># 所以没有elf文件头信息，只是单纯的二进制可执行文件。并且$(LD)规定</span></span><br><span class=\"line\"><span class=\"comment\"># 代码的入口点是start、并且从地址0x7C00（物理地址）开始，最终的文件名是bootblock</span></span><br><span class=\"line\"><span class=\"comment\"># 最后一步，调用pl脚本对引导扇区进行签名，在512字节引导扇区最后两字节写入0x55aa</span></span><br><span class=\"line\"><span class=\"section\">bootblock: bootasm.S bootmain.c</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -fno-pic -O -nostdinc -I. -c bootmain.c</span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -fno-pic -nostdinc -I. -c bootasm.S</span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S bootblock.o &gt; bootblock.asm</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJCOPY)</span> -S -O binary -j .text bootblock.o bootblock</span><br><span class=\"line\">\t./sign.pl bootblock</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 产生AP cpu的boot代码</span></span><br><span class=\"line\"><span class=\"comment\"># 指定程序的加载地址是0x7000（物理地址）</span></span><br><span class=\"line\"><span class=\"comment\"># 可执行代码的格式和bootblock相同，纯粹的二进制程序，没有elf的头部信息</span></span><br><span class=\"line\"><span class=\"comment\"># 但最终输出的entryother会和kernel合并</span></span><br><span class=\"line\"><span class=\"section\">entryother: entryother.S</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -fno-pic -nostdinc -I. -c entryother.S</span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJCOPY)</span> -S -O binary -j .text bootblockother.o entryother</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S bootblockother.o &gt; entryother.asm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 产生第一个进程，init进程的boot代码</span></span><br><span class=\"line\"><span class=\"comment\"># 同样以$(OBJCOPY)提取纯粹的可执行代码，没有elf头部信息，输出文件名为initcode</span></span><br><span class=\"line\"><span class=\"comment\"># 指定程序的加载地址是0（虚拟地址）</span></span><br><span class=\"line\"><span class=\"section\">initcode: initcode.S</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -nostdinc -I. -c initcode.S</span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -N -e start -Ttext 0 -o initcode.out initcode.o</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJCOPY)</span> -S -O binary initcode.out initcode</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S initcode.o &gt; initcode.asm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 产生内核的elf可执行文件</span></span><br><span class=\"line\"><span class=\"section\">kernel: <span class=\"variable\">$(OBJS)</span> entry.o entryother initcode kernel.ld</span></span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -T kernel.ld -o kernel entry.o <span class=\"variable\">$(OBJS)</span> -b binary initcode entryother</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S kernel &gt; kernel.asm</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -t kernel | sed &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; kernel.sym</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里编译器、链接器的选项具体作用读者可以自行百度，这里只阐述比较关键的部分。</p>\n<p>首先是利用dd命令制作xv6.img镜像，从代码中可以很清楚的看到，bootblock填到了第0号扇区、kernel填到了1号以及之后的扇区。bootblock作用就是使cpu从实时模式转换为保护模式，然后将kernel从磁盘上加载到内存。这里要注意一个特殊的数字0x7C00，它出现在生成bootblock二进制文件的$(LD)阶段，这里暗示了bootblock代码在加载进内存时应该被放在0x7C00的位置。事实也是如此，<strong>在BIOS完成硬件初始化后，就会将第0号扇区（一个扇区一般就是512字节）的512字节代码加载到内存的0x7C00的位置，然后BIOS就会让eip指向0x7C00的位置，去执行bootasm.S里面的汇编代码。</strong></p>\n<p>这里有个关键点：在使用$(LD)命令生成bootblock.o时，命令参数部分bootasm.o放在bootmain.o前面，会导致链接时，bootasm.o代码就会靠前，这样在eip执行0x7C00位置的代码时，一定是从start开始。</p>\n<p>bootblock是由$(OBJCOPY)生成，$(OBJCOPY)的作用就是去除elf文件中的各种头部，因为BIOS只负责从第0号扇区加载bootblock，不会解析elf文件，所以，$(OBJCOPY)去提取纯粹的二进制是非常有必要的！</p>\n<p>bootblock具体细节下面会详细探讨</p>\n<h3 id=\"kernel-ld\"><a href=\"#kernel-ld\" class=\"headerlink\" title=\"kernel.ld\"></a>kernel.ld</h3><p>这里贴出kernel.ld比较关键的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OUTPUT_FORMAT(&quot;elf32-i386&quot;, &quot;elf32-i386&quot;, &quot;elf32-i386&quot;)</span><br><span class=\"line\">OUTPUT_ARCH(i386)</span><br><span class=\"line\">ENTRY(_start)</span><br><span class=\"line\"></span><br><span class=\"line\">SECTIONS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t/* Link the kernel at this address: &quot;.&quot; means the current address */</span><br><span class=\"line\">        /* Must be equal to KERNLINK */</span><br><span class=\"line\">\t. = 0x80100000; // 定义代码起始的虚拟地址</span><br><span class=\"line\"></span><br><span class=\"line\">\t.text : AT(0x100000) &#123;  // 定义了起始加载地址</span><br><span class=\"line\">\t\t*(.text .stub .text.* .gnu.linkonce.t.*)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*</span><br><span class=\"line\">    省略...</span><br><span class=\"line\">  */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从kernel的链接脚本我们可以看到，kernel的起始虚拟内存地址是0x8010 0000，内核实际加载的物理地址是x100000，由AT定义。这里我反复标注了 虚拟地址 &#x2F; 物理地址 ，这两者一定要分清！</p>\n<h2 id=\"从实时模式到保护模式\"><a href=\"#从实时模式到保护模式\" class=\"headerlink\" title=\"从实时模式到保护模式\"></a>从实时模式到保护模式</h2><p>本段代码实现位于xv6的bootasm.S文件。具体细节如下，xv6使用的AT&amp;T的汇编，还是比较好懂的，读者有疑问的话，可以百度去搜相关指令的作用。英文注释已经非常详细，我就直接引用了。</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &quot;asm.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;memlayout.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;mmu.h&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Start the first CPU: switch to 32-bit protected mode, jump into C.</span></span><br><span class=\"line\"><span class=\"comment\"># The BIOS loads this code from the first sector of the hard disk into</span></span><br><span class=\"line\"><span class=\"comment\"># memory at physical address 0x7c00 and starts executing in real mode</span></span><br><span class=\"line\"><span class=\"comment\"># with %cs=0 %ip=7c00.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.code16</span>                       # Assemble for <span class=\"number\">16</span>-bit mode</span><br><span class=\"line\"><span class=\"symbol\">.globl</span> start</span><br><span class=\"line\"><span class=\"symbol\">start:</span></span><br><span class=\"line\">  cli                         # BIOS enabled interrupts<span class=\"comment\">; disable</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Zero data segment registers DS, ES, and SS.</span></span><br><span class=\"line\">  xorw    %ax,%ax             # Set %ax to zero</span><br><span class=\"line\">  movw    %ax,%ds             # -&gt; <span class=\"meta\">Data</span> Segment</span><br><span class=\"line\">  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class=\"line\">  movw    %ax,%ss             # -&gt; Stack Segment</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 硬件相关，主线是OS的启动，该部分不深究也没影响，其实就是一个固定步骤。</span></span><br><span class=\"line\">  <span class=\"comment\"># Physical address line A20 is tied to zero so that the first PCs </span></span><br><span class=\"line\">  <span class=\"comment\"># with 2 MB would run software that assumed 1 MB.  Undo that.</span></span><br><span class=\"line\"><span class=\"symbol\">seta20.1:</span></span><br><span class=\"line\">  inb     <span class=\"number\">$0x64</span>,%al               # Wait for not busy</span><br><span class=\"line\">  testb   <span class=\"number\">$0x2</span>,%al</span><br><span class=\"line\">  jnz     seta20.<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  movb    <span class=\"number\">$0xd1</span>,%al               # <span class=\"number\">0xd1</span> -&gt; port <span class=\"number\">0x64</span></span><br><span class=\"line\">  outb    %al,<span class=\"number\">$0x64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">seta20.2:</span></span><br><span class=\"line\">  inb     <span class=\"number\">$0x64</span>,%al               # Wait for not busy</span><br><span class=\"line\">  testb   <span class=\"number\">$0x2</span>,%al</span><br><span class=\"line\">  jnz     seta20.<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">  movb    <span class=\"number\">$0xdf</span>,%al               # <span class=\"number\">0xdf</span> -&gt; port <span class=\"number\">0x60</span></span><br><span class=\"line\">  outb    %al,<span class=\"number\">$0x60</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Switch from real to protected mode.  Use a bootstrap GDT that makes</span></span><br><span class=\"line\">  <span class=\"comment\"># virtual addresses map directly to physical addresses so that the</span></span><br><span class=\"line\">  <span class=\"comment\"># effective memory map doesn&#x27;t change during the transition.</span></span><br><span class=\"line\">  lgdt    gdtdesc</span><br><span class=\"line\">  movl    %cr0, %eax</span><br><span class=\"line\">  orl     $CR0_PE, %eax</span><br><span class=\"line\">  movl    %eax, %cr0</span><br><span class=\"line\"> <span class=\"comment\">########################### 以下正式进入32位保护模式</span></span><br><span class=\"line\"><span class=\"comment\">//PAGEBREAK!</span></span><br><span class=\"line\">  <span class=\"comment\"># Complete the transition to 32-bit protected mode by using a long jmp</span></span><br><span class=\"line\">  <span class=\"comment\"># to reload %cs and %eip.  The segment descriptors are set up with no</span></span><br><span class=\"line\">  <span class=\"comment\"># translation, so that the mapping is still the identity mapping.</span></span><br><span class=\"line\">  ljmp    $(SEG_KCODE&lt;&lt;<span class=\"number\">3</span>), $start32</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.code32</span>  # Tell assembler to generate <span class=\"number\">32</span>-bit <span class=\"meta\">code</span> now.</span><br><span class=\"line\"><span class=\"symbol\">start32:</span></span><br><span class=\"line\">  <span class=\"comment\"># Set up the protected-mode data segment registers</span></span><br><span class=\"line\">  movw    $(SEG_KDATA&lt;&lt;<span class=\"number\">3</span>), %ax    # Our <span class=\"meta\">data</span> segment selector</span><br><span class=\"line\">  movw    %ax, %ds                # -&gt; DS: <span class=\"meta\">Data</span> Segment</span><br><span class=\"line\">  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class=\"line\">  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br><span class=\"line\">  movw    <span class=\"number\">$0</span>, %ax                 # Zero segments not ready for use</span><br><span class=\"line\">  movw    %ax, %fs                # -&gt; FS</span><br><span class=\"line\">  movw    %ax, %gs                # -&gt; GS</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Set up the stack pointer and call into C.</span></span><br><span class=\"line\">  movl    $start, %esp            # 这里将esp栈设置到了start，由于栈向低地址处增长，所以刚好和bootasm文件的代码背道而驰。</span><br><span class=\"line\">  call    bootmain</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># If bootmain returns (it shouldn&#x27;t), trigger a Bochs</span></span><br><span class=\"line\">  <span class=\"comment\"># breakpoint if running under Bochs, then loop.</span></span><br><span class=\"line\">  movw    <span class=\"number\">$0x8a00</span>, %ax            # <span class=\"number\">0x8a00</span> -&gt; port <span class=\"number\">0x8a00</span></span><br><span class=\"line\">  movw    %ax, %dx</span><br><span class=\"line\">  outw    %ax, %dx</span><br><span class=\"line\">  movw    <span class=\"number\">$0x8ae0</span>, %ax            # <span class=\"number\">0x8ae0</span> -&gt; port <span class=\"number\">0x8a00</span></span><br><span class=\"line\">  outw    %ax, %dx</span><br><span class=\"line\"><span class=\"symbol\">spin:</span></span><br><span class=\"line\">  jmp     spin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Bootstrap GDT</span></span><br><span class=\"line\"><span class=\"symbol\">.p2align</span> <span class=\"number\">2</span>                                # force <span class=\"number\">4</span> byte alignment</span><br><span class=\"line\"><span class=\"symbol\">gdt:</span></span><br><span class=\"line\">  SEG_NULLASM                             # null seg</span><br><span class=\"line\">  SEG_ASM(STA_X<span class=\"title\">|STA_R, 0x0, 0xffffffff)   # code seg</span></span><br><span class=\"line\"><span class=\"title\">  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">gdtdesc:</span></span><br><span class=\"line\"><span class=\"title\">  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1</span></span><br><span class=\"line\"><span class=\"title\">  .long   gdt                             # address gdt</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br></pre></td></tr></table></figure>\n\n<p>这里先普及一下实时模式和保护模式的区别：</p>\n<ul>\n<li><p>实时模式：为兼容以前的PC。特点是：寄存器都是16位。寻址方式：16位的段寄存器 + 16位的偏移寄存器，最大寻址范围是20位。</p>\n</li>\n<li><p>保护模式：现代CPU的寻址方式。特点是：寄存器有16位、32为、64位。寻址方式：段描述符 + 32位偏移寄存器。最大寻址范围4G+。</p>\n</li>\n</ul>\n<p>bootasm.S是操作系统被加载内存前，最先开始执行的代码。BIOS是运行在实时模式下的程序，只拥有1M的寻址空间（<strong>boot代码被加载到0x7C00 &lt; 1M 就能证明存在1M的限制</strong>），所以在cpu拥有4G寻址空间前，还需要进行一些初始化操作，</p>\n<p>从实时模式 -&gt; 保护模式的转变流程非常固定，在xv6的bootasm中实现如下：</p>\n<ol start=\"0\">\n<li><p>对于多核处理器，最先启动的CPU（我们称为BSP（bootstrap processor）），BSP一上电就是实时模式。其余的从处理器（我们称为AP）在后面的内核初始化阶段会被BSP依次唤醒并初始化。</p>\n</li>\n<li><p>关中断。清空各种段寄存器，包括ds、es、ss。</p>\n</li>\n<li><p>打开A20地址线.</p>\n</li>\n<li><p>加载全局描述符表。即使用lgdt指令将表的地址和大小放在GDTR中。（这里的全局描述符表是临时的，后面内核初始化会更换一张gdt表，那张表更加完善。</p>\n</li>\n<li><p>将CR0寄存器第0位设置为1（PE位），此时正式转换成保护模式。</p>\n</li>\n<li><p>使用ljmp（长跳转指令）指令刷新段寄存器，跳到start32。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># xv6对ljmp的注释如下：</span><br><span class=\"line\"># Complete the transition to 32-bit protected mode by using a long jmp</span><br><span class=\"line\"># to reload %cs and %eip. </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化数据段、栈段寄存器，将esp设置到0x7C00处，跳到bootmain函数中，该函数会将XV6 OS加载到内存。</p>\n</li>\n</ol>\n<p>相关的结构如下：</p>\n<p>段描述符（Descriptor），描述一段地址的特性，包括基地址、范围、权限、粒度（范围以字节为单位还是以4K为单位）、类型（代码&#x2F;数据）等信息：</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/SegmentDescriptor.png\"></p>\n<p>全局描述符表，由许多个8字节段描述符组成的表：</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/GDT.png\"></p>\n<p>全局描述符表寄存器，其<strong>基地址</strong>的内容是全局描述符表的首地址，<strong>界限</strong>是全局描述符表的大小：</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/GDTR.png\"></p>\n<p>段选择子，【代码、数据、栈等】段使用了哪个段描述符，索引号指使用段描述符在全局描述符表的偏移（8字节为单位），第2位指明是全局描述符还是局部描述符，0~1位指示段的特权级：</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/SegmentSelector.png\"></p>\n<p>从低特权级的段空间 跳到 高特权级的段空间就会发生cpu特权级的切换，cpu就是通过全局描述符表来确定一个段的特权级。最典型的就是用户进程调用系统调用产生的特权级切换，这中间涉及查tss段、切栈等复杂操作，我们后面在进行详细的讨论。</p>\n<p>对于GDT的详细描述，这里推荐两篇博客，这两篇博客写的真的非常好！相信阅读之后，对全局描述符会有一个清晰的认识，全局描述符的几幅图片也是取自这两篇文章，如有侵权，可告知删除：</p>\n<p><a href=\"https://blog.csdn.net/abc123lzf/article/details/109289567\">详细介绍了段描述符各个位的作用</a></p>\n<p><a href=\"https://blog.csdn.net/me1171115772/article/details/51750442\">可以作为扩展，里面介绍了局部描述符的作用</a></p>\n<h2 id=\"正式将XV6加载到内存\"><a href=\"#正式将XV6加载到内存\" class=\"headerlink\" title=\"正式将XV6加载到内存\"></a>正式将XV6加载到内存</h2><p>分析该部分细节前，先需要了解一下elf文件的格式，我们重点关注elf文件的ELF header和Program header table。直接上各个字段的描述：</p>\n<p>引用自博客<a href=\"https://zhuanlan.zhihu.com/p/165336511\">https://zhuanlan.zhihu.com/p/165336511</a>如有侵权，可告知删除：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ELF_MAGIC 0x464C457FU  <span class=\"comment\">// &quot;\\x7FELF&quot; in little endian</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ELF 文件的头部</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">elfhdr</span> &#123;</span><br><span class=\"line\">  uint magic;       <span class=\"comment\">// 4 字节，为 0x464C457FU（大端模式）或 0x7felf（小端模式）</span></span><br><span class=\"line\">                      <span class=\"comment\">// 表明该文件是个 ELF 格式文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uchar elf[<span class=\"number\">12</span>];    <span class=\"comment\">// 12 字节，每字节对应意义如下：</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0 : 1 = 32 位程序；2 = 64 位程序</span></span><br><span class=\"line\">                    <span class=\"comment\">//     1 : 数据编码方式，0 = 无效；1 = 小端模式；2 = 大端模式</span></span><br><span class=\"line\">                    <span class=\"comment\">//     2 : 只是版本，固定为 0x1</span></span><br><span class=\"line\">                    <span class=\"comment\">//     3 : 目标操作系统架构</span></span><br><span class=\"line\">                    <span class=\"comment\">//     4 : 目标操作系统版本</span></span><br><span class=\"line\">                    <span class=\"comment\">//     5 ~ 11 : 固定为 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort type;      <span class=\"comment\">// 2 字节，表明该文件类型，意义如下：</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x0 : 未知目标文件格式</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x1 : 可重定位文件</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x2 : 可执行文件</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x3 : 共享目标文件</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x4 : 转储文件</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0xff00 : 特定处理器文件</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0xffff : 特定处理器文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort machine;   <span class=\"comment\">// 2 字节，表明运行该程序需要的计算机体系架构，</span></span><br><span class=\"line\">                    <span class=\"comment\">// 这里我们只需要知道 0x0 为未指定；0x3 为 x86 架构</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint version;     <span class=\"comment\">// 4 字节，表示该文件的版本号</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint entry;       <span class=\"comment\">// 4 字节，该文件的入口地址，没有入口（非可执行文件）则为 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint phoff;       <span class=\"comment\">// 4 字节，表示该文件的“程序头部表”相对于文件的位置，单位是字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint shoff;       <span class=\"comment\">// 4 字节，表示该文件的“节区头部表”相对于文件的位置，单位是字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint flags;       <span class=\"comment\">// 4 字节，特定处理器标志</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort ehsize;    <span class=\"comment\">// 2 字节，ELF文件头部的大小，单位是字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort phentsize; <span class=\"comment\">// 2 字节，表示程序头部表中一个入口的大小，单位是字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort phnum;     <span class=\"comment\">// 2 字节，表示程序头部表的入口个数，</span></span><br><span class=\"line\">                    <span class=\"comment\">// phnum * phentsize = 程序头部表大小（单位是字节）</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort shentsize; <span class=\"comment\">// 2 字节，节区头部表入口大小，单位是字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort shnum;     <span class=\"comment\">// 2 字节，节区头部表入口个数，</span></span><br><span class=\"line\">                    <span class=\"comment\">// shnum * shentsize = 节区头部表大小（单位是字节）</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort shstrndx;  <span class=\"comment\">// 2 字节，表示字符表相关入口的节区头部表索引</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序头表</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">proghdr</span> &#123;</span><br><span class=\"line\">  uint type;        <span class=\"comment\">// 4 字节， 段类型</span></span><br><span class=\"line\">                    <span class=\"comment\">//         1 PT_LOAD : 可载入的段</span></span><br><span class=\"line\">                    <span class=\"comment\">//         2 PT_DYNAMIC : 动态链接信息</span></span><br><span class=\"line\">                    <span class=\"comment\">//         3 PT_INTERP : 指定要作为解释程序调用的以空字符结尾的路径名的位置和大小</span></span><br><span class=\"line\">                    <span class=\"comment\">//         4 PT_NOTE : 指定辅助信息的位置和大小</span></span><br><span class=\"line\">                    <span class=\"comment\">//         5 PT_SHLIB : 保留类型，但具有未指定的语义</span></span><br><span class=\"line\">                    <span class=\"comment\">//         6 PT_PHDR : 指定程序头表在文件及程序内存映像中的位置和大小</span></span><br><span class=\"line\">                    <span class=\"comment\">//         7 PT_TLS : 指定线程局部存储模板</span></span><br><span class=\"line\">  uint off;         <span class=\"comment\">// 4 字节， 段的第一个字节在文件中的偏移</span></span><br><span class=\"line\">  uint vaddr;       <span class=\"comment\">// 4 字节， 段的第一个字节在内存中的虚拟地址</span></span><br><span class=\"line\">  uint paddr;       <span class=\"comment\">// 4 字节， 段的第一个字节在内存中的物理地址(适用于物理内存定位型的系统)</span></span><br><span class=\"line\">  uint filesz;      <span class=\"comment\">// 4 字节， 段在文件中的长度</span></span><br><span class=\"line\">  uint memsz;       <span class=\"comment\">// 4 字节， 段在内存中的长度</span></span><br><span class=\"line\">  uint flags;       <span class=\"comment\">// 4 字节， 段标志</span></span><br><span class=\"line\">                    <span class=\"comment\">//         1 : 可执行</span></span><br><span class=\"line\">                    <span class=\"comment\">//         2 : 可写入</span></span><br><span class=\"line\">                    <span class=\"comment\">//         4 : 可读取</span></span><br><span class=\"line\">  uint align;       <span class=\"comment\">// 4 字节， 段在文件及内存中如何对齐</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果感兴趣的话，可以参考文章：<a href=\"https://blog.csdn.net/pingxiaozhao/article/details/109239221\">ELF文件格式的详解</a>，这篇文章讲解的更为详细，但是对于现阶段来说，可以不用了解太仔细，知道elf文件的ELF header和Program header table各个字段的作用就足够你继续学习XV6操作系统。</p>\n<p>对kernel elf文件解析的主流程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">bootmain</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">elfhdr</span> *elf;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proghdr</span> *ph, *eph;</span><br><span class=\"line\">  <span class=\"built_in\">void</span> (*entry)(<span class=\"type\">void</span>);</span><br><span class=\"line\">  uchar* pa;</span><br><span class=\"line\">  <span class=\"comment\">// 预留足够空间</span></span><br><span class=\"line\">  <span class=\"comment\">// 46K</span></span><br><span class=\"line\">  elf = (<span class=\"keyword\">struct</span> elfhdr*)<span class=\"number\">0x10000</span>;  <span class=\"comment\">// scratch space</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 以0为偏移读4096个字节，读elf文件头</span></span><br><span class=\"line\">  <span class=\"comment\">// Read 1st page off disk</span></span><br><span class=\"line\">  <span class=\"built_in\">readseg</span>((uchar*)elf, <span class=\"number\">4096</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 判断elf文件魔数。</span></span><br><span class=\"line\">  <span class=\"comment\">// Is this an ELF executable?</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(elf-&gt;magic != ELF_MAGIC)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;  <span class=\"comment\">// let bootasm.S handle error</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定位到Program header table</span></span><br><span class=\"line\">  <span class=\"comment\">// Load each program segment (ignores ph flags).</span></span><br><span class=\"line\">  ph = (<span class=\"keyword\">struct</span> proghdr*)((uchar*)elf + elf-&gt;phoff);</span><br><span class=\"line\">  <span class=\"comment\">// 程序头部表个数</span></span><br><span class=\"line\">  eph = ph + elf-&gt;phnum;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 一个段一个段的读</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; ph &lt; eph; ph++)&#123;  <span class=\"comment\">// 以struct proghdr为单位自增。</span></span><br><span class=\"line\">    <span class=\"comment\">// 应该加载到的物理内存，xv6中是0x100000</span></span><br><span class=\"line\">    pa = (uchar*)ph-&gt;paddr;</span><br><span class=\"line\">    <span class=\"comment\">// 读取整个段到pa中</span></span><br><span class=\"line\">    <span class=\"built_in\">readseg</span>(pa, ph-&gt;filesz, ph-&gt;off);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ph-&gt;memsz &gt; ph-&gt;filesz)</span><br><span class=\"line\">      <span class=\"comment\">// mem大小比file大小大，多余的补零</span></span><br><span class=\"line\">      <span class=\"built_in\">stosb</span>(pa + ph-&gt;filesz, <span class=\"number\">0</span>, ph-&gt;memsz - ph-&gt;filesz);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Call the entry point from the ELF header.</span></span><br><span class=\"line\">  <span class=\"comment\">// Does not return!</span></span><br><span class=\"line\">  entry = (<span class=\"built_in\">void</span>(*)(<span class=\"type\">void</span>))(elf-&gt;entry);  <span class=\"comment\">// 在xv6的kernel.ld中描述为_start</span></span><br><span class=\"line\">  <span class=\"built_in\">entry</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前半部分做的操作就是不断从kernel的elf文件中按照程序头将各个段读取到内存。后面通过elf头中的entry，该字段保存内核入口点_start（这可以通过阅读kernel.ld文件来证明），去执行_start开始的代码，这里要提醒读者的是，到目前为止，对cpu来说状态是：保护模式 &amp; 已经装填了全局描述符 &amp; <strong>一切地址皆是物理地址</strong>。而kernel的elf文件中代码都是使用的（0x8010 0000开始的）虚拟地址，所以我们后面在entry.S中会看到，在给_start赋值前，会通过一个宏将真正的入口地址的虚拟地址转换为XV6加载到内存的物理地址。从而我们在物理地址寻址模式下，可以利用_start准确跳转到xv6的入口代码。</p>\n<p>需要注意的是：<strong>在执行bootasm汇编代码时，esp的位置是不确定的，唯一能确定的是esp在1M空间之内。在bootasm汇编最后才会将esp挪到0x7c00的位置！</strong></p>\n<p>在bootmain执行完毕后，内存布局如下：</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/boot.drawio.png\"></p>\n<p>接下来深入分析一下从磁盘读取文件的细节，这些内容都是和硬件相关的，通过操作硬件寄存器来实现读写磁盘，这部分深入下去也是挺让人头大的，作者也是菜鸟一个，也就力所能及的叙述一些自己明白的东西吧。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">waitdisk</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Wait for disk ready.</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>((<span class=\"built_in\">inb</span>(<span class=\"number\">0x1F7</span>) &amp; <span class=\"number\">0xC0</span>) != <span class=\"number\">0x40</span>)</span><br><span class=\"line\">    ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// readsect也引用自https://zhuanlan.zhihu.com/p/165336511，如有侵权，可联系我删除</span></span><br><span class=\"line\"><span class=\"comment\">// Read a single sector at offset into dst.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">readsect</span><span class=\"params\">(<span class=\"type\">void</span> *dst, uint offset)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Issue command.</span></span><br><span class=\"line\">  <span class=\"built_in\">waitdisk</span>();</span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F2</span>, <span class=\"number\">1</span>);   <span class=\"comment\">// count = 1          // 要读取的扇区数量 count = 1</span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F3</span>, offset);                    <span class=\"comment\">// 扇区 LBA 地址的 0-7 位</span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F4</span>, offset &gt;&gt; <span class=\"number\">8</span>);               <span class=\"comment\">// 扇区 LBA 地址的 8-15 位</span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F5</span>, offset &gt;&gt; <span class=\"number\">16</span>);              <span class=\"comment\">// 扇区 LBA 地址的 16-23 位</span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F6</span>, (offset &gt;&gt; <span class=\"number\">24</span>) | <span class=\"number\">0xE0</span>);     <span class=\"comment\">// offset | 11100000 保证高三位恒为 1</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         第7位     恒为1</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         第6位     LBA模式的开关，置1为LBA模式</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         第5位     恒为1</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         第4位     为0代表主硬盘、为1代表从硬盘</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         第3~0位   扇区 LBA 地址的 24-27 位</span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F7</span>, <span class=\"number\">0x20</span>);  <span class=\"comment\">// cmd 0x20 - read sectors  // 20h为读，30h为写</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Read data.</span></span><br><span class=\"line\">  <span class=\"built_in\">waitdisk</span>();</span><br><span class=\"line\">  <span class=\"built_in\">insl</span>(<span class=\"number\">0x1F0</span>, dst, SECTSIZE/<span class=\"number\">4</span>); <span class=\"comment\">// 读的时候以4字节位单位读，所以需要扇区除以4，代表要读的次数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Read &#x27;count&#x27; bytes at &#x27;offset&#x27; from kernel into physical address &#x27;pa&#x27;.</span></span><br><span class=\"line\"><span class=\"comment\">// Might copy more than asked.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">readseg</span><span class=\"params\">(uchar* pa, uint count, uint offset)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  uchar* epa; <span class=\"comment\">// end phy addr</span></span><br><span class=\"line\"></span><br><span class=\"line\">  epa = pa + count; <span class=\"comment\">// 结束地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 这里将起始物理地址回退了offset的SECTSIZE（512）余数个Byte</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为在从磁盘上读数据的时候，以512字节进行读取。所以offset会以512为单位向下取整，</span></span><br><span class=\"line\">  <span class=\"comment\">// 被换算成扇区号的偏移。如果offset原来不是SECTSIZE的整数倍，向下取整会导致offset截断，</span></span><br><span class=\"line\">  <span class=\"comment\">// 记换算后的offset为ofs，此时如果直接读取ofs扇区会多读offset % SECTSIZE个字节，</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以需要提前将pa的地址减去offset % SECTSIZE个字节来排除offset被截断的多余的字节。</span></span><br><span class=\"line\">  <span class=\"comment\">// Round down to sector boundary.</span></span><br><span class=\"line\">  pa -= offset % SECTSIZE;    </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将offset换算成扇区号</span></span><br><span class=\"line\">  <span class=\"comment\">// Translate from bytes to sectors; kernel starts at sector 1.</span></span><br><span class=\"line\">  offset = (offset / SECTSIZE) + <span class=\"number\">1</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 依次读取每个扇区，最后一个扇区多读了也没关系。</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; pa &lt; epa; pa += SECTSIZE, offset++)</span><br><span class=\"line\">    <span class=\"built_in\">readsect</span>(pa, offset);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>仔细推敲readseg函数中pa回滚的操作，总感觉这样贸然回滚，会覆盖之前已经被加载到内存中的代码。既然xv6敢这样写，八成说明是没有问题的，具体的原因，作者实在琢磨不透，如果有了解的朋友，可以在评论区交流一下。</p>\n<h2 id=\"跳到-start，正式进入内核前的预初始化\"><a href=\"#跳到-start，正式进入内核前的预初始化\" class=\"headerlink\" title=\"跳到_start，正式进入内核前的预初始化\"></a>跳到_start，正式进入内核前的预初始化</h2><p>相关代码文件是entry.S</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &quot;asm.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;memlayout.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;mmu.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;param.h&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Multiboot header.  Data to direct multiboot loader.</span></span><br><span class=\"line\"><span class=\"symbol\">.p2align</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"symbol\">.text</span></span><br><span class=\"line\"><span class=\"symbol\">.globl</span> multiboot_header</span><br><span class=\"line\"><span class=\"symbol\">multiboot_header:</span></span><br><span class=\"line\">  <span class=\"comment\">#define magic 0x1badb002</span></span><br><span class=\"line\">  <span class=\"comment\">#define flags 0</span></span><br><span class=\"line\">  <span class=\"meta\">.long</span> magic</span><br><span class=\"line\">  <span class=\"meta\">.long</span> flags</span><br><span class=\"line\">  <span class=\"meta\">.long</span> (-magic-flags)</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 这里就能看到，因为elf描述的一些标签是使用的虚拟地址，</span></span><br><span class=\"line\"><span class=\"comment\"># 而在进入entry开启分页前都是使用的物理地址，所以使用了</span></span><br><span class=\"line\"><span class=\"comment\"># V2P_WO宏将entry转换成了物理地址。方便bootmain跳转到entry.</span></span><br><span class=\"line\"><span class=\"comment\"># V2P_WO展开就是将输入的地址减去 0x8000 0000 的偏移。</span></span><br><span class=\"line\"><span class=\"symbol\">.globl</span> _start</span><br><span class=\"line\"><span class=\"symbol\">_start</span> = V2P_WO(<span class=\"meta\">entry</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Entering xv6 on boot processor, with paging off.</span></span><br><span class=\"line\"><span class=\"symbol\">.globl</span> <span class=\"meta\">entry</span></span><br><span class=\"line\"><span class=\"symbol\">entry:</span></span><br><span class=\"line\">  <span class=\"comment\"># 打开4M big page开关</span></span><br><span class=\"line\">  <span class=\"comment\"># Turn on page size extension for 4Mbyte pages</span></span><br><span class=\"line\">  movl    %cr4, %eax</span><br><span class=\"line\">  orl     $(CR4_PSE), %eax</span><br><span class=\"line\">  movl    %eax, %cr4</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 将页目录设置为entrypgdir，同样由于在启用虚拟内存前，</span></span><br><span class=\"line\">  <span class=\"comment\"># 需要将虚拟地址entrypgdir转换为物理地址，有关entrypgdir</span></span><br><span class=\"line\">  <span class=\"comment\"># 的定义在内存管理章节进行详细叙述。</span></span><br><span class=\"line\">  <span class=\"comment\"># Set page directory</span></span><br><span class=\"line\">  movl    $(V2P_WO(entrypgdir)), %eax</span><br><span class=\"line\">  movl    %eax, %cr3</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 开启分页</span></span><br><span class=\"line\">  <span class=\"comment\"># Turn on paging.</span></span><br><span class=\"line\">  movl    %cr0, %eax</span><br><span class=\"line\">  orl     $(CR0_PG<span class=\"title\">|CR0_WP), %eax</span></span><br><span class=\"line\"><span class=\"title\">  movl    %eax, %cr0</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">  ########################### 以下正式进入分页模式，地址皆是虚拟地址</span></span><br><span class=\"line\"><span class=\"title\">  # 再一次修改esp指针，将esp移到内核代码范围中</span></span><br><span class=\"line\"><span class=\"title\">  # Set up the stack pointer.</span></span><br><span class=\"line\"><span class=\"title\">  movl $(stack + KSTACKSIZE), %esp</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">  # 真正进入内核main函数，开始各种初始化。</span></span><br><span class=\"line\"><span class=\"title\">  mov $main, %eax</span></span><br><span class=\"line\"><span class=\"title\">  jmp *%eax</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">.comm stack, KSTACKSIZE</span></span><br></pre></td></tr></table></figure>\n\n<p>该部分代码负责进入main函数前的初始化，主要工作如下：</p>\n<ol>\n<li><p>打开4M big page分页开关，让cpu支持4M大页。entrypgdir会将内核区域与映射为物理地址低4M的大页，我们后面会详细进行讨论，entrypgdir的生命周期非常短，在main函数中初始化过程中，会另外产生一个粒度更小的页表kpgdir（4K为一页），该页表会一直作为xv6的内核页表。</p>\n</li>\n<li><p>设置entrypgdir为BSP（booststrap processor）的页目录。</p>\n</li>\n<li><p>开启分页。</p>\n</li>\n<li><p>修改esp。指向内核自己分配的4K大小的栈上。</p>\n</li>\n<li><p>进入main。</p>\n</li>\n</ol>\n<p>在entry.S代码执行完后，cpu开启分页模式，所有的地址都将以虚拟地址的形式存在。此时内存布局如下：</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/entry.drawio.png\"></p>\n<p>至此，cpu的预初始化进行完毕。下面几章将围绕内核的初始化去讲解类unix操作系统的内存管理、进程调度、文件系统子模块。</p>\n<hr>\n<p><strong>本章完结</strong></p>\n","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Onix是一款相对于XV6来说功能更为健全的单核OS，由于功能更加完善，Onix也更加复杂。代码阅读起来会比较绕。</p>\n<p>XV6是一款简单易读的多核操作系统，但其功能相对Onix来说更为简陋，比如Onix对物理内存的管理采用了位图、内核内存和进程相关的内存进行了分开管理，页目录使用单独的内核内存，没有和页表、页框混用等。而XV6显得非常简陋。尽管XV6的实验可以弥补部分缺陷。</p>\n<p>Onix操作系统也实现了bootloader，对于将OS加载到内存的操作，Onix是采用汇编进行内核加载，并且在加载内核前，还会进行一个内存探测的操作，所以Onix的bootloader稍微有些复杂。而XV6操作系统的启动操作写的非常简洁，加载内核的操作采用的是C语言的形式，非常利于阅读学习，但是XV6不会进行内存探测。为求方便，本文主要叙述XV6的启动流程。</p>\n<p>Onix相关链接：</p>\n<ul>\n<li><p><a href=\"https://github.com/StevenBaby/onix\">github仓库链接</a></p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/BV1qM4y127om/\">B站配套视频链接</a></p>\n</li>\n</ul>\n<p>XV6-x86的github链接：</p>\n<ul>\n<li><a href=\"https://github.com/mit-pdos/xv6-public\">链接</a></li>\n</ul>","more":"<h2 id=\"Makefile-kernel-ld文件的分析\"><a href=\"#Makefile-kernel-ld文件的分析\" class=\"headerlink\" title=\"Makefile &amp; kernel.ld文件的分析\"></a>Makefile &amp; kernel.ld文件的分析</h2><p>首先科普一个概念 —— 引导扇区</p>\n<p><strong>引导扇区：是计算机启动过程中 BIOS 读取的第一个磁盘扇区（通常为 512 字节），用于加载操作系统或更复杂的引导程序（如 GRUB）。</strong></p>\n<p>BISO规定引导扇区有如下要求：</p>\n<ol>\n<li>引导扇区的代码被加载到内存的0x7c00位置执行</li>\n<li>引导扇区有且仅有512字节。</li>\n<li>引导扇区的魔数在最后两个字节的位置，值0x55aa。</li>\n</ol>\n<p>在叙述os启动前，必须要了解其Makefile是怎么写的。同时，在了解bootmain从镜像中加载os的代码到内存中前，因为os是elf格式，所以我们需要了解os的link脚本是怎么布局的。以便我们能更好掌握os的内存布局。</p>\n<h3 id=\"Makefile\"><a href=\"#Makefile\" class=\"headerlink\" title=\"Makefile\"></a>Makefile</h3><p>这里贴出makefile比较关键的代码：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 利用dd命令制作OS镜像，依赖bootblock和kernel，</span></span><br><span class=\"line\"><span class=\"comment\"># 首先划分了10000个扇区</span></span><br><span class=\"line\"><span class=\"comment\"># 然后将bootblock写到了第0号扇区</span></span><br><span class=\"line\"><span class=\"comment\"># 最后从1号扇区开始，填入OS的代码文件。</span></span><br><span class=\"line\"><span class=\"section\">xv6.img: bootblock kernel</span></span><br><span class=\"line\">\tdd if=/dev/zero of=xv6.img count=10000</span><br><span class=\"line\">\tdd if=bootblock of=xv6.img conv=notrunc</span><br><span class=\"line\">\tdd if=kernel of=xv6.img seek=1 conv=notrunc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 单独产生os的bootloader模块，并且该模块是使用$(OBJCOPY)产生，</span></span><br><span class=\"line\"><span class=\"comment\"># 所以没有elf文件头信息，只是单纯的二进制可执行文件。并且$(LD)规定</span></span><br><span class=\"line\"><span class=\"comment\"># 代码的入口点是start、并且从地址0x7C00（物理地址）开始，最终的文件名是bootblock</span></span><br><span class=\"line\"><span class=\"comment\"># 最后一步，调用pl脚本对引导扇区进行签名，在512字节引导扇区最后两字节写入0x55aa</span></span><br><span class=\"line\"><span class=\"section\">bootblock: bootasm.S bootmain.c</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -fno-pic -O -nostdinc -I. -c bootmain.c</span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -fno-pic -nostdinc -I. -c bootasm.S</span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S bootblock.o &gt; bootblock.asm</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJCOPY)</span> -S -O binary -j .text bootblock.o bootblock</span><br><span class=\"line\">\t./sign.pl bootblock</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 产生AP cpu的boot代码</span></span><br><span class=\"line\"><span class=\"comment\"># 指定程序的加载地址是0x7000（物理地址）</span></span><br><span class=\"line\"><span class=\"comment\"># 可执行代码的格式和bootblock相同，纯粹的二进制程序，没有elf的头部信息</span></span><br><span class=\"line\"><span class=\"comment\"># 但最终输出的entryother会和kernel合并</span></span><br><span class=\"line\"><span class=\"section\">entryother: entryother.S</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -fno-pic -nostdinc -I. -c entryother.S</span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJCOPY)</span> -S -O binary -j .text bootblockother.o entryother</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S bootblockother.o &gt; entryother.asm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 产生第一个进程，init进程的boot代码</span></span><br><span class=\"line\"><span class=\"comment\"># 同样以$(OBJCOPY)提取纯粹的可执行代码，没有elf头部信息，输出文件名为initcode</span></span><br><span class=\"line\"><span class=\"comment\"># 指定程序的加载地址是0（虚拟地址）</span></span><br><span class=\"line\"><span class=\"section\">initcode: initcode.S</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -nostdinc -I. -c initcode.S</span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -N -e start -Ttext 0 -o initcode.out initcode.o</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJCOPY)</span> -S -O binary initcode.out initcode</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S initcode.o &gt; initcode.asm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 产生内核的elf可执行文件</span></span><br><span class=\"line\"><span class=\"section\">kernel: <span class=\"variable\">$(OBJS)</span> entry.o entryother initcode kernel.ld</span></span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -T kernel.ld -o kernel entry.o <span class=\"variable\">$(OBJS)</span> -b binary initcode entryother</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S kernel &gt; kernel.asm</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -t kernel | sed &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; kernel.sym</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里编译器、链接器的选项具体作用读者可以自行百度，这里只阐述比较关键的部分。</p>\n<p>首先是利用dd命令制作xv6.img镜像，从代码中可以很清楚的看到，bootblock填到了第0号扇区、kernel填到了1号以及之后的扇区。bootblock作用就是使cpu从实时模式转换为保护模式，然后将kernel从磁盘上加载到内存。这里要注意一个特殊的数字0x7C00，它出现在生成bootblock二进制文件的$(LD)阶段，这里暗示了bootblock代码在加载进内存时应该被放在0x7C00的位置。事实也是如此，<strong>在BIOS完成硬件初始化后，就会将第0号扇区（一个扇区一般就是512字节）的512字节代码加载到内存的0x7C00的位置，然后BIOS就会让eip指向0x7C00的位置，去执行bootasm.S里面的汇编代码。</strong></p>\n<p>这里有个关键点：在使用$(LD)命令生成bootblock.o时，命令参数部分bootasm.o放在bootmain.o前面，会导致链接时，bootasm.o代码就会靠前，这样在eip执行0x7C00位置的代码时，一定是从start开始。</p>\n<p>bootblock是由$(OBJCOPY)生成，$(OBJCOPY)的作用就是去除elf文件中的各种头部，因为BIOS只负责从第0号扇区加载bootblock，不会解析elf文件，所以，$(OBJCOPY)去提取纯粹的二进制是非常有必要的！</p>\n<p>bootblock具体细节下面会详细探讨</p>\n<h3 id=\"kernel-ld\"><a href=\"#kernel-ld\" class=\"headerlink\" title=\"kernel.ld\"></a>kernel.ld</h3><p>这里贴出kernel.ld比较关键的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OUTPUT_FORMAT(&quot;elf32-i386&quot;, &quot;elf32-i386&quot;, &quot;elf32-i386&quot;)</span><br><span class=\"line\">OUTPUT_ARCH(i386)</span><br><span class=\"line\">ENTRY(_start)</span><br><span class=\"line\"></span><br><span class=\"line\">SECTIONS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t/* Link the kernel at this address: &quot;.&quot; means the current address */</span><br><span class=\"line\">        /* Must be equal to KERNLINK */</span><br><span class=\"line\">\t. = 0x80100000; // 定义代码起始的虚拟地址</span><br><span class=\"line\"></span><br><span class=\"line\">\t.text : AT(0x100000) &#123;  // 定义了起始加载地址</span><br><span class=\"line\">\t\t*(.text .stub .text.* .gnu.linkonce.t.*)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*</span><br><span class=\"line\">    省略...</span><br><span class=\"line\">  */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从kernel的链接脚本我们可以看到，kernel的起始虚拟内存地址是0x8010 0000，内核实际加载的物理地址是x100000，由AT定义。这里我反复标注了 虚拟地址 &#x2F; 物理地址 ，这两者一定要分清！</p>\n<h2 id=\"从实时模式到保护模式\"><a href=\"#从实时模式到保护模式\" class=\"headerlink\" title=\"从实时模式到保护模式\"></a>从实时模式到保护模式</h2><p>本段代码实现位于xv6的bootasm.S文件。具体细节如下，xv6使用的AT&amp;T的汇编，还是比较好懂的，读者有疑问的话，可以百度去搜相关指令的作用。英文注释已经非常详细，我就直接引用了。</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &quot;asm.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;memlayout.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;mmu.h&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Start the first CPU: switch to 32-bit protected mode, jump into C.</span></span><br><span class=\"line\"><span class=\"comment\"># The BIOS loads this code from the first sector of the hard disk into</span></span><br><span class=\"line\"><span class=\"comment\"># memory at physical address 0x7c00 and starts executing in real mode</span></span><br><span class=\"line\"><span class=\"comment\"># with %cs=0 %ip=7c00.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.code16</span>                       # Assemble for <span class=\"number\">16</span>-bit mode</span><br><span class=\"line\"><span class=\"symbol\">.globl</span> start</span><br><span class=\"line\"><span class=\"symbol\">start:</span></span><br><span class=\"line\">  cli                         # BIOS enabled interrupts<span class=\"comment\">; disable</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Zero data segment registers DS, ES, and SS.</span></span><br><span class=\"line\">  xorw    %ax,%ax             # Set %ax to zero</span><br><span class=\"line\">  movw    %ax,%ds             # -&gt; <span class=\"meta\">Data</span> Segment</span><br><span class=\"line\">  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class=\"line\">  movw    %ax,%ss             # -&gt; Stack Segment</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 硬件相关，主线是OS的启动，该部分不深究也没影响，其实就是一个固定步骤。</span></span><br><span class=\"line\">  <span class=\"comment\"># Physical address line A20 is tied to zero so that the first PCs </span></span><br><span class=\"line\">  <span class=\"comment\"># with 2 MB would run software that assumed 1 MB.  Undo that.</span></span><br><span class=\"line\"><span class=\"symbol\">seta20.1:</span></span><br><span class=\"line\">  inb     <span class=\"number\">$0x64</span>,%al               # Wait for not busy</span><br><span class=\"line\">  testb   <span class=\"number\">$0x2</span>,%al</span><br><span class=\"line\">  jnz     seta20.<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  movb    <span class=\"number\">$0xd1</span>,%al               # <span class=\"number\">0xd1</span> -&gt; port <span class=\"number\">0x64</span></span><br><span class=\"line\">  outb    %al,<span class=\"number\">$0x64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">seta20.2:</span></span><br><span class=\"line\">  inb     <span class=\"number\">$0x64</span>,%al               # Wait for not busy</span><br><span class=\"line\">  testb   <span class=\"number\">$0x2</span>,%al</span><br><span class=\"line\">  jnz     seta20.<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">  movb    <span class=\"number\">$0xdf</span>,%al               # <span class=\"number\">0xdf</span> -&gt; port <span class=\"number\">0x60</span></span><br><span class=\"line\">  outb    %al,<span class=\"number\">$0x60</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Switch from real to protected mode.  Use a bootstrap GDT that makes</span></span><br><span class=\"line\">  <span class=\"comment\"># virtual addresses map directly to physical addresses so that the</span></span><br><span class=\"line\">  <span class=\"comment\"># effective memory map doesn&#x27;t change during the transition.</span></span><br><span class=\"line\">  lgdt    gdtdesc</span><br><span class=\"line\">  movl    %cr0, %eax</span><br><span class=\"line\">  orl     $CR0_PE, %eax</span><br><span class=\"line\">  movl    %eax, %cr0</span><br><span class=\"line\"> <span class=\"comment\">########################### 以下正式进入32位保护模式</span></span><br><span class=\"line\"><span class=\"comment\">//PAGEBREAK!</span></span><br><span class=\"line\">  <span class=\"comment\"># Complete the transition to 32-bit protected mode by using a long jmp</span></span><br><span class=\"line\">  <span class=\"comment\"># to reload %cs and %eip.  The segment descriptors are set up with no</span></span><br><span class=\"line\">  <span class=\"comment\"># translation, so that the mapping is still the identity mapping.</span></span><br><span class=\"line\">  ljmp    $(SEG_KCODE&lt;&lt;<span class=\"number\">3</span>), $start32</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.code32</span>  # Tell assembler to generate <span class=\"number\">32</span>-bit <span class=\"meta\">code</span> now.</span><br><span class=\"line\"><span class=\"symbol\">start32:</span></span><br><span class=\"line\">  <span class=\"comment\"># Set up the protected-mode data segment registers</span></span><br><span class=\"line\">  movw    $(SEG_KDATA&lt;&lt;<span class=\"number\">3</span>), %ax    # Our <span class=\"meta\">data</span> segment selector</span><br><span class=\"line\">  movw    %ax, %ds                # -&gt; DS: <span class=\"meta\">Data</span> Segment</span><br><span class=\"line\">  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class=\"line\">  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br><span class=\"line\">  movw    <span class=\"number\">$0</span>, %ax                 # Zero segments not ready for use</span><br><span class=\"line\">  movw    %ax, %fs                # -&gt; FS</span><br><span class=\"line\">  movw    %ax, %gs                # -&gt; GS</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Set up the stack pointer and call into C.</span></span><br><span class=\"line\">  movl    $start, %esp            # 这里将esp栈设置到了start，由于栈向低地址处增长，所以刚好和bootasm文件的代码背道而驰。</span><br><span class=\"line\">  call    bootmain</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># If bootmain returns (it shouldn&#x27;t), trigger a Bochs</span></span><br><span class=\"line\">  <span class=\"comment\"># breakpoint if running under Bochs, then loop.</span></span><br><span class=\"line\">  movw    <span class=\"number\">$0x8a00</span>, %ax            # <span class=\"number\">0x8a00</span> -&gt; port <span class=\"number\">0x8a00</span></span><br><span class=\"line\">  movw    %ax, %dx</span><br><span class=\"line\">  outw    %ax, %dx</span><br><span class=\"line\">  movw    <span class=\"number\">$0x8ae0</span>, %ax            # <span class=\"number\">0x8ae0</span> -&gt; port <span class=\"number\">0x8a00</span></span><br><span class=\"line\">  outw    %ax, %dx</span><br><span class=\"line\"><span class=\"symbol\">spin:</span></span><br><span class=\"line\">  jmp     spin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Bootstrap GDT</span></span><br><span class=\"line\"><span class=\"symbol\">.p2align</span> <span class=\"number\">2</span>                                # force <span class=\"number\">4</span> byte alignment</span><br><span class=\"line\"><span class=\"symbol\">gdt:</span></span><br><span class=\"line\">  SEG_NULLASM                             # null seg</span><br><span class=\"line\">  SEG_ASM(STA_X<span class=\"title\">|STA_R, 0x0, 0xffffffff)   # code seg</span></span><br><span class=\"line\"><span class=\"title\">  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">gdtdesc:</span></span><br><span class=\"line\"><span class=\"title\">  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1</span></span><br><span class=\"line\"><span class=\"title\">  .long   gdt                             # address gdt</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br></pre></td></tr></table></figure>\n\n<p>这里先普及一下实时模式和保护模式的区别：</p>\n<ul>\n<li><p>实时模式：为兼容以前的PC。特点是：寄存器都是16位。寻址方式：16位的段寄存器 + 16位的偏移寄存器，最大寻址范围是20位。</p>\n</li>\n<li><p>保护模式：现代CPU的寻址方式。特点是：寄存器有16位、32为、64位。寻址方式：段描述符 + 32位偏移寄存器。最大寻址范围4G+。</p>\n</li>\n</ul>\n<p>bootasm.S是操作系统被加载内存前，最先开始执行的代码。BIOS是运行在实时模式下的程序，只拥有1M的寻址空间（<strong>boot代码被加载到0x7C00 &lt; 1M 就能证明存在1M的限制</strong>），所以在cpu拥有4G寻址空间前，还需要进行一些初始化操作，</p>\n<p>从实时模式 -&gt; 保护模式的转变流程非常固定，在xv6的bootasm中实现如下：</p>\n<ol start=\"0\">\n<li><p>对于多核处理器，最先启动的CPU（我们称为BSP（bootstrap processor）），BSP一上电就是实时模式。其余的从处理器（我们称为AP）在后面的内核初始化阶段会被BSP依次唤醒并初始化。</p>\n</li>\n<li><p>关中断。清空各种段寄存器，包括ds、es、ss。</p>\n</li>\n<li><p>打开A20地址线.</p>\n</li>\n<li><p>加载全局描述符表。即使用lgdt指令将表的地址和大小放在GDTR中。（这里的全局描述符表是临时的，后面内核初始化会更换一张gdt表，那张表更加完善。</p>\n</li>\n<li><p>将CR0寄存器第0位设置为1（PE位），此时正式转换成保护模式。</p>\n</li>\n<li><p>使用ljmp（长跳转指令）指令刷新段寄存器，跳到start32。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># xv6对ljmp的注释如下：</span><br><span class=\"line\"># Complete the transition to 32-bit protected mode by using a long jmp</span><br><span class=\"line\"># to reload %cs and %eip. </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化数据段、栈段寄存器，将esp设置到0x7C00处，跳到bootmain函数中，该函数会将XV6 OS加载到内存。</p>\n</li>\n</ol>\n<p>相关的结构如下：</p>\n<p>段描述符（Descriptor），描述一段地址的特性，包括基地址、范围、权限、粒度（范围以字节为单位还是以4K为单位）、类型（代码&#x2F;数据）等信息：</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/SegmentDescriptor.png\"></p>\n<p>全局描述符表，由许多个8字节段描述符组成的表：</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/GDT.png\"></p>\n<p>全局描述符表寄存器，其<strong>基地址</strong>的内容是全局描述符表的首地址，<strong>界限</strong>是全局描述符表的大小：</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/GDTR.png\"></p>\n<p>段选择子，【代码、数据、栈等】段使用了哪个段描述符，索引号指使用段描述符在全局描述符表的偏移（8字节为单位），第2位指明是全局描述符还是局部描述符，0~1位指示段的特权级：</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/SegmentSelector.png\"></p>\n<p>从低特权级的段空间 跳到 高特权级的段空间就会发生cpu特权级的切换，cpu就是通过全局描述符表来确定一个段的特权级。最典型的就是用户进程调用系统调用产生的特权级切换，这中间涉及查tss段、切栈等复杂操作，我们后面在进行详细的讨论。</p>\n<p>对于GDT的详细描述，这里推荐两篇博客，这两篇博客写的真的非常好！相信阅读之后，对全局描述符会有一个清晰的认识，全局描述符的几幅图片也是取自这两篇文章，如有侵权，可告知删除：</p>\n<p><a href=\"https://blog.csdn.net/abc123lzf/article/details/109289567\">详细介绍了段描述符各个位的作用</a></p>\n<p><a href=\"https://blog.csdn.net/me1171115772/article/details/51750442\">可以作为扩展，里面介绍了局部描述符的作用</a></p>\n<h2 id=\"正式将XV6加载到内存\"><a href=\"#正式将XV6加载到内存\" class=\"headerlink\" title=\"正式将XV6加载到内存\"></a>正式将XV6加载到内存</h2><p>分析该部分细节前，先需要了解一下elf文件的格式，我们重点关注elf文件的ELF header和Program header table。直接上各个字段的描述：</p>\n<p>引用自博客<a href=\"https://zhuanlan.zhihu.com/p/165336511\">https://zhuanlan.zhihu.com/p/165336511</a>如有侵权，可告知删除：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ELF_MAGIC 0x464C457FU  <span class=\"comment\">// &quot;\\x7FELF&quot; in little endian</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ELF 文件的头部</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">elfhdr</span> &#123;</span><br><span class=\"line\">  uint magic;       <span class=\"comment\">// 4 字节，为 0x464C457FU（大端模式）或 0x7felf（小端模式）</span></span><br><span class=\"line\">                      <span class=\"comment\">// 表明该文件是个 ELF 格式文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uchar elf[<span class=\"number\">12</span>];    <span class=\"comment\">// 12 字节，每字节对应意义如下：</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0 : 1 = 32 位程序；2 = 64 位程序</span></span><br><span class=\"line\">                    <span class=\"comment\">//     1 : 数据编码方式，0 = 无效；1 = 小端模式；2 = 大端模式</span></span><br><span class=\"line\">                    <span class=\"comment\">//     2 : 只是版本，固定为 0x1</span></span><br><span class=\"line\">                    <span class=\"comment\">//     3 : 目标操作系统架构</span></span><br><span class=\"line\">                    <span class=\"comment\">//     4 : 目标操作系统版本</span></span><br><span class=\"line\">                    <span class=\"comment\">//     5 ~ 11 : 固定为 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort type;      <span class=\"comment\">// 2 字节，表明该文件类型，意义如下：</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x0 : 未知目标文件格式</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x1 : 可重定位文件</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x2 : 可执行文件</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x3 : 共享目标文件</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x4 : 转储文件</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0xff00 : 特定处理器文件</span></span><br><span class=\"line\">                    <span class=\"comment\">//     0xffff : 特定处理器文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort machine;   <span class=\"comment\">// 2 字节，表明运行该程序需要的计算机体系架构，</span></span><br><span class=\"line\">                    <span class=\"comment\">// 这里我们只需要知道 0x0 为未指定；0x3 为 x86 架构</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint version;     <span class=\"comment\">// 4 字节，表示该文件的版本号</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint entry;       <span class=\"comment\">// 4 字节，该文件的入口地址，没有入口（非可执行文件）则为 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint phoff;       <span class=\"comment\">// 4 字节，表示该文件的“程序头部表”相对于文件的位置，单位是字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint shoff;       <span class=\"comment\">// 4 字节，表示该文件的“节区头部表”相对于文件的位置，单位是字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint flags;       <span class=\"comment\">// 4 字节，特定处理器标志</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort ehsize;    <span class=\"comment\">// 2 字节，ELF文件头部的大小，单位是字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort phentsize; <span class=\"comment\">// 2 字节，表示程序头部表中一个入口的大小，单位是字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort phnum;     <span class=\"comment\">// 2 字节，表示程序头部表的入口个数，</span></span><br><span class=\"line\">                    <span class=\"comment\">// phnum * phentsize = 程序头部表大小（单位是字节）</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort shentsize; <span class=\"comment\">// 2 字节，节区头部表入口大小，单位是字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort shnum;     <span class=\"comment\">// 2 字节，节区头部表入口个数，</span></span><br><span class=\"line\">                    <span class=\"comment\">// shnum * shentsize = 节区头部表大小（单位是字节）</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort shstrndx;  <span class=\"comment\">// 2 字节，表示字符表相关入口的节区头部表索引</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序头表</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">proghdr</span> &#123;</span><br><span class=\"line\">  uint type;        <span class=\"comment\">// 4 字节， 段类型</span></span><br><span class=\"line\">                    <span class=\"comment\">//         1 PT_LOAD : 可载入的段</span></span><br><span class=\"line\">                    <span class=\"comment\">//         2 PT_DYNAMIC : 动态链接信息</span></span><br><span class=\"line\">                    <span class=\"comment\">//         3 PT_INTERP : 指定要作为解释程序调用的以空字符结尾的路径名的位置和大小</span></span><br><span class=\"line\">                    <span class=\"comment\">//         4 PT_NOTE : 指定辅助信息的位置和大小</span></span><br><span class=\"line\">                    <span class=\"comment\">//         5 PT_SHLIB : 保留类型，但具有未指定的语义</span></span><br><span class=\"line\">                    <span class=\"comment\">//         6 PT_PHDR : 指定程序头表在文件及程序内存映像中的位置和大小</span></span><br><span class=\"line\">                    <span class=\"comment\">//         7 PT_TLS : 指定线程局部存储模板</span></span><br><span class=\"line\">  uint off;         <span class=\"comment\">// 4 字节， 段的第一个字节在文件中的偏移</span></span><br><span class=\"line\">  uint vaddr;       <span class=\"comment\">// 4 字节， 段的第一个字节在内存中的虚拟地址</span></span><br><span class=\"line\">  uint paddr;       <span class=\"comment\">// 4 字节， 段的第一个字节在内存中的物理地址(适用于物理内存定位型的系统)</span></span><br><span class=\"line\">  uint filesz;      <span class=\"comment\">// 4 字节， 段在文件中的长度</span></span><br><span class=\"line\">  uint memsz;       <span class=\"comment\">// 4 字节， 段在内存中的长度</span></span><br><span class=\"line\">  uint flags;       <span class=\"comment\">// 4 字节， 段标志</span></span><br><span class=\"line\">                    <span class=\"comment\">//         1 : 可执行</span></span><br><span class=\"line\">                    <span class=\"comment\">//         2 : 可写入</span></span><br><span class=\"line\">                    <span class=\"comment\">//         4 : 可读取</span></span><br><span class=\"line\">  uint align;       <span class=\"comment\">// 4 字节， 段在文件及内存中如何对齐</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果感兴趣的话，可以参考文章：<a href=\"https://blog.csdn.net/pingxiaozhao/article/details/109239221\">ELF文件格式的详解</a>，这篇文章讲解的更为详细，但是对于现阶段来说，可以不用了解太仔细，知道elf文件的ELF header和Program header table各个字段的作用就足够你继续学习XV6操作系统。</p>\n<p>对kernel elf文件解析的主流程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">bootmain</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">elfhdr</span> *elf;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proghdr</span> *ph, *eph;</span><br><span class=\"line\">  <span class=\"built_in\">void</span> (*entry)(<span class=\"type\">void</span>);</span><br><span class=\"line\">  uchar* pa;</span><br><span class=\"line\">  <span class=\"comment\">// 预留足够空间</span></span><br><span class=\"line\">  <span class=\"comment\">// 46K</span></span><br><span class=\"line\">  elf = (<span class=\"keyword\">struct</span> elfhdr*)<span class=\"number\">0x10000</span>;  <span class=\"comment\">// scratch space</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 以0为偏移读4096个字节，读elf文件头</span></span><br><span class=\"line\">  <span class=\"comment\">// Read 1st page off disk</span></span><br><span class=\"line\">  <span class=\"built_in\">readseg</span>((uchar*)elf, <span class=\"number\">4096</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 判断elf文件魔数。</span></span><br><span class=\"line\">  <span class=\"comment\">// Is this an ELF executable?</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(elf-&gt;magic != ELF_MAGIC)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;  <span class=\"comment\">// let bootasm.S handle error</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定位到Program header table</span></span><br><span class=\"line\">  <span class=\"comment\">// Load each program segment (ignores ph flags).</span></span><br><span class=\"line\">  ph = (<span class=\"keyword\">struct</span> proghdr*)((uchar*)elf + elf-&gt;phoff);</span><br><span class=\"line\">  <span class=\"comment\">// 程序头部表个数</span></span><br><span class=\"line\">  eph = ph + elf-&gt;phnum;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 一个段一个段的读</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; ph &lt; eph; ph++)&#123;  <span class=\"comment\">// 以struct proghdr为单位自增。</span></span><br><span class=\"line\">    <span class=\"comment\">// 应该加载到的物理内存，xv6中是0x100000</span></span><br><span class=\"line\">    pa = (uchar*)ph-&gt;paddr;</span><br><span class=\"line\">    <span class=\"comment\">// 读取整个段到pa中</span></span><br><span class=\"line\">    <span class=\"built_in\">readseg</span>(pa, ph-&gt;filesz, ph-&gt;off);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ph-&gt;memsz &gt; ph-&gt;filesz)</span><br><span class=\"line\">      <span class=\"comment\">// mem大小比file大小大，多余的补零</span></span><br><span class=\"line\">      <span class=\"built_in\">stosb</span>(pa + ph-&gt;filesz, <span class=\"number\">0</span>, ph-&gt;memsz - ph-&gt;filesz);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Call the entry point from the ELF header.</span></span><br><span class=\"line\">  <span class=\"comment\">// Does not return!</span></span><br><span class=\"line\">  entry = (<span class=\"built_in\">void</span>(*)(<span class=\"type\">void</span>))(elf-&gt;entry);  <span class=\"comment\">// 在xv6的kernel.ld中描述为_start</span></span><br><span class=\"line\">  <span class=\"built_in\">entry</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前半部分做的操作就是不断从kernel的elf文件中按照程序头将各个段读取到内存。后面通过elf头中的entry，该字段保存内核入口点_start（这可以通过阅读kernel.ld文件来证明），去执行_start开始的代码，这里要提醒读者的是，到目前为止，对cpu来说状态是：保护模式 &amp; 已经装填了全局描述符 &amp; <strong>一切地址皆是物理地址</strong>。而kernel的elf文件中代码都是使用的（0x8010 0000开始的）虚拟地址，所以我们后面在entry.S中会看到，在给_start赋值前，会通过一个宏将真正的入口地址的虚拟地址转换为XV6加载到内存的物理地址。从而我们在物理地址寻址模式下，可以利用_start准确跳转到xv6的入口代码。</p>\n<p>需要注意的是：<strong>在执行bootasm汇编代码时，esp的位置是不确定的，唯一能确定的是esp在1M空间之内。在bootasm汇编最后才会将esp挪到0x7c00的位置！</strong></p>\n<p>在bootmain执行完毕后，内存布局如下：</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/boot.drawio.png\"></p>\n<p>接下来深入分析一下从磁盘读取文件的细节，这些内容都是和硬件相关的，通过操作硬件寄存器来实现读写磁盘，这部分深入下去也是挺让人头大的，作者也是菜鸟一个，也就力所能及的叙述一些自己明白的东西吧。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">waitdisk</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Wait for disk ready.</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>((<span class=\"built_in\">inb</span>(<span class=\"number\">0x1F7</span>) &amp; <span class=\"number\">0xC0</span>) != <span class=\"number\">0x40</span>)</span><br><span class=\"line\">    ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// readsect也引用自https://zhuanlan.zhihu.com/p/165336511，如有侵权，可联系我删除</span></span><br><span class=\"line\"><span class=\"comment\">// Read a single sector at offset into dst.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">readsect</span><span class=\"params\">(<span class=\"type\">void</span> *dst, uint offset)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Issue command.</span></span><br><span class=\"line\">  <span class=\"built_in\">waitdisk</span>();</span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F2</span>, <span class=\"number\">1</span>);   <span class=\"comment\">// count = 1          // 要读取的扇区数量 count = 1</span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F3</span>, offset);                    <span class=\"comment\">// 扇区 LBA 地址的 0-7 位</span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F4</span>, offset &gt;&gt; <span class=\"number\">8</span>);               <span class=\"comment\">// 扇区 LBA 地址的 8-15 位</span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F5</span>, offset &gt;&gt; <span class=\"number\">16</span>);              <span class=\"comment\">// 扇区 LBA 地址的 16-23 位</span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F6</span>, (offset &gt;&gt; <span class=\"number\">24</span>) | <span class=\"number\">0xE0</span>);     <span class=\"comment\">// offset | 11100000 保证高三位恒为 1</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         第7位     恒为1</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         第6位     LBA模式的开关，置1为LBA模式</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         第5位     恒为1</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         第4位     为0代表主硬盘、为1代表从硬盘</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         第3~0位   扇区 LBA 地址的 24-27 位</span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F7</span>, <span class=\"number\">0x20</span>);  <span class=\"comment\">// cmd 0x20 - read sectors  // 20h为读，30h为写</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Read data.</span></span><br><span class=\"line\">  <span class=\"built_in\">waitdisk</span>();</span><br><span class=\"line\">  <span class=\"built_in\">insl</span>(<span class=\"number\">0x1F0</span>, dst, SECTSIZE/<span class=\"number\">4</span>); <span class=\"comment\">// 读的时候以4字节位单位读，所以需要扇区除以4，代表要读的次数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Read &#x27;count&#x27; bytes at &#x27;offset&#x27; from kernel into physical address &#x27;pa&#x27;.</span></span><br><span class=\"line\"><span class=\"comment\">// Might copy more than asked.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">readseg</span><span class=\"params\">(uchar* pa, uint count, uint offset)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  uchar* epa; <span class=\"comment\">// end phy addr</span></span><br><span class=\"line\"></span><br><span class=\"line\">  epa = pa + count; <span class=\"comment\">// 结束地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 这里将起始物理地址回退了offset的SECTSIZE（512）余数个Byte</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为在从磁盘上读数据的时候，以512字节进行读取。所以offset会以512为单位向下取整，</span></span><br><span class=\"line\">  <span class=\"comment\">// 被换算成扇区号的偏移。如果offset原来不是SECTSIZE的整数倍，向下取整会导致offset截断，</span></span><br><span class=\"line\">  <span class=\"comment\">// 记换算后的offset为ofs，此时如果直接读取ofs扇区会多读offset % SECTSIZE个字节，</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以需要提前将pa的地址减去offset % SECTSIZE个字节来排除offset被截断的多余的字节。</span></span><br><span class=\"line\">  <span class=\"comment\">// Round down to sector boundary.</span></span><br><span class=\"line\">  pa -= offset % SECTSIZE;    </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将offset换算成扇区号</span></span><br><span class=\"line\">  <span class=\"comment\">// Translate from bytes to sectors; kernel starts at sector 1.</span></span><br><span class=\"line\">  offset = (offset / SECTSIZE) + <span class=\"number\">1</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 依次读取每个扇区，最后一个扇区多读了也没关系。</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; pa &lt; epa; pa += SECTSIZE, offset++)</span><br><span class=\"line\">    <span class=\"built_in\">readsect</span>(pa, offset);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>仔细推敲readseg函数中pa回滚的操作，总感觉这样贸然回滚，会覆盖之前已经被加载到内存中的代码。既然xv6敢这样写，八成说明是没有问题的，具体的原因，作者实在琢磨不透，如果有了解的朋友，可以在评论区交流一下。</p>\n<h2 id=\"跳到-start，正式进入内核前的预初始化\"><a href=\"#跳到-start，正式进入内核前的预初始化\" class=\"headerlink\" title=\"跳到_start，正式进入内核前的预初始化\"></a>跳到_start，正式进入内核前的预初始化</h2><p>相关代码文件是entry.S</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &quot;asm.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;memlayout.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;mmu.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;param.h&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Multiboot header.  Data to direct multiboot loader.</span></span><br><span class=\"line\"><span class=\"symbol\">.p2align</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"symbol\">.text</span></span><br><span class=\"line\"><span class=\"symbol\">.globl</span> multiboot_header</span><br><span class=\"line\"><span class=\"symbol\">multiboot_header:</span></span><br><span class=\"line\">  <span class=\"comment\">#define magic 0x1badb002</span></span><br><span class=\"line\">  <span class=\"comment\">#define flags 0</span></span><br><span class=\"line\">  <span class=\"meta\">.long</span> magic</span><br><span class=\"line\">  <span class=\"meta\">.long</span> flags</span><br><span class=\"line\">  <span class=\"meta\">.long</span> (-magic-flags)</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 这里就能看到，因为elf描述的一些标签是使用的虚拟地址，</span></span><br><span class=\"line\"><span class=\"comment\"># 而在进入entry开启分页前都是使用的物理地址，所以使用了</span></span><br><span class=\"line\"><span class=\"comment\"># V2P_WO宏将entry转换成了物理地址。方便bootmain跳转到entry.</span></span><br><span class=\"line\"><span class=\"comment\"># V2P_WO展开就是将输入的地址减去 0x8000 0000 的偏移。</span></span><br><span class=\"line\"><span class=\"symbol\">.globl</span> _start</span><br><span class=\"line\"><span class=\"symbol\">_start</span> = V2P_WO(<span class=\"meta\">entry</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Entering xv6 on boot processor, with paging off.</span></span><br><span class=\"line\"><span class=\"symbol\">.globl</span> <span class=\"meta\">entry</span></span><br><span class=\"line\"><span class=\"symbol\">entry:</span></span><br><span class=\"line\">  <span class=\"comment\"># 打开4M big page开关</span></span><br><span class=\"line\">  <span class=\"comment\"># Turn on page size extension for 4Mbyte pages</span></span><br><span class=\"line\">  movl    %cr4, %eax</span><br><span class=\"line\">  orl     $(CR4_PSE), %eax</span><br><span class=\"line\">  movl    %eax, %cr4</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 将页目录设置为entrypgdir，同样由于在启用虚拟内存前，</span></span><br><span class=\"line\">  <span class=\"comment\"># 需要将虚拟地址entrypgdir转换为物理地址，有关entrypgdir</span></span><br><span class=\"line\">  <span class=\"comment\"># 的定义在内存管理章节进行详细叙述。</span></span><br><span class=\"line\">  <span class=\"comment\"># Set page directory</span></span><br><span class=\"line\">  movl    $(V2P_WO(entrypgdir)), %eax</span><br><span class=\"line\">  movl    %eax, %cr3</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 开启分页</span></span><br><span class=\"line\">  <span class=\"comment\"># Turn on paging.</span></span><br><span class=\"line\">  movl    %cr0, %eax</span><br><span class=\"line\">  orl     $(CR0_PG<span class=\"title\">|CR0_WP), %eax</span></span><br><span class=\"line\"><span class=\"title\">  movl    %eax, %cr0</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">  ########################### 以下正式进入分页模式，地址皆是虚拟地址</span></span><br><span class=\"line\"><span class=\"title\">  # 再一次修改esp指针，将esp移到内核代码范围中</span></span><br><span class=\"line\"><span class=\"title\">  # Set up the stack pointer.</span></span><br><span class=\"line\"><span class=\"title\">  movl $(stack + KSTACKSIZE), %esp</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">  # 真正进入内核main函数，开始各种初始化。</span></span><br><span class=\"line\"><span class=\"title\">  mov $main, %eax</span></span><br><span class=\"line\"><span class=\"title\">  jmp *%eax</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">.comm stack, KSTACKSIZE</span></span><br></pre></td></tr></table></figure>\n\n<p>该部分代码负责进入main函数前的初始化，主要工作如下：</p>\n<ol>\n<li><p>打开4M big page分页开关，让cpu支持4M大页。entrypgdir会将内核区域与映射为物理地址低4M的大页，我们后面会详细进行讨论，entrypgdir的生命周期非常短，在main函数中初始化过程中，会另外产生一个粒度更小的页表kpgdir（4K为一页），该页表会一直作为xv6的内核页表。</p>\n</li>\n<li><p>设置entrypgdir为BSP（booststrap processor）的页目录。</p>\n</li>\n<li><p>开启分页。</p>\n</li>\n<li><p>修改esp。指向内核自己分配的4K大小的栈上。</p>\n</li>\n<li><p>进入main。</p>\n</li>\n</ol>\n<p>在entry.S代码执行完后，cpu开启分页模式，所有的地址都将以虚拟地址的形式存在。此时内存布局如下：</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/entry.drawio.png\"></p>\n<p>至此，cpu的预初始化进行完毕。下面几章将围绕内核的初始化去讲解类unix操作系统的内存管理、进程调度、文件系统子模块。</p>\n<hr>\n<p><strong>本章完结</strong></p>"}],"PostAsset":[{"_id":"source/_posts/muduo/AsyncLogging/photo/AsynLogging.drawio.png","slug":"photo\\AsynLogging.drawio.png","post":"cmg3w8w9k0003q8wsb3i18lsz","modified":0,"renderable":0},{"_id":"source/_posts/buildroot/stage_install/photo/stage_install0.png","slug":"photo\\stage_install0.png","post":"cmg3w8w9i0001q8ws0sso6gl1","modified":0,"renderable":0},{"_id":"source/_posts/buildroot/stage_install/photo/stage_install1.png","slug":"photo\\stage_install1.png","post":"cmg3w8w9i0001q8ws0sso6gl1","modified":0,"renderable":0},{"_id":"source/_posts/buildroot/stage_install/photo/stage_install2.png","slug":"photo\\stage_install2.png","post":"cmg3w8w9i0001q8ws0sso6gl1","modified":0,"renderable":0},{"_id":"source/_posts/muduo/EventLoopThreadPool/photo/EventLoopThreadPool.drawio.png","slug":"photo\\EventLoopThreadPool.drawio.png","post":"cmg3w8w9p000cq8wsbylt7ba0","modified":0,"renderable":0},{"_id":"source/_posts/muduo/EvevntLoopAndThread/photo/EventLoop.drawio.png","slug":"photo\\EventLoop.drawio.png","post":"cmg3w8w9p000eq8ws2a4bco90","modified":0,"renderable":0},{"_id":"source/_posts/muduo/ThreadAndThreadPool/photo/ThreadPool.drawio.png","slug":"photo\\ThreadPool.drawio.png","post":"cmg3w8w9r000oq8ws4u2pb7o9","modified":0,"renderable":0},{"_id":"source/_posts/muduo/TcpServer/photo/TcpServer.drawio.png","slug":"photo\\TcpServer.drawio.png","post":"cmg3w8w9r000mq8wsbnlaectd","modified":0,"renderable":0},{"_id":"source/_posts/workflow/TCPServer_1/photo/EventLoopFlowChart.drawio.png","slug":"photo\\EventLoopFlowChart.drawio.png","post":"cmg3w8w9s000uq8ws80lh02fu","modified":0,"renderable":0},{"_id":"source/_posts/workflow/TCPServer_1/photo/EventLoopThreadPool.drawio.png","slug":"photo\\EventLoopThreadPool.drawio.png","post":"cmg3w8w9s000uq8ws80lh02fu","modified":0,"renderable":0},{"_id":"source/_posts/workflow/TCPServer_2/photo/ReadStatusTranslate.drawio.png","slug":"photo\\ReadStatusTranslate.drawio.png","post":"cmg3w8w9t0010q8ws2bl6bydm","modified":0,"renderable":0},{"_id":"source/_posts/workflow/TCPServer_2/photo/StateTranslateThreadPool.drawio.png","slug":"photo\\StateTranslateThreadPool.drawio.png","post":"cmg3w8w9t0010q8ws2bl6bydm","modified":0,"renderable":0},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/entry.png","slug":"photo\\memmanager\\entry.png","post":"cmg3w8w9u0012q8wsfwecb723","modified":0,"renderable":0},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/kalloc.drawio.png","slug":"photo\\memmanager\\kalloc.drawio.png","post":"cmg3w8w9u0012q8wsfwecb723","modified":0,"renderable":0},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/main_page_table.drawio.png","slug":"photo\\memmanager\\main_page_table.drawio.png","post":"cmg3w8w9u0012q8wsfwecb723","modified":0,"renderable":0},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/memory_paging_02.drawio.png","slug":"photo\\memmanager\\memory_paging_02.drawio.png","post":"cmg3w8w9u0012q8wsfwecb723","modified":0,"renderable":0},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/onix_memory_map.drawio.png","slug":"photo\\memmanager\\onix_memory_map.drawio.png","post":"cmg3w8w9u0012q8wsfwecb723","modified":0,"renderable":0},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/vaddr.png","slug":"photo\\memmanager\\vaddr.png","post":"cmg3w8w9u0012q8wsfwecb723","modified":0,"renderable":0},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/vaddr2paddr.png","slug":"photo\\memmanager\\vaddr2paddr.png","post":"cmg3w8w9u0012q8wsfwecb723","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/8259a.drawio.png","slug":"photo\\scheduler\\8259a.drawio.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/APICStructure.png","slug":"photo\\scheduler\\APICStructure.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/entry_types.png","slug":"photo\\scheduler\\entry_types.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/IDTR.png","slug":"photo\\scheduler\\IDTR.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/IDT_Entry.png","slug":"photo\\scheduler\\IDT_Entry.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/imcrp.png","slug":"photo\\scheduler\\imcrp.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/ioapic_entry.png","slug":"photo\\scheduler\\ioapic_entry.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png","slug":"photo\\scheduler\\MP_Configuration_Data_Structures.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/MP_configuration_table_header.png","slug":"photo\\scheduler\\MP_configuration_table_header.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/MP_floating_pointer_structure.png","slug":"photo\\scheduler\\MP_floating_pointer_structure.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/processor_entry.png","slug":"photo\\scheduler\\processor_entry.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/scheduler.drawio.png","slug":"photo\\scheduler\\scheduler.drawio.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/scheduler_pluse.drawio.png","slug":"photo\\scheduler\\scheduler_pluse.drawio.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/task_stack.drawio.png","slug":"photo\\scheduler\\task_stack.drawio.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/trap_frame.png","slug":"photo\\scheduler\\trap_frame.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/trap__structure.png","slug":"photo\\scheduler\\trap__structure.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/universal_algorithm.png","slug":"photo\\scheduler\\universal_algorithm.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/yield_scheduler.png","slug":"photo\\scheduler\\yield_scheduler.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio","slug":"photo\\filesystem\\onix_caceh1.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio.png","slug":"photo\\filesystem\\onix_caceh1.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache.drawio","slug":"photo\\filesystem\\onix_cache.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache.drawio.png","slug":"photo\\filesystem\\onix_cache.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache2.drawio","slug":"photo\\filesystem\\onix_cache2.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache2.drawio.png","slug":"photo\\filesystem\\onix_cache2.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache3.drawio","slug":"photo\\filesystem\\onix_cache3.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache3.drawio.png","slug":"photo\\filesystem\\onix_cache3.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_dentry.drawio","slug":"photo\\filesystem\\onix_dentry.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_dentry.drawio.png","slug":"photo\\filesystem\\onix_dentry.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio","slug":"photo\\filesystem\\onix_fsstructureondisk.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio.png","slug":"photo\\filesystem\\onix_fsstructureondisk.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio","slug":"photo\\filesystem\\onix_fs_structure.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio.png","slug":"photo\\filesystem\\onix_fs_structure.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_ide.drawio","slug":"photo\\filesystem\\onix_ide.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_ide.drawio.png","slug":"photo\\filesystem\\onix_ide.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio","slug":"photo\\filesystem\\onix_minix_inode.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio.png","slug":"photo\\filesystem\\onix_minix_inode.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_mount.drawio","slug":"photo\\filesystem\\onix_mount.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_mount.drawio.png","slug":"photo\\filesystem\\onix_mount.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio","slug":"photo\\filesystem\\onix_vfs_structure.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio.png","slug":"photo\\filesystem\\onix_vfs_structure.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_fsstructureondisk.png","slug":"photo\\filesystem\\xv6_fsstructureondisk.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio","slug":"photo\\filesystem\\xv6_fs_structure.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio.png","slug":"photo\\filesystem\\xv6_fs_structure.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_ide.drawio","slug":"photo\\filesystem\\xv6_ide.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_ide.drawio.png","slug":"photo\\filesystem\\xv6_ide.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio","slug":"photo\\filesystem\\xv6_log_structure.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio.png","slug":"photo\\filesystem\\xv6_log_structure.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/Logo.jpg","slug":"photo\\Logo.jpg","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/8259a.drawio.png","slug":"photo\\scheduler\\8259a.drawio.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/APICStructure.png","slug":"photo\\scheduler\\APICStructure.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/entry_types.png","slug":"photo\\scheduler\\entry_types.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/IDTR.png","slug":"photo\\scheduler\\IDTR.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/IDT_Entry.png","slug":"photo\\scheduler\\IDT_Entry.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/imcrp.png","slug":"photo\\scheduler\\imcrp.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/ioapic_entry.png","slug":"photo\\scheduler\\ioapic_entry.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/MP_Configuration_Data_Structures.png","slug":"photo\\scheduler\\MP_Configuration_Data_Structures.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/MP_configuration_table_header.png","slug":"photo\\scheduler\\MP_configuration_table_header.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/MP_floating_pointer_structure.png","slug":"photo\\scheduler\\MP_floating_pointer_structure.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/processor_entry.png","slug":"photo\\scheduler\\processor_entry.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/scheduler.drawio.png","slug":"photo\\scheduler\\scheduler.drawio.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/scheduler_pluse.drawio.png","slug":"photo\\scheduler\\scheduler_pluse.drawio.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/task_stack.drawio.png","slug":"photo\\scheduler\\task_stack.drawio.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/trap_frame.png","slug":"photo\\scheduler\\trap_frame.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/trap__structure.png","slug":"photo\\scheduler\\trap__structure.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/universal_algorithm.png","slug":"photo\\scheduler\\universal_algorithm.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/yield_scheduler.png","slug":"photo\\scheduler\\yield_scheduler.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/start/boot.drawio.png","slug":"photo\\start\\boot.drawio.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/start/entry.drawio.png","slug":"photo\\start\\entry.drawio.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/start/GDT.png","slug":"photo\\start\\GDT.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/start/GDTR.png","slug":"photo\\start\\GDTR.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/start/SegmentDescriptor.png","slug":"photo\\start\\SegmentDescriptor.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/start/SegmentSelector.png","slug":"photo\\start\\SegmentSelector.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cmg3w8w9i0001q8ws0sso6gl1","tag_id":"cmg3w8w9l0004q8ws6v7de8g9","_id":"cmg3w8w9m0007q8ws3itw2kea"},{"post_id":"cmg3w8w9k0003q8wsb3i18lsz","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9m0008q8ws8eg17a15"},{"post_id":"cmg3w8w9o0009q8ws2nst23jm","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9p000bq8ws9nle43uc"},{"post_id":"cmg3w8w9o000aq8ws7nc90xlj","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9p000dq8wscfxhe60r"},{"post_id":"cmg3w8w9p000cq8wsbylt7ba0","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9q000fq8wsaj7ice34"},{"post_id":"cmg3w8w9p000eq8ws2a4bco90","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9q000hq8wsb2isaytg"},{"post_id":"cmg3w8w9q000gq8wscd9u3po5","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9q000jq8ws0srg3i7i"},{"post_id":"cmg3w8w9q000iq8ws6f7reaee","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9r000lq8wsbu9lat7a"},{"post_id":"cmg3w8w9q000kq8ws5wshe41s","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9r000nq8wsemsyh7yu"},{"post_id":"cmg3w8w9r000mq8wsbnlaectd","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9s000pq8ws2vrqbt3u"},{"post_id":"cmg3w8w9r000oq8ws4u2pb7o9","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9s000rq8ws9xpi98cp"},{"post_id":"cmg3w8w9s000qq8wsfjymfkx3","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9s000tq8wsg3x8fkq2"},{"post_id":"cmg3w8w9s000sq8ws8wi65amy","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9t000vq8wsb6hv28ct"},{"post_id":"cmg3w8w9s000uq8ws80lh02fu","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9t000xq8wsf61bem9w"},{"post_id":"cmg3w8w9t000wq8ws64du4jnn","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9t000zq8wsdqptg4ii"},{"post_id":"cmg3w8w9t000yq8ws5v75f0jg","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9t0011q8ws4e7ue97x"},{"post_id":"cmg3w8w9t0010q8ws2bl6bydm","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9u0013q8ws822j3ykw"},{"post_id":"cmg3w8w9v0017q8wseafudr8p","tag_id":"cmg3w8w9u0015q8ws02uy0nc3","_id":"cmg3w8w9v0019q8ws7diehjgb"},{"post_id":"cmg3w8w9u0012q8wsfwecb723","tag_id":"cmg3w8w9u0015q8ws02uy0nc3","_id":"cmg3w8w9v001aq8wsd4lk4bbq"},{"post_id":"cmg3w8w9u0014q8ws9y7072z2","tag_id":"cmg3w8w9u0015q8ws02uy0nc3","_id":"cmg3w8w9w001cq8wshuljfnkm"},{"post_id":"cmg3w8w9u0016q8ws8p1n16tx","tag_id":"cmg3w8w9u0015q8ws02uy0nc3","_id":"cmg3w8w9w001dq8ws0qwg2qa1"}],"Tag":[{"name":"Linux应用技术笔记","_id":"cmg3w8w9l0004q8ws6v7de8g9"},{"name":"高性能服务器框架","_id":"cmg3w8w9m0006q8wsdrlwcbve"},{"name":"类Unix源码剖析","_id":"cmg3w8w9u0015q8ws02uy0nc3"}]}}