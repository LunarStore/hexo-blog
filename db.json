{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/LICENSE","path":"lib/pace/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/README.md","path":"lib/pace/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flat-top.min.css","path":"lib/pace/pace-theme-flat-top.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-material.min.css","path":"lib/pace/pace-theme-material.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/theme-next-canvas-ribbon-master/LICENSE","path":"lib/canvas-ribbon/theme-next-canvas-ribbon-master/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/theme-next-canvas-ribbon-master/README.md","path":"lib/canvas-ribbon/theme-next-canvas-ribbon-master/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/theme-next-canvas-ribbon-master/canvas-ribbon.js","path":"lib/canvas-ribbon/theme-next-canvas-ribbon-master/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/images/avatar.jpg","hash":"eedc3cb767ecbcdbadd5e7e1b4a2c574eeb930c3","modified":1759053230518},{"_id":"source/categories/index.md","hash":"af5140ff20c645870dfaa9d26534a3e9bb700ba4","modified":1759111973953},{"_id":"source/_posts/buildroot/stage_install.md","hash":"6004c7b8f2e0e2b30dfdfd5f96a92f7c8d1dad0a","modified":1759052478567},{"_id":"source/tags/index.md","hash":"ef05055df2050c154617702d8e5bad2ac03bba88","modified":1759111973955},{"_id":"source/about/index.md","hash":"f5591229459156000fa5b889359ef835acb9275f","modified":1759111973953},{"_id":"source/_posts/muduo/AsyncLogging.md","hash":"e31d329de368c4215e2dc8e5ef97391416628956","modified":1759075603125},{"_id":"source/_posts/muduo/EventLoopThreadPool.md","hash":"de468956fd7776b61b4f8ec12683a817f7502075","modified":1759075603125},{"_id":"source/_posts/muduo/EvevntLoopAndThread.md","hash":"58aa33f122cc4e8a0003083064c5030cf21fc1a6","modified":1759075603125},{"_id":"source/_posts/muduo/ChannelAndPoller.md","hash":"da2f641387269dbfab5b949ad6a78af6626c218e","modified":1759075603125},{"_id":"source/_posts/muduo/SynLogging.md","hash":"c3939f8b7d9c0aa3d0da611a3f3ab285b7b4d4c3","modified":1759075603130},{"_id":"source/_posts/muduo/TcpServer.md","hash":"30079f59f27690b216dd6ed68db1d30bc9a0ae88","modified":1759075603130},{"_id":"source/_posts/muduo/TcpClient.md","hash":"0eb8dc9e28d9978759912a7700c15acbedfd508a","modified":1759075603130},{"_id":"source/_posts/muduo/TcpConnection.md","hash":"d07ebc49d86f6f2e2c14246580279f4765347359","modified":1759075603130},{"_id":"source/_posts/muduo/Start.md","hash":"b958561c56063d82a0a56a75f4af834fd6c9f5e2","modified":1759075603130},{"_id":"source/_posts/workflow/TCPServer_2.md","hash":"2cfab0c1affca173bce830f55e90fd9c9d121d64","modified":1759070287199},{"_id":"source/_posts/workflow/TCPServer_3.md","hash":"79ff27a9387906229ca82c279592732fc86fb34a","modified":1759070073264},{"_id":"source/_posts/workflow/TCPServer_1.md","hash":"7d073c987730f266b3eea5690679c340fd6858b3","modified":1759070007743},{"_id":"source/_posts/workflow/go_task.md","hash":"54ad7218b87400ce3e4b46972f5f891ce62fc60a","modified":1759069937118},{"_id":"source/_posts/xv6/Boot.md","hash":"876f271de6a63a0188d98304621e035c462d3170","modified":1759052445876},{"_id":"source/_posts/xv6/FileSystem.md","hash":"276ebb30037b686b701f908753c914ace89a9aa7","modified":1759071679926},{"_id":"source/_posts/xv6/MemoryManager.md","hash":"af75bed854526a65f513c7298f140b3ca0885acf","modified":1759052458181},{"_id":"source/_posts/xv6/Scheduler.md","hash":"46a6516bfb16c321dc5821df54abb1dea34cd7d4","modified":1759052468734},{"_id":"source/_posts/muduo/ThreadSafeAndSync.md","hash":"cc1415f8143286d454a7a4bf011b522bfbde5d29","modified":1759075603135},{"_id":"source/_posts/muduo/ThreadAndThreadPool/photo/ThreadPool.drawio.png","hash":"fd81e3dc3084ae1ba009f2b0c5b808025921ae42","modified":1706771375173},{"_id":"source/_posts/muduo/EvevntLoopAndThread/photo/EventLoop.drawio.png","hash":"1b042f052b1c603a63b3423dbd16c661e8e03d28","modified":1705390642525},{"_id":"source/_posts/muduo/ThreadAndThreadPool.md","hash":"75f90634ff882cc964a34016434bd3bd03f658dc","modified":1759075603135},{"_id":"source/_posts/xv6/Boot/photo/Logo.jpg","hash":"808892bb96be6a1e7e82534873c36e7ae2cb9544","modified":1759021665518},{"_id":"source/_posts/xv6/Boot/photo/scheduler/8259a.drawio.png","hash":"83d2785b610a50aed51bbd2721a4d8dc91d09e6d","modified":1717813054252},{"_id":"source/_posts/xv6/Boot/photo/scheduler/IDT_Entry.png","hash":"4cd80376efd49a1cfa9213496d7b61f3320eb64c","modified":1717591506752},{"_id":"source/_posts/xv6/Boot/photo/scheduler/IDTR.png","hash":"49db6c278ef03ebf2a718819995c81a7e0e852b5","modified":1717595225355},{"_id":"source/_posts/xv6/Boot/photo/scheduler/MP_floating_pointer_structure.png","hash":"a3458fe0c961df5a72a7cf12b409dd9dcc05afe5","modified":1717646250634},{"_id":"source/_posts/xv6/Boot/photo/scheduler/imcrp.png","hash":"8c9864113c89b148bd721ea5f4b93b6e6da5efa9","modified":1717651724294},{"_id":"source/_posts/xv6/Boot/photo/scheduler/ioapic_entry.png","hash":"7b551a258d0b1dc29c5851d1c8355fa037841796","modified":1717646386248},{"_id":"source/_posts/xv6/Boot/photo/scheduler/task_stack.drawio.png","hash":"ba199d6a2e2d9f403408bbeabc5b94a4d598f4e0","modified":1717725546886},{"_id":"source/_posts/xv6/Boot/photo/scheduler/trap_frame.png","hash":"6a191f20fab43fadd95da12ef456ee6c149cba87","modified":1717665607888},{"_id":"source/_posts/xv6/Boot/photo/start/GDT.png","hash":"c7865b8c24a0bb195567b318fdb2c332c642e954","modified":1716790321552},{"_id":"source/_posts/xv6/Boot/photo/start/GDTR.png","hash":"c1de122b466da828be0ae56e3d195416f5c29af4","modified":1716791186516},{"_id":"source/_posts/xv6/Boot/photo/start/SegmentDescriptor.png","hash":"0b2178b404782f2aedef546f3e4841cd4b0f5328","modified":1716790249997},{"_id":"source/_posts/xv6/Boot/photo/start/SegmentSelector.png","hash":"4cb9e6e79a1e9e29cb4bfc975e050855d58a0d9c","modified":1716790287039},{"_id":"source/_posts/xv6/Boot/photo/start/boot.drawio.png","hash":"4d4eeec0332589443e39742c5007784058433312","modified":1717728321411},{"_id":"source/_posts/xv6/Boot/photo/start/entry.drawio.png","hash":"60d49b69b0f343b4bb71c830294c95c7565bb5ff","modified":1717504193205},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/8259a.drawio.png","hash":"83d2785b610a50aed51bbd2721a4d8dc91d09e6d","modified":1717813054252},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/IDTR.png","hash":"49db6c278ef03ebf2a718819995c81a7e0e852b5","modified":1717595225355},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/IDT_Entry.png","hash":"4cd80376efd49a1cfa9213496d7b61f3320eb64c","modified":1717591506752},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/MP_floating_pointer_structure.png","hash":"a3458fe0c961df5a72a7cf12b409dd9dcc05afe5","modified":1717646250634},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/imcrp.png","hash":"8c9864113c89b148bd721ea5f4b93b6e6da5efa9","modified":1717651724294},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/ioapic_entry.png","hash":"7b551a258d0b1dc29c5851d1c8355fa037841796","modified":1717646386248},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/task_stack.drawio.png","hash":"ba199d6a2e2d9f403408bbeabc5b94a4d598f4e0","modified":1717725546886},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/trap_frame.png","hash":"6a191f20fab43fadd95da12ef456ee6c149cba87","modified":1717665607888},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio","hash":"bc34b6aad6a41e1dadad7aac08c053de83ec9b62","modified":1759111973918},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache.drawio","hash":"7474147536b4ac4c3c00ea16b07671f780e13d97","modified":1759111973920},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache2.drawio","hash":"f34adef92989402356e6d139def58c7e190c55b7","modified":1759111973921},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache3.drawio","hash":"31c156b1c05b206c65cff8160e891390acc88823","modified":1759111973921},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_dentry.drawio","hash":"65a8be4674b07c5b29bdde8b2902729cb5f9d15d","modified":1759111973922},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio","hash":"8ce9d32364920623b9dd517df178e8bbcc68cb6b","modified":1759111973923},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio","hash":"08195759ab6c5ac2616e128760855b57a992e852","modified":1759111973924},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio.png","hash":"09710d67477b554aaa7323a2c375ee9d0d341687","modified":1758267860416},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio.png","hash":"3337f4f391a9d971abdf4951b0a2987486775eb8","modified":1758790058275},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_ide.drawio","hash":"1a8f29964aee9423db4757763cf65a47daa4d211","modified":1759111973925},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio","hash":"a64e4db9d0e53d2981f516a2e7135e52a2f177d0","modified":1759111973926},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio","hash":"4319249aa4713a3944272ca2c77b95fd4415e428","modified":1759111973932},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_ide.drawio","hash":"7b59e34715988f6a95cb9851e0ebe6502b473c4d","modified":1759111973932},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_fsstructureondisk.png","hash":"3347f61be1d43d87912ac2106a09c6a34576669e","modified":1758765034940},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio","hash":"ed57340c1d5249c677289edf08db313e3be0a089","modified":1759111973932},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio.png","hash":"c97b586ce404c596a4cc0577d3691ae36ef1beb0","modified":1758768616730},{"_id":"source/_posts/muduo/TimerQueue.md","hash":"fbcdc41f05586832657cd3707bb9c87931979879","modified":1759075603135},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/entry.png","hash":"3d63c684eb7a4300424f1cc83b64407f8346b3ae","modified":1717478000642},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/kalloc.drawio.png","hash":"7051117fab81b005bd89c6b5ecf5306dd0621885","modified":1717484416877},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/memory_paging_02.drawio.png","hash":"28391dd60a873b1a9c780022ad1bbbe92309bfad","modified":1717512366970},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/vaddr.png","hash":"5428246143a54c039ddf86504d7d77c104b4a4dc","modified":1717477075443},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/main_page_table.drawio.png","hash":"c892bc156ba2d25cdb8372353b4f5c262f2e4c99","modified":1717503991074},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/onix_memory_map.drawio.png","hash":"21b0eb31b9d8524d394b6345a1b78add0ce073ee","modified":1717511797850},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1759111973955},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1759111973956},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1759111973956},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1759111973959},{"_id":"themes/next/.gitignore","hash":"d9021ac0041b511356fc7044cb02c6e0e567d706","modified":1759111973959},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1759111973959},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1759111973959},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1759111973960},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1759111973960},{"_id":"themes/next/_config.yml","hash":"a0e2a22021d828d88ce47a7f1e2a938b9756d772","modified":1759111973960},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1759111973956},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1759111973982},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1759111973962},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1759111973956},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1759111973957},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1759111973957},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1759111973958},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1759111973958},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1759111973958},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1759111973958},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1759111973958},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1759111973959},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1759111973959},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1759111973961},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1759111973961},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1759111973961},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1759111973961},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1759111973962},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1759111973962},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1759111973962},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1759111973962},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1759111973967},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1759111973982},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1759111973982},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1759111973982},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1759111973982},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1759111973982},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1759111973982},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1759111973967},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1759111973962},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1759111973967},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1759111973967},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1759111973967},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1759049299332},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1759111973967},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1759111973967},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1759111973967},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1759111973967},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1759111973967},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1759111973967},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1759111973967},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1759111973967},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1759111973967},{"_id":"themes/next/languages/tr.yml","hash":"46e09f2119cbfbcf93fb8dbd267dccabeb8b0cda","modified":1759111973967},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1759111973967},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1759111973967},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1759111973967},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1759111973967},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1759111973967},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1759111973967},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1759111973967},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1759111973987},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1759111973957},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1759111973957},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1759111973957},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1759111973962},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1759111973962},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1759111973962},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"c459531bba73a11ce84435d2c91f105ecd0e310a","modified":1759111973967},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1759111973957},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1759111973962},{"_id":"themes/next/layout/_macro/post.swig","hash":"60d4ab526812d93ad17e44e51ddaf5d7d4e06475","modified":1759111973967},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1759111973972},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1759111973972},{"_id":"themes/next/layout/_partials/footer.swig","hash":"a76355d230792e924ea3beb3094bad4b51567419","modified":1759111973972},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1759111973972},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1759111973972},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1759111973972},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1759111973962},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1759111973962},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1759111973977},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1759111973977},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1759111973977},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1759111973977},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1759111973977},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"bd9ba0bf60cc3008ee14339fa395ee6af188e879","modified":1759111973977},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1759111973977},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1759111973982},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1759111973982},{"_id":"themes/next/source/css/_mixins.styl","hash":"cf81a6731aa436e7bb8d9a743b01f62107e27dd3","modified":1759111974008},{"_id":"themes/next/source/css/_colors.styl","hash":"9d65353ca8c634eb96142dcee1b36b6f1004522a","modified":1759111973992},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1759111974011},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1759111974011},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1759049303805},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1759049303820},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1759111974011},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1759111974011},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1759111974011},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1759111974011},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1759111974011},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1759111974011},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1759111974016},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1759049304086},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1759111974016},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1759049304096},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1759111974016},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1759111974019},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1759111974016},{"_id":"themes/next/source/js/algolia-search.js","hash":"f0cee802b4d48d5e78ba88d77d4257cb8a88dd6e","modified":1759111974016},{"_id":"themes/next/source/js/bookmark.js","hash":"2268bfcab8cf9019e590e2d356b08a3d4a0cf791","modified":1759111974016},{"_id":"themes/next/source/js/local-search.js","hash":"8f046860139f8dc7d1b445290a19e391800ff322","modified":1759111974018},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1759111974018},{"_id":"themes/next/source/js/next-boot.js","hash":"509c5b02446d4989a6ef3081cafeb9497cdde4e5","modified":1759111974018},{"_id":"themes/next/source/js/utils.js","hash":"db826a40e5830371f5fd4d648c2855a74c223cc1","modified":1759111974019},{"_id":"themes/next/scripts/events/index.js","hash":"7baf362743b3d30626066614d877891fc140c502","modified":1759111973987},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1759111973987},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1759111973987},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1759111973987},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1759111973987},{"_id":"themes/next/scripts/filters/post.js","hash":"cf5b0db0a9271687f7a21bc581ae87addd8f0767","modified":1759111973987},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1759111973987},{"_id":"themes/next/scripts/helpers/engine.js","hash":"6abda91b431c9b6f6cd2adfa665e694cfdb171be","modified":1759111973987},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1759111973987},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1759111973987},{"_id":"themes/next/scripts/tags/button.js","hash":"178d3efb8d2c1aca606181894c352fc65c40c32a","modified":1759111973987},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1759111973992},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e11a738ee77c4304add79c964bdec3715c45653a","modified":1759111973992},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1759111973992},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1759111973992},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1759111973992},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1759111973992},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1759111973992},{"_id":"themes/next/scripts/tags/tabs.js","hash":"72a5adbd8f300bee1d0c289367598ca06b2bed17","modified":1759111973992},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1759111973972},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"6a3901962ad7e698640a288be627947de90de1f6","modified":1759111973972},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1759111973972},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1759111973992},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"11acd6b585eeb823358e642c7dde7d637fda706f","modified":1759111973972},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1759111973972},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1759111973972},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1759111973972},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1759111973972},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"ca1b16202403515550f57b51dccb19afcb10ccf1","modified":1759111973972},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"5fd5ba53962aefccb43b1d2b306a534add2373e1","modified":1759111973972},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"deffa919e72da6c2cdc2f32d403c809916bd36d1","modified":1759111973972},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1759111973972},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1759111973972},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1759111973972},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"d1b9a43bdfaf2b151cce1a74d23e65c2e488e41b","modified":1759111973972},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1759111973972},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1759111973972},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1759111973972},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1759111973977},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1759111973977},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1759111973977},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1759111973977},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1759111973977},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1759111973977},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1759111973977},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1759111973977},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1759111973977},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1759111973977},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1759111973977},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1759111973977},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1759111973977},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1759111973977},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1759111973977},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1759111973977},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1759111973977},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1759111973977},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1759111973982},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1759111973982},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1759111973982},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1759111973982},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1759111973982},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1759111973982},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1759111973982},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"5b5618c2f6ad1d7971e6db257222fce89aa56565","modified":1759111973982},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1759111973982},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1759111973982},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1759111973982},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1759111973982},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1759111974011},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1759111974011},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1759111974011},{"_id":"themes/next/source/css/_variables/base.styl","hash":"fa086b75ff09268e22adf6cb36b2b6720306d824","modified":1759111974011},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"93625aa12a40482fe911e350758f9b4abe4546ff","modified":1759111974011},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1759111974020},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1759111974020},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1759111974021},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1759111974020},{"_id":"themes/next/source/lib/pace/README.md","hash":"168f57bb63563b9671d0c4f10c0940e7eec261f0","modified":1759057797094},{"_id":"themes/next/source/lib/pace/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1759057797064},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1759057797120},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1759111974020},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1759057797166},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1759057797142},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1759057797206},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1759057797231},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1759057797267},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1759057797181},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1759057797221},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1759057797247},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1759057797282},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1759057797333},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1759057797358},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1759057797398},{"_id":"themes/next/source/lib/pace/pace-theme-material.min.css","hash":"f1ff83985c090f3a3236554c5ef69542dcceb049","modified":1759057797378},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1759057797433},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1759111974025},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1759111974025},{"_id":"themes/next/source/js/schemes/muse.js","hash":"78c77614b9fe0d7d97aa08468c6cffbcbda96b75","modified":1759111974019},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"1a9741145938e2c754a808381350723cbebf43c5","modified":1759111974019},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1759111973987},{"_id":"themes/next/source/lib/pace/pace-theme-flat-top.min.css","hash":"5e1c97e232b46e48592a8e4983ae5a89e0a7da6a","modified":1759057797308},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1759111973987},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"31a6c8fbdfa16112b0b099727437b9df7641d421","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"d002c9eea7e7dd31b64a4172012d4294489974d5","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"14917c0f9ac76b50296e64437316cba0966c61d1","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1759111973987},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"7ff11f64f4315d06ba585928fc9a8bc3761894a5","modified":1759111973987},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1759111973997},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"6471369bd120986f4afad25ad1216f9c4e8405d5","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"7ed4733240206d1aa729c835e69a85f8f3c73cd6","modified":1759111974002},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1759111974008},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1759111974007},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"83b7104a319cfbf6af3548f354240eb07dd73d38","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1759111974008},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1759111974011},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"315eea625a90a19421b6d6413322ae40bb5ad4c6","modified":1759111974011},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"919068c7db32bfee26238e3a783efe14b3060d63","modified":1759111974011},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"c9df5ee78b46f4a2926e6e88fbe1ba1a9a75aecc","modified":1759111974011},{"_id":"themes/next/source/lib/canvas-ribbon/theme-next-canvas-ribbon-master/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1759058217329},{"_id":"themes/next/source/lib/canvas-ribbon/theme-next-canvas-ribbon-master/README.md","hash":"3a18d68b0673c0e79faecc8503268ac7bec7d30e","modified":1759058217355},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1759111974011},{"_id":"themes/next/source/lib/canvas-ribbon/theme-next-canvas-ribbon-master/canvas-ribbon.js","hash":"65b1a8f12d04b15d7ed6eeb9d11dec760a799c5f","modified":1759058217370},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1759111974021},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1759111974021},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1759111974022},{"_id":"themes/next/source/lib/pace/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1759057797458},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"f7977cfacaca9db6fab4d154486ad57ec4b0fde9","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"73c578914052e11392cd4364af9075b66832b793","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1759111973997},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"0812ae7ecd1d8c60ec4290f506ec10881ed0fca8","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1759111974002},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1759111974002},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1759111973994},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1759111974002},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"66001b7624ca044f9c06e75036f0e6e4b091b094","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"5912a1676a973b6d9291b43aec6aeeef6871d1ed","modified":1759111973994},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"a22c639cdf1073c9d060af62233125991ddf4dd5","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1759111973994},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"44749e3f07a328d81a959708316494d3d737ab57","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"81b2bbd6fb590101a089bc390ed4934f5c462215","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"82a275ca74086a46b8e82d5ebf78c7a807cd9c8b","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1759111973997},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1759111973997},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"8c318a485c56dbdcdb22fd00781484ecc151bf8a","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"9d1f42d01f6e346b61f83cdd4f5fbd3bf8e44968","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1759111974007},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1759111974002},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1759111974007},{"_id":"themes/next/source/lib/canvas-ribbon/theme-next-canvas-ribbon-master/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1759058217386},{"_id":"source/images/wechatpay.jpg","hash":"4f7b73da01747011fb11fe937256210b1440343b","modified":1759056317889},{"_id":"source/_posts/buildroot/stage_install/photo/stage_install1.png","hash":"d0c23fc7da37176cf88979bee31141ad1fda271f","modified":1751378133020},{"_id":"source/_posts/buildroot/stage_install/photo/stage_install0.png","hash":"510b5c98d7fa60e398c4e0e15a0bd24c4f768c20","modified":1751378186677},{"_id":"source/_posts/buildroot/stage_install/photo/stage_install2.png","hash":"e9516f2e56c1ec5ab24ef261d6cbd1f4b0f1ff9f","modified":1751378069381},{"_id":"source/_posts/muduo/EventLoopThreadPool/photo/EventLoopThreadPool.drawio.png","hash":"efc8d5f6931112927291f92b16f10b1c60678d1d","modified":1705460743374},{"_id":"source/_posts/xv6/Boot/photo/scheduler/APICStructure.png","hash":"90aa790259201a55aa54328695c98bb8d63948ef","modified":1717571871485},{"_id":"source/_posts/xv6/Boot/photo/scheduler/MP_Configuration_Data_Structures.png","hash":"2916cdda4078a3dbb84f424a81a42fba9200abaa","modified":1717650679511},{"_id":"source/_posts/xv6/Boot/photo/scheduler/entry_types.png","hash":"f4ecccc51783db7a021e60befb4b5ec3040f5e0b","modified":1717649747224},{"_id":"source/_posts/xv6/Boot/photo/scheduler/processor_entry.png","hash":"e922fd5bab1c28c3e869803e1f1dbddbe0b9363e","modified":1717646358453},{"_id":"source/_posts/xv6/Boot/photo/scheduler/scheduler.drawio.png","hash":"d8fd08a7e1c6ac088c2c55da51d3f2b4082d2038","modified":1717687042770},{"_id":"source/_posts/xv6/Boot/photo/scheduler/scheduler_pluse.drawio.png","hash":"2c5e81074ed0f84056964fdf070ed45e97196f89","modified":1717935466105},{"_id":"source/_posts/xv6/Boot/photo/scheduler/universal_algorithm.png","hash":"a2dd1ec0eb390d534e4570d8eac0a8427727a1d0","modified":1717666452516},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/APICStructure.png","hash":"90aa790259201a55aa54328695c98bb8d63948ef","modified":1717571871485},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png","hash":"2916cdda4078a3dbb84f424a81a42fba9200abaa","modified":1717650679511},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/entry_types.png","hash":"f4ecccc51783db7a021e60befb4b5ec3040f5e0b","modified":1717649747224},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/processor_entry.png","hash":"e922fd5bab1c28c3e869803e1f1dbddbe0b9363e","modified":1717646358453},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/scheduler.drawio.png","hash":"d8fd08a7e1c6ac088c2c55da51d3f2b4082d2038","modified":1717687042770},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/scheduler_pluse.drawio.png","hash":"2c5e81074ed0f84056964fdf070ed45e97196f89","modified":1717935466105},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/universal_algorithm.png","hash":"a2dd1ec0eb390d534e4570d8eac0a8427727a1d0","modified":1717666452516},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio.png","hash":"0510767317a632fdf8e8077007492b81d4f9dc4a","modified":1758457929179},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache.drawio.png","hash":"e69f782d81971897de45ba427d9cdca7757b7b24","modified":1758455633428},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache2.drawio.png","hash":"ced58c1012c04b6e486fb2eec12a618126422a83","modified":1758458318241},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache3.drawio.png","hash":"8f1b794aa02d3125a379b0636d648b4326c7294d","modified":1758459074551},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_dentry.drawio.png","hash":"8d3f51c1b536e41e6d64e4b26c45c8a1daabd000","modified":1758989274858},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_ide.drawio.png","hash":"73e5cf76ca64efd8d99c2f71e04967f1f1b8fcd8","modified":1758274994042},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_mount.drawio","hash":"5e94d7ab3a3f38419022b57dfda1a430d8b4dcb4","modified":1759111973927},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio","hash":"8d25e43234e275ffd482a771bff5318f69b58ddf","modified":1759111973927},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio.png","hash":"95e79ebed1e00dffdc1827adafe184f246163bf2","modified":1758197598316},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_ide.drawio.png","hash":"ba8ea2c0090da682608a91cd37c9fa107f8e1b91","modified":1758264793550},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/vaddr2paddr.png","hash":"6ffa614b9a3a80240fc42d53e2faecf7d516d141","modified":1717476210791},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1759049304944},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1759049304916},{"_id":"source/_posts/muduo/AsyncLogging/photo/AsynLogging.drawio.png","hash":"d9a524d478c3ea9f3a47a744bb2ccf962ccb3fec","modified":1706771088386},{"_id":"source/_posts/workflow/TCPServer_1/photo/EventLoopThreadPool.drawio.png","hash":"6378bde2125ca7e8a1e85b123866b983d8574fb2","modified":1730363968900},{"_id":"source/_posts/xv6/Boot/photo/scheduler/MP_configuration_table_header.png","hash":"77f8f397c241da0e86e870ccfaa281a0d5efb536","modified":1717646308549},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/MP_configuration_table_header.png","hash":"77f8f397c241da0e86e870ccfaa281a0d5efb536","modified":1717646308549},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio.png","hash":"30030b6c629dbb70e3d0f84043d07be91ff74361","modified":1758888464591},{"_id":"source/_posts/muduo/TcpServer/photo/TcpServer.drawio.png","hash":"aa9f13db074318701d634b6a57abd727b1730f5f","modified":1705651048478},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1759049304887},{"_id":"source/_posts/workflow/TCPServer_1/photo/EventLoopFlowChart.drawio.png","hash":"bdbda89e07f8248ccb9689325a5cd2c0ecd0c2f9","modified":1730363057282},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio.png","hash":"cbc2de25bbddf38fb4da4787b179b992908f771d","modified":1758975153948},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_mount.drawio.png","hash":"9937ffdc3bded10f1ae61991a4f116455026b3e9","modified":1758971773093},{"_id":"source/_posts/xv6/Boot/photo/scheduler/trap__structure.png","hash":"2c96a0e25efeda0c90515b6cd996c28409fe1dfb","modified":1717661661090},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/trap__structure.png","hash":"2c96a0e25efeda0c90515b6cd996c28409fe1dfb","modified":1717661661090},{"_id":"source/_posts/xv6/Boot/photo/scheduler/yield_scheduler.png","hash":"ca89de4ab6f0f1f47b33cd4983fd390bc23f3811","modified":1717685346373},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/yield_scheduler.png","hash":"ca89de4ab6f0f1f47b33cd4983fd390bc23f3811","modified":1717685346373},{"_id":"source/_posts/workflow/TCPServer_2/photo/StateTranslateThreadPool.drawio.png","hash":"68eeedeae08a12c9839189bf5a90e8830575e895","modified":1730618095140},{"_id":"source/_posts/workflow/TCPServer_2/photo/ReadStatusTranslate.drawio.png","hash":"7bd7f8ebef714823af6113fa5dc06fb67c5ebd9f","modified":1730638585817},{"_id":"public/about/index.html","hash":"4e7d045c600c521ddece36d98e67ec2cef8e37ef","modified":1759122105257},{"_id":"public/categories/index.html","hash":"ac5d1d86c8b73fac100ec8d90f195d943db788f1","modified":1759122105257},{"_id":"public/tags/index.html","hash":"eec83d1442d4cde75c77554e77c22a08b329dfd2","modified":1759122105257},{"_id":"public/archives/page/3/index.html","hash":"6d05d00d4ada7d36ea60b1d5dd1fa94d943cb0a4","modified":1759122105257},{"_id":"public/archives/2024/06/index.html","hash":"01f04798033b74399b7428a8d01ff61d01851360","modified":1759122105257},{"_id":"public/archives/2024/10/index.html","hash":"da53c90507e5d9a51fe63e34af13016d3740ee94","modified":1759122105257},{"_id":"public/archives/2024/11/page/2/index.html","hash":"827fc29833ceec698de2e75b5b43ddce402203c8","modified":1759122105257},{"_id":"public/archives/2025/index.html","hash":"69fdfe055306b54a6db23f5179765eb99d91272c","modified":1759122105257},{"_id":"public/archives/2025/09/index.html","hash":"e919969afe4e5bb1f28a6afe0d161302d8b47080","modified":1759122105257},{"_id":"public/page/3/index.html","hash":"a858ba6a181b801a182216a808556c3d5d055825","modified":1759122105257},{"_id":"public/tags/Linux/index.html","hash":"1320e33403aba2225fa36d4fc19f23db430da6b2","modified":1759122105257},{"_id":"public/tags//page/2/index.html","hash":"5040dbcd1e563e1af1d27650f0b76197cf3b76c0","modified":1759122105257},{"_id":"public/tags/Unix/index.html","hash":"e9dda06e22a3ea550b431ec74ba6255d5e14703e","modified":1759122105257},{"_id":"public/2025/09/28/buildroot/stage_install/index.html","hash":"11499183fd18b97bb4a3492df7a7abafe3f8984a","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/index.html","hash":"dc7ea0b0ed3ca2c4ee66d6d72d08972c1788270a","modified":1759122105257},{"_id":"public/2024/11/07/workflow/TCPServer_3/index.html","hash":"4f54d8ef9c83ec2fe630ae4ab15f1378ae874fff","modified":1759122105257},{"_id":"public/2024/11/04/workflow/TCPServer_2/index.html","hash":"c8ed1ea24c121e2ff6fbadb19cb0d02fd6899fbe","modified":1759122105257},{"_id":"public/2024/11/02/muduo/AsyncLogging/index.html","hash":"2e1c9b8f3033bdc51e4263e64bfa097a9276e2e5","modified":1759122105257},{"_id":"public/2024/11/02/muduo/ChannelAndPoller/index.html","hash":"495601eae67308dbbbcf622b8394666a550f0906","modified":1759122105257},{"_id":"public/2024/11/02/muduo/Start/index.html","hash":"0f7eee216abbc6c579431834dd03099efc6b5513","modified":1759122105257},{"_id":"public/2024/11/02/muduo/EventLoopThreadPool/index.html","hash":"5f12c8c3c82dc7a3453cffc0aa775836bf5abf02","modified":1759122105257},{"_id":"public/2024/11/02/muduo/EvevntLoopAndThread/index.html","hash":"bc6f7074e136b7995234699288765b2cd4c98acd","modified":1759122105257},{"_id":"public/2024/11/02/muduo/SynLogging/index.html","hash":"ecf8de9c8782ae0a0a9e08185edaba05b265b1b8","modified":1759122105257},{"_id":"public/2024/11/02/muduo/TcpClient/index.html","hash":"f5092026d7a7c908e7447f07941fb3ed475da917","modified":1759122105257},{"_id":"public/2024/11/02/muduo/TcpConnection/index.html","hash":"7b4635acad1bb9993091da4db0a0f703237caaeb","modified":1759122105257},{"_id":"public/2024/11/02/muduo/TcpServer/index.html","hash":"5dad0f4e7f8e861aa973b5273535d99eddc73a25","modified":1759122105257},{"_id":"public/2024/11/02/muduo/ThreadAndThreadPool/index.html","hash":"ca567df348581cfa1eb70e03cecf5f2ac44fe2ca","modified":1759122105257},{"_id":"public/2024/11/02/muduo/ThreadSafeAndSync/index.html","hash":"3661a29f97501adf3793da86c9aec7d94417628a","modified":1759122105257},{"_id":"public/2024/11/02/muduo/TimerQueue/index.html","hash":"79f2530ad7cb24315b18433e06bbf6dcd10725a2","modified":1759122105257},{"_id":"public/2024/11/02/workflow/TCPServer_1/index.html","hash":"1416b9b4267c60a8942048c6ef1f0d9d35015394","modified":1759122105257},{"_id":"public/2024/10/13/workflow/go_task/index.html","hash":"d5160874e61dcaa37127293867b52e9d498f1ba9","modified":1759122105257},{"_id":"public/2024/06/08/xv6/Scheduler/index.html","hash":"815b8f4569ec549b1378d7a0b2ce33d70417f9bf","modified":1759122105257},{"_id":"public/2024/06/07/xv6/MemoryManager/index.html","hash":"0e1cf722c970b89b19b068958a2ce3ac16a7581c","modified":1759122105257},{"_id":"public/2024/06/07/xv6/Boot/index.html","hash":"0311d784b7f57b78760be25f89473a87d2dfd641","modified":1759122105257},{"_id":"public/archives/index.html","hash":"3a467ed228e509a0df44966fff97c3006b7d230f","modified":1759122105257},{"_id":"public/archives/page/2/index.html","hash":"dcba0cd0495fd9dc5b088f63ed5a487274a163ed","modified":1759122105257},{"_id":"public/archives/2024/index.html","hash":"c71889dc61febfd610835c2fde8c2ed42e5ee333","modified":1759122105257},{"_id":"public/archives/2024/page/2/index.html","hash":"4d6ddf61bd59ee2f24389d6ad390e2836d0a7964","modified":1759122105257},{"_id":"public/archives/2024/11/index.html","hash":"3f5e0e42e8561d0f34f8f8b1b7e9c0a1c0c959b9","modified":1759122105257},{"_id":"public/index.html","hash":"cbe204d9e0815682b4f0e74b70b3e05a25cd50ad","modified":1759122105257},{"_id":"public/page/2/index.html","hash":"c3c663d953df7792a9a5d45a624cb705c6179db3","modified":1759122105257},{"_id":"public/tags//index.html","hash":"0afb785e02ae1dd594f0a4941c97842a44739709","modified":1759122105257},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1759110968437},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1759110968437},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1759122105257},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1759122105257},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1759122105257},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1759122105257},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1759122105257},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1759122105257},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1759122105257},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1759110968437},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1759122105257},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1759110968437},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1759122105257},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1759122105257},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1759122105257},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1759122105257},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1759122105257},{"_id":"public/images/avatar.jpg","hash":"eedc3cb767ecbcdbadd5e7e1b4a2c574eeb930c3","modified":1759110968437},{"_id":"public/2024/11/02/muduo/ThreadAndThreadPool/photo/ThreadPool.drawio.png","hash":"fd81e3dc3084ae1ba009f2b0c5b808025921ae42","modified":1759110968437},{"_id":"public/2024/11/02/muduo/EvevntLoopAndThread/photo/EventLoop.drawio.png","hash":"1b042f052b1c603a63b3423dbd16c661e8e03d28","modified":1759110968437},{"_id":"public/2024/06/07/xv6/MemoryManager/photo/memmanager/entry.png","hash":"3d63c684eb7a4300424f1cc83b64407f8346b3ae","modified":1759110968437},{"_id":"public/2024/06/07/xv6/MemoryManager/photo/memmanager/kalloc.drawio.png","hash":"7051117fab81b005bd89c6b5ecf5306dd0621885","modified":1759110968437},{"_id":"public/2024/06/07/xv6/MemoryManager/photo/memmanager/main_page_table.drawio.png","hash":"c892bc156ba2d25cdb8372353b4f5c262f2e4c99","modified":1759110968437},{"_id":"public/2024/06/07/xv6/MemoryManager/photo/memmanager/memory_paging_02.drawio.png","hash":"28391dd60a873b1a9c780022ad1bbbe92309bfad","modified":1759110968437},{"_id":"public/lib/canvas-ribbon/theme-next-canvas-ribbon-master/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1759110968437},{"_id":"public/lib/pace/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1759110968437},{"_id":"public/2024/06/07/xv6/MemoryManager/photo/memmanager/onix_memory_map.drawio.png","hash":"21b0eb31b9d8524d394b6345a1b78add0ce073ee","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/8259a.drawio.png","hash":"83d2785b610a50aed51bbd2721a4d8dc91d09e6d","modified":1759110968437},{"_id":"public/2024/06/07/xv6/MemoryManager/photo/memmanager/vaddr.png","hash":"5428246143a54c039ddf86504d7d77c104b4a4dc","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/IDTR.png","hash":"49db6c278ef03ebf2a718819995c81a7e0e852b5","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/ioapic_entry.png","hash":"7b551a258d0b1dc29c5851d1c8355fa037841796","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/imcrp.png","hash":"8c9864113c89b148bd721ea5f4b93b6e6da5efa9","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/IDT_Entry.png","hash":"4cd80376efd49a1cfa9213496d7b61f3320eb64c","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/MP_floating_pointer_structure.png","hash":"a3458fe0c961df5a72a7cf12b409dd9dcc05afe5","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/task_stack.drawio.png","hash":"ba199d6a2e2d9f403408bbeabc5b94a4d598f4e0","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/trap_frame.png","hash":"6a191f20fab43fadd95da12ef456ee6c149cba87","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio","hash":"bc34b6aad6a41e1dadad7aac08c053de83ec9b62","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache.drawio","hash":"7474147536b4ac4c3c00ea16b07671f780e13d97","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache2.drawio","hash":"f34adef92989402356e6d139def58c7e190c55b7","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache3.drawio","hash":"31c156b1c05b206c65cff8160e891390acc88823","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_dentry.drawio","hash":"65a8be4674b07c5b29bdde8b2902729cb5f9d15d","modified":1759122105257},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1759110968437},{"_id":"public/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1759110968437},{"_id":"public/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1759110968437},{"_id":"public/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1759110968437},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1759110968437},{"_id":"public/js/local-search.js","hash":"b42bd1c883ce91db8632d96e0f0e062cb6b73adc","modified":1759110968437},{"_id":"public/js/utils.js","hash":"d26efec3ecda8ec1ac32a4304e8c309c07aec56b","modified":1759110968437},{"_id":"public/css/main.css","hash":"77cc8f08bee3d9433f0b8a19dea65a95d382868c","modified":1759122105257},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio","hash":"08195759ab6c5ac2616e128760855b57a992e852","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio.png","hash":"3337f4f391a9d971abdf4951b0a2987486775eb8","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio","hash":"8ce9d32364920623b9dd517df178e8bbcc68cb6b","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_ide.drawio","hash":"1a8f29964aee9423db4757763cf65a47daa4d211","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio.png","hash":"09710d67477b554aaa7323a2c375ee9d0d341687","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio","hash":"a64e4db9d0e53d2981f516a2e7135e52a2f177d0","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_fsstructureondisk.png","hash":"3347f61be1d43d87912ac2106a09c6a34576669e","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio","hash":"4319249aa4713a3944272ca2c77b95fd4415e428","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio","hash":"ed57340c1d5249c677289edf08db313e3be0a089","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_ide.drawio","hash":"7b59e34715988f6a95cb9851e0ebe6502b473c4d","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio.png","hash":"c97b586ce404c596a4cc0577d3691ae36ef1beb0","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/Logo.jpg","hash":"808892bb96be6a1e7e82534873c36e7ae2cb9544","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/8259a.drawio.png","hash":"83d2785b610a50aed51bbd2721a4d8dc91d09e6d","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/IDTR.png","hash":"49db6c278ef03ebf2a718819995c81a7e0e852b5","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/IDT_Entry.png","hash":"4cd80376efd49a1cfa9213496d7b61f3320eb64c","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/imcrp.png","hash":"8c9864113c89b148bd721ea5f4b93b6e6da5efa9","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/ioapic_entry.png","hash":"7b551a258d0b1dc29c5851d1c8355fa037841796","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/MP_floating_pointer_structure.png","hash":"a3458fe0c961df5a72a7cf12b409dd9dcc05afe5","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/task_stack.drawio.png","hash":"ba199d6a2e2d9f403408bbeabc5b94a4d598f4e0","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/trap_frame.png","hash":"6a191f20fab43fadd95da12ef456ee6c149cba87","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/start/boot.drawio.png","hash":"4d4eeec0332589443e39742c5007784058433312","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/start/entry.drawio.png","hash":"60d49b69b0f343b4bb71c830294c95c7565bb5ff","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/start/GDT.png","hash":"c7865b8c24a0bb195567b318fdb2c332c642e954","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/start/GDTR.png","hash":"c1de122b466da828be0ae56e3d195416f5c29af4","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/start/SegmentDescriptor.png","hash":"0b2178b404782f2aedef546f3e4841cd4b0f5328","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/start/SegmentSelector.png","hash":"4cb9e6e79a1e9e29cb4bfc975e050855d58a0d9c","modified":1759110968437},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1759110968437},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1759110968437},{"_id":"public/images/wechatpay.jpg","hash":"4f7b73da01747011fb11fe937256210b1440343b","modified":1759110968437},{"_id":"public/2024/11/02/muduo/AsyncLogging/photo/AsynLogging.drawio.png","hash":"d9a524d478c3ea9f3a47a744bb2ccf962ccb3fec","modified":1759110968437},{"_id":"public/2025/09/28/buildroot/stage_install/photo/stage_install0.png","hash":"510b5c98d7fa60e398c4e0e15a0bd24c4f768c20","modified":1759110968437},{"_id":"public/2024/11/02/muduo/EventLoopThreadPool/photo/EventLoopThreadPool.drawio.png","hash":"efc8d5f6931112927291f92b16f10b1c60678d1d","modified":1759110968437},{"_id":"public/2025/09/28/buildroot/stage_install/photo/stage_install1.png","hash":"d0c23fc7da37176cf88979bee31141ad1fda271f","modified":1759110968437},{"_id":"public/2025/09/28/buildroot/stage_install/photo/stage_install2.png","hash":"e9516f2e56c1ec5ab24ef261d6cbd1f4b0f1ff9f","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/APICStructure.png","hash":"90aa790259201a55aa54328695c98bb8d63948ef","modified":1759110968437},{"_id":"public/2024/06/07/xv6/MemoryManager/photo/memmanager/vaddr2paddr.png","hash":"6ffa614b9a3a80240fc42d53e2faecf7d516d141","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/entry_types.png","hash":"f4ecccc51783db7a021e60befb4b5ec3040f5e0b","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png","hash":"2916cdda4078a3dbb84f424a81a42fba9200abaa","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler.drawio.png","hash":"d8fd08a7e1c6ac088c2c55da51d3f2b4082d2038","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler_pluse.drawio.png","hash":"2c5e81074ed0f84056964fdf070ed45e97196f89","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/universal_algorithm.png","hash":"a2dd1ec0eb390d534e4570d8eac0a8427727a1d0","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio.png","hash":"0510767317a632fdf8e8077007492b81d4f9dc4a","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache2.drawio.png","hash":"ced58c1012c04b6e486fb2eec12a618126422a83","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache.drawio.png","hash":"e69f782d81971897de45ba427d9cdca7757b7b24","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache3.drawio.png","hash":"8f1b794aa02d3125a379b0636d648b4326c7294d","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_dentry.drawio.png","hash":"8d3f51c1b536e41e6d64e4b26c45c8a1daabd000","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1759110968437},{"_id":"public/lib/pace/README.html","hash":"b1db0e6c71c25fbdc5a161e1bd70382846ce99ab","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-flat-top.min.css","hash":"5e1c97e232b46e48592a8e4983ae5a89e0a7da6a","modified":1759110968437},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1759110968437},{"_id":"public/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1759110968437},{"_id":"public/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1759110968437},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1759110968437},{"_id":"public/lib/canvas-ribbon/theme-next-canvas-ribbon-master/README.html","hash":"1b6d10c79836d002d90f4bcf35f498f1bf38c7ee","modified":1759110968437},{"_id":"public/lib/canvas-ribbon/theme-next-canvas-ribbon-master/canvas-ribbon.js","hash":"65b1a8f12d04b15d7ed6eeb9d11dec760a799c5f","modified":1759110968437},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1759110968437},{"_id":"public/lib/pace/pace-theme-material.min.css","hash":"f1ff83985c090f3a3236554c5ef69542dcceb049","modified":1759110968437},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1759110968437},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/processor_entry.png","hash":"e922fd5bab1c28c3e869803e1f1dbddbe0b9363e","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_ide.drawio.png","hash":"73e5cf76ca64efd8d99c2f71e04967f1f1b8fcd8","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_mount.drawio","hash":"5e94d7ab3a3f38419022b57dfda1a430d8b4dcb4","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio","hash":"8d25e43234e275ffd482a771bff5318f69b58ddf","modified":1759122105257},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio.png","hash":"95e79ebed1e00dffdc1827adafe184f246163bf2","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_ide.drawio.png","hash":"ba8ea2c0090da682608a91cd37c9fa107f8e1b91","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/entry_types.png","hash":"f4ecccc51783db7a021e60befb4b5ec3040f5e0b","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/APICStructure.png","hash":"90aa790259201a55aa54328695c98bb8d63948ef","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/MP_Configuration_Data_Structures.png","hash":"2916cdda4078a3dbb84f424a81a42fba9200abaa","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/scheduler_pluse.drawio.png","hash":"2c5e81074ed0f84056964fdf070ed45e97196f89","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/scheduler.drawio.png","hash":"d8fd08a7e1c6ac088c2c55da51d3f2b4082d2038","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/processor_entry.png","hash":"e922fd5bab1c28c3e869803e1f1dbddbe0b9363e","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/universal_algorithm.png","hash":"a2dd1ec0eb390d534e4570d8eac0a8427727a1d0","modified":1759110968437},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1759110968437},{"_id":"public/2024/11/02/workflow/TCPServer_1/photo/EventLoopThreadPool.drawio.png","hash":"6378bde2125ca7e8a1e85b123866b983d8574fb2","modified":1759110968437},{"_id":"public/2024/11/02/muduo/TcpServer/photo/TcpServer.drawio.png","hash":"aa9f13db074318701d634b6a57abd727b1730f5f","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/MP_configuration_table_header.png","hash":"77f8f397c241da0e86e870ccfaa281a0d5efb536","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio.png","hash":"30030b6c629dbb70e3d0f84043d07be91ff74361","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/MP_configuration_table_header.png","hash":"77f8f397c241da0e86e870ccfaa281a0d5efb536","modified":1759110968437},{"_id":"public/2024/11/02/workflow/TCPServer_1/photo/EventLoopFlowChart.drawio.png","hash":"bdbda89e07f8248ccb9689325a5cd2c0ecd0c2f9","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio.png","hash":"cbc2de25bbddf38fb4da4787b179b992908f771d","modified":1759110968437},{"_id":"public/2025/09/28/xv6/FileSystem/photo/filesystem/onix_mount.drawio.png","hash":"9937ffdc3bded10f1ae61991a4f116455026b3e9","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/trap__structure.png","hash":"2c96a0e25efeda0c90515b6cd996c28409fe1dfb","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/trap__structure.png","hash":"2c96a0e25efeda0c90515b6cd996c28409fe1dfb","modified":1759110968437},{"_id":"public/2024/06/08/xv6/Scheduler/photo/scheduler/yield_scheduler.png","hash":"ca89de4ab6f0f1f47b33cd4983fd390bc23f3811","modified":1759110968437},{"_id":"public/2024/06/07/xv6/Boot/photo/scheduler/yield_scheduler.png","hash":"ca89de4ab6f0f1f47b33cd4983fd390bc23f3811","modified":1759110968437},{"_id":"public/2024/11/04/workflow/TCPServer_2/photo/StateTranslateThreadPool.drawio.png","hash":"68eeedeae08a12c9839189bf5a90e8830575e895","modified":1759110968437},{"_id":"public/2024/11/04/workflow/TCPServer_2/photo/ReadStatusTranslate.drawio.png","hash":"7bd7f8ebef714823af6113fa5dc06fb67c5ebd9f","modified":1759110968437}],"Category":[],"Data":[],"Page":[{"title":"","date":"2025-09-28T09:44:49.000Z","tags":"about","_content":"","source":"about/index.md","raw":"---\ntitle: \ndate: 2025-09-28 17:44:49\ntags: about\n---\n","updated":"2025-09-29T02:12:53.953Z","path":"about/index.html","_id":"cmg3w8w9g0000q8wsdo6dfyst","comments":1,"layout":"page","content":"","excerpt":"","more":""},{"title":"","date":"2025-09-28T09:48:31.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: \ndate: 2025-09-28 17:48:31\ntype: categories\n---\n","updated":"2025-09-29T02:12:53.953Z","path":"categories/index.html","_id":"cmg3w8w9k0002q8ws44n48f9b","comments":1,"layout":"page","content":"","excerpt":"","more":""},{"title":"","date":"2025-09-28T08:57:26.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: \ndate: 2025-09-28 16:57:26\ntype: tags\n---\n","updated":"2025-09-29T02:12:53.955Z","path":"tags/index.html","_id":"cmg3w8w9m0005q8ws2qlggkme","comments":1,"layout":"page","content":"","excerpt":"","more":""}],"Post":[{"title":"Buildrootstage/targetcmakeinstll","date":"2025-09-28T04:00:00.000Z","_content":"\n## \n\n buildroot/package/pkg-cmake.mk buildrootmkXX_INSTALL_STAGING_CMDS  XX_INSTALL_TARGET_CMDSXX_INSTALL_STAGING_CMDSXX_INSTALL_TARGET_CMDSmk\n\nXX_INSTALL_STAGING_CMDS  XX_INSTALL_TARGET_CMDScmake install buildroot/package/pkg-cmake.mk install\n\n\n\n<!-- more -->\n\nConfig.in\n\n```\nconfig BR2_PACKAGE_MYPROJECT\n    bool \"my project\"\n    help\n        this configuration is used to enable or disable myproject.\n```\n\n- XX_INSTALL_STAGING_CMDSmk\n\n    ```makefile\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    # ONVIF_SRVD_VERSION =\n    MYPROJECT_SITE = $(TOPDIR)/../external/myproject\n    MYPROJECT_SITE_METHOD = local\n    MYPROJECT_DEPENDENCIES = rockchip-mpp\n    MYPROJECT_INSTALL_STAGING = YES\n    endif\n\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    $(eval $(cmake-package))\n    endif\n    ```\n\n    \n\n    ![](./stage_install/photo/stage_install0.png)\n\n    cmake\n\n- XX_INSTALL_STAGING_CMDS\n\n    ```makefile\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    # ONVIF_SRVD_VERSION =\n    MYPROJECT_SITE = $(TOPDIR)/../external/myproject\n    MYPROJECT_SITE_METHOD = local\n    MYPROJECT_DEPENDENCIES = rockchip-mpp\n    MYPROJECT_INSTALL_STAGING = YES\n    endif\n\n    define MYPROJECT_INSTALL_STAGING_CMDS\n        echo \"ok\"\n    endef\n\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    $(eval $(cmake-package))\n    endif\n    ```\n\n    \n\n    ![](./stage_install/photo/stage_install1.png)\n\n    ok\n\n- XX_INSTALL_STAGING_CMDSbuildroot/package/pkg-cmake.mkmk\n\n    ```makefile\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    # ONVIF_SRVD_VERSION =\n    MYPROJECT_SITE = $(TOPDIR)/../external/myproject\n    MYPROJECT_SITE_METHOD = local\n    MYPROJECT_DEPENDENCIES = rockchip-mpp\n    MYPROJECT_INSTALL_STAGING = YES\n    endif\n\n    define MYPROJECT_INSTALL_STAGING_CMDS\n        $(TARGET_MAKE_ENV) $(MYPROJECT_MAKE_ENV) $(MYPROJECT_MAKE) $(MYPROJECT_MAKE_OPTS) $(MYPROJECT_INSTALL_STAGING_OPTS) -C $(MYPROJECT_BUILDDIR)\n        echo \"ok\"\n    endef\n\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    $(eval $(cmake-package))\n    endif\n    ```\n\n    \n\n    ![](./stage_install/photo/stage_install2.png)\n\n    cmake\n\n---\n\n****","source":"_posts/buildroot/stage_install.md","raw":"---\ntitle: Buildrootstage/targetcmakeinstll\ndate: 2025-09-28 12:00:00\ntags:\n  - Linux\n---\n\n## \n\n buildroot/package/pkg-cmake.mk buildrootmkXX_INSTALL_STAGING_CMDS  XX_INSTALL_TARGET_CMDSXX_INSTALL_STAGING_CMDSXX_INSTALL_TARGET_CMDSmk\n\nXX_INSTALL_STAGING_CMDS  XX_INSTALL_TARGET_CMDScmake install buildroot/package/pkg-cmake.mk install\n\n\n\n<!-- more -->\n\nConfig.in\n\n```\nconfig BR2_PACKAGE_MYPROJECT\n    bool \"my project\"\n    help\n        this configuration is used to enable or disable myproject.\n```\n\n- XX_INSTALL_STAGING_CMDSmk\n\n    ```makefile\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    # ONVIF_SRVD_VERSION =\n    MYPROJECT_SITE = $(TOPDIR)/../external/myproject\n    MYPROJECT_SITE_METHOD = local\n    MYPROJECT_DEPENDENCIES = rockchip-mpp\n    MYPROJECT_INSTALL_STAGING = YES\n    endif\n\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    $(eval $(cmake-package))\n    endif\n    ```\n\n    \n\n    ![](./stage_install/photo/stage_install0.png)\n\n    cmake\n\n- XX_INSTALL_STAGING_CMDS\n\n    ```makefile\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    # ONVIF_SRVD_VERSION =\n    MYPROJECT_SITE = $(TOPDIR)/../external/myproject\n    MYPROJECT_SITE_METHOD = local\n    MYPROJECT_DEPENDENCIES = rockchip-mpp\n    MYPROJECT_INSTALL_STAGING = YES\n    endif\n\n    define MYPROJECT_INSTALL_STAGING_CMDS\n        echo \"ok\"\n    endef\n\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    $(eval $(cmake-package))\n    endif\n    ```\n\n    \n\n    ![](./stage_install/photo/stage_install1.png)\n\n    ok\n\n- XX_INSTALL_STAGING_CMDSbuildroot/package/pkg-cmake.mkmk\n\n    ```makefile\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    # ONVIF_SRVD_VERSION =\n    MYPROJECT_SITE = $(TOPDIR)/../external/myproject\n    MYPROJECT_SITE_METHOD = local\n    MYPROJECT_DEPENDENCIES = rockchip-mpp\n    MYPROJECT_INSTALL_STAGING = YES\n    endif\n\n    define MYPROJECT_INSTALL_STAGING_CMDS\n        $(TARGET_MAKE_ENV) $(MYPROJECT_MAKE_ENV) $(MYPROJECT_MAKE) $(MYPROJECT_MAKE_OPTS) $(MYPROJECT_INSTALL_STAGING_OPTS) -C $(MYPROJECT_BUILDDIR)\n        echo \"ok\"\n    endef\n\n    ifeq ($(BR2_PACKAGE_MYPROJECT), y)\n    $(eval $(cmake-package))\n    endif\n    ```\n\n    \n\n    ![](./stage_install/photo/stage_install2.png)\n\n    cmake\n\n---\n\n****","slug":"buildroot/stage_install","published":1,"updated":"2025-09-28T09:41:18.567Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9i0001q8ws0sso6gl1","content":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p> buildroot&#x2F;package&#x2F;pkg-cmake.mk buildrootmkXX_INSTALL_STAGING_CMDS  XX_INSTALL_TARGET_CMDSXX_INSTALL_STAGING_CMDSXX_INSTALL_TARGET_CMDSmk</p>\n<p>XX_INSTALL_STAGING_CMDS  XX_INSTALL_TARGET_CMDScmake install buildroot&#x2F;package&#x2F;pkg-cmake.mk install</p>\n<p></p>\n<span id=\"more\"></span>\n\n<p>Config.in</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config BR2_PACKAGE_MYPROJECT</span><br><span class=\"line\">    bool &quot;my project&quot;</span><br><span class=\"line\">    help</span><br><span class=\"line\">        this configuration is used to enable or disable myproject.</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>XX_INSTALL_STAGING_CMDSmk</p>\n  <figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"comment\"># ONVIF_SRVD_VERSION =</span></span><br><span class=\"line\">MYPROJECT_SITE = <span class=\"variable\">$(TOPDIR)</span>/../external/myproject</span><br><span class=\"line\">MYPROJECT_SITE_METHOD = local</span><br><span class=\"line\">MYPROJECT_DEPENDENCIES = rockchip-mpp</span><br><span class=\"line\">MYPROJECT_INSTALL_STAGING = YES</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">eval</span> $(cmake-package)</span>)</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<p>  </p>\n<p>  <img src=\"/2025/09/28/buildroot/stage_install/photo/stage_install0.png\"></p>\n<p>  cmake</p>\n</li>\n<li><p>XX_INSTALL_STAGING_CMDS</p>\n  <figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"comment\"># ONVIF_SRVD_VERSION =</span></span><br><span class=\"line\">MYPROJECT_SITE = <span class=\"variable\">$(TOPDIR)</span>/../external/myproject</span><br><span class=\"line\">MYPROJECT_SITE_METHOD = local</span><br><span class=\"line\">MYPROJECT_DEPENDENCIES = rockchip-mpp</span><br><span class=\"line\">MYPROJECT_INSTALL_STAGING = YES</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">define</span> MYPROJECT_INSTALL_STAGING_CMDS</span><br><span class=\"line\">    echo <span class=\"string\">&quot;ok&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">endef</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">eval</span> $(cmake-package)</span>)</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<p>  </p>\n<p>  <img src=\"/2025/09/28/buildroot/stage_install/photo/stage_install1.png\"></p>\n<p>  ok</p>\n</li>\n<li><p>XX_INSTALL_STAGING_CMDSbuildroot&#x2F;package&#x2F;pkg-cmake.mkmk</p>\n  <figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"comment\"># ONVIF_SRVD_VERSION =</span></span><br><span class=\"line\">MYPROJECT_SITE = <span class=\"variable\">$(TOPDIR)</span>/../external/myproject</span><br><span class=\"line\">MYPROJECT_SITE_METHOD = local</span><br><span class=\"line\">MYPROJECT_DEPENDENCIES = rockchip-mpp</span><br><span class=\"line\">MYPROJECT_INSTALL_STAGING = YES</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">define</span> MYPROJECT_INSTALL_STAGING_CMDS</span><br><span class=\"line\">    <span class=\"variable\">$(TARGET_MAKE_ENV)</span> <span class=\"variable\">$(MYPROJECT_MAKE_ENV)</span> <span class=\"variable\">$(MYPROJECT_MAKE)</span> <span class=\"variable\">$(MYPROJECT_MAKE_OPTS)</span> <span class=\"variable\">$(MYPROJECT_INSTALL_STAGING_OPTS)</span> -C <span class=\"variable\">$(MYPROJECT_BUILDDIR)</span></span><br><span class=\"line\">    echo <span class=\"string\">&quot;ok&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">endef</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">eval</span> $(cmake-package)</span>)</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<p>  </p>\n<p>  <img src=\"/2025/09/28/buildroot/stage_install/photo/stage_install2.png\"></p>\n<p>  cmake</p>\n</li>\n</ul>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p> buildroot&#x2F;package&#x2F;pkg-cmake.mk buildrootmkXX_INSTALL_STAGING_CMDS  XX_INSTALL_TARGET_CMDSXX_INSTALL_STAGING_CMDSXX_INSTALL_TARGET_CMDSmk</p>\n<p>XX_INSTALL_STAGING_CMDS  XX_INSTALL_TARGET_CMDScmake install buildroot&#x2F;package&#x2F;pkg-cmake.mk install</p>\n<p></p>","more":"<p>Config.in</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config BR2_PACKAGE_MYPROJECT</span><br><span class=\"line\">    bool &quot;my project&quot;</span><br><span class=\"line\">    help</span><br><span class=\"line\">        this configuration is used to enable or disable myproject.</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>XX_INSTALL_STAGING_CMDSmk</p>\n  <figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"comment\"># ONVIF_SRVD_VERSION =</span></span><br><span class=\"line\">MYPROJECT_SITE = <span class=\"variable\">$(TOPDIR)</span>/../external/myproject</span><br><span class=\"line\">MYPROJECT_SITE_METHOD = local</span><br><span class=\"line\">MYPROJECT_DEPENDENCIES = rockchip-mpp</span><br><span class=\"line\">MYPROJECT_INSTALL_STAGING = YES</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">eval</span> $(cmake-package)</span>)</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<p>  </p>\n<p>  <img src=\"/2025/09/28/buildroot/stage_install/photo/stage_install0.png\"></p>\n<p>  cmake</p>\n</li>\n<li><p>XX_INSTALL_STAGING_CMDS</p>\n  <figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"comment\"># ONVIF_SRVD_VERSION =</span></span><br><span class=\"line\">MYPROJECT_SITE = <span class=\"variable\">$(TOPDIR)</span>/../external/myproject</span><br><span class=\"line\">MYPROJECT_SITE_METHOD = local</span><br><span class=\"line\">MYPROJECT_DEPENDENCIES = rockchip-mpp</span><br><span class=\"line\">MYPROJECT_INSTALL_STAGING = YES</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">define</span> MYPROJECT_INSTALL_STAGING_CMDS</span><br><span class=\"line\">    echo <span class=\"string\">&quot;ok&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">endef</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">eval</span> $(cmake-package)</span>)</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<p>  </p>\n<p>  <img src=\"/2025/09/28/buildroot/stage_install/photo/stage_install1.png\"></p>\n<p>  ok</p>\n</li>\n<li><p>XX_INSTALL_STAGING_CMDSbuildroot&#x2F;package&#x2F;pkg-cmake.mkmk</p>\n  <figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"comment\"># ONVIF_SRVD_VERSION =</span></span><br><span class=\"line\">MYPROJECT_SITE = <span class=\"variable\">$(TOPDIR)</span>/../external/myproject</span><br><span class=\"line\">MYPROJECT_SITE_METHOD = local</span><br><span class=\"line\">MYPROJECT_DEPENDENCIES = rockchip-mpp</span><br><span class=\"line\">MYPROJECT_INSTALL_STAGING = YES</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">define</span> MYPROJECT_INSTALL_STAGING_CMDS</span><br><span class=\"line\">    <span class=\"variable\">$(TARGET_MAKE_ENV)</span> <span class=\"variable\">$(MYPROJECT_MAKE_ENV)</span> <span class=\"variable\">$(MYPROJECT_MAKE)</span> <span class=\"variable\">$(MYPROJECT_MAKE_OPTS)</span> <span class=\"variable\">$(MYPROJECT_INSTALL_STAGING_OPTS)</span> -C <span class=\"variable\">$(MYPROJECT_BUILDDIR)</span></span><br><span class=\"line\">    echo <span class=\"string\">&quot;ok&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">endef</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BR2_PACKAGE_MYPROJECT)</span>, y)</span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">eval</span> $(cmake-package)</span>)</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<p>  </p>\n<p>  <img src=\"/2025/09/28/buildroot/stage_install/photo/stage_install2.png\"></p>\n<p>  cmake</p>\n</li>\n</ul>\n<hr>\n<p><strong></strong></p>"},{"title":"muduo4","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nMuduoAsyncLogging.ccIOLogFile.ccFileUtil.cc\n\n## \n\nMuduo\n\n****\n\nMuduoMuduo****MuduoMuduo****currentBuffer_nextBuffer_Muduo\n\n****\n\n**** buffers****\n\n\n\n1.  ****\n<!-- more -->\n\n2.  ****\n\n3.  \n\n4.  \n\n**Muduo**\n\n## \n\n****\n\n```cpp\nclass AsyncLogging : noncopyable{\npublic:\n\n    AsyncLogging(const string& basename,\n                off_t rollSize,\n                int flushInterval = 3);\n\n    ~AsyncLogging(){\n        if (running_){\n            stop();\n        }\n    }\n\n    void append(const char* logline, int len);\n\n    void start(){\n        running_ = true;\n        thread_.start();    // \n        latch_.wait();  // \n    }\n\n    void stop() NO_THREAD_SAFETY_ANALYSIS{\n        running_ = false;\n        cond_.notify();\n        thread_.join();\n    }\n\nprivate:\n\n    void threadFunc();\n\n    typedef muduo::detail::FixedBuffer<muduo::detail::kLargeBuffer> Buffer;   // 4M\n    typedef std::vector<std::unique_ptr<Buffer>> BufferVector;  // \n    typedef BufferVector::value_type BufferPtr;\n\n    const int flushInterval_; // \n    std::atomic<bool> running_; // \n    const string basename_; // \n    const off_t rollSize_;  // \n    muduo::Thread thread_;  // \n    muduo::CountDownLatch latch_; // \n    muduo::MutexLock mutex_;\n    muduo::Condition cond_ GUARDED_BY(mutex_);  // Buffer\n    BufferPtr currentBuffer_ GUARDED_BY(mutex_);  // buff\n    BufferPtr nextBuffer_ GUARDED_BY(mutex_); // buff\n    BufferVector buffers_ GUARDED_BY(mutex_); // buff\n};\n```\n\n****\n\nMuduocurrentBuffer_nextBuffer_\n\n![](./AsyncLogging/photo/AsynLogging.drawio.png)\n\n****\n\n```cpp\n/*\n* \n* 1. AsyncLogging::threadFunc\n* 2. currentBuffer_nextBuffer_\n*/\n\n// ...\n\nvoid AsyncLogging::append(const char* logline, int len){\n    muduo::MutexLockGuard lock(mutex_); // \n    if (currentBuffer_->avail() > len){  //\n        currentBuffer_->append(logline, len); // \n    }else{ //\n        buffers_.push_back(std::move(currentBuffer_));  // \n\n        if (nextBuffer_){  // \n            currentBuffer_ = std::move(nextBuffer_);\n        }else { // \n            currentBuffer_.reset(new Buffer); // Rarely happens\n        }\n        currentBuffer_->append(logline, len);\n        cond_.notify(); // \n    }\n}\n\nvoid AsyncLogging::threadFunc(){\n    assert(running_ == true);\n    latch_.countDown();\n    LogFile output(basename_, rollSize_, false);  // \n    BufferPtr newBuffer1(new Buffer); // buff\n    BufferPtr newBuffer2(new Buffer);\n    newBuffer1->bzero();\n    newBuffer2->bzero();\n    BufferVector buffersToWrite;\n    buffersToWrite.reserve(16);\n    while (running_){\n        // buffbuffbuff\n        assert(newBuffer1 && newBuffer1->length() == 0);\n        assert(newBuffer2 && newBuffer2->length() == 0);\n        assert(buffersToWrite.empty());\n\n        {\n            muduo::MutexLockGuard lock(mutex_);\n            if (buffers_.empty()){  // unusual usage!\n                /*\n                * 1. AsyncLogging::append\n                * 2. \n                */\n                cond_.waitForSeconds(flushInterval_);\n            }\n            // currentBuffer_\n            buffers_.push_back(std::move(currentBuffer_)); \n            currentBuffer_ = std::move(newBuffer1); // currentBuffer_\n            buffersToWrite.swap(buffers_);  // \n            if (!nextBuffer_){ // nextBuffer_\n                // nextBuffer_\n                nextBuffer_ = std::move(newBuffer2);\n            }\n        }\n\n        assert(!buffersToWrite.empty());  // 1\n\n        if (buffersToWrite.size() > 25){ // \n            char buf[256];\n            snprintf(buf, sizeof buf, \"Dropped log messages at %s, %zd larger buffers\\n\",\n                    Timestamp::now().toFormattedString().c_str(),\n                    buffersToWrite.size()-2);\n            fputs(buf, stderr);\n            output.append(buf, static_cast<int>(strlen(buf)));\n            buffersToWrite.erase(buffersToWrite.begin()+2, buffersToWrite.end());\n        }\n\n        for (const auto& buffer : buffersToWrite){ // \n            // FIXME: use unbuffered stdio FILE ? or use ::writev ?\n            output.append(buffer->data(), buffer->length());\n        }\n\n        if (buffersToWrite.size() > 2){ // buffnewBuffer1newBuffer2\n            // drop non-bzero-ed buffers, avoid trashing\n            buffersToWrite.resize(2);\n        }\n\n        if (!newBuffer1){\n            assert(!buffersToWrite.empty());\n            newBuffer1 = std::move(buffersToWrite.back());\n            buffersToWrite.pop_back();\n            newBuffer1->reset();\n        }\n\n        if (!newBuffer2){\n            assert(!buffersToWrite.empty());\n            newBuffer2 = std::move(buffersToWrite.back());\n            buffersToWrite.pop_back();\n            newBuffer2->reset();\n        }\n\n        buffersToWrite.clear(); // \n        output.flush(); // \n    }\n    output.flush();\n}\n\n```\n\n****\n\nMuduo\n\n```cpp\n// \n\n// \nstruct CriticalData {\n    // ...\n};\n\nvoid processCriticalData(const CriticalData& data) {\n    // \n    // \n}\n\n// \nvoid criticalSection(const CriticalData& sharedData) {\n    CriticalData localCopy\n    // \n    // ...\n\n    // \n    localCopy.swap(sharedData);\n\n    // \n    // ...\n\n    // \n    processCriticalData(localCopy);\n}\n```\n\n## \n\n****\n\nMuduo\n\n****\n\nMuduo\n\n1.  \n\n2.  \n\n3.  \n\n****\n\nMuduonextBuffer_currentBuffer_newBuffernextBuffer_\n\n****\n\n  nextBuffer_ currentBuffer_ currentBuffer_ \n\n nextBuffer_\n\n---\n\n****","source":"_posts/muduo/AsyncLogging.md","raw":"---\ntitle: muduo4\ndate: 2024-11-02 12:00:00\ntags:\n  - \n---\n\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nMuduoAsyncLogging.ccIOLogFile.ccFileUtil.cc\n\n## \n\nMuduo\n\n****\n\nMuduoMuduo****MuduoMuduo****currentBuffer_nextBuffer_Muduo\n\n****\n\n**** buffers****\n\n\n\n1.  ****\n<!-- more -->\n\n2.  ****\n\n3.  \n\n4.  \n\n**Muduo**\n\n## \n\n****\n\n```cpp\nclass AsyncLogging : noncopyable{\npublic:\n\n    AsyncLogging(const string& basename,\n                off_t rollSize,\n                int flushInterval = 3);\n\n    ~AsyncLogging(){\n        if (running_){\n            stop();\n        }\n    }\n\n    void append(const char* logline, int len);\n\n    void start(){\n        running_ = true;\n        thread_.start();    // \n        latch_.wait();  // \n    }\n\n    void stop() NO_THREAD_SAFETY_ANALYSIS{\n        running_ = false;\n        cond_.notify();\n        thread_.join();\n    }\n\nprivate:\n\n    void threadFunc();\n\n    typedef muduo::detail::FixedBuffer<muduo::detail::kLargeBuffer> Buffer;   // 4M\n    typedef std::vector<std::unique_ptr<Buffer>> BufferVector;  // \n    typedef BufferVector::value_type BufferPtr;\n\n    const int flushInterval_; // \n    std::atomic<bool> running_; // \n    const string basename_; // \n    const off_t rollSize_;  // \n    muduo::Thread thread_;  // \n    muduo::CountDownLatch latch_; // \n    muduo::MutexLock mutex_;\n    muduo::Condition cond_ GUARDED_BY(mutex_);  // Buffer\n    BufferPtr currentBuffer_ GUARDED_BY(mutex_);  // buff\n    BufferPtr nextBuffer_ GUARDED_BY(mutex_); // buff\n    BufferVector buffers_ GUARDED_BY(mutex_); // buff\n};\n```\n\n****\n\nMuduocurrentBuffer_nextBuffer_\n\n![](./AsyncLogging/photo/AsynLogging.drawio.png)\n\n****\n\n```cpp\n/*\n* \n* 1. AsyncLogging::threadFunc\n* 2. currentBuffer_nextBuffer_\n*/\n\n// ...\n\nvoid AsyncLogging::append(const char* logline, int len){\n    muduo::MutexLockGuard lock(mutex_); // \n    if (currentBuffer_->avail() > len){  //\n        currentBuffer_->append(logline, len); // \n    }else{ //\n        buffers_.push_back(std::move(currentBuffer_));  // \n\n        if (nextBuffer_){  // \n            currentBuffer_ = std::move(nextBuffer_);\n        }else { // \n            currentBuffer_.reset(new Buffer); // Rarely happens\n        }\n        currentBuffer_->append(logline, len);\n        cond_.notify(); // \n    }\n}\n\nvoid AsyncLogging::threadFunc(){\n    assert(running_ == true);\n    latch_.countDown();\n    LogFile output(basename_, rollSize_, false);  // \n    BufferPtr newBuffer1(new Buffer); // buff\n    BufferPtr newBuffer2(new Buffer);\n    newBuffer1->bzero();\n    newBuffer2->bzero();\n    BufferVector buffersToWrite;\n    buffersToWrite.reserve(16);\n    while (running_){\n        // buffbuffbuff\n        assert(newBuffer1 && newBuffer1->length() == 0);\n        assert(newBuffer2 && newBuffer2->length() == 0);\n        assert(buffersToWrite.empty());\n\n        {\n            muduo::MutexLockGuard lock(mutex_);\n            if (buffers_.empty()){  // unusual usage!\n                /*\n                * 1. AsyncLogging::append\n                * 2. \n                */\n                cond_.waitForSeconds(flushInterval_);\n            }\n            // currentBuffer_\n            buffers_.push_back(std::move(currentBuffer_)); \n            currentBuffer_ = std::move(newBuffer1); // currentBuffer_\n            buffersToWrite.swap(buffers_);  // \n            if (!nextBuffer_){ // nextBuffer_\n                // nextBuffer_\n                nextBuffer_ = std::move(newBuffer2);\n            }\n        }\n\n        assert(!buffersToWrite.empty());  // 1\n\n        if (buffersToWrite.size() > 25){ // \n            char buf[256];\n            snprintf(buf, sizeof buf, \"Dropped log messages at %s, %zd larger buffers\\n\",\n                    Timestamp::now().toFormattedString().c_str(),\n                    buffersToWrite.size()-2);\n            fputs(buf, stderr);\n            output.append(buf, static_cast<int>(strlen(buf)));\n            buffersToWrite.erase(buffersToWrite.begin()+2, buffersToWrite.end());\n        }\n\n        for (const auto& buffer : buffersToWrite){ // \n            // FIXME: use unbuffered stdio FILE ? or use ::writev ?\n            output.append(buffer->data(), buffer->length());\n        }\n\n        if (buffersToWrite.size() > 2){ // buffnewBuffer1newBuffer2\n            // drop non-bzero-ed buffers, avoid trashing\n            buffersToWrite.resize(2);\n        }\n\n        if (!newBuffer1){\n            assert(!buffersToWrite.empty());\n            newBuffer1 = std::move(buffersToWrite.back());\n            buffersToWrite.pop_back();\n            newBuffer1->reset();\n        }\n\n        if (!newBuffer2){\n            assert(!buffersToWrite.empty());\n            newBuffer2 = std::move(buffersToWrite.back());\n            buffersToWrite.pop_back();\n            newBuffer2->reset();\n        }\n\n        buffersToWrite.clear(); // \n        output.flush(); // \n    }\n    output.flush();\n}\n\n```\n\n****\n\nMuduo\n\n```cpp\n// \n\n// \nstruct CriticalData {\n    // ...\n};\n\nvoid processCriticalData(const CriticalData& data) {\n    // \n    // \n}\n\n// \nvoid criticalSection(const CriticalData& sharedData) {\n    CriticalData localCopy\n    // \n    // ...\n\n    // \n    localCopy.swap(sharedData);\n\n    // \n    // ...\n\n    // \n    processCriticalData(localCopy);\n}\n```\n\n## \n\n****\n\nMuduo\n\n****\n\nMuduo\n\n1.  \n\n2.  \n\n3.  \n\n****\n\nMuduonextBuffer_currentBuffer_newBuffernextBuffer_\n\n****\n\n  nextBuffer_ currentBuffer_ currentBuffer_ \n\n nextBuffer_\n\n---\n\n****","slug":"muduo/AsyncLogging","published":1,"updated":"2025-09-28T16:06:43.125Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9k0003q8wsb3i18lsz","content":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>MuduoAsyncLogging.ccIOLogFile.ccFileUtil.cc</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>Muduo</p>\n<p><strong></strong></p>\n<p>MuduoMuduo<strong></strong>MuduoMuduo<strong></strong>currentBuffer_nextBuffer_Muduo</p>\n<p><strong></strong></p>\n<p><strong></strong> buffers<strong></strong></p>\n<p></p>\n<ol>\n<li><p> <strong></strong></p>\n<span id=\"more\"></span>\n</li>\n<li><p> <strong></strong></p>\n</li>\n<li><p> </p>\n</li>\n<li><p> </p>\n</li>\n</ol>\n<p><strong>Muduo</strong></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AsyncLogging</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">AsyncLogging</span>(<span class=\"type\">const</span> string&amp; basename,</span><br><span class=\"line\">                <span class=\"type\">off_t</span> rollSize,</span><br><span class=\"line\">                <span class=\"type\">int</span> flushInterval = <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">AsyncLogging</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (running_)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">stop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* logline, <span class=\"type\">int</span> len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        running_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        thread_.<span class=\"built_in\">start</span>();    <span class=\"comment\">// </span></span><br><span class=\"line\">        latch_.<span class=\"built_in\">wait</span>();  <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> NO_THREAD_SAFETY_ANALYSIS</span>&#123;</span><br><span class=\"line\">        running_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        cond_.<span class=\"built_in\">notify</span>();</span><br><span class=\"line\">        thread_.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">threadFunc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> muduo::detail::FixedBuffer&lt;muduo::detail::kLargeBuffer&gt; Buffer;   <span class=\"comment\">// 4M</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;std::unique_ptr&lt;Buffer&gt;&gt; BufferVector;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> BufferVector::value_type BufferPtr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> flushInterval_; <span class=\"comment\">// </span></span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">bool</span>&gt; running_; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">const</span> string basename_; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">off_t</span> rollSize_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    muduo::Thread thread_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    muduo::CountDownLatch latch_; <span class=\"comment\">// </span></span><br><span class=\"line\">    muduo::MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">muduo::Condition cond_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// Buffer</span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr currentBuffer_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// buff</span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr nextBuffer_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// buff</span></span><br><span class=\"line\">    <span class=\"function\">BufferVector buffers_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// buff</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p>MuduocurrentBuffer_nextBuffer_</p>\n<p><img src=\"/2024/11/02/muduo/AsyncLogging/photo/AsynLogging.drawio.png\" alt=\"\"></p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* </span></span><br><span class=\"line\"><span class=\"comment\">* 1. AsyncLogging::threadFunc</span></span><br><span class=\"line\"><span class=\"comment\">* 2. currentBuffer_nextBuffer_</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AsyncLogging::append</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* logline, <span class=\"type\">int</span> len)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">muduo::MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentBuffer_-&gt;<span class=\"built_in\">avail</span>() &gt; len)&#123;  <span class=\"comment\">//</span></span><br><span class=\"line\">        currentBuffer_-&gt;<span class=\"built_in\">append</span>(logline, len); <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">//</span></span><br><span class=\"line\">        buffers_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(currentBuffer_));  <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextBuffer_)&#123;  <span class=\"comment\">// </span></span><br><span class=\"line\">            currentBuffer_ = std::<span class=\"built_in\">move</span>(nextBuffer_);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            currentBuffer_.<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> Buffer); <span class=\"comment\">// Rarely happens</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentBuffer_-&gt;<span class=\"built_in\">append</span>(logline, len);</span><br><span class=\"line\">        cond_.<span class=\"built_in\">notify</span>(); <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AsyncLogging::threadFunc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(running_ == <span class=\"literal\">true</span>);</span><br><span class=\"line\">    latch_.<span class=\"built_in\">countDown</span>();</span><br><span class=\"line\">    <span class=\"function\">LogFile <span class=\"title\">output</span><span class=\"params\">(basename_, rollSize_, <span class=\"literal\">false</span>)</span></span>;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr <span class=\"title\">newBuffer1</span><span class=\"params\">(<span class=\"keyword\">new</span> Buffer)</span></span>; <span class=\"comment\">// buff</span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr <span class=\"title\">newBuffer2</span><span class=\"params\">(<span class=\"keyword\">new</span> Buffer)</span></span>;</span><br><span class=\"line\">    newBuffer1-&gt;<span class=\"built_in\">bzero</span>();</span><br><span class=\"line\">    newBuffer2-&gt;<span class=\"built_in\">bzero</span>();</span><br><span class=\"line\">    BufferVector buffersToWrite;</span><br><span class=\"line\">    buffersToWrite.<span class=\"built_in\">reserve</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (running_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// buffbuffbuff</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(newBuffer1 &amp;&amp; newBuffer1-&gt;<span class=\"built_in\">length</span>() == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(newBuffer2 &amp;&amp; newBuffer2-&gt;<span class=\"built_in\">length</span>() == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(buffersToWrite.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"function\">muduo::MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (buffers_.<span class=\"built_in\">empty</span>())&#123;  <span class=\"comment\">// unusual usage!</span></span><br><span class=\"line\">                <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                * 1. AsyncLogging::append</span></span><br><span class=\"line\"><span class=\"comment\">                * 2. </span></span><br><span class=\"line\"><span class=\"comment\">                */</span></span><br><span class=\"line\">                cond_.<span class=\"built_in\">waitForSeconds</span>(flushInterval_);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// currentBuffer_</span></span><br><span class=\"line\">            buffers_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(currentBuffer_)); </span><br><span class=\"line\">            currentBuffer_ = std::<span class=\"built_in\">move</span>(newBuffer1); <span class=\"comment\">// currentBuffer_</span></span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">swap</span>(buffers_);  <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!nextBuffer_)&#123; <span class=\"comment\">// nextBuffer_</span></span><br><span class=\"line\">                <span class=\"comment\">// nextBuffer_</span></span><br><span class=\"line\">                nextBuffer_ = std::<span class=\"built_in\">move</span>(newBuffer2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(!buffersToWrite.<span class=\"built_in\">empty</span>());  <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buffersToWrite.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">25</span>)&#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"type\">char</span> buf[<span class=\"number\">256</span>];</span><br><span class=\"line\">            <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;Dropped log messages at %s, %zd larger buffers\\n&quot;</span>,</span><br><span class=\"line\">                    Timestamp::<span class=\"built_in\">now</span>().<span class=\"built_in\">toFormattedString</span>().<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">                    buffersToWrite.<span class=\"built_in\">size</span>()<span class=\"number\">-2</span>);</span><br><span class=\"line\">            <span class=\"built_in\">fputs</span>(buf, stderr);</span><br><span class=\"line\">            output.<span class=\"built_in\">append</span>(buf, <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"built_in\">strlen</span>(buf)));</span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">erase</span>(buffersToWrite.<span class=\"built_in\">begin</span>()<span class=\"number\">+2</span>, buffersToWrite.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; buffer : buffersToWrite)&#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use unbuffered stdio FILE ? or use ::writev ?</span></span><br><span class=\"line\">            output.<span class=\"built_in\">append</span>(buffer-&gt;<span class=\"built_in\">data</span>(), buffer-&gt;<span class=\"built_in\">length</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buffersToWrite.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">2</span>)&#123; <span class=\"comment\">// buffnewBuffer1newBuffer2</span></span><br><span class=\"line\">            <span class=\"comment\">// drop non-bzero-ed buffers, avoid trashing</span></span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">resize</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!newBuffer1)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(!buffersToWrite.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\">            newBuffer1 = std::<span class=\"built_in\">move</span>(buffersToWrite.<span class=\"built_in\">back</span>());</span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            newBuffer1-&gt;<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!newBuffer2)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(!buffersToWrite.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\">            newBuffer2 = std::<span class=\"built_in\">move</span>(buffersToWrite.<span class=\"built_in\">back</span>());</span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            newBuffer2-&gt;<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        buffersToWrite.<span class=\"built_in\">clear</span>(); <span class=\"comment\">// </span></span><br><span class=\"line\">        output.<span class=\"built_in\">flush</span>(); <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    output.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p>Muduo</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CriticalData</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processCriticalData</span><span class=\"params\">(<span class=\"type\">const</span> CriticalData&amp; data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">criticalSection</span><span class=\"params\">(<span class=\"type\">const</span> CriticalData&amp; sharedData)</span> </span>&#123;</span><br><span class=\"line\">    CriticalData localCopy</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    localCopy.<span class=\"built_in\">swap</span>(sharedData);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"built_in\">processCriticalData</span>(localCopy);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<p>Muduo</p>\n<p><strong></strong></p>\n<p>Muduo</p>\n<ol>\n<li><p> </p>\n</li>\n<li><p> </p>\n</li>\n<li><p> </p>\n</li>\n</ol>\n<p><strong></strong></p>\n<p>MuduonextBuffer_currentBuffer_newBuffernextBuffer_</p>\n<p><strong></strong></p>\n<p>  nextBuffer_ currentBuffer_ currentBuffer_ </p>\n<p> nextBuffer_</p>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>MuduoAsyncLogging.ccIOLogFile.ccFileUtil.cc</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>Muduo</p>\n<p><strong></strong></p>\n<p>MuduoMuduo<strong></strong>MuduoMuduo<strong></strong>currentBuffer_nextBuffer_Muduo</p>\n<p><strong></strong></p>\n<p><strong></strong> buffers<strong></strong></p>\n<p></p>\n<ol>\n<li><p> <strong></strong></p></li></ol>","more":"\n<li><p> <strong></strong></p>\n</li>\n<li><p> </p>\n</li>\n<li><p> </p>\n</li>\n\n<p><strong>Muduo</strong></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AsyncLogging</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">AsyncLogging</span>(<span class=\"type\">const</span> string&amp; basename,</span><br><span class=\"line\">                <span class=\"type\">off_t</span> rollSize,</span><br><span class=\"line\">                <span class=\"type\">int</span> flushInterval = <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">AsyncLogging</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (running_)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">stop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* logline, <span class=\"type\">int</span> len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        running_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        thread_.<span class=\"built_in\">start</span>();    <span class=\"comment\">// </span></span><br><span class=\"line\">        latch_.<span class=\"built_in\">wait</span>();  <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> NO_THREAD_SAFETY_ANALYSIS</span>&#123;</span><br><span class=\"line\">        running_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        cond_.<span class=\"built_in\">notify</span>();</span><br><span class=\"line\">        thread_.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">threadFunc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> muduo::detail::FixedBuffer&lt;muduo::detail::kLargeBuffer&gt; Buffer;   <span class=\"comment\">// 4M</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;std::unique_ptr&lt;Buffer&gt;&gt; BufferVector;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> BufferVector::value_type BufferPtr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> flushInterval_; <span class=\"comment\">// </span></span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">bool</span>&gt; running_; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">const</span> string basename_; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">off_t</span> rollSize_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    muduo::Thread thread_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    muduo::CountDownLatch latch_; <span class=\"comment\">// </span></span><br><span class=\"line\">    muduo::MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">muduo::Condition cond_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// Buffer</span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr currentBuffer_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// buff</span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr nextBuffer_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// buff</span></span><br><span class=\"line\">    <span class=\"function\">BufferVector buffers_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// buff</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p>MuduocurrentBuffer_nextBuffer_</p>\n<p><img src=\"/2024/11/02/muduo/AsyncLogging/photo/AsynLogging.drawio.png\" alt=\"\"></p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* </span></span><br><span class=\"line\"><span class=\"comment\">* 1. AsyncLogging::threadFunc</span></span><br><span class=\"line\"><span class=\"comment\">* 2. currentBuffer_nextBuffer_</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AsyncLogging::append</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* logline, <span class=\"type\">int</span> len)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">muduo::MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentBuffer_-&gt;<span class=\"built_in\">avail</span>() &gt; len)&#123;  <span class=\"comment\">//</span></span><br><span class=\"line\">        currentBuffer_-&gt;<span class=\"built_in\">append</span>(logline, len); <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">//</span></span><br><span class=\"line\">        buffers_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(currentBuffer_));  <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextBuffer_)&#123;  <span class=\"comment\">// </span></span><br><span class=\"line\">            currentBuffer_ = std::<span class=\"built_in\">move</span>(nextBuffer_);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            currentBuffer_.<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> Buffer); <span class=\"comment\">// Rarely happens</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentBuffer_-&gt;<span class=\"built_in\">append</span>(logline, len);</span><br><span class=\"line\">        cond_.<span class=\"built_in\">notify</span>(); <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AsyncLogging::threadFunc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(running_ == <span class=\"literal\">true</span>);</span><br><span class=\"line\">    latch_.<span class=\"built_in\">countDown</span>();</span><br><span class=\"line\">    <span class=\"function\">LogFile <span class=\"title\">output</span><span class=\"params\">(basename_, rollSize_, <span class=\"literal\">false</span>)</span></span>;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr <span class=\"title\">newBuffer1</span><span class=\"params\">(<span class=\"keyword\">new</span> Buffer)</span></span>; <span class=\"comment\">// buff</span></span><br><span class=\"line\">    <span class=\"function\">BufferPtr <span class=\"title\">newBuffer2</span><span class=\"params\">(<span class=\"keyword\">new</span> Buffer)</span></span>;</span><br><span class=\"line\">    newBuffer1-&gt;<span class=\"built_in\">bzero</span>();</span><br><span class=\"line\">    newBuffer2-&gt;<span class=\"built_in\">bzero</span>();</span><br><span class=\"line\">    BufferVector buffersToWrite;</span><br><span class=\"line\">    buffersToWrite.<span class=\"built_in\">reserve</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (running_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// buffbuffbuff</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(newBuffer1 &amp;&amp; newBuffer1-&gt;<span class=\"built_in\">length</span>() == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(newBuffer2 &amp;&amp; newBuffer2-&gt;<span class=\"built_in\">length</span>() == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(buffersToWrite.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"function\">muduo::MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (buffers_.<span class=\"built_in\">empty</span>())&#123;  <span class=\"comment\">// unusual usage!</span></span><br><span class=\"line\">                <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                * 1. AsyncLogging::append</span></span><br><span class=\"line\"><span class=\"comment\">                * 2. </span></span><br><span class=\"line\"><span class=\"comment\">                */</span></span><br><span class=\"line\">                cond_.<span class=\"built_in\">waitForSeconds</span>(flushInterval_);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// currentBuffer_</span></span><br><span class=\"line\">            buffers_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(currentBuffer_)); </span><br><span class=\"line\">            currentBuffer_ = std::<span class=\"built_in\">move</span>(newBuffer1); <span class=\"comment\">// currentBuffer_</span></span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">swap</span>(buffers_);  <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!nextBuffer_)&#123; <span class=\"comment\">// nextBuffer_</span></span><br><span class=\"line\">                <span class=\"comment\">// nextBuffer_</span></span><br><span class=\"line\">                nextBuffer_ = std::<span class=\"built_in\">move</span>(newBuffer2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(!buffersToWrite.<span class=\"built_in\">empty</span>());  <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buffersToWrite.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">25</span>)&#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"type\">char</span> buf[<span class=\"number\">256</span>];</span><br><span class=\"line\">            <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;Dropped log messages at %s, %zd larger buffers\\n&quot;</span>,</span><br><span class=\"line\">                    Timestamp::<span class=\"built_in\">now</span>().<span class=\"built_in\">toFormattedString</span>().<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">                    buffersToWrite.<span class=\"built_in\">size</span>()<span class=\"number\">-2</span>);</span><br><span class=\"line\">            <span class=\"built_in\">fputs</span>(buf, stderr);</span><br><span class=\"line\">            output.<span class=\"built_in\">append</span>(buf, <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"built_in\">strlen</span>(buf)));</span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">erase</span>(buffersToWrite.<span class=\"built_in\">begin</span>()<span class=\"number\">+2</span>, buffersToWrite.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; buffer : buffersToWrite)&#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use unbuffered stdio FILE ? or use ::writev ?</span></span><br><span class=\"line\">            output.<span class=\"built_in\">append</span>(buffer-&gt;<span class=\"built_in\">data</span>(), buffer-&gt;<span class=\"built_in\">length</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buffersToWrite.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">2</span>)&#123; <span class=\"comment\">// buffnewBuffer1newBuffer2</span></span><br><span class=\"line\">            <span class=\"comment\">// drop non-bzero-ed buffers, avoid trashing</span></span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">resize</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!newBuffer1)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(!buffersToWrite.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\">            newBuffer1 = std::<span class=\"built_in\">move</span>(buffersToWrite.<span class=\"built_in\">back</span>());</span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            newBuffer1-&gt;<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!newBuffer2)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(!buffersToWrite.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\">            newBuffer2 = std::<span class=\"built_in\">move</span>(buffersToWrite.<span class=\"built_in\">back</span>());</span><br><span class=\"line\">            buffersToWrite.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            newBuffer2-&gt;<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        buffersToWrite.<span class=\"built_in\">clear</span>(); <span class=\"comment\">// </span></span><br><span class=\"line\">        output.<span class=\"built_in\">flush</span>(); <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    output.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p>Muduo</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CriticalData</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processCriticalData</span><span class=\"params\">(<span class=\"type\">const</span> CriticalData&amp; data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">criticalSection</span><span class=\"params\">(<span class=\"type\">const</span> CriticalData&amp; sharedData)</span> </span>&#123;</span><br><span class=\"line\">    CriticalData localCopy</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    localCopy.<span class=\"built_in\">swap</span>(sharedData);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"built_in\">processCriticalData</span>(localCopy);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<p>Muduo</p>\n<p><strong></strong></p>\n<p>Muduo</p>\n<ol>\n<li><p> </p>\n</li>\n<li><p> </p>\n</li>\n<li><p> </p>\n</li>\n</ol>\n<p><strong></strong></p>\n<p>MuduonextBuffer_currentBuffer_newBuffernextBuffer_</p>\n<p><strong></strong></p>\n<p>  nextBuffer_ currentBuffer_ currentBuffer_ </p>\n<p> nextBuffer_</p>\n<hr>\n<p><strong></strong></p>"},{"title":"muduo5ChannelPoller","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nChannelfdfdfdIOIOPollerLinuxIO./net/pollerPollerEPollPollerPollPoller\n\n\n\n## Channel\n\n****\n\n<!-- more -->\n```cpp\nclass Channel : noncopyable{\npublic:\n    typedef std::function<void()> EventCallback;\n    typedef std::function<void(Timestamp)> ReadEventCallback;\n\n    Channel(EventLoop* loop, int fd);\n    ~Channel();\n\n    void handleEvent(Timestamp receiveTime);\n    void setReadCallback(ReadEventCallback cb)\n    { readCallback_ = std::move(cb); }\n    void setWriteCallback(EventCallback cb)\n    { writeCallback_ = std::move(cb); }\n    void setCloseCallback(EventCallback cb)\n    { closeCallback_ = std::move(cb); }\n    void setErrorCallback(EventCallback cb)\n    { errorCallback_ = std::move(cb); }\n\n    /// Tie this channel to the owner object managed by shared_ptr,\n    /// prevent the owner object being destroyed in handleEvent.\n    void tie(const std::shared_ptr<void>&);\n\n    int fd() const { return fd_; }\n    int events() const { return events_; }\n    void set_revents(int revt) { revents_ = revt; } // used by pollers\n    // int revents() const { return revents_; }\n    bool isNoneEvent() const { return events_ == kNoneEvent; }\n\n    void enableReading() { events_ |= kReadEvent; update(); }\n    void disableReading() { events_ &= ~kReadEvent; update(); }\n    void enableWriting() { events_ |= kWriteEvent; update(); }\n    void disableWriting() { events_ &= ~kWriteEvent; update(); }\n    void disableAll() { events_ = kNoneEvent; update(); }\n    bool isWriting() const { return events_ & kWriteEvent; }\n    bool isReading() const { return events_ & kReadEvent; }\n\n    // for Poller\n    int index() { return index_; }\n    void set_index(int idx) { index_ = idx; }\n\n    // for debug\n    string reventsToString() const;\n    string eventsToString() const;\n\n    void doNotLogHup() { logHup_ = false; }\n\n    EventLoop* ownerLoop() { return loop_; }\n    void remove();\n\nprivate:\n    static string eventsToString(int fd, int ev);\n\n    void update();\n    void handleEventWithGuard(Timestamp receiveTime);\n\n    static const int kNoneEvent;  // 0\n    static const int kReadEvent;  // POLLIN | POLLPRI\n    static const int kWriteEvent; // POLLOUT\n\n    EventLoop* loop_; // channelEventLoop\n    const int  fd_; // fd\n    int        events_;\n    int        revents_; // it's the received event types of epoll or poll // \n    int        index_; // used by Poller.\n    bool       logHup_;\n\n    std::weak_ptr<void> tie_;   // \n    bool tied_;\n    bool eventHandling_;  // handleEventWithGuard\n    bool addedToLoop_;  // EventLoop\n    ReadEventCallback readCallback_;  // \n    EventCallback writeCallback_; // \n    EventCallback closeCallback_; // \n    EventCallback errorCallback_; // \n};\n```\n\n****\n\n```cpp\nChannel::Channel(EventLoop* loop, int fd__)\n  : loop_(loop),\n    fd_(fd__),\n    events_(0),\n    revents_(0),\n    index_(-1),\n    logHup_(true),\n    tied_(false),\n    eventHandling_(false),\n    addedToLoop_(false)\n{\n}\n\nChannel::~Channel(){\n    assert(!eventHandling_);\n    assert(!addedToLoop_);\n    if (loop_->isInLoopThread()){\n        // channelEventLoop\n        assert(!loop_->hasChannel(this));\n    }\n}\n\nvoid Channel::tie(const std::shared_ptr<void>& obj){\n    tie_ = obj;   // \n    tied_ = true;\n}\n\nvoid Channel::update(){\n    // EventLoopfd\n    addedToLoop_ = true;\n    loop_->updateChannel(this);\n}\n\nvoid Channel::remove(){\n    // EventLoopchannel\n    assert(isNoneEvent());\n    addedToLoop_ = false;\n    loop_->removeChannel(this);\n}\n\nvoid Channel::handleEvent(Timestamp receiveTime){\n    std::shared_ptr<void> guard;\n    if (tied_){\n        guard = tie_.lock();\n        if (guard){ // \n            handleEventWithGuard(receiveTime);\n        }\n    }else{\n        handleEventWithGuard(receiveTime);\n    }\n}\n\nvoid Channel::handleEventWithGuard(Timestamp receiveTime){\n    eventHandling_ = true;\n    if ((revents_ & POLLHUP) && !(revents_ & POLLIN)){\n        // fd\n        // \n        if (closeCallback_) closeCallback_();\n    }\n\n    if (revents_ & (POLLERR | POLLNVAL)){\n        // \n        if (errorCallback_) errorCallback_();\n    }\n    if (revents_ & (POLLIN | POLLPRI | POLLRDHUP)){\n        // \n        if (readCallback_) readCallback_(receiveTime);\n    }\n    if (revents_ & POLLOUT){\n        // \n        if (writeCallback_) writeCallback_();\n    }\n    eventHandling_ = false;\n}\n\n```\n\n****\n\n**cpp**\n\n\n\n\n\n```cpp\nclass Node;\n\nclass Node {\npublic:\n    std::shared_ptr<Node> next;\n\n    Node() {\n        std::cout << \"Node constructed\" << std::endl;\n    }\n\n    ~Node() {\n        std::cout << \"Node destructed\" << std::endl;\n    }\n};\n\nint main() {\n    std::shared_ptr<Node> node1 = std::make_shared<Node>();\n\n    node1->next = node1;\n    return 0;\n}\n\n```\n\n\n\n```\n[root@localhost muduo]# g++ -Wall -std=c++11 -o test.bin test.cc \n[root@localhost muduo]# \n[root@localhost muduo]# \n[root@localhost muduo]# ./test.bin \nNode constructed\n[root@localhost muduo]#\n```\n\n**weak_ptr**\n\n### \n\n****\n\nMuduoChannel`std::weak_ptr<void> tie_`\n\n****\n\nstd::weak_ptrcircular referenceTcpConnectionChannelstd::weak_ptr\n\n****\n\nfdPOLLHUPPOLLRDHUPPOLLIN/POLLOUT\n\n****\n\ndeamoPOLLHUPPOLLIN/POLLOUT/POLLRDHUP\n\n|           |                                                               |                       |\n|   :---:         |   :---:                                                             |   :---:                       |\n|   POLLIN      |                                                   |       |\n|   POLLOUT     |                                                     |                 |\n|   POLLRDHUP   |   POLLIN                                  |                         |\n|   POLLHUP     |   POLLIN/POLLOUT    |                         |\n\n## Poller\n\nMuduoPollerlinuxCIOPollerEventLoopEventLoopPollerIO\n\n**Poller**\n\n```cpp\nclass Poller : noncopyable{\npublic:\n    typedef std::vector<Channel*> ChannelList;\n\n    Poller(EventLoop* loop);\n    virtual ~Poller();\n\n    /// Polls the I/O events.\n    /// Must be called in the loop thread.\n    virtual Timestamp poll(int timeoutMs, ChannelList* activeChannels) = 0;\n\n    /// Changes the interested I/O events.\n    /// Must be called in the loop thread.\n    virtual void updateChannel(Channel* channel) = 0;\n\n    /// Remove the channel, when it destructs.\n    /// Must be called in the loop thread.\n    virtual void removeChannel(Channel* channel) = 0;\n\n    virtual bool hasChannel(Channel* channel) const;\n\n    static Poller* newDefaultPoller(EventLoop* loop);\n\n    void assertInLoopThread() const{\n        ownerLoop_->assertInLoopThread();\n    }\n\nprotected:\n    typedef std::map<int, Channel*> ChannelMap; \n    ChannelMap channels_;// fdchannel\n\n    private:\n    EventLoop* ownerLoop_;  // EventLoop\n};\n```\n\n**Poller**\n\n```cpp\nPoller::Poller(EventLoop* loop)\n  : ownerLoop_(loop){\n}\n\nPoller::~Poller() = default;\n\nbool Poller::hasChannel(Channel* channel) const{\n    assertInLoopThread();\n    ChannelMap::const_iterator it = channels_.find(channel->fd());\n    return it != channels_.end() && it->second == channel;\n}\n\n```\n\nMuduoPollerEPollPollerPollPollerPollPoller\n\n### PollPoller\n\nmuduoPollPoller  poll() EventLoopPollPoller  Channel poll() \n\n PollPoller \n\n1.  PollPoller  PollPoller.cc \n\n2.  PollPoller  Poller  Poller \n\n3.   poll  fillActiveChannels\n\n    - poll  poll() \n    - fillActiveChannels  poll()  activeChannels \n\n4.  PollPoller  EventLoop PollPoller  EventLoop EventLoop  Channel handleEvent\n\n****\n\n```cpp\nclass PollPoller : public Poller{\npublic:\n\n    PollPoller(EventLoop* loop);\n    ~PollPoller() override;\n\n    Timestamp poll(int timeoutMs, ChannelList* activeChannels) override;\n    void updateChannel(Channel* channel) override;\n    void removeChannel(Channel* channel) override;\n\nprivate:\n    void fillActiveChannels(int numEvents,\n                            ChannelList* activeChannels) const;\n\n    /*\n    * struct pollfd\n    *    struct pollfd {\n    *        int   fd;     //     \n    *       short events;   // \n    *        short revents; // \n    *    };\n    */\n\n    typedef std::vector<struct pollfd> PollFdList;\n    PollFdList pollfds_;\n};\n\n```\n\n****\n\n```cpp\nPollPoller::PollPoller(EventLoop* loop)\n  : Poller(loop){\n}\n\nPollPoller::~PollPoller() = default;\n\n// EventLoopEventLoop \nTimestamp PollPoller::poll(int timeoutMs, ChannelList* activeChannels){\n    // \n    // XXX pollfds_ shouldn't change\n    int numEvents = ::poll(&*pollfds_.begin(), pollfds_.size(), timeoutMs);\n    int savedErrno = errno;\n    Timestamp now(Timestamp::now());\n    if (numEvents > 0){\n        fillActiveChannels(numEvents, activeChannels);\n    }else if (numEvents == 0){\n        LOG_TRACE << \" nothing happened\";\n    }else{\n        if (savedErrno != EINTR){   // \n            errno = savedErrno;\n            LOG_SYSERR << \"PollPoller::poll()\";\n        }\n    }\n    return now;\n}\n\nvoid PollPoller::fillActiveChannels(int numEvents,\n                                    ChannelList* activeChannels) const{\n    // fdchannelactiveChannelsEventLoop\n    for (PollFdList::const_iterator pfd = pollfds_.begin();\n        pfd != pollfds_.end() && numEvents > 0; ++pfd){\n        if (pfd->revents > 0){\n            --numEvents;\n            ChannelMap::const_iterator ch = channels_.find(pfd->fd);\n            assert(ch != channels_.end());   //\n            Channel* channel = ch->second;\n            channel->set_revents(pfd->revents);\n            // pfd->revents = 0;    // poll\n            activeChannels->push_back(channel);\n        }\n    }\n}\n\nvoid PollPoller::updateChannel(Channel* channel){\n    Poller::assertInLoopThread();\n    if (channel->index() < 0){\n        // channel\n        // a new one, add to pollfds_\n        assert(channels_.find(channel->fd()) == channels_.end());\n        struct pollfd pfd;\n        pfd.fd = channel->fd();\n        pfd.events = static_cast<short>(channel->events());\n        pfd.revents = 0;\n        pollfds_.push_back(pfd);\n        int idx = static_cast<int>(pollfds_.size())-1;\n        channel->set_index(idx);\n        channels_[pfd.fd] = channel;\n    }else{\n        // update existing one\n        assert(channels_.find(channel->fd()) != channels_.end());\n        int idx = channel->index();\n        // idx \n        assert(0 <= idx && idx < static_cast<int>(pollfds_.size()));\n        struct pollfd& pfd = pollfds_[idx];\n        // fd-(fd + 1)pollfdchannel\n        assert(pfd.fd == channel->fd() || pfd.fd == -channel->fd()-1);\n        pfd.fd = channel->fd();\n        pfd.events = static_cast<short>(channel->events());\n        pfd.revents = 0;\n        if (channel->isNoneEvent()){\n            // \n            // ignore this pollfd\n            pfd.fd = -channel->fd()-1;\n        }\n    }\n}\n\nvoid PollPoller::removeChannel(Channel* channel){\n    Poller::assertInLoopThread();\n    assert(channels_.find(channel->fd()) != channels_.end());\n    assert(channels_[channel->fd()] == channel);\n    assert(channel->isNoneEvent());\n    int idx = channel->index();\n    assert(0 <= idx && idx < static_cast<int>(pollfds_.size()));\n    const struct pollfd& pfd = pollfds_[idx]; (void)pfd;\n    assert(pfd.fd == -channel->fd()-1 && pfd.events == channel->events());\n    size_t n = channels_.erase(channel->fd());\n    assert(n == 1); (void)n;\n\n    /*\n    * pollMuduo\n    * fdpop_back\n    * fdchannels_\n    * fdcahnnelindexfd\n    * \n    */\n    if (implicit_cast<size_t>(idx) == pollfds_.size()-1){\n        pollfds_.pop_back();\n    }else{\n        int channelAtEnd = pollfds_.back().fd;\n        iter_swap(pollfds_.begin()+idx, pollfds_.end()-1);\n        if (channelAtEnd < 0){\n            channelAtEnd = -channelAtEnd-1;\n        }\n        channels_[channelAtEnd]->set_index(idx);\n        pollfds_.pop_back();\n    }\n}\n```\n\n## \n\n****\n\nMuduofdChannel?\n\n****\n\nChannelPollerMuduofdchannelIOPollerchannelRedis\n\n---\n\n****","source":"_posts/muduo/ChannelAndPoller.md","raw":"---\ntitle: muduo5ChannelPoller\ndate: 2024-11-02 12:00:00\ntags:\n  - \n---\n\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nChannelfdfdfdIOIOPollerLinuxIO./net/pollerPollerEPollPollerPollPoller\n\n\n\n## Channel\n\n****\n\n<!-- more -->\n```cpp\nclass Channel : noncopyable{\npublic:\n    typedef std::function<void()> EventCallback;\n    typedef std::function<void(Timestamp)> ReadEventCallback;\n\n    Channel(EventLoop* loop, int fd);\n    ~Channel();\n\n    void handleEvent(Timestamp receiveTime);\n    void setReadCallback(ReadEventCallback cb)\n    { readCallback_ = std::move(cb); }\n    void setWriteCallback(EventCallback cb)\n    { writeCallback_ = std::move(cb); }\n    void setCloseCallback(EventCallback cb)\n    { closeCallback_ = std::move(cb); }\n    void setErrorCallback(EventCallback cb)\n    { errorCallback_ = std::move(cb); }\n\n    /// Tie this channel to the owner object managed by shared_ptr,\n    /// prevent the owner object being destroyed in handleEvent.\n    void tie(const std::shared_ptr<void>&);\n\n    int fd() const { return fd_; }\n    int events() const { return events_; }\n    void set_revents(int revt) { revents_ = revt; } // used by pollers\n    // int revents() const { return revents_; }\n    bool isNoneEvent() const { return events_ == kNoneEvent; }\n\n    void enableReading() { events_ |= kReadEvent; update(); }\n    void disableReading() { events_ &= ~kReadEvent; update(); }\n    void enableWriting() { events_ |= kWriteEvent; update(); }\n    void disableWriting() { events_ &= ~kWriteEvent; update(); }\n    void disableAll() { events_ = kNoneEvent; update(); }\n    bool isWriting() const { return events_ & kWriteEvent; }\n    bool isReading() const { return events_ & kReadEvent; }\n\n    // for Poller\n    int index() { return index_; }\n    void set_index(int idx) { index_ = idx; }\n\n    // for debug\n    string reventsToString() const;\n    string eventsToString() const;\n\n    void doNotLogHup() { logHup_ = false; }\n\n    EventLoop* ownerLoop() { return loop_; }\n    void remove();\n\nprivate:\n    static string eventsToString(int fd, int ev);\n\n    void update();\n    void handleEventWithGuard(Timestamp receiveTime);\n\n    static const int kNoneEvent;  // 0\n    static const int kReadEvent;  // POLLIN | POLLPRI\n    static const int kWriteEvent; // POLLOUT\n\n    EventLoop* loop_; // channelEventLoop\n    const int  fd_; // fd\n    int        events_;\n    int        revents_; // it's the received event types of epoll or poll // \n    int        index_; // used by Poller.\n    bool       logHup_;\n\n    std::weak_ptr<void> tie_;   // \n    bool tied_;\n    bool eventHandling_;  // handleEventWithGuard\n    bool addedToLoop_;  // EventLoop\n    ReadEventCallback readCallback_;  // \n    EventCallback writeCallback_; // \n    EventCallback closeCallback_; // \n    EventCallback errorCallback_; // \n};\n```\n\n****\n\n```cpp\nChannel::Channel(EventLoop* loop, int fd__)\n  : loop_(loop),\n    fd_(fd__),\n    events_(0),\n    revents_(0),\n    index_(-1),\n    logHup_(true),\n    tied_(false),\n    eventHandling_(false),\n    addedToLoop_(false)\n{\n}\n\nChannel::~Channel(){\n    assert(!eventHandling_);\n    assert(!addedToLoop_);\n    if (loop_->isInLoopThread()){\n        // channelEventLoop\n        assert(!loop_->hasChannel(this));\n    }\n}\n\nvoid Channel::tie(const std::shared_ptr<void>& obj){\n    tie_ = obj;   // \n    tied_ = true;\n}\n\nvoid Channel::update(){\n    // EventLoopfd\n    addedToLoop_ = true;\n    loop_->updateChannel(this);\n}\n\nvoid Channel::remove(){\n    // EventLoopchannel\n    assert(isNoneEvent());\n    addedToLoop_ = false;\n    loop_->removeChannel(this);\n}\n\nvoid Channel::handleEvent(Timestamp receiveTime){\n    std::shared_ptr<void> guard;\n    if (tied_){\n        guard = tie_.lock();\n        if (guard){ // \n            handleEventWithGuard(receiveTime);\n        }\n    }else{\n        handleEventWithGuard(receiveTime);\n    }\n}\n\nvoid Channel::handleEventWithGuard(Timestamp receiveTime){\n    eventHandling_ = true;\n    if ((revents_ & POLLHUP) && !(revents_ & POLLIN)){\n        // fd\n        // \n        if (closeCallback_) closeCallback_();\n    }\n\n    if (revents_ & (POLLERR | POLLNVAL)){\n        // \n        if (errorCallback_) errorCallback_();\n    }\n    if (revents_ & (POLLIN | POLLPRI | POLLRDHUP)){\n        // \n        if (readCallback_) readCallback_(receiveTime);\n    }\n    if (revents_ & POLLOUT){\n        // \n        if (writeCallback_) writeCallback_();\n    }\n    eventHandling_ = false;\n}\n\n```\n\n****\n\n**cpp**\n\n\n\n\n\n```cpp\nclass Node;\n\nclass Node {\npublic:\n    std::shared_ptr<Node> next;\n\n    Node() {\n        std::cout << \"Node constructed\" << std::endl;\n    }\n\n    ~Node() {\n        std::cout << \"Node destructed\" << std::endl;\n    }\n};\n\nint main() {\n    std::shared_ptr<Node> node1 = std::make_shared<Node>();\n\n    node1->next = node1;\n    return 0;\n}\n\n```\n\n\n\n```\n[root@localhost muduo]# g++ -Wall -std=c++11 -o test.bin test.cc \n[root@localhost muduo]# \n[root@localhost muduo]# \n[root@localhost muduo]# ./test.bin \nNode constructed\n[root@localhost muduo]#\n```\n\n**weak_ptr**\n\n### \n\n****\n\nMuduoChannel`std::weak_ptr<void> tie_`\n\n****\n\nstd::weak_ptrcircular referenceTcpConnectionChannelstd::weak_ptr\n\n****\n\nfdPOLLHUPPOLLRDHUPPOLLIN/POLLOUT\n\n****\n\ndeamoPOLLHUPPOLLIN/POLLOUT/POLLRDHUP\n\n|           |                                                               |                       |\n|   :---:         |   :---:                                                             |   :---:                       |\n|   POLLIN      |                                                   |       |\n|   POLLOUT     |                                                     |                 |\n|   POLLRDHUP   |   POLLIN                                  |                         |\n|   POLLHUP     |   POLLIN/POLLOUT    |                         |\n\n## Poller\n\nMuduoPollerlinuxCIOPollerEventLoopEventLoopPollerIO\n\n**Poller**\n\n```cpp\nclass Poller : noncopyable{\npublic:\n    typedef std::vector<Channel*> ChannelList;\n\n    Poller(EventLoop* loop);\n    virtual ~Poller();\n\n    /// Polls the I/O events.\n    /// Must be called in the loop thread.\n    virtual Timestamp poll(int timeoutMs, ChannelList* activeChannels) = 0;\n\n    /// Changes the interested I/O events.\n    /// Must be called in the loop thread.\n    virtual void updateChannel(Channel* channel) = 0;\n\n    /// Remove the channel, when it destructs.\n    /// Must be called in the loop thread.\n    virtual void removeChannel(Channel* channel) = 0;\n\n    virtual bool hasChannel(Channel* channel) const;\n\n    static Poller* newDefaultPoller(EventLoop* loop);\n\n    void assertInLoopThread() const{\n        ownerLoop_->assertInLoopThread();\n    }\n\nprotected:\n    typedef std::map<int, Channel*> ChannelMap; \n    ChannelMap channels_;// fdchannel\n\n    private:\n    EventLoop* ownerLoop_;  // EventLoop\n};\n```\n\n**Poller**\n\n```cpp\nPoller::Poller(EventLoop* loop)\n  : ownerLoop_(loop){\n}\n\nPoller::~Poller() = default;\n\nbool Poller::hasChannel(Channel* channel) const{\n    assertInLoopThread();\n    ChannelMap::const_iterator it = channels_.find(channel->fd());\n    return it != channels_.end() && it->second == channel;\n}\n\n```\n\nMuduoPollerEPollPollerPollPollerPollPoller\n\n### PollPoller\n\nmuduoPollPoller  poll() EventLoopPollPoller  Channel poll() \n\n PollPoller \n\n1.  PollPoller  PollPoller.cc \n\n2.  PollPoller  Poller  Poller \n\n3.   poll  fillActiveChannels\n\n    - poll  poll() \n    - fillActiveChannels  poll()  activeChannels \n\n4.  PollPoller  EventLoop PollPoller  EventLoop EventLoop  Channel handleEvent\n\n****\n\n```cpp\nclass PollPoller : public Poller{\npublic:\n\n    PollPoller(EventLoop* loop);\n    ~PollPoller() override;\n\n    Timestamp poll(int timeoutMs, ChannelList* activeChannels) override;\n    void updateChannel(Channel* channel) override;\n    void removeChannel(Channel* channel) override;\n\nprivate:\n    void fillActiveChannels(int numEvents,\n                            ChannelList* activeChannels) const;\n\n    /*\n    * struct pollfd\n    *    struct pollfd {\n    *        int   fd;     //     \n    *       short events;   // \n    *        short revents; // \n    *    };\n    */\n\n    typedef std::vector<struct pollfd> PollFdList;\n    PollFdList pollfds_;\n};\n\n```\n\n****\n\n```cpp\nPollPoller::PollPoller(EventLoop* loop)\n  : Poller(loop){\n}\n\nPollPoller::~PollPoller() = default;\n\n// EventLoopEventLoop \nTimestamp PollPoller::poll(int timeoutMs, ChannelList* activeChannels){\n    // \n    // XXX pollfds_ shouldn't change\n    int numEvents = ::poll(&*pollfds_.begin(), pollfds_.size(), timeoutMs);\n    int savedErrno = errno;\n    Timestamp now(Timestamp::now());\n    if (numEvents > 0){\n        fillActiveChannels(numEvents, activeChannels);\n    }else if (numEvents == 0){\n        LOG_TRACE << \" nothing happened\";\n    }else{\n        if (savedErrno != EINTR){   // \n            errno = savedErrno;\n            LOG_SYSERR << \"PollPoller::poll()\";\n        }\n    }\n    return now;\n}\n\nvoid PollPoller::fillActiveChannels(int numEvents,\n                                    ChannelList* activeChannels) const{\n    // fdchannelactiveChannelsEventLoop\n    for (PollFdList::const_iterator pfd = pollfds_.begin();\n        pfd != pollfds_.end() && numEvents > 0; ++pfd){\n        if (pfd->revents > 0){\n            --numEvents;\n            ChannelMap::const_iterator ch = channels_.find(pfd->fd);\n            assert(ch != channels_.end());   //\n            Channel* channel = ch->second;\n            channel->set_revents(pfd->revents);\n            // pfd->revents = 0;    // poll\n            activeChannels->push_back(channel);\n        }\n    }\n}\n\nvoid PollPoller::updateChannel(Channel* channel){\n    Poller::assertInLoopThread();\n    if (channel->index() < 0){\n        // channel\n        // a new one, add to pollfds_\n        assert(channels_.find(channel->fd()) == channels_.end());\n        struct pollfd pfd;\n        pfd.fd = channel->fd();\n        pfd.events = static_cast<short>(channel->events());\n        pfd.revents = 0;\n        pollfds_.push_back(pfd);\n        int idx = static_cast<int>(pollfds_.size())-1;\n        channel->set_index(idx);\n        channels_[pfd.fd] = channel;\n    }else{\n        // update existing one\n        assert(channels_.find(channel->fd()) != channels_.end());\n        int idx = channel->index();\n        // idx \n        assert(0 <= idx && idx < static_cast<int>(pollfds_.size()));\n        struct pollfd& pfd = pollfds_[idx];\n        // fd-(fd + 1)pollfdchannel\n        assert(pfd.fd == channel->fd() || pfd.fd == -channel->fd()-1);\n        pfd.fd = channel->fd();\n        pfd.events = static_cast<short>(channel->events());\n        pfd.revents = 0;\n        if (channel->isNoneEvent()){\n            // \n            // ignore this pollfd\n            pfd.fd = -channel->fd()-1;\n        }\n    }\n}\n\nvoid PollPoller::removeChannel(Channel* channel){\n    Poller::assertInLoopThread();\n    assert(channels_.find(channel->fd()) != channels_.end());\n    assert(channels_[channel->fd()] == channel);\n    assert(channel->isNoneEvent());\n    int idx = channel->index();\n    assert(0 <= idx && idx < static_cast<int>(pollfds_.size()));\n    const struct pollfd& pfd = pollfds_[idx]; (void)pfd;\n    assert(pfd.fd == -channel->fd()-1 && pfd.events == channel->events());\n    size_t n = channels_.erase(channel->fd());\n    assert(n == 1); (void)n;\n\n    /*\n    * pollMuduo\n    * fdpop_back\n    * fdchannels_\n    * fdcahnnelindexfd\n    * \n    */\n    if (implicit_cast<size_t>(idx) == pollfds_.size()-1){\n        pollfds_.pop_back();\n    }else{\n        int channelAtEnd = pollfds_.back().fd;\n        iter_swap(pollfds_.begin()+idx, pollfds_.end()-1);\n        if (channelAtEnd < 0){\n            channelAtEnd = -channelAtEnd-1;\n        }\n        channels_[channelAtEnd]->set_index(idx);\n        pollfds_.pop_back();\n    }\n}\n```\n\n## \n\n****\n\nMuduofdChannel?\n\n****\n\nChannelPollerMuduofdchannelIOPollerchannelRedis\n\n---\n\n****","slug":"muduo/ChannelAndPoller","published":1,"updated":"2025-09-28T16:06:43.125Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9o0009q8ws2nst23jm","content":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>ChannelfdfdfdIOIOPollerLinuxIO.&#x2F;net&#x2F;pollerPollerEPollPollerPollPoller</p>\n<p></p>\n<h2 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><p><strong></strong></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Channel</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>()&gt; EventCallback;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(Timestamp)&gt; ReadEventCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Channel</span>(EventLoop* loop, <span class=\"type\">int</span> fd);</span><br><span class=\"line\">    ~<span class=\"built_in\">Channel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleEvent</span><span class=\"params\">(Timestamp receiveTime)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setReadCallback</span><span class=\"params\">(ReadEventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; readCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWriteCallback</span><span class=\"params\">(EventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; writeCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setCloseCallback</span><span class=\"params\">(EventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; closeCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setErrorCallback</span><span class=\"params\">(EventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; errorCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Tie this channel to the owner object managed by shared_ptr,</span></span><br><span class=\"line\">    <span class=\"comment\">/// prevent the owner object being destroyed in handleEvent.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">tie</span><span class=\"params\">(<span class=\"type\">const</span> std::shared_ptr&lt;<span class=\"type\">void</span>&gt;&amp;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fd</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> fd_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">events</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_revents</span><span class=\"params\">(<span class=\"type\">int</span> revt)</span> </span>&#123; revents_ = revt; &#125; <span class=\"comment\">// used by pollers</span></span><br><span class=\"line\">    <span class=\"comment\">// int revents() const &#123; return revents_; &#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isNoneEvent</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_ == kNoneEvent; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enableReading</span><span class=\"params\">()</span> </span>&#123; events_ |= kReadEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disableReading</span><span class=\"params\">()</span> </span>&#123; events_ &amp;= ~kReadEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enableWriting</span><span class=\"params\">()</span> </span>&#123; events_ |= kWriteEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disableWriting</span><span class=\"params\">()</span> </span>&#123; events_ &amp;= ~kWriteEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disableAll</span><span class=\"params\">()</span> </span>&#123; events_ = kNoneEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isWriting</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_ &amp; kWriteEvent; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isReading</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_ &amp; kReadEvent; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for Poller</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">index</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> index_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_index</span><span class=\"params\">(<span class=\"type\">int</span> idx)</span> </span>&#123; index_ = idx; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for debug</span></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">reventsToString</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">eventsToString</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">doNotLogHup</span><span class=\"params\">()</span> </span>&#123; logHup_ = <span class=\"literal\">false</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">ownerLoop</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> loop_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> string <span class=\"title\">eventsToString</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span> ev)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleEventWithGuard</span><span class=\"params\">(Timestamp receiveTime)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kNoneEvent;  <span class=\"comment\">// 0</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kReadEvent;  <span class=\"comment\">// POLLIN | POLLPRI</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kWriteEvent; <span class=\"comment\">// POLLOUT</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// channelEventLoop</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span>  fd_; <span class=\"comment\">// fd</span></span><br><span class=\"line\">    <span class=\"type\">int</span>        events_;</span><br><span class=\"line\">    <span class=\"type\">int</span>        revents_; <span class=\"comment\">// it&#x27;s the received event types of epoll or poll // </span></span><br><span class=\"line\">    <span class=\"type\">int</span>        index_; <span class=\"comment\">// used by Poller.</span></span><br><span class=\"line\">    <span class=\"type\">bool</span>       logHup_;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::weak_ptr&lt;<span class=\"type\">void</span>&gt; tie_;   <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> tied_;</span><br><span class=\"line\">    <span class=\"type\">bool</span> eventHandling_;  <span class=\"comment\">// handleEventWithGuard</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> addedToLoop_;  <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">    ReadEventCallback readCallback_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    EventCallback writeCallback_; <span class=\"comment\">// </span></span><br><span class=\"line\">    EventCallback closeCallback_; <span class=\"comment\">// </span></span><br><span class=\"line\">    EventCallback errorCallback_; <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Channel::<span class=\"built_in\">Channel</span>(EventLoop* loop, <span class=\"type\">int</span> fd__)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(loop),</span><br><span class=\"line\">    <span class=\"built_in\">fd_</span>(fd__),</span><br><span class=\"line\">    <span class=\"built_in\">events_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">revents_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">index_</span>(<span class=\"number\">-1</span>),</span><br><span class=\"line\">    <span class=\"built_in\">logHup_</span>(<span class=\"literal\">true</span>),</span><br><span class=\"line\">    <span class=\"built_in\">tied_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">eventHandling_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">addedToLoop_</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Channel::~<span class=\"built_in\">Channel</span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!eventHandling_);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!addedToLoop_);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loop_-&gt;<span class=\"built_in\">isInLoopThread</span>())&#123;</span><br><span class=\"line\">        <span class=\"comment\">// channelEventLoop</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(!loop_-&gt;<span class=\"built_in\">hasChannel</span>(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::tie</span><span class=\"params\">(<span class=\"type\">const</span> std::shared_ptr&lt;<span class=\"type\">void</span>&gt;&amp; obj)</span></span>&#123;</span><br><span class=\"line\">    tie_ = obj;   <span class=\"comment\">// </span></span><br><span class=\"line\">    tied_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::update</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// EventLoopfd</span></span><br><span class=\"line\">    addedToLoop_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">updateChannel</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::remove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// EventLoopchannel</span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"built_in\">isNoneEvent</span>());</span><br><span class=\"line\">    addedToLoop_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">removeChannel</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::handleEvent</span><span class=\"params\">(Timestamp receiveTime)</span></span>&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;<span class=\"type\">void</span>&gt; guard;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tied_)&#123;</span><br><span class=\"line\">        guard = tie_.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (guard)&#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"built_in\">handleEventWithGuard</span>(receiveTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">handleEventWithGuard</span>(receiveTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::handleEventWithGuard</span><span class=\"params\">(Timestamp receiveTime)</span></span>&#123;</span><br><span class=\"line\">    eventHandling_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))&#123;</span><br><span class=\"line\">        <span class=\"comment\">// fd</span></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (closeCallback_) <span class=\"built_in\">closeCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (revents_ &amp; (POLLERR | POLLNVAL))&#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errorCallback_) <span class=\"built_in\">errorCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))&#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (readCallback_) <span class=\"built_in\">readCallback_</span>(receiveTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (revents_ &amp; POLLOUT)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (writeCallback_) <span class=\"built_in\">writeCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eventHandling_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p><strong>cpp</strong></p>\n<p></p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    std::shared_ptr&lt;Node&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Node</span>() &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Node constructed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">Node</span>() &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Node destructed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;Node&gt; node1 = std::<span class=\"built_in\">make_shared</span>&lt;Node&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    node1-&gt;next = node1;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost muduo]# g++ -Wall -std=c++11 -o test.bin test.cc </span><br><span class=\"line\">[root@localhost muduo]# </span><br><span class=\"line\">[root@localhost muduo]# </span><br><span class=\"line\">[root@localhost muduo]# ./test.bin </span><br><span class=\"line\">Node constructed</span><br><span class=\"line\">[root@localhost muduo]#</span><br></pre></td></tr></table></figure>\n\n<p><strong>weak_ptr</strong></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p><strong></strong></p>\n<p>MuduoChannel<code>std::weak_ptr&lt;void&gt; tie_</code></p>\n<p><strong></strong></p>\n<p>std::weak_ptrcircular referenceTcpConnectionChannelstd::weak_ptr</p>\n<p><strong></strong></p>\n<p>fdPOLLHUPPOLLRDHUPPOLLIN&#x2F;POLLOUT</p>\n<p><strong></strong></p>\n<p>deamoPOLLHUPPOLLIN&#x2F;POLLOUT&#x2F;POLLRDHUP</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">POLLIN</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">POLLOUT</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">POLLRDHUP</td>\n<td align=\"center\">POLLIN</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">POLLHUP</td>\n<td align=\"center\">POLLIN&#x2F;POLLOUT</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"Poller\"><a href=\"#Poller\" class=\"headerlink\" title=\"Poller\"></a>Poller</h2><p>MuduoPollerlinuxCIOPollerEventLoopEventLoopPollerIO</p>\n<p><strong>Poller</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Poller</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;Channel*&gt; ChannelList;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Poller</span>(EventLoop* loop);</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Poller</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Polls the I/O events.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the loop thread.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Timestamp <span class=\"title\">poll</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMs, ChannelList* activeChannels)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Changes the interested I/O events.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the loop thread.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">updateChannel</span><span class=\"params\">(Channel* channel)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Remove the channel, when it destructs.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the loop thread.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">removeChannel</span><span class=\"params\">(Channel* channel)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">hasChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> Poller* <span class=\"title\">newDefaultPoller</span><span class=\"params\">(EventLoop* loop)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assertInLoopThread</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        ownerLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::map&lt;<span class=\"type\">int</span>, Channel*&gt; ChannelMap; </span><br><span class=\"line\">    ChannelMap channels_;<span class=\"comment\">// fdchannel</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    EventLoop* ownerLoop_;  <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Poller</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Poller::<span class=\"built_in\">Poller</span>(EventLoop* loop)</span><br><span class=\"line\">  : <span class=\"built_in\">ownerLoop_</span>(loop)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Poller::~<span class=\"built_in\">Poller</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Poller::hasChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    ChannelMap::const_iterator it = channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> it != channels_.<span class=\"built_in\">end</span>() &amp;&amp; it-&gt;second == channel;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>MuduoPollerEPollPollerPollPollerPollPoller</p>\n<h3 id=\"PollPoller\"><a href=\"#PollPoller\" class=\"headerlink\" title=\"PollPoller\"></a>PollPoller</h3><p>muduoPollPoller  poll() EventLoopPollPoller  Channel poll() </p>\n<p> PollPoller </p>\n<ol>\n<li><p> PollPoller  PollPoller.cc </p>\n</li>\n<li><p> PollPoller  Poller  Poller </p>\n</li>\n<li><p>  poll  fillActiveChannels</p>\n<ul>\n<li>poll  poll() </li>\n<li>fillActiveChannels  poll()  activeChannels </li>\n</ul>\n</li>\n<li><p> PollPoller  EventLoop PollPoller  EventLoop EventLoop  Channel handleEvent</p>\n</li>\n</ol>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PollPoller</span> : <span class=\"keyword\">public</span> Poller&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">PollPoller</span>(EventLoop* loop);</span><br><span class=\"line\">    ~<span class=\"built_in\">PollPoller</span>() <span class=\"keyword\">override</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Timestamp <span class=\"title\">poll</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMs, ChannelList* activeChannels)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fillActiveChannels</span><span class=\"params\">(<span class=\"type\">int</span> numEvents,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            ChannelList* activeChannels)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * struct pollfd</span></span><br><span class=\"line\"><span class=\"comment\">    *    struct pollfd &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    *        int   fd;     //     </span></span><br><span class=\"line\"><span class=\"comment\">    *       short events;   // </span></span><br><span class=\"line\"><span class=\"comment\">    *        short revents; // </span></span><br><span class=\"line\"><span class=\"comment\">    *    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;<span class=\"keyword\">struct</span> pollfd&gt; PollFdList;</span><br><span class=\"line\">    PollFdList pollfds_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PollPoller::<span class=\"built_in\">PollPoller</span>(EventLoop* loop)</span><br><span class=\"line\">  : <span class=\"built_in\">Poller</span>(loop)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PollPoller::~<span class=\"built_in\">PollPoller</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// EventLoopEventLoop </span></span><br><span class=\"line\"><span class=\"function\">Timestamp <span class=\"title\">PollPoller::poll</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMs, ChannelList* activeChannels)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// XXX pollfds_ shouldn&#x27;t change</span></span><br><span class=\"line\">    <span class=\"type\">int</span> numEvents = ::<span class=\"built_in\">poll</span>(&amp;*pollfds_.<span class=\"built_in\">begin</span>(), pollfds_.<span class=\"built_in\">size</span>(), timeoutMs);</span><br><span class=\"line\">    <span class=\"type\">int</span> savedErrno = errno;</span><br><span class=\"line\">    <span class=\"function\">Timestamp <span class=\"title\">now</span><span class=\"params\">(Timestamp::now())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numEvents &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">fillActiveChannels</span>(numEvents, activeChannels);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (numEvents == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        LOG_TRACE &lt;&lt; <span class=\"string\">&quot; nothing happened&quot;</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (savedErrno != EINTR)&#123;   <span class=\"comment\">// </span></span><br><span class=\"line\">            errno = savedErrno;</span><br><span class=\"line\">            LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;PollPoller::poll()&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> now;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PollPoller::fillActiveChannels</span><span class=\"params\">(<span class=\"type\">int</span> numEvents,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                    ChannelList* activeChannels)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// fdchannelactiveChannelsEventLoop</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (PollFdList::const_iterator pfd = pollfds_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        pfd != pollfds_.<span class=\"built_in\">end</span>() &amp;&amp; numEvents &gt; <span class=\"number\">0</span>; ++pfd)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pfd-&gt;revents &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            --numEvents;</span><br><span class=\"line\">            ChannelMap::const_iterator ch = channels_.<span class=\"built_in\">find</span>(pfd-&gt;fd);</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(ch != channels_.<span class=\"built_in\">end</span>());   <span class=\"comment\">//</span></span><br><span class=\"line\">            Channel* channel = ch-&gt;second;</span><br><span class=\"line\">            channel-&gt;<span class=\"built_in\">set_revents</span>(pfd-&gt;revents);</span><br><span class=\"line\">            <span class=\"comment\">// pfd-&gt;revents = 0;    // poll</span></span><br><span class=\"line\">            activeChannels-&gt;<span class=\"built_in\">push_back</span>(channel);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PollPoller::updateChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    Poller::<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel-&gt;<span class=\"built_in\">index</span>() &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// channel</span></span><br><span class=\"line\">        <span class=\"comment\">// a new one, add to pollfds_</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>()) == channels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">pollfd</span> pfd;</span><br><span class=\"line\">        pfd.fd = channel-&gt;<span class=\"built_in\">fd</span>();</span><br><span class=\"line\">        pfd.events = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">short</span>&gt;(channel-&gt;<span class=\"built_in\">events</span>());</span><br><span class=\"line\">        pfd.revents = <span class=\"number\">0</span>;</span><br><span class=\"line\">        pollfds_.<span class=\"built_in\">push_back</span>(pfd);</span><br><span class=\"line\">        <span class=\"type\">int</span> idx = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(pollfds_.<span class=\"built_in\">size</span>())<span class=\"number\">-1</span>;</span><br><span class=\"line\">        channel-&gt;<span class=\"built_in\">set_index</span>(idx);</span><br><span class=\"line\">        channels_[pfd.fd] = channel;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// update existing one</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>()) != channels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"type\">int</span> idx = channel-&gt;<span class=\"built_in\">index</span>();</span><br><span class=\"line\">        <span class=\"comment\">// idx </span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"number\">0</span> &lt;= idx &amp;&amp; idx &lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(pollfds_.<span class=\"built_in\">size</span>()));</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">pollfd</span>&amp; pfd = pollfds_[idx];</span><br><span class=\"line\">        <span class=\"comment\">// fd-(fd + 1)pollfdchannel</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(pfd.fd == channel-&gt;<span class=\"built_in\">fd</span>() || pfd.fd == -channel-&gt;<span class=\"built_in\">fd</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        pfd.fd = channel-&gt;<span class=\"built_in\">fd</span>();</span><br><span class=\"line\">        pfd.events = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">short</span>&gt;(channel-&gt;<span class=\"built_in\">events</span>());</span><br><span class=\"line\">        pfd.revents = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channel-&gt;<span class=\"built_in\">isNoneEvent</span>())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"comment\">// ignore this pollfd</span></span><br><span class=\"line\">            pfd.fd = -channel-&gt;<span class=\"built_in\">fd</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PollPoller::removeChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    Poller::<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>()) != channels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channels_[channel-&gt;<span class=\"built_in\">fd</span>()] == channel);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channel-&gt;<span class=\"built_in\">isNoneEvent</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> idx = channel-&gt;<span class=\"built_in\">index</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"number\">0</span> &lt;= idx &amp;&amp; idx &lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(pollfds_.<span class=\"built_in\">size</span>()));</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">pollfd</span>&amp; pfd = pollfds_[idx]; (<span class=\"type\">void</span>)pfd;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(pfd.fd == -channel-&gt;<span class=\"built_in\">fd</span>()<span class=\"number\">-1</span> &amp;&amp; pfd.events == channel-&gt;<span class=\"built_in\">events</span>());</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = channels_.<span class=\"built_in\">erase</span>(channel-&gt;<span class=\"built_in\">fd</span>());</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(n == <span class=\"number\">1</span>); (<span class=\"type\">void</span>)n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * pollMuduo</span></span><br><span class=\"line\"><span class=\"comment\">    * fdpop_back</span></span><br><span class=\"line\"><span class=\"comment\">    * fdchannels_</span></span><br><span class=\"line\"><span class=\"comment\">    * fdcahnnelindexfd</span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">implicit_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(idx) == pollfds_.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        pollfds_.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> channelAtEnd = pollfds_.<span class=\"built_in\">back</span>().fd;</span><br><span class=\"line\">        <span class=\"built_in\">iter_swap</span>(pollfds_.<span class=\"built_in\">begin</span>()+idx, pollfds_.<span class=\"built_in\">end</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channelAtEnd &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            channelAtEnd = -channelAtEnd<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        channels_[channelAtEnd]-&gt;<span class=\"built_in\">set_index</span>(idx);</span><br><span class=\"line\">        pollfds_.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<p>MuduofdChannel?</p>\n<p><strong></strong></p>\n<p>ChannelPollerMuduofdchannelIOPollerchannelRedis</p>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>ChannelfdfdfdIOIOPollerLinuxIO.&#x2F;net&#x2F;pollerPollerEPollPollerPollPoller</p>\n<p></p>\n<h2 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><p><strong></strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Channel</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>()&gt; EventCallback;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(Timestamp)&gt; ReadEventCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Channel</span>(EventLoop* loop, <span class=\"type\">int</span> fd);</span><br><span class=\"line\">    ~<span class=\"built_in\">Channel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleEvent</span><span class=\"params\">(Timestamp receiveTime)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setReadCallback</span><span class=\"params\">(ReadEventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; readCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWriteCallback</span><span class=\"params\">(EventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; writeCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setCloseCallback</span><span class=\"params\">(EventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; closeCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setErrorCallback</span><span class=\"params\">(EventCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; errorCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Tie this channel to the owner object managed by shared_ptr,</span></span><br><span class=\"line\">    <span class=\"comment\">/// prevent the owner object being destroyed in handleEvent.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">tie</span><span class=\"params\">(<span class=\"type\">const</span> std::shared_ptr&lt;<span class=\"type\">void</span>&gt;&amp;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fd</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> fd_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">events</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_revents</span><span class=\"params\">(<span class=\"type\">int</span> revt)</span> </span>&#123; revents_ = revt; &#125; <span class=\"comment\">// used by pollers</span></span><br><span class=\"line\">    <span class=\"comment\">// int revents() const &#123; return revents_; &#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isNoneEvent</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_ == kNoneEvent; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enableReading</span><span class=\"params\">()</span> </span>&#123; events_ |= kReadEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disableReading</span><span class=\"params\">()</span> </span>&#123; events_ &amp;= ~kReadEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enableWriting</span><span class=\"params\">()</span> </span>&#123; events_ |= kWriteEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disableWriting</span><span class=\"params\">()</span> </span>&#123; events_ &amp;= ~kWriteEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disableAll</span><span class=\"params\">()</span> </span>&#123; events_ = kNoneEvent; <span class=\"built_in\">update</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isWriting</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_ &amp; kWriteEvent; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isReading</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> events_ &amp; kReadEvent; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for Poller</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">index</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> index_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_index</span><span class=\"params\">(<span class=\"type\">int</span> idx)</span> </span>&#123; index_ = idx; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for debug</span></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">reventsToString</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">eventsToString</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">doNotLogHup</span><span class=\"params\">()</span> </span>&#123; logHup_ = <span class=\"literal\">false</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">ownerLoop</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> loop_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> string <span class=\"title\">eventsToString</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span> ev)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleEventWithGuard</span><span class=\"params\">(Timestamp receiveTime)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kNoneEvent;  <span class=\"comment\">// 0</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kReadEvent;  <span class=\"comment\">// POLLIN | POLLPRI</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kWriteEvent; <span class=\"comment\">// POLLOUT</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// channelEventLoop</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span>  fd_; <span class=\"comment\">// fd</span></span><br><span class=\"line\">    <span class=\"type\">int</span>        events_;</span><br><span class=\"line\">    <span class=\"type\">int</span>        revents_; <span class=\"comment\">// it&#x27;s the received event types of epoll or poll // </span></span><br><span class=\"line\">    <span class=\"type\">int</span>        index_; <span class=\"comment\">// used by Poller.</span></span><br><span class=\"line\">    <span class=\"type\">bool</span>       logHup_;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::weak_ptr&lt;<span class=\"type\">void</span>&gt; tie_;   <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> tied_;</span><br><span class=\"line\">    <span class=\"type\">bool</span> eventHandling_;  <span class=\"comment\">// handleEventWithGuard</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> addedToLoop_;  <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">    ReadEventCallback readCallback_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    EventCallback writeCallback_; <span class=\"comment\">// </span></span><br><span class=\"line\">    EventCallback closeCallback_; <span class=\"comment\">// </span></span><br><span class=\"line\">    EventCallback errorCallback_; <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Channel::<span class=\"built_in\">Channel</span>(EventLoop* loop, <span class=\"type\">int</span> fd__)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(loop),</span><br><span class=\"line\">    <span class=\"built_in\">fd_</span>(fd__),</span><br><span class=\"line\">    <span class=\"built_in\">events_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">revents_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">index_</span>(<span class=\"number\">-1</span>),</span><br><span class=\"line\">    <span class=\"built_in\">logHup_</span>(<span class=\"literal\">true</span>),</span><br><span class=\"line\">    <span class=\"built_in\">tied_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">eventHandling_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">addedToLoop_</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Channel::~<span class=\"built_in\">Channel</span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!eventHandling_);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!addedToLoop_);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loop_-&gt;<span class=\"built_in\">isInLoopThread</span>())&#123;</span><br><span class=\"line\">        <span class=\"comment\">// channelEventLoop</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(!loop_-&gt;<span class=\"built_in\">hasChannel</span>(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::tie</span><span class=\"params\">(<span class=\"type\">const</span> std::shared_ptr&lt;<span class=\"type\">void</span>&gt;&amp; obj)</span></span>&#123;</span><br><span class=\"line\">    tie_ = obj;   <span class=\"comment\">// </span></span><br><span class=\"line\">    tied_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::update</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// EventLoopfd</span></span><br><span class=\"line\">    addedToLoop_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">updateChannel</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::remove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// EventLoopchannel</span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"built_in\">isNoneEvent</span>());</span><br><span class=\"line\">    addedToLoop_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">removeChannel</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::handleEvent</span><span class=\"params\">(Timestamp receiveTime)</span></span>&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;<span class=\"type\">void</span>&gt; guard;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tied_)&#123;</span><br><span class=\"line\">        guard = tie_.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (guard)&#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"built_in\">handleEventWithGuard</span>(receiveTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">handleEventWithGuard</span>(receiveTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Channel::handleEventWithGuard</span><span class=\"params\">(Timestamp receiveTime)</span></span>&#123;</span><br><span class=\"line\">    eventHandling_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))&#123;</span><br><span class=\"line\">        <span class=\"comment\">// fd</span></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (closeCallback_) <span class=\"built_in\">closeCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (revents_ &amp; (POLLERR | POLLNVAL))&#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errorCallback_) <span class=\"built_in\">errorCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))&#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (readCallback_) <span class=\"built_in\">readCallback_</span>(receiveTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (revents_ &amp; POLLOUT)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (writeCallback_) <span class=\"built_in\">writeCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eventHandling_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p><strong>cpp</strong></p>\n<p></p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    std::shared_ptr&lt;Node&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Node</span>() &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Node constructed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">Node</span>() &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Node destructed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;Node&gt; node1 = std::<span class=\"built_in\">make_shared</span>&lt;Node&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    node1-&gt;next = node1;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost muduo]# g++ -Wall -std=c++11 -o test.bin test.cc </span><br><span class=\"line\">[root@localhost muduo]# </span><br><span class=\"line\">[root@localhost muduo]# </span><br><span class=\"line\">[root@localhost muduo]# ./test.bin </span><br><span class=\"line\">Node constructed</span><br><span class=\"line\">[root@localhost muduo]#</span><br></pre></td></tr></table></figure>\n\n<p><strong>weak_ptr</strong></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p><strong></strong></p>\n<p>MuduoChannel<code>std::weak_ptr&lt;void&gt; tie_</code></p>\n<p><strong></strong></p>\n<p>std::weak_ptrcircular referenceTcpConnectionChannelstd::weak_ptr</p>\n<p><strong></strong></p>\n<p>fdPOLLHUPPOLLRDHUPPOLLIN&#x2F;POLLOUT</p>\n<p><strong></strong></p>\n<p>deamoPOLLHUPPOLLIN&#x2F;POLLOUT&#x2F;POLLRDHUP</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">POLLIN</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">POLLOUT</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">POLLRDHUP</td>\n<td align=\"center\">POLLIN</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">POLLHUP</td>\n<td align=\"center\">POLLIN&#x2F;POLLOUT</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"Poller\"><a href=\"#Poller\" class=\"headerlink\" title=\"Poller\"></a>Poller</h2><p>MuduoPollerlinuxCIOPollerEventLoopEventLoopPollerIO</p>\n<p><strong>Poller</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Poller</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;Channel*&gt; ChannelList;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Poller</span>(EventLoop* loop);</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Poller</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Polls the I/O events.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the loop thread.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Timestamp <span class=\"title\">poll</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMs, ChannelList* activeChannels)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Changes the interested I/O events.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the loop thread.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">updateChannel</span><span class=\"params\">(Channel* channel)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Remove the channel, when it destructs.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the loop thread.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">removeChannel</span><span class=\"params\">(Channel* channel)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">hasChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> Poller* <span class=\"title\">newDefaultPoller</span><span class=\"params\">(EventLoop* loop)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assertInLoopThread</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        ownerLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::map&lt;<span class=\"type\">int</span>, Channel*&gt; ChannelMap; </span><br><span class=\"line\">    ChannelMap channels_;<span class=\"comment\">// fdchannel</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    EventLoop* ownerLoop_;  <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Poller</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Poller::<span class=\"built_in\">Poller</span>(EventLoop* loop)</span><br><span class=\"line\">  : <span class=\"built_in\">ownerLoop_</span>(loop)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Poller::~<span class=\"built_in\">Poller</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Poller::hasChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    ChannelMap::const_iterator it = channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> it != channels_.<span class=\"built_in\">end</span>() &amp;&amp; it-&gt;second == channel;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>MuduoPollerEPollPollerPollPollerPollPoller</p>\n<h3 id=\"PollPoller\"><a href=\"#PollPoller\" class=\"headerlink\" title=\"PollPoller\"></a>PollPoller</h3><p>muduoPollPoller  poll() EventLoopPollPoller  Channel poll() </p>\n<p> PollPoller </p>\n<ol>\n<li><p> PollPoller  PollPoller.cc </p>\n</li>\n<li><p> PollPoller  Poller  Poller </p>\n</li>\n<li><p>  poll  fillActiveChannels</p>\n<ul>\n<li>poll  poll() </li>\n<li>fillActiveChannels  poll()  activeChannels </li>\n</ul>\n</li>\n<li><p> PollPoller  EventLoop PollPoller  EventLoop EventLoop  Channel handleEvent</p>\n</li>\n</ol>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PollPoller</span> : <span class=\"keyword\">public</span> Poller&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">PollPoller</span>(EventLoop* loop);</span><br><span class=\"line\">    ~<span class=\"built_in\">PollPoller</span>() <span class=\"keyword\">override</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Timestamp <span class=\"title\">poll</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMs, ChannelList* activeChannels)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeChannel</span><span class=\"params\">(Channel* channel)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fillActiveChannels</span><span class=\"params\">(<span class=\"type\">int</span> numEvents,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            ChannelList* activeChannels)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * struct pollfd</span></span><br><span class=\"line\"><span class=\"comment\">    *    struct pollfd &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    *        int   fd;     //     </span></span><br><span class=\"line\"><span class=\"comment\">    *       short events;   // </span></span><br><span class=\"line\"><span class=\"comment\">    *        short revents; // </span></span><br><span class=\"line\"><span class=\"comment\">    *    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;<span class=\"keyword\">struct</span> pollfd&gt; PollFdList;</span><br><span class=\"line\">    PollFdList pollfds_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PollPoller::<span class=\"built_in\">PollPoller</span>(EventLoop* loop)</span><br><span class=\"line\">  : <span class=\"built_in\">Poller</span>(loop)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PollPoller::~<span class=\"built_in\">PollPoller</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// EventLoopEventLoop </span></span><br><span class=\"line\"><span class=\"function\">Timestamp <span class=\"title\">PollPoller::poll</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMs, ChannelList* activeChannels)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// XXX pollfds_ shouldn&#x27;t change</span></span><br><span class=\"line\">    <span class=\"type\">int</span> numEvents = ::<span class=\"built_in\">poll</span>(&amp;*pollfds_.<span class=\"built_in\">begin</span>(), pollfds_.<span class=\"built_in\">size</span>(), timeoutMs);</span><br><span class=\"line\">    <span class=\"type\">int</span> savedErrno = errno;</span><br><span class=\"line\">    <span class=\"function\">Timestamp <span class=\"title\">now</span><span class=\"params\">(Timestamp::now())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numEvents &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">fillActiveChannels</span>(numEvents, activeChannels);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (numEvents == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        LOG_TRACE &lt;&lt; <span class=\"string\">&quot; nothing happened&quot;</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (savedErrno != EINTR)&#123;   <span class=\"comment\">// </span></span><br><span class=\"line\">            errno = savedErrno;</span><br><span class=\"line\">            LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;PollPoller::poll()&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> now;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PollPoller::fillActiveChannels</span><span class=\"params\">(<span class=\"type\">int</span> numEvents,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                    ChannelList* activeChannels)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// fdchannelactiveChannelsEventLoop</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (PollFdList::const_iterator pfd = pollfds_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        pfd != pollfds_.<span class=\"built_in\">end</span>() &amp;&amp; numEvents &gt; <span class=\"number\">0</span>; ++pfd)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pfd-&gt;revents &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            --numEvents;</span><br><span class=\"line\">            ChannelMap::const_iterator ch = channels_.<span class=\"built_in\">find</span>(pfd-&gt;fd);</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(ch != channels_.<span class=\"built_in\">end</span>());   <span class=\"comment\">//</span></span><br><span class=\"line\">            Channel* channel = ch-&gt;second;</span><br><span class=\"line\">            channel-&gt;<span class=\"built_in\">set_revents</span>(pfd-&gt;revents);</span><br><span class=\"line\">            <span class=\"comment\">// pfd-&gt;revents = 0;    // poll</span></span><br><span class=\"line\">            activeChannels-&gt;<span class=\"built_in\">push_back</span>(channel);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PollPoller::updateChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    Poller::<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel-&gt;<span class=\"built_in\">index</span>() &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// channel</span></span><br><span class=\"line\">        <span class=\"comment\">// a new one, add to pollfds_</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>()) == channels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">pollfd</span> pfd;</span><br><span class=\"line\">        pfd.fd = channel-&gt;<span class=\"built_in\">fd</span>();</span><br><span class=\"line\">        pfd.events = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">short</span>&gt;(channel-&gt;<span class=\"built_in\">events</span>());</span><br><span class=\"line\">        pfd.revents = <span class=\"number\">0</span>;</span><br><span class=\"line\">        pollfds_.<span class=\"built_in\">push_back</span>(pfd);</span><br><span class=\"line\">        <span class=\"type\">int</span> idx = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(pollfds_.<span class=\"built_in\">size</span>())<span class=\"number\">-1</span>;</span><br><span class=\"line\">        channel-&gt;<span class=\"built_in\">set_index</span>(idx);</span><br><span class=\"line\">        channels_[pfd.fd] = channel;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// update existing one</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>()) != channels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"type\">int</span> idx = channel-&gt;<span class=\"built_in\">index</span>();</span><br><span class=\"line\">        <span class=\"comment\">// idx </span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"number\">0</span> &lt;= idx &amp;&amp; idx &lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(pollfds_.<span class=\"built_in\">size</span>()));</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">pollfd</span>&amp; pfd = pollfds_[idx];</span><br><span class=\"line\">        <span class=\"comment\">// fd-(fd + 1)pollfdchannel</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(pfd.fd == channel-&gt;<span class=\"built_in\">fd</span>() || pfd.fd == -channel-&gt;<span class=\"built_in\">fd</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        pfd.fd = channel-&gt;<span class=\"built_in\">fd</span>();</span><br><span class=\"line\">        pfd.events = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">short</span>&gt;(channel-&gt;<span class=\"built_in\">events</span>());</span><br><span class=\"line\">        pfd.revents = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channel-&gt;<span class=\"built_in\">isNoneEvent</span>())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"comment\">// ignore this pollfd</span></span><br><span class=\"line\">            pfd.fd = -channel-&gt;<span class=\"built_in\">fd</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PollPoller::removeChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    Poller::<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channels_.<span class=\"built_in\">find</span>(channel-&gt;<span class=\"built_in\">fd</span>()) != channels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channels_[channel-&gt;<span class=\"built_in\">fd</span>()] == channel);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channel-&gt;<span class=\"built_in\">isNoneEvent</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> idx = channel-&gt;<span class=\"built_in\">index</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"number\">0</span> &lt;= idx &amp;&amp; idx &lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(pollfds_.<span class=\"built_in\">size</span>()));</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">pollfd</span>&amp; pfd = pollfds_[idx]; (<span class=\"type\">void</span>)pfd;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(pfd.fd == -channel-&gt;<span class=\"built_in\">fd</span>()<span class=\"number\">-1</span> &amp;&amp; pfd.events == channel-&gt;<span class=\"built_in\">events</span>());</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = channels_.<span class=\"built_in\">erase</span>(channel-&gt;<span class=\"built_in\">fd</span>());</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(n == <span class=\"number\">1</span>); (<span class=\"type\">void</span>)n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * pollMuduo</span></span><br><span class=\"line\"><span class=\"comment\">    * fdpop_back</span></span><br><span class=\"line\"><span class=\"comment\">    * fdchannels_</span></span><br><span class=\"line\"><span class=\"comment\">    * fdcahnnelindexfd</span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">implicit_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(idx) == pollfds_.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        pollfds_.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> channelAtEnd = pollfds_.<span class=\"built_in\">back</span>().fd;</span><br><span class=\"line\">        <span class=\"built_in\">iter_swap</span>(pollfds_.<span class=\"built_in\">begin</span>()+idx, pollfds_.<span class=\"built_in\">end</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channelAtEnd &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            channelAtEnd = -channelAtEnd<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        channels_[channelAtEnd]-&gt;<span class=\"built_in\">set_index</span>(idx);</span><br><span class=\"line\">        pollfds_.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<p>MuduofdChannel?</p>\n<p><strong></strong></p>\n<p>ChannelPollerMuduofdchannelIOPollerchannelRedis</p>\n<hr>\n<p><strong></strong></p>"},{"title":"muduo0muduo","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n[muduo11TcpClient](./TcpClient.md)\n\n## \n\n<!-- more -->\n```bash\ngit clone https://github.com/chenshuo/muduo.git #\n\n# \nyum install cmake   # cmake\nyum install boost-devel # boost\n\n# build\ncd muduo\nmkdir build\ncd build\n\n# buildmakefile\ncmake ..\n\n# \nmake -j4\n\n# \nmake install\n```\n\n## \n\n****\n\n```bash\n/root/workspace/muduo/muduo/base/TimeZone.cc:171:36: error: conversion to int from long unsigned int may alter its value [-Werror=conversion]\n   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);\n                                    ^\n/root/workspace/muduo/muduo/base/TimeZone.cc:171:54: error: conversion to int from long unsigned int may alter its value [-Werror=conversion]\n   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);\n                                                      ^\ncc1plus: all warnings being treated as errors\nmake[2]: *** [muduo/base/CMakeFiles/muduo_base.dir/TimeZone.cc.o] Error 1\nmake[2]: *** Waiting for unfinished jobs....\nmake[1]: *** [muduo/base/CMakeFiles/muduo_base.dir/all] Error 2\nmake: *** [all] Error 2\n```\n\n\n\n>  `-Werror=conversion`  long unsigned int  int \n\nCMakeLists.txt`-Werror`\n\n---\n\n****","source":"_posts/muduo/Start.md","raw":"---\ntitle: muduo0muduo\ndate: 2024-11-02 12:00:00\ntags:\n  - \n---\n\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n[muduo11TcpClient](./TcpClient.md)\n\n## \n\n<!-- more -->\n```bash\ngit clone https://github.com/chenshuo/muduo.git #\n\n# \nyum install cmake   # cmake\nyum install boost-devel # boost\n\n# build\ncd muduo\nmkdir build\ncd build\n\n# buildmakefile\ncmake ..\n\n# \nmake -j4\n\n# \nmake install\n```\n\n## \n\n****\n\n```bash\n/root/workspace/muduo/muduo/base/TimeZone.cc:171:36: error: conversion to int from long unsigned int may alter its value [-Werror=conversion]\n   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);\n                                    ^\n/root/workspace/muduo/muduo/base/TimeZone.cc:171:54: error: conversion to int from long unsigned int may alter its value [-Werror=conversion]\n   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);\n                                                      ^\ncc1plus: all warnings being treated as errors\nmake[2]: *** [muduo/base/CMakeFiles/muduo_base.dir/TimeZone.cc.o] Error 1\nmake[2]: *** Waiting for unfinished jobs....\nmake[1]: *** [muduo/base/CMakeFiles/muduo_base.dir/all] Error 2\nmake: *** [all] Error 2\n```\n\n\n\n>  `-Werror=conversion`  long unsigned int  int \n\nCMakeLists.txt`-Werror`\n\n---\n\n****","slug":"muduo/Start","published":1,"updated":"2025-09-28T16:06:43.130Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9o000aq8ws7nc90xlj","content":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><a href=\"./TcpClient.md\">muduo11TcpClient</a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><span id=\"more\"></span>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/chenshuo/muduo.git <span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\">yum install cmake   <span class=\"comment\"># cmake</span></span><br><span class=\"line\">yum install boost-devel <span class=\"comment\"># boost</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># build</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> muduo</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> build</span><br><span class=\"line\"><span class=\"built_in\">cd</span> build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># buildmakefile</span></span><br><span class=\"line\">cmake ..</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\">make -j4</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/root/workspace/muduo/muduo/base/TimeZone.cc:171:36: error: conversion to int from long unsigned int may alter its value [-Werror=conversion]</span><br><span class=\"line\">   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);</span><br><span class=\"line\">                                    ^</span><br><span class=\"line\">/root/workspace/muduo/muduo/base/TimeZone.cc:171:54: error: conversion to int from long unsigned int may alter its value [-Werror=conversion]</span><br><span class=\"line\">   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);</span><br><span class=\"line\">                                                      ^</span><br><span class=\"line\">cc1plus: all warnings being treated as errors</span><br><span class=\"line\">make[2]: *** [muduo/base/CMakeFiles/muduo_base.dir/TimeZone.cc.o] Error 1</span><br><span class=\"line\">make[2]: *** Waiting <span class=\"keyword\">for</span> unfinished <span class=\"built_in\">jobs</span>....</span><br><span class=\"line\">make[1]: *** [muduo/base/CMakeFiles/muduo_base.dir/all] Error 2</span><br><span class=\"line\">make: *** [all] Error 2</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<blockquote>\n<p> <code>-Werror=conversion</code>  long unsigned int  int </p>\n</blockquote>\n<p>CMakeLists.txt<code>-Werror</code></p>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><a href=\"./TcpClient.md\">muduo11TcpClient</a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/chenshuo/muduo.git <span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\">yum install cmake   <span class=\"comment\"># cmake</span></span><br><span class=\"line\">yum install boost-devel <span class=\"comment\"># boost</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># build</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> muduo</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> build</span><br><span class=\"line\"><span class=\"built_in\">cd</span> build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># buildmakefile</span></span><br><span class=\"line\">cmake ..</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\">make -j4</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/root/workspace/muduo/muduo/base/TimeZone.cc:171:36: error: conversion to int from long unsigned int may alter its value [-Werror=conversion]</span><br><span class=\"line\">   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);</span><br><span class=\"line\">                                    ^</span><br><span class=\"line\">/root/workspace/muduo/muduo/base/TimeZone.cc:171:54: error: conversion to int from long unsigned int may alter its value [-Werror=conversion]</span><br><span class=\"line\">   const int time_size = v1 ? sizeof(int32_t) : sizeof(int64_t);</span><br><span class=\"line\">                                                      ^</span><br><span class=\"line\">cc1plus: all warnings being treated as errors</span><br><span class=\"line\">make[2]: *** [muduo/base/CMakeFiles/muduo_base.dir/TimeZone.cc.o] Error 1</span><br><span class=\"line\">make[2]: *** Waiting <span class=\"keyword\">for</span> unfinished <span class=\"built_in\">jobs</span>....</span><br><span class=\"line\">make[1]: *** [muduo/base/CMakeFiles/muduo_base.dir/all] Error 2</span><br><span class=\"line\">make: *** [all] Error 2</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<blockquote>\n<p> <code>-Werror=conversion</code>  long unsigned int  int </p>\n</blockquote>\n<p>CMakeLists.txt<code>-Werror</code></p>\n<hr>\n<p><strong></strong></p>"},{"title":"muduo7EventLoopThreadPool","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nbaseEventLoopThreadPoolEventLoopThreadEventLoopOne Loop Per ThreadMuduo\n\n## \n\n****\n\n<!-- more -->\n```cpp\nclass EventLoopThreadPool : noncopyable{\npublic:\n    typedef std::function<void(EventLoop*)> ThreadInitCallback;\n\n    EventLoopThreadPool(EventLoop* baseLoop, const string& nameArg);\n    ~EventLoopThreadPool();\n    void setThreadNum(int numThreads) { numThreads_ = numThreads; }\n    void start(const ThreadInitCallback& cb = ThreadInitCallback());\n\n    // valid after calling start()\n    /// round-robin\n    EventLoop* getNextLoop();\n\n    /// with the same hash code, it will always return the same EventLoop\n    EventLoop* getLoopForHash(size_t hashCode);\n\n    std::vector<EventLoop*> getAllLoops();\n\n    bool started() const\n    { return started_; }\n\n    const string& name() const\n    { return name_; }\n\nprivate:\n\n    EventLoop* baseLoop_; // EventLoopThreadPoolEventLoop\n    string name_; // \n    bool started_;  // \n    int numThreads_;  // EventLoopThread\n    int next_;    // round-robin\n    std::vector<std::unique_ptr<EventLoopThread>> threads_; // \n    std::vector<EventLoop*> loops_; // EventLoop\n};\n```\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)EventLoopThreadPool\n\n![](./EventLoopThreadPool/photo/EventLoopThreadPool.drawio.png)\n\n****\n\n```cpp\nEventLoopThreadPool::EventLoopThreadPool(EventLoop* baseLoop, const string& nameArg)\n  : baseLoop_(baseLoop),\n    name_(nameArg),\n    started_(false),\n    numThreads_(0),\n    next_(0){\n}\n\nEventLoopThreadPool::~EventLoopThreadPool(){\n    // Don't delete loop, it's stack variable\n}\n\nvoid EventLoopThreadPool::start(const ThreadInitCallback& cb){\n    assert(!started_);\n    baseLoop_->assertInLoopThread();\n\n    started_ = true;\n\n    for (int i = 0; i < numThreads_; ++i){\n        char buf[name_.size() + 32];\n        snprintf(buf, sizeof buf, \"%s%d\", name_.c_str(), i);\n        EventLoopThread* t = new EventLoopThread(cb, buf);\n        threads_.push_back(std::unique_ptr<EventLoopThread>(t));\n        loops_.push_back(t->startLoop()); // \n    }\n    if (numThreads_ == 0 && cb){\n        cb(baseLoop_);\n    }\n}\n\nEventLoop* EventLoopThreadPool::getNextLoop(){ // round-robin\n    baseLoop_->assertInLoopThread();\n    assert(started_);\n    EventLoop* loop = baseLoop_;  // 0baseLoop\n\n    if (!loops_.empty()){\n        // round-robin\n        loop = loops_[next_];\n        ++next_;\n        if (implicit_cast<size_t>(next_) >= loops_.size()){\n            next_ = 0;\n        }\n    }\n    return loop;\n}\n\nEventLoop* EventLoopThreadPool::getLoopForHash(size_t hashCode){ // hash\n    baseLoop_->assertInLoopThread();\n    EventLoop* loop = baseLoop_;// 0baseLoop\n\n    if (!loops_.empty()){\n        loop = loops_[hashCode % loops_.size()];\n    }\n    return loop;\n}\n\nstd::vector<EventLoop*> EventLoopThreadPool::getAllLoops(){\n    baseLoop_->assertInLoopThread();\n    assert(started_);\n    if (loops_.empty()){\n        return std::vector<EventLoop*>(1, baseLoop_);\n    }else{\n        return loops_;\n    }\n}\n```\n\n## \n\n****\n\n`EventLoopThreadPool::getNextLoop()``EventLoopThreadPool::getLoopForHash`\n\n****\n\n\n\n****\n\nMuduounique_ptrsahred_ptr\n\n\n\n1. ** std::unique_ptr**\n\n2.  Muduostd::shared_ptrstd::unique_ptr\n\n3.  std::shared_ptr\n\n4.  std::shared_ptr\n\n---\n\n****","source":"_posts/muduo/EventLoopThreadPool.md","raw":"---\ntitle: muduo7EventLoopThreadPool\ndate: 2024-11-02 12:00:00\ntags:\n  - \n---\n\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nbaseEventLoopThreadPoolEventLoopThreadEventLoopOne Loop Per ThreadMuduo\n\n## \n\n****\n\n<!-- more -->\n```cpp\nclass EventLoopThreadPool : noncopyable{\npublic:\n    typedef std::function<void(EventLoop*)> ThreadInitCallback;\n\n    EventLoopThreadPool(EventLoop* baseLoop, const string& nameArg);\n    ~EventLoopThreadPool();\n    void setThreadNum(int numThreads) { numThreads_ = numThreads; }\n    void start(const ThreadInitCallback& cb = ThreadInitCallback());\n\n    // valid after calling start()\n    /// round-robin\n    EventLoop* getNextLoop();\n\n    /// with the same hash code, it will always return the same EventLoop\n    EventLoop* getLoopForHash(size_t hashCode);\n\n    std::vector<EventLoop*> getAllLoops();\n\n    bool started() const\n    { return started_; }\n\n    const string& name() const\n    { return name_; }\n\nprivate:\n\n    EventLoop* baseLoop_; // EventLoopThreadPoolEventLoop\n    string name_; // \n    bool started_;  // \n    int numThreads_;  // EventLoopThread\n    int next_;    // round-robin\n    std::vector<std::unique_ptr<EventLoopThread>> threads_; // \n    std::vector<EventLoop*> loops_; // EventLoop\n};\n```\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)EventLoopThreadPool\n\n![](./EventLoopThreadPool/photo/EventLoopThreadPool.drawio.png)\n\n****\n\n```cpp\nEventLoopThreadPool::EventLoopThreadPool(EventLoop* baseLoop, const string& nameArg)\n  : baseLoop_(baseLoop),\n    name_(nameArg),\n    started_(false),\n    numThreads_(0),\n    next_(0){\n}\n\nEventLoopThreadPool::~EventLoopThreadPool(){\n    // Don't delete loop, it's stack variable\n}\n\nvoid EventLoopThreadPool::start(const ThreadInitCallback& cb){\n    assert(!started_);\n    baseLoop_->assertInLoopThread();\n\n    started_ = true;\n\n    for (int i = 0; i < numThreads_; ++i){\n        char buf[name_.size() + 32];\n        snprintf(buf, sizeof buf, \"%s%d\", name_.c_str(), i);\n        EventLoopThread* t = new EventLoopThread(cb, buf);\n        threads_.push_back(std::unique_ptr<EventLoopThread>(t));\n        loops_.push_back(t->startLoop()); // \n    }\n    if (numThreads_ == 0 && cb){\n        cb(baseLoop_);\n    }\n}\n\nEventLoop* EventLoopThreadPool::getNextLoop(){ // round-robin\n    baseLoop_->assertInLoopThread();\n    assert(started_);\n    EventLoop* loop = baseLoop_;  // 0baseLoop\n\n    if (!loops_.empty()){\n        // round-robin\n        loop = loops_[next_];\n        ++next_;\n        if (implicit_cast<size_t>(next_) >= loops_.size()){\n            next_ = 0;\n        }\n    }\n    return loop;\n}\n\nEventLoop* EventLoopThreadPool::getLoopForHash(size_t hashCode){ // hash\n    baseLoop_->assertInLoopThread();\n    EventLoop* loop = baseLoop_;// 0baseLoop\n\n    if (!loops_.empty()){\n        loop = loops_[hashCode % loops_.size()];\n    }\n    return loop;\n}\n\nstd::vector<EventLoop*> EventLoopThreadPool::getAllLoops(){\n    baseLoop_->assertInLoopThread();\n    assert(started_);\n    if (loops_.empty()){\n        return std::vector<EventLoop*>(1, baseLoop_);\n    }else{\n        return loops_;\n    }\n}\n```\n\n## \n\n****\n\n`EventLoopThreadPool::getNextLoop()``EventLoopThreadPool::getLoopForHash`\n\n****\n\n\n\n****\n\nMuduounique_ptrsahred_ptr\n\n\n\n1. ** std::unique_ptr**\n\n2.  Muduostd::shared_ptrstd::unique_ptr\n\n3.  std::shared_ptr\n\n4.  std::shared_ptr\n\n---\n\n****","slug":"muduo/EventLoopThreadPool","published":1,"updated":"2025-09-28T16:06:43.125Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9p000cq8wsbylt7ba0","content":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>baseEventLoopThreadPoolEventLoopThreadEventLoopOne Loop Per ThreadMuduo</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EventLoopThreadPool</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(EventLoop*)&gt; ThreadInitCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">EventLoopThreadPool</span>(EventLoop* baseLoop, <span class=\"type\">const</span> string&amp; nameArg);</span><br><span class=\"line\">    ~<span class=\"built_in\">EventLoopThreadPool</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadNum</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span> </span>&#123; numThreads_ = numThreads; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"type\">const</span> ThreadInitCallback&amp; cb = ThreadInitCallback())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// valid after calling start()</span></span><br><span class=\"line\">    <span class=\"comment\">/// round-robin</span></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getNextLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// with the same hash code, it will always return the same EventLoop</span></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getLoopForHash</span><span class=\"params\">(<span class=\"type\">size_t</span> hashCode)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;EventLoop*&gt; <span class=\"title\">getAllLoops</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">started</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> started_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* baseLoop_; <span class=\"comment\">// EventLoopThreadPoolEventLoop</span></span><br><span class=\"line\">    string name_; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> started_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> numThreads_;  <span class=\"comment\">// EventLoopThread</span></span><br><span class=\"line\">    <span class=\"type\">int</span> next_;    <span class=\"comment\">// round-robin</span></span><br><span class=\"line\">    std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; threads_; <span class=\"comment\">// </span></span><br><span class=\"line\">    std::vector&lt;EventLoop*&gt; loops_; <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a>EventLoopThreadPool</p>\n<p><img src=\"/2024/11/02/muduo/EventLoopThreadPool/photo/EventLoopThreadPool.drawio.png\"></p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopThreadPool::<span class=\"built_in\">EventLoopThreadPool</span>(EventLoop* baseLoop, <span class=\"type\">const</span> string&amp; nameArg)</span><br><span class=\"line\">  : <span class=\"built_in\">baseLoop_</span>(baseLoop),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">started_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">numThreads_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">next_</span>(<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoopThreadPool::~<span class=\"built_in\">EventLoopThreadPool</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t delete loop, it&#x27;s stack variable</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoopThreadPool::start</span><span class=\"params\">(<span class=\"type\">const</span> ThreadInitCallback&amp; cb)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!started_);</span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    started_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; numThreads_; ++i)&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> buf[name_.<span class=\"built_in\">size</span>() + <span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;%s%d&quot;</span>, name_.<span class=\"built_in\">c_str</span>(), i);</span><br><span class=\"line\">        EventLoopThread* t = <span class=\"keyword\">new</span> <span class=\"built_in\">EventLoopThread</span>(cb, buf);</span><br><span class=\"line\">        threads_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">unique_ptr</span>&lt;EventLoopThread&gt;(t));</span><br><span class=\"line\">        loops_.<span class=\"built_in\">push_back</span>(t-&gt;<span class=\"built_in\">startLoop</span>()); <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numThreads_ == <span class=\"number\">0</span> &amp;&amp; cb)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cb</span>(baseLoop_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EventLoop* <span class=\"title\">EventLoopThreadPool::getNextLoop</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// round-robin</span></span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(started_);</span><br><span class=\"line\">    EventLoop* loop = baseLoop_;  <span class=\"comment\">// 0baseLoop</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loops_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"comment\">// round-robin</span></span><br><span class=\"line\">        loop = loops_[next_];</span><br><span class=\"line\">        ++next_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">implicit_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(next_) &gt;= loops_.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            next_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EventLoop* <span class=\"title\">EventLoopThreadPool::getLoopForHash</span><span class=\"params\">(<span class=\"type\">size_t</span> hashCode)</span></span>&#123; <span class=\"comment\">// hash</span></span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    EventLoop* loop = baseLoop_;<span class=\"comment\">// 0baseLoop</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loops_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        loop = loops_[hashCode % loops_.<span class=\"built_in\">size</span>()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;EventLoop*&gt; <span class=\"title\">EventLoopThreadPool::getAllLoops</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(started_);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loops_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::<span class=\"built_in\">vector</span>&lt;EventLoop*&gt;(<span class=\"number\">1</span>, baseLoop_);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> loops_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<p><code>EventLoopThreadPool::getNextLoop()</code><code>EventLoopThreadPool::getLoopForHash</code></p>\n<p><strong></strong></p>\n<p></p>\n<p><strong></strong></p>\n<p>Muduounique_ptrsahred_ptr</p>\n<p></p>\n<ol>\n<li><p><strong> std::unique_ptr</strong></p>\n</li>\n<li><p> Muduostd::shared_ptrstd::unique_ptr</p>\n</li>\n<li><p> std::shared_ptr</p>\n</li>\n<li><p> std::shared_ptr</p>\n</li>\n</ol>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>baseEventLoopThreadPoolEventLoopThreadEventLoopOne Loop Per ThreadMuduo</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EventLoopThreadPool</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(EventLoop*)&gt; ThreadInitCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">EventLoopThreadPool</span>(EventLoop* baseLoop, <span class=\"type\">const</span> string&amp; nameArg);</span><br><span class=\"line\">    ~<span class=\"built_in\">EventLoopThreadPool</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadNum</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span> </span>&#123; numThreads_ = numThreads; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"type\">const</span> ThreadInitCallback&amp; cb = ThreadInitCallback())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// valid after calling start()</span></span><br><span class=\"line\">    <span class=\"comment\">/// round-robin</span></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getNextLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// with the same hash code, it will always return the same EventLoop</span></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getLoopForHash</span><span class=\"params\">(<span class=\"type\">size_t</span> hashCode)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;EventLoop*&gt; <span class=\"title\">getAllLoops</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">started</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> started_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* baseLoop_; <span class=\"comment\">// EventLoopThreadPoolEventLoop</span></span><br><span class=\"line\">    string name_; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> started_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> numThreads_;  <span class=\"comment\">// EventLoopThread</span></span><br><span class=\"line\">    <span class=\"type\">int</span> next_;    <span class=\"comment\">// round-robin</span></span><br><span class=\"line\">    std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; threads_; <span class=\"comment\">// </span></span><br><span class=\"line\">    std::vector&lt;EventLoop*&gt; loops_; <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a>EventLoopThreadPool</p>\n<p><img src=\"/2024/11/02/muduo/EventLoopThreadPool/photo/EventLoopThreadPool.drawio.png\"></p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopThreadPool::<span class=\"built_in\">EventLoopThreadPool</span>(EventLoop* baseLoop, <span class=\"type\">const</span> string&amp; nameArg)</span><br><span class=\"line\">  : <span class=\"built_in\">baseLoop_</span>(baseLoop),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">started_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">numThreads_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">next_</span>(<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoopThreadPool::~<span class=\"built_in\">EventLoopThreadPool</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t delete loop, it&#x27;s stack variable</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoopThreadPool::start</span><span class=\"params\">(<span class=\"type\">const</span> ThreadInitCallback&amp; cb)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!started_);</span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    started_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; numThreads_; ++i)&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> buf[name_.<span class=\"built_in\">size</span>() + <span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;%s%d&quot;</span>, name_.<span class=\"built_in\">c_str</span>(), i);</span><br><span class=\"line\">        EventLoopThread* t = <span class=\"keyword\">new</span> <span class=\"built_in\">EventLoopThread</span>(cb, buf);</span><br><span class=\"line\">        threads_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">unique_ptr</span>&lt;EventLoopThread&gt;(t));</span><br><span class=\"line\">        loops_.<span class=\"built_in\">push_back</span>(t-&gt;<span class=\"built_in\">startLoop</span>()); <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numThreads_ == <span class=\"number\">0</span> &amp;&amp; cb)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cb</span>(baseLoop_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EventLoop* <span class=\"title\">EventLoopThreadPool::getNextLoop</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// round-robin</span></span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(started_);</span><br><span class=\"line\">    EventLoop* loop = baseLoop_;  <span class=\"comment\">// 0baseLoop</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loops_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"comment\">// round-robin</span></span><br><span class=\"line\">        loop = loops_[next_];</span><br><span class=\"line\">        ++next_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">implicit_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(next_) &gt;= loops_.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            next_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EventLoop* <span class=\"title\">EventLoopThreadPool::getLoopForHash</span><span class=\"params\">(<span class=\"type\">size_t</span> hashCode)</span></span>&#123; <span class=\"comment\">// hash</span></span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    EventLoop* loop = baseLoop_;<span class=\"comment\">// 0baseLoop</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loops_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        loop = loops_[hashCode % loops_.<span class=\"built_in\">size</span>()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;EventLoop*&gt; <span class=\"title\">EventLoopThreadPool::getAllLoops</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    baseLoop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(started_);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loops_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::<span class=\"built_in\">vector</span>&lt;EventLoop*&gt;(<span class=\"number\">1</span>, baseLoop_);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> loops_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<p><code>EventLoopThreadPool::getNextLoop()</code><code>EventLoopThreadPool::getLoopForHash</code></p>\n<p><strong></strong></p>\n<p></p>\n<p><strong></strong></p>\n<p>Muduounique_ptrsahred_ptr</p>\n<p></p>\n<ol>\n<li><p><strong> std::unique_ptr</strong></p>\n</li>\n<li><p> Muduostd::shared_ptrstd::unique_ptr</p>\n</li>\n<li><p> std::shared_ptr</p>\n</li>\n<li><p> std::shared_ptr</p>\n</li>\n</ol>\n<hr>\n<p><strong></strong></p>"},{"title":"muduo6EvevntLoopThread","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nMuduoEventLoopThread\n\nExevntLoopThreadOne Loop Per ThreadepollIO **** ********Muduo\n\n## EventLoop\n\n****\n\n<!-- more -->\n```cpp\nclass EventLoop : noncopyable{\npublic:\n    typedef std::function<void()> Functor;\n\n    EventLoop();\n    ~EventLoop();  // force out-line dtor, for std::unique_ptr members.\n\n    ///\n    /// Loops forever.\n    ///\n    /// Must be called in the same thread as creation of the object.\n    ///\n    void loop();\n\n    /// Quits loop.\n    ///\n    /// This is not 100% thread safe, if you call through a raw pointer,\n    /// better to call through shared_ptr<EventLoop> for 100% safety.\n    void quit();\n\n    /// Runs callback immediately in the loop thread.\n    /// It wakes up the loop, and run the cb.\n    /// If in the same loop thread, cb is run within the function.\n    /// Safe to call from other threads.\n    void runInLoop(Functor cb);\n    /// Queues callback in the loop thread.\n    /// Runs after finish pooling.\n    /// Safe to call from other threads.\n    void queueInLoop(Functor cb);\n\n    size_t queueSize() const;\n\n    // timers\n\n    // ...\n\n    // internal usage\n    void wakeup();\n    void updateChannel(Channel* channel);\n    void removeChannel(Channel* channel);\n\n    // pid_t threadId() const { return threadId_; }\n    void assertInLoopThread()\n\n    bool isInLoopThread() const { return threadId_ == CurrentThread::tid(); }\n    // EventLoop\n    static EventLoop* getEventLoopOfCurrentThread();\n\nprivate:\n    void abortNotInLoopThread();\n    void handleRead();  // waked up\n    void doPendingFunctors();\n\n    typedef std::vector<Channel*> ChannelList;\n\n    bool looping_; /* atomic */ // loop()\n    std::atomic<bool> quit_;  // EventLoop\n    bool eventHandling_; /* atomic */ // \n    bool callingPendingFunctors_; /* atomic */  // \n    int64_t iteration_;   // loop()\n    const pid_t threadId_;  // EventLoop\n    Timestamp pollReturnTime_;  // epoll_wait\n    std::unique_ptr<Poller> poller_;  // epoll/poll\n    std::unique_ptr<TimerQueue> timerQueue_;  // \n    int wakeupFd_;  // tickleFdepoll_wait\n    // unlike in TimerQueue, which is an internal class,\n    // we don't expose Channel to client.\n    std::unique_ptr<Channel> wakeupChannel_;  // tickleFdchannel\n    boost::any context_;  // \n\n    // scratch variables\n    ChannelList activeChannels_;   // poller_fdchannel\n    Channel* currentActiveChannel_; // loop()channel\n\n    mutable MutexLock mutex_; // pendingFunctors_\n    std::vector<Functor> pendingFunctors_ GUARDED_BY(mutex_); // \n};\n```\n\nMuduoEventLoopLinuxEventFdwakeupChannel_sylar`EventLoop::wakeup()`sylar`IOManager::tickle()`\n\nMuduoEventLoopMuduoLinuxTimeFdTimerQueuefdChannelChannelEventLoopPoller\n\nEventLoop`EventLoop::loop()`\n\n![loop](./EvevntLoopAndThread/photo/EventLoop.drawio.png)\n\n****\n\n```cpp\n// forEventLoop\n__thread EventLoop* t_loopInThisThread = 0;\n\nEventLoop::EventLoop()\n  : // ...\n    threadId_(CurrentThread::tid()),\n    poller_(Poller::newDefaultPoller(this)),    // epoll\n    timerQueue_(new TimerQueue(this)),      // MuduotimerfdTimerQueuechannelEventLoppPollerfd\n    wakeupFd_(createEventfd()),   // eventfdtickle\n    wakeupChannel_(new Channel(this, wakeupFd_)){ // eventfdchannel\n\n    LOG_DEBUG << \"EventLoop created \" << this << \" in thread \" << threadId_;\n    if (t_loopInThisThread){\n        LOG_FATAL << \"Another EventLoop \" << t_loopInThisThread\n                << \" exists in this thread \" << threadId_;\n    }else{\n        t_loopInThisThread = this;  // \n    }\n    // eventfd\n    wakeupChannel_->setReadCallback(\n        std::bind(&EventLoop::handleRead, this));\n    // we are always reading the wakeupfd\n    wakeupChannel_->enableReading();\n}\n\nEventLoop::~EventLoop(){\n    // \n    LOG_DEBUG << \"EventLoop \" << this << \" of thread \" << threadId_\n            << \" destructs in thread \" << CurrentThread::tid();\n    wakeupChannel_->disableAll();\n    wakeupChannel_->remove();\n    ::close(wakeupFd_);\n    t_loopInThisThread = NULL;\n}\n\nvoid EventLoop::loop(){\n    assert(!looping_);\n    assertInLoopThread(); // \n    looping_ = true;\n    quit_ = false;  // FIXME: what if someone calls quit() before loop() ?\n    LOG_TRACE << \"EventLoop \" << this << \" start looping\";\n\n    while (!quit_){\n        activeChannels_.clear();\n        pollReturnTime_ = poller_->poll(kPollTimeMs, &activeChannels_); // epoll_wait\n        ++iteration_;\n        if (Logger::logLevel() <= Logger::TRACE){\n            printActiveChannels();\n        }\n        // TODO sort channel by priority\n        eventHandling_ = true;  // fd\n        for (Channel* channel : activeChannels_){\n            currentActiveChannel_ = channel;\n            currentActiveChannel_->handleEvent(pollReturnTime_);  // channel\n        }\n        currentActiveChannel_ = NULL;\n        eventHandling_ = false; // fd\n        doPendingFunctors();  // \n    }\n\n    LOG_TRACE << \"EventLoop \" << this << \" stop looping\";\n    looping_ = false;\n}\n\nvoid EventLoop::quit(){\n    quit_ = true;\n    // \n    // There is a chance that loop() just executes while(!quit_) and exits,\n    // then EventLoop destructs, then we are accessing an invalid object.\n    // Can be fixed using mutex_ in both places.\n    if (!isInLoopThread()){  // quitActivewakeup();\n        wakeup();\n    } // quitActive\n}\n\nvoid EventLoop::runInLoop(Functor cb){\n    if (isInLoopThread()) {// runInLoopActive\n        cb();\n    }else{  // runInLoop\n        queueInLoop(std::move(cb));\n    }\n}\n\nvoid EventLoop::queueInLoop(Functor cb){\n    {\n        MutexLockGuard lock(mutex_);\n        pendingFunctors_.push_back(std::move(cb));  // \n    }\n\n    if (!isInLoopThread() || callingPendingFunctors_){ \n        // queueInLoop || queueInLoop\n        //epoll_wait\n        wakeup();\n    }\n}\n\nvoid EventLoop::updateChannel(Channel* channel){\n    assert(channel->ownerLoop() == this);\n    assertInLoopThread();\n    poller_->updateChannel(channel);\n}\n\nvoid EventLoop::removeChannel(Channel* channel){\n    assert(channel->ownerLoop() == this);\n    assertInLoopThread();\n    if (eventHandling_){\n        // channelremovechannelchannel\n        assert(currentActiveChannel_ == channel ||\n            std::find(activeChannels_.begin(), activeChannels_.end(), channel) == activeChannels_.end());\n    }\n    poller_->removeChannel(channel);\n}\n// \nvoid EventLoop::wakeup(){\n    uint64_t one = 1;\n    // tickle\n    ssize_t n = sockets::write(wakeupFd_, &one, sizeof one);\n    if (n != sizeof one){\n        LOG_ERROR << \"EventLoop::wakeup() writes \" << n << \" bytes instead of 8\";\n    }\n}\n\nvoid EventLoop::handleRead(){\n    uint64_t one = 1;\n    // tickle \n    ssize_t n = sockets::read(wakeupFd_, &one, sizeof one);\n    if (n != sizeof one){\n        LOG_ERROR << \"EventLoop::handleRead() reads \" << n << \" bytes instead of 8\";\n    }\n}\n\nvoid EventLoop::doPendingFunctors(){\n    std::vector<Functor> functors;\n    callingPendingFunctors_ = true;\n    // \n    {\n        MutexLockGuard lock(mutex_);\n        functors.swap(pendingFunctors_);\n    }\n\n    for (const Functor& functor : functors){\n        functor();\n    }\n    callingPendingFunctors_ = false;\n}\n```\n\n### \n\nEventLooppoller_timerQueue_EventLoopEventLooptimerQueue_poller_MuduotimerQueue_poller_\n\n## EventLoopThread\n\nEventLoopEventLoop::loop()\n\nEventLoopThread\n\n****\n\n```cpp\nclass EventLoopThread : noncopyable{\npublic:\n    typedef std::function<void(EventLoop*)> ThreadInitCallback;\n\n    EventLoopThread(const ThreadInitCallback& cb = ThreadInitCallback(),\n                    const string& name = string());\n    ~EventLoopThread();\n    EventLoop* startLoop();\n\nprivate:\n    void threadFunc();\n\n    EventLoop* loop_ GUARDED_BY(mutex_);  // EventLoop\n    bool exiting_;  // living\n    Thread thread_; // \n    MutexLock mutex_;\n    Condition cond_ GUARDED_BY(mutex_);\n    ThreadInitCallback callback_;\n};\n```\n\nEventLoopEventLoopThread[muduo3](./ThreadAndThreadPool.md)EventLoopThread\n\n1. EventLoopThread::startLoop() ->\n\n2. Thread::start()  -> \n\n3. pthread_create(..., &detail::startThread,...)    -> \n\n4. startThread(void* obj)   ->\n\n5. ThreadData::runInThread()    -> \n\n6. Thread::func_()  ->\n\n7. EventLoopThread::threadFunc()    ->\n\n8. EventLoop::loop()\n\n\n****\n\n```cpp\nEventLoopThread::EventLoopThread(const ThreadInitCallback& cb,\n                                 const string& name)\n  : loop_(NULL),\n    exiting_(false),\n    thread_(std::bind(&EventLoopThread::threadFunc, this), name),\n    mutex_(),\n    cond_(mutex_),\n    callback_(cb){\n}\n\nEventLoopThread::~EventLoopThread(){\n    exiting_ = true;\n    if (loop_ != NULL){ // not 100% race-free, eg. threadFunc could be running callback_.\n        // still a tiny chance to call destructed object, if threadFunc exits just now.\n        // but when EventLoopThread destructs, usually programming is exiting anyway.\n        loop_->quit();\n        thread_.join();\n    }\n}\n\nEventLoop* EventLoopThread::startLoop(){\n    assert(!thread_.started());\n    thread_.start();\n\n    EventLoop* loop = NULL;\n    {\n        MutexLockGuard lock(mutex_);\n        while (loop_ == NULL){  // /\n            cond_.wait();\n        }\n        loop = loop_;\n    }\n\n    return loop;\n}\n\nvoid EventLoopThread::threadFunc(){\n    EventLoop loop;\n\n    if (callback_){\n        callback_(&loop);\n    }\n\n    {\n        MutexLockGuard lock(mutex_);\n        loop_ = &loop;\n        cond_.notify();\n    }\n\n    loop.loop();\n    //assert(exiting_);\n    MutexLockGuard lock(mutex_);\n    loop_ = NULL;\n}\n```\n\n## \n\nMuduoEventLoop file descriptor\n\n1.   EventLoop \n\n2.  Multiplexing EventLoop  selectpollepoll \n\n3.  \n\n**MuduoOne Loop Per Thread**\n\n---\n\n****","source":"_posts/muduo/EvevntLoopAndThread.md","raw":"---\ntitle: muduo6EvevntLoopThread\ndate: 2024-11-02 12:00:00\ntags:\n  - \n---\n\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nMuduoEventLoopThread\n\nExevntLoopThreadOne Loop Per ThreadepollIO **** ********Muduo\n\n## EventLoop\n\n****\n\n<!-- more -->\n```cpp\nclass EventLoop : noncopyable{\npublic:\n    typedef std::function<void()> Functor;\n\n    EventLoop();\n    ~EventLoop();  // force out-line dtor, for std::unique_ptr members.\n\n    ///\n    /// Loops forever.\n    ///\n    /// Must be called in the same thread as creation of the object.\n    ///\n    void loop();\n\n    /// Quits loop.\n    ///\n    /// This is not 100% thread safe, if you call through a raw pointer,\n    /// better to call through shared_ptr<EventLoop> for 100% safety.\n    void quit();\n\n    /// Runs callback immediately in the loop thread.\n    /// It wakes up the loop, and run the cb.\n    /// If in the same loop thread, cb is run within the function.\n    /// Safe to call from other threads.\n    void runInLoop(Functor cb);\n    /// Queues callback in the loop thread.\n    /// Runs after finish pooling.\n    /// Safe to call from other threads.\n    void queueInLoop(Functor cb);\n\n    size_t queueSize() const;\n\n    // timers\n\n    // ...\n\n    // internal usage\n    void wakeup();\n    void updateChannel(Channel* channel);\n    void removeChannel(Channel* channel);\n\n    // pid_t threadId() const { return threadId_; }\n    void assertInLoopThread()\n\n    bool isInLoopThread() const { return threadId_ == CurrentThread::tid(); }\n    // EventLoop\n    static EventLoop* getEventLoopOfCurrentThread();\n\nprivate:\n    void abortNotInLoopThread();\n    void handleRead();  // waked up\n    void doPendingFunctors();\n\n    typedef std::vector<Channel*> ChannelList;\n\n    bool looping_; /* atomic */ // loop()\n    std::atomic<bool> quit_;  // EventLoop\n    bool eventHandling_; /* atomic */ // \n    bool callingPendingFunctors_; /* atomic */  // \n    int64_t iteration_;   // loop()\n    const pid_t threadId_;  // EventLoop\n    Timestamp pollReturnTime_;  // epoll_wait\n    std::unique_ptr<Poller> poller_;  // epoll/poll\n    std::unique_ptr<TimerQueue> timerQueue_;  // \n    int wakeupFd_;  // tickleFdepoll_wait\n    // unlike in TimerQueue, which is an internal class,\n    // we don't expose Channel to client.\n    std::unique_ptr<Channel> wakeupChannel_;  // tickleFdchannel\n    boost::any context_;  // \n\n    // scratch variables\n    ChannelList activeChannels_;   // poller_fdchannel\n    Channel* currentActiveChannel_; // loop()channel\n\n    mutable MutexLock mutex_; // pendingFunctors_\n    std::vector<Functor> pendingFunctors_ GUARDED_BY(mutex_); // \n};\n```\n\nMuduoEventLoopLinuxEventFdwakeupChannel_sylar`EventLoop::wakeup()`sylar`IOManager::tickle()`\n\nMuduoEventLoopMuduoLinuxTimeFdTimerQueuefdChannelChannelEventLoopPoller\n\nEventLoop`EventLoop::loop()`\n\n![loop](./EvevntLoopAndThread/photo/EventLoop.drawio.png)\n\n****\n\n```cpp\n// forEventLoop\n__thread EventLoop* t_loopInThisThread = 0;\n\nEventLoop::EventLoop()\n  : // ...\n    threadId_(CurrentThread::tid()),\n    poller_(Poller::newDefaultPoller(this)),    // epoll\n    timerQueue_(new TimerQueue(this)),      // MuduotimerfdTimerQueuechannelEventLoppPollerfd\n    wakeupFd_(createEventfd()),   // eventfdtickle\n    wakeupChannel_(new Channel(this, wakeupFd_)){ // eventfdchannel\n\n    LOG_DEBUG << \"EventLoop created \" << this << \" in thread \" << threadId_;\n    if (t_loopInThisThread){\n        LOG_FATAL << \"Another EventLoop \" << t_loopInThisThread\n                << \" exists in this thread \" << threadId_;\n    }else{\n        t_loopInThisThread = this;  // \n    }\n    // eventfd\n    wakeupChannel_->setReadCallback(\n        std::bind(&EventLoop::handleRead, this));\n    // we are always reading the wakeupfd\n    wakeupChannel_->enableReading();\n}\n\nEventLoop::~EventLoop(){\n    // \n    LOG_DEBUG << \"EventLoop \" << this << \" of thread \" << threadId_\n            << \" destructs in thread \" << CurrentThread::tid();\n    wakeupChannel_->disableAll();\n    wakeupChannel_->remove();\n    ::close(wakeupFd_);\n    t_loopInThisThread = NULL;\n}\n\nvoid EventLoop::loop(){\n    assert(!looping_);\n    assertInLoopThread(); // \n    looping_ = true;\n    quit_ = false;  // FIXME: what if someone calls quit() before loop() ?\n    LOG_TRACE << \"EventLoop \" << this << \" start looping\";\n\n    while (!quit_){\n        activeChannels_.clear();\n        pollReturnTime_ = poller_->poll(kPollTimeMs, &activeChannels_); // epoll_wait\n        ++iteration_;\n        if (Logger::logLevel() <= Logger::TRACE){\n            printActiveChannels();\n        }\n        // TODO sort channel by priority\n        eventHandling_ = true;  // fd\n        for (Channel* channel : activeChannels_){\n            currentActiveChannel_ = channel;\n            currentActiveChannel_->handleEvent(pollReturnTime_);  // channel\n        }\n        currentActiveChannel_ = NULL;\n        eventHandling_ = false; // fd\n        doPendingFunctors();  // \n    }\n\n    LOG_TRACE << \"EventLoop \" << this << \" stop looping\";\n    looping_ = false;\n}\n\nvoid EventLoop::quit(){\n    quit_ = true;\n    // \n    // There is a chance that loop() just executes while(!quit_) and exits,\n    // then EventLoop destructs, then we are accessing an invalid object.\n    // Can be fixed using mutex_ in both places.\n    if (!isInLoopThread()){  // quitActivewakeup();\n        wakeup();\n    } // quitActive\n}\n\nvoid EventLoop::runInLoop(Functor cb){\n    if (isInLoopThread()) {// runInLoopActive\n        cb();\n    }else{  // runInLoop\n        queueInLoop(std::move(cb));\n    }\n}\n\nvoid EventLoop::queueInLoop(Functor cb){\n    {\n        MutexLockGuard lock(mutex_);\n        pendingFunctors_.push_back(std::move(cb));  // \n    }\n\n    if (!isInLoopThread() || callingPendingFunctors_){ \n        // queueInLoop || queueInLoop\n        //epoll_wait\n        wakeup();\n    }\n}\n\nvoid EventLoop::updateChannel(Channel* channel){\n    assert(channel->ownerLoop() == this);\n    assertInLoopThread();\n    poller_->updateChannel(channel);\n}\n\nvoid EventLoop::removeChannel(Channel* channel){\n    assert(channel->ownerLoop() == this);\n    assertInLoopThread();\n    if (eventHandling_){\n        // channelremovechannelchannel\n        assert(currentActiveChannel_ == channel ||\n            std::find(activeChannels_.begin(), activeChannels_.end(), channel) == activeChannels_.end());\n    }\n    poller_->removeChannel(channel);\n}\n// \nvoid EventLoop::wakeup(){\n    uint64_t one = 1;\n    // tickle\n    ssize_t n = sockets::write(wakeupFd_, &one, sizeof one);\n    if (n != sizeof one){\n        LOG_ERROR << \"EventLoop::wakeup() writes \" << n << \" bytes instead of 8\";\n    }\n}\n\nvoid EventLoop::handleRead(){\n    uint64_t one = 1;\n    // tickle \n    ssize_t n = sockets::read(wakeupFd_, &one, sizeof one);\n    if (n != sizeof one){\n        LOG_ERROR << \"EventLoop::handleRead() reads \" << n << \" bytes instead of 8\";\n    }\n}\n\nvoid EventLoop::doPendingFunctors(){\n    std::vector<Functor> functors;\n    callingPendingFunctors_ = true;\n    // \n    {\n        MutexLockGuard lock(mutex_);\n        functors.swap(pendingFunctors_);\n    }\n\n    for (const Functor& functor : functors){\n        functor();\n    }\n    callingPendingFunctors_ = false;\n}\n```\n\n### \n\nEventLooppoller_timerQueue_EventLoopEventLooptimerQueue_poller_MuduotimerQueue_poller_\n\n## EventLoopThread\n\nEventLoopEventLoop::loop()\n\nEventLoopThread\n\n****\n\n```cpp\nclass EventLoopThread : noncopyable{\npublic:\n    typedef std::function<void(EventLoop*)> ThreadInitCallback;\n\n    EventLoopThread(const ThreadInitCallback& cb = ThreadInitCallback(),\n                    const string& name = string());\n    ~EventLoopThread();\n    EventLoop* startLoop();\n\nprivate:\n    void threadFunc();\n\n    EventLoop* loop_ GUARDED_BY(mutex_);  // EventLoop\n    bool exiting_;  // living\n    Thread thread_; // \n    MutexLock mutex_;\n    Condition cond_ GUARDED_BY(mutex_);\n    ThreadInitCallback callback_;\n};\n```\n\nEventLoopEventLoopThread[muduo3](./ThreadAndThreadPool.md)EventLoopThread\n\n1. EventLoopThread::startLoop() ->\n\n2. Thread::start()  -> \n\n3. pthread_create(..., &detail::startThread,...)    -> \n\n4. startThread(void* obj)   ->\n\n5. ThreadData::runInThread()    -> \n\n6. Thread::func_()  ->\n\n7. EventLoopThread::threadFunc()    ->\n\n8. EventLoop::loop()\n\n\n****\n\n```cpp\nEventLoopThread::EventLoopThread(const ThreadInitCallback& cb,\n                                 const string& name)\n  : loop_(NULL),\n    exiting_(false),\n    thread_(std::bind(&EventLoopThread::threadFunc, this), name),\n    mutex_(),\n    cond_(mutex_),\n    callback_(cb){\n}\n\nEventLoopThread::~EventLoopThread(){\n    exiting_ = true;\n    if (loop_ != NULL){ // not 100% race-free, eg. threadFunc could be running callback_.\n        // still a tiny chance to call destructed object, if threadFunc exits just now.\n        // but when EventLoopThread destructs, usually programming is exiting anyway.\n        loop_->quit();\n        thread_.join();\n    }\n}\n\nEventLoop* EventLoopThread::startLoop(){\n    assert(!thread_.started());\n    thread_.start();\n\n    EventLoop* loop = NULL;\n    {\n        MutexLockGuard lock(mutex_);\n        while (loop_ == NULL){  // /\n            cond_.wait();\n        }\n        loop = loop_;\n    }\n\n    return loop;\n}\n\nvoid EventLoopThread::threadFunc(){\n    EventLoop loop;\n\n    if (callback_){\n        callback_(&loop);\n    }\n\n    {\n        MutexLockGuard lock(mutex_);\n        loop_ = &loop;\n        cond_.notify();\n    }\n\n    loop.loop();\n    //assert(exiting_);\n    MutexLockGuard lock(mutex_);\n    loop_ = NULL;\n}\n```\n\n## \n\nMuduoEventLoop file descriptor\n\n1.   EventLoop \n\n2.  Multiplexing EventLoop  selectpollepoll \n\n3.  \n\n**MuduoOne Loop Per Thread**\n\n---\n\n****","slug":"muduo/EvevntLoopAndThread","published":1,"updated":"2025-09-28T16:06:43.125Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9p000eq8ws2a4bco90","content":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>MuduoEventLoopThread</p>\n<p>ExevntLoopThreadOne Loop Per ThreadepollIO <strong></strong> <strong></strong><strong></strong>Muduo</p>\n<h2 id=\"EventLoop\"><a href=\"#EventLoop\" class=\"headerlink\" title=\"EventLoop\"></a>EventLoop</h2><p><strong></strong></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EventLoop</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>()&gt; Functor;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">EventLoop</span>();</span><br><span class=\"line\">    ~<span class=\"built_in\">EventLoop</span>();  <span class=\"comment\">// force out-line dtor, for std::unique_ptr members.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Loops forever.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the same thread as creation of the object.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Quits loop.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// This is not 100% thread safe, if you call through a raw pointer,</span></span><br><span class=\"line\">    <span class=\"comment\">/// better to call through shared_ptr&lt;EventLoop&gt; for 100% safety.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Runs callback immediately in the loop thread.</span></span><br><span class=\"line\">    <span class=\"comment\">/// It wakes up the loop, and run the cb.</span></span><br><span class=\"line\">    <span class=\"comment\">/// If in the same loop thread, cb is run within the function.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Safe to call from other threads.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">runInLoop</span><span class=\"params\">(Functor cb)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Queues callback in the loop thread.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Runs after finish pooling.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Safe to call from other threads.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">queueInLoop</span><span class=\"params\">(Functor cb)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">queueSize</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// timers</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// internal usage</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wakeup</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateChannel</span><span class=\"params\">(Channel* channel)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeChannel</span><span class=\"params\">(Channel* channel)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// pid_t threadId() const &#123; return threadId_; &#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assertInLoopThread</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"type\">bool</span> <span class=\"title\">isInLoopThread</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> threadId_ == CurrentThread::<span class=\"built_in\">tid</span>(); &#125;</span><br><span class=\"line\">    <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> EventLoop* <span class=\"title\">getEventLoopOfCurrentThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">abortNotInLoopThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// waked up</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">doPendingFunctors</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;Channel*&gt; ChannelList;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> looping_; <span class=\"comment\">/* atomic */</span> <span class=\"comment\">// loop()</span></span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">bool</span>&gt; quit_;  <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> eventHandling_; <span class=\"comment\">/* atomic */</span> <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> callingPendingFunctors_; <span class=\"comment\">/* atomic */</span>  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int64_t</span> iteration_;   <span class=\"comment\">// loop()</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">pid_t</span> threadId_;  <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">    Timestamp pollReturnTime_;  <span class=\"comment\">// epoll_wait</span></span><br><span class=\"line\">    std::unique_ptr&lt;Poller&gt; poller_;  <span class=\"comment\">// epoll/poll</span></span><br><span class=\"line\">    std::unique_ptr&lt;TimerQueue&gt; timerQueue_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> wakeupFd_;  <span class=\"comment\">// tickleFdepoll_wait</span></span><br><span class=\"line\">    <span class=\"comment\">// unlike in TimerQueue, which is an internal class,</span></span><br><span class=\"line\">    <span class=\"comment\">// we don&#x27;t expose Channel to client.</span></span><br><span class=\"line\">    std::unique_ptr&lt;Channel&gt; wakeupChannel_;  <span class=\"comment\">// tickleFdchannel</span></span><br><span class=\"line\">    boost::any context_;  <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// scratch variables</span></span><br><span class=\"line\">    ChannelList activeChannels_;   <span class=\"comment\">// poller_fdchannel</span></span><br><span class=\"line\">    Channel* currentActiveChannel_; <span class=\"comment\">// loop()channel</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_; <span class=\"comment\">// pendingFunctors_</span></span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;Functor&gt; pendingFunctors_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>MuduoEventLoopLinuxEventFdwakeupChannel_sylar<code>EventLoop::wakeup()</code>sylar<code>IOManager::tickle()</code></p>\n<p>MuduoEventLoopMuduoLinuxTimeFdTimerQueuefdChannelChannelEventLoopPoller</p>\n<p>EventLoop<code>EventLoop::loop()</code></p>\n<p><img src=\"/2024/11/02/muduo/EvevntLoopAndThread/photo/EventLoop.drawio.png\" alt=\"loop\"></p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// forEventLoop</span></span><br><span class=\"line\">__thread EventLoop* t_loopInThisThread = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoop::<span class=\"built_in\">EventLoop</span>()</span><br><span class=\"line\">  : <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"built_in\">threadId_</span>(CurrentThread::<span class=\"built_in\">tid</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">poller_</span>(Poller::<span class=\"built_in\">newDefaultPoller</span>(<span class=\"keyword\">this</span>)),    <span class=\"comment\">// epoll</span></span><br><span class=\"line\">    <span class=\"built_in\">timerQueue_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">TimerQueue</span>(<span class=\"keyword\">this</span>)),      <span class=\"comment\">// MuduotimerfdTimerQueuechannelEventLoppPollerfd</span></span><br><span class=\"line\">    <span class=\"built_in\">wakeupFd_</span>(<span class=\"built_in\">createEventfd</span>()),   <span class=\"comment\">// eventfdtickle</span></span><br><span class=\"line\">    <span class=\"built_in\">wakeupChannel_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Channel</span>(<span class=\"keyword\">this</span>, wakeupFd_))&#123; <span class=\"comment\">// eventfdchannel</span></span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;EventLoop created &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; in thread &quot;</span> &lt;&lt; threadId_;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t_loopInThisThread)&#123;</span><br><span class=\"line\">        LOG_FATAL &lt;&lt; <span class=\"string\">&quot;Another EventLoop &quot;</span> &lt;&lt; t_loopInThisThread</span><br><span class=\"line\">                &lt;&lt; <span class=\"string\">&quot; exists in this thread &quot;</span> &lt;&lt; threadId_;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        t_loopInThisThread = <span class=\"keyword\">this</span>;  <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// eventfd</span></span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">setReadCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;EventLoop::handleRead, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    <span class=\"comment\">// we are always reading the wakeupfd</span></span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">enableReading</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoop::~<span class=\"built_in\">EventLoop</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;EventLoop &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; of thread &quot;</span> &lt;&lt; threadId_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot; destructs in thread &quot;</span> &lt;&lt; CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    ::<span class=\"built_in\">close</span>(wakeupFd_);</span><br><span class=\"line\">    t_loopInThisThread = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::loop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!looping_);</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>(); <span class=\"comment\">// </span></span><br><span class=\"line\">    looping_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    quit_ = <span class=\"literal\">false</span>;  <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> what if someone calls quit() before loop() ?</span></span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;EventLoop &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; start looping&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!quit_)&#123;</span><br><span class=\"line\">        activeChannels_.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        pollReturnTime_ = poller_-&gt;<span class=\"built_in\">poll</span>(kPollTimeMs, &amp;activeChannels_); <span class=\"comment\">// epoll_wait</span></span><br><span class=\"line\">        ++iteration_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Logger::<span class=\"built_in\">logLevel</span>() &lt;= Logger::TRACE)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printActiveChannels</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// TODO sort channel by priority</span></span><br><span class=\"line\">        eventHandling_ = <span class=\"literal\">true</span>;  <span class=\"comment\">// fd</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Channel* channel : activeChannels_)&#123;</span><br><span class=\"line\">            currentActiveChannel_ = channel;</span><br><span class=\"line\">            currentActiveChannel_-&gt;<span class=\"built_in\">handleEvent</span>(pollReturnTime_);  <span class=\"comment\">// channel</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentActiveChannel_ = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        eventHandling_ = <span class=\"literal\">false</span>; <span class=\"comment\">// fd</span></span><br><span class=\"line\">        <span class=\"built_in\">doPendingFunctors</span>();  <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;EventLoop &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; stop looping&quot;</span>;</span><br><span class=\"line\">    looping_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::quit</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    quit_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// There is a chance that loop() just executes while(!quit_) and exits,</span></span><br><span class=\"line\">    <span class=\"comment\">// then EventLoop destructs, then we are accessing an invalid object.</span></span><br><span class=\"line\">    <span class=\"comment\">// Can be fixed using mutex_ in both places.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">isInLoopThread</span>())&#123;  <span class=\"comment\">// quitActivewakeup();</span></span><br><span class=\"line\">        <span class=\"built_in\">wakeup</span>();</span><br><span class=\"line\">    &#125; <span class=\"comment\">// quitActive</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::runInLoop</span><span class=\"params\">(Functor cb)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isInLoopThread</span>()) &#123;<span class=\"comment\">// runInLoopActive</span></span><br><span class=\"line\">        <span class=\"built_in\">cb</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  <span class=\"comment\">// runInLoop</span></span><br><span class=\"line\">        <span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">move</span>(cb));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::queueInLoop</span><span class=\"params\">(Functor cb)</span></span>&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        pendingFunctors_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(cb));  <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">isInLoopThread</span>() || callingPendingFunctors_)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// queueInLoop || queueInLoop</span></span><br><span class=\"line\">        <span class=\"comment\">//epoll_wait</span></span><br><span class=\"line\">        <span class=\"built_in\">wakeup</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::updateChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channel-&gt;<span class=\"built_in\">ownerLoop</span>() == <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    poller_-&gt;<span class=\"built_in\">updateChannel</span>(channel);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::removeChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channel-&gt;<span class=\"built_in\">ownerLoop</span>() == <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventHandling_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// channelremovechannelchannel</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(currentActiveChannel_ == channel ||</span><br><span class=\"line\">            std::<span class=\"built_in\">find</span>(activeChannels_.<span class=\"built_in\">begin</span>(), activeChannels_.<span class=\"built_in\">end</span>(), channel) == activeChannels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poller_-&gt;<span class=\"built_in\">removeChannel</span>(channel);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::wakeup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> one = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// tickle</span></span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">write</span>(wakeupFd_, &amp;one, <span class=\"keyword\">sizeof</span> one);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n != <span class=\"keyword\">sizeof</span> one)&#123;</span><br><span class=\"line\">        LOG_ERROR &lt;&lt; <span class=\"string\">&quot;EventLoop::wakeup() writes &quot;</span> &lt;&lt; n &lt;&lt; <span class=\"string\">&quot; bytes instead of 8&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::handleRead</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> one = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// tickle </span></span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">read</span>(wakeupFd_, &amp;one, <span class=\"keyword\">sizeof</span> one);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n != <span class=\"keyword\">sizeof</span> one)&#123;</span><br><span class=\"line\">        LOG_ERROR &lt;&lt; <span class=\"string\">&quot;EventLoop::handleRead() reads &quot;</span> &lt;&lt; n &lt;&lt; <span class=\"string\">&quot; bytes instead of 8&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::doPendingFunctors</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    std::vector&lt;Functor&gt; functors;</span><br><span class=\"line\">    callingPendingFunctors_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        functors.<span class=\"built_in\">swap</span>(pendingFunctors_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Functor&amp; functor : functors)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">functor</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    callingPendingFunctors_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>EventLooppoller_timerQueue_EventLoopEventLooptimerQueue_poller_MuduotimerQueue_poller_</p>\n<h2 id=\"EventLoopThread\"><a href=\"#EventLoopThread\" class=\"headerlink\" title=\"EventLoopThread\"></a>EventLoopThread</h2><p>EventLoopEventLoop::loop()</p>\n<p>EventLoopThread</p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EventLoopThread</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(EventLoop*)&gt; ThreadInitCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">EventLoopThread</span>(<span class=\"type\">const</span> ThreadInitCallback&amp; cb = <span class=\"built_in\">ThreadInitCallback</span>(),</span><br><span class=\"line\">                    <span class=\"type\">const</span> string&amp; name = <span class=\"built_in\">string</span>());</span><br><span class=\"line\">    ~<span class=\"built_in\">EventLoopThread</span>();</span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">startLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">threadFunc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">EventLoop* loop_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> exiting_;  <span class=\"comment\">// living</span></span><br><span class=\"line\">    Thread thread_; <span class=\"comment\">// </span></span><br><span class=\"line\">    MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">Condition cond_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    ThreadInitCallback callback_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>EventLoopEventLoopThread<a href=\"./ThreadAndThreadPool.md\">muduo3</a>EventLoopThread</p>\n<ol>\n<li><p>EventLoopThread::startLoop() -&gt;</p>\n</li>\n<li><p>Thread::start()  -&gt; </p>\n</li>\n<li><p>pthread_create(, &amp;detail::startThread,)    -&gt; </p>\n</li>\n<li><p>startThread(void* obj)   -&gt;</p>\n</li>\n<li><p>ThreadData::runInThread()    -&gt; </p>\n</li>\n<li><p>Thread::func_()  -&gt;</p>\n</li>\n<li><p>EventLoopThread::threadFunc()    -&gt;</p>\n</li>\n<li><p>EventLoop::loop()</p>\n</li>\n</ol>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopThread::<span class=\"built_in\">EventLoopThread</span>(<span class=\"type\">const</span> ThreadInitCallback&amp; cb,</span><br><span class=\"line\">                                 <span class=\"type\">const</span> string&amp; name)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"literal\">NULL</span>),</span><br><span class=\"line\">    <span class=\"built_in\">exiting_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">thread_</span>(std::<span class=\"built_in\">bind</span>(&amp;EventLoopThread::threadFunc, <span class=\"keyword\">this</span>), name),</span><br><span class=\"line\">    <span class=\"built_in\">mutex_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">cond_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">callback_</span>(cb)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoopThread::~<span class=\"built_in\">EventLoopThread</span>()&#123;</span><br><span class=\"line\">    exiting_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loop_ != <span class=\"literal\">NULL</span>)&#123; <span class=\"comment\">// not 100% race-free, eg. threadFunc could be running callback_.</span></span><br><span class=\"line\">        <span class=\"comment\">// still a tiny chance to call destructed object, if threadFunc exits just now.</span></span><br><span class=\"line\">        <span class=\"comment\">// but when EventLoopThread destructs, usually programming is exiting anyway.</span></span><br><span class=\"line\">        loop_-&gt;<span class=\"built_in\">quit</span>();</span><br><span class=\"line\">        thread_.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EventLoop* <span class=\"title\">EventLoopThread::startLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!thread_.<span class=\"built_in\">started</span>());</span><br><span class=\"line\">    thread_.<span class=\"built_in\">start</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (loop_ == <span class=\"literal\">NULL</span>)&#123;  <span class=\"comment\">// /</span></span><br><span class=\"line\">            cond_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        loop = loop_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoopThread::threadFunc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    EventLoop loop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">callback_</span>(&amp;loop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        loop_ = &amp;loop;</span><br><span class=\"line\">        cond_.<span class=\"built_in\">notify</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    loop.<span class=\"built_in\">loop</span>();</span><br><span class=\"line\">    <span class=\"comment\">//assert(exiting_);</span></span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    loop_ = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>MuduoEventLoop file descriptor</p>\n<ol>\n<li><p>  EventLoop </p>\n</li>\n<li><p> Multiplexing EventLoop  selectpollepoll </p>\n</li>\n<li><p> </p>\n</li>\n</ol>\n<p><strong>MuduoOne Loop Per Thread</strong></p>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>MuduoEventLoopThread</p>\n<p>ExevntLoopThreadOne Loop Per ThreadepollIO <strong></strong> <strong></strong><strong></strong>Muduo</p>\n<h2 id=\"EventLoop\"><a href=\"#EventLoop\" class=\"headerlink\" title=\"EventLoop\"></a>EventLoop</h2><p><strong></strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EventLoop</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>()&gt; Functor;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">EventLoop</span>();</span><br><span class=\"line\">    ~<span class=\"built_in\">EventLoop</span>();  <span class=\"comment\">// force out-line dtor, for std::unique_ptr members.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Loops forever.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be called in the same thread as creation of the object.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Quits loop.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// This is not 100% thread safe, if you call through a raw pointer,</span></span><br><span class=\"line\">    <span class=\"comment\">/// better to call through shared_ptr&lt;EventLoop&gt; for 100% safety.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Runs callback immediately in the loop thread.</span></span><br><span class=\"line\">    <span class=\"comment\">/// It wakes up the loop, and run the cb.</span></span><br><span class=\"line\">    <span class=\"comment\">/// If in the same loop thread, cb is run within the function.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Safe to call from other threads.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">runInLoop</span><span class=\"params\">(Functor cb)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Queues callback in the loop thread.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Runs after finish pooling.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Safe to call from other threads.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">queueInLoop</span><span class=\"params\">(Functor cb)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">queueSize</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// timers</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// internal usage</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wakeup</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateChannel</span><span class=\"params\">(Channel* channel)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeChannel</span><span class=\"params\">(Channel* channel)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// pid_t threadId() const &#123; return threadId_; &#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assertInLoopThread</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"type\">bool</span> <span class=\"title\">isInLoopThread</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> threadId_ == CurrentThread::<span class=\"built_in\">tid</span>(); &#125;</span><br><span class=\"line\">    <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> EventLoop* <span class=\"title\">getEventLoopOfCurrentThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">abortNotInLoopThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// waked up</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">doPendingFunctors</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::vector&lt;Channel*&gt; ChannelList;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> looping_; <span class=\"comment\">/* atomic */</span> <span class=\"comment\">// loop()</span></span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">bool</span>&gt; quit_;  <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> eventHandling_; <span class=\"comment\">/* atomic */</span> <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> callingPendingFunctors_; <span class=\"comment\">/* atomic */</span>  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int64_t</span> iteration_;   <span class=\"comment\">// loop()</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">pid_t</span> threadId_;  <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">    Timestamp pollReturnTime_;  <span class=\"comment\">// epoll_wait</span></span><br><span class=\"line\">    std::unique_ptr&lt;Poller&gt; poller_;  <span class=\"comment\">// epoll/poll</span></span><br><span class=\"line\">    std::unique_ptr&lt;TimerQueue&gt; timerQueue_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> wakeupFd_;  <span class=\"comment\">// tickleFdepoll_wait</span></span><br><span class=\"line\">    <span class=\"comment\">// unlike in TimerQueue, which is an internal class,</span></span><br><span class=\"line\">    <span class=\"comment\">// we don&#x27;t expose Channel to client.</span></span><br><span class=\"line\">    std::unique_ptr&lt;Channel&gt; wakeupChannel_;  <span class=\"comment\">// tickleFdchannel</span></span><br><span class=\"line\">    boost::any context_;  <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// scratch variables</span></span><br><span class=\"line\">    ChannelList activeChannels_;   <span class=\"comment\">// poller_fdchannel</span></span><br><span class=\"line\">    Channel* currentActiveChannel_; <span class=\"comment\">// loop()channel</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_; <span class=\"comment\">// pendingFunctors_</span></span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;Functor&gt; pendingFunctors_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>; <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>MuduoEventLoopLinuxEventFdwakeupChannel_sylar<code>EventLoop::wakeup()</code>sylar<code>IOManager::tickle()</code></p>\n<p>MuduoEventLoopMuduoLinuxTimeFdTimerQueuefdChannelChannelEventLoopPoller</p>\n<p>EventLoop<code>EventLoop::loop()</code></p>\n<p><img src=\"/2024/11/02/muduo/EvevntLoopAndThread/photo/EventLoop.drawio.png\" alt=\"loop\"></p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// forEventLoop</span></span><br><span class=\"line\">__thread EventLoop* t_loopInThisThread = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoop::<span class=\"built_in\">EventLoop</span>()</span><br><span class=\"line\">  : <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"built_in\">threadId_</span>(CurrentThread::<span class=\"built_in\">tid</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">poller_</span>(Poller::<span class=\"built_in\">newDefaultPoller</span>(<span class=\"keyword\">this</span>)),    <span class=\"comment\">// epoll</span></span><br><span class=\"line\">    <span class=\"built_in\">timerQueue_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">TimerQueue</span>(<span class=\"keyword\">this</span>)),      <span class=\"comment\">// MuduotimerfdTimerQueuechannelEventLoppPollerfd</span></span><br><span class=\"line\">    <span class=\"built_in\">wakeupFd_</span>(<span class=\"built_in\">createEventfd</span>()),   <span class=\"comment\">// eventfdtickle</span></span><br><span class=\"line\">    <span class=\"built_in\">wakeupChannel_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Channel</span>(<span class=\"keyword\">this</span>, wakeupFd_))&#123; <span class=\"comment\">// eventfdchannel</span></span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;EventLoop created &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; in thread &quot;</span> &lt;&lt; threadId_;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t_loopInThisThread)&#123;</span><br><span class=\"line\">        LOG_FATAL &lt;&lt; <span class=\"string\">&quot;Another EventLoop &quot;</span> &lt;&lt; t_loopInThisThread</span><br><span class=\"line\">                &lt;&lt; <span class=\"string\">&quot; exists in this thread &quot;</span> &lt;&lt; threadId_;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        t_loopInThisThread = <span class=\"keyword\">this</span>;  <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// eventfd</span></span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">setReadCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;EventLoop::handleRead, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    <span class=\"comment\">// we are always reading the wakeupfd</span></span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">enableReading</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoop::~<span class=\"built_in\">EventLoop</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;EventLoop &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; of thread &quot;</span> &lt;&lt; threadId_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot; destructs in thread &quot;</span> &lt;&lt; CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\">    wakeupChannel_-&gt;<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    ::<span class=\"built_in\">close</span>(wakeupFd_);</span><br><span class=\"line\">    t_loopInThisThread = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::loop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!looping_);</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>(); <span class=\"comment\">// </span></span><br><span class=\"line\">    looping_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    quit_ = <span class=\"literal\">false</span>;  <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> what if someone calls quit() before loop() ?</span></span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;EventLoop &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; start looping&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!quit_)&#123;</span><br><span class=\"line\">        activeChannels_.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        pollReturnTime_ = poller_-&gt;<span class=\"built_in\">poll</span>(kPollTimeMs, &amp;activeChannels_); <span class=\"comment\">// epoll_wait</span></span><br><span class=\"line\">        ++iteration_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Logger::<span class=\"built_in\">logLevel</span>() &lt;= Logger::TRACE)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printActiveChannels</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// TODO sort channel by priority</span></span><br><span class=\"line\">        eventHandling_ = <span class=\"literal\">true</span>;  <span class=\"comment\">// fd</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Channel* channel : activeChannels_)&#123;</span><br><span class=\"line\">            currentActiveChannel_ = channel;</span><br><span class=\"line\">            currentActiveChannel_-&gt;<span class=\"built_in\">handleEvent</span>(pollReturnTime_);  <span class=\"comment\">// channel</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentActiveChannel_ = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        eventHandling_ = <span class=\"literal\">false</span>; <span class=\"comment\">// fd</span></span><br><span class=\"line\">        <span class=\"built_in\">doPendingFunctors</span>();  <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;EventLoop &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; <span class=\"string\">&quot; stop looping&quot;</span>;</span><br><span class=\"line\">    looping_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::quit</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    quit_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// There is a chance that loop() just executes while(!quit_) and exits,</span></span><br><span class=\"line\">    <span class=\"comment\">// then EventLoop destructs, then we are accessing an invalid object.</span></span><br><span class=\"line\">    <span class=\"comment\">// Can be fixed using mutex_ in both places.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">isInLoopThread</span>())&#123;  <span class=\"comment\">// quitActivewakeup();</span></span><br><span class=\"line\">        <span class=\"built_in\">wakeup</span>();</span><br><span class=\"line\">    &#125; <span class=\"comment\">// quitActive</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::runInLoop</span><span class=\"params\">(Functor cb)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isInLoopThread</span>()) &#123;<span class=\"comment\">// runInLoopActive</span></span><br><span class=\"line\">        <span class=\"built_in\">cb</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  <span class=\"comment\">// runInLoop</span></span><br><span class=\"line\">        <span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">move</span>(cb));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::queueInLoop</span><span class=\"params\">(Functor cb)</span></span>&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        pendingFunctors_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(cb));  <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">isInLoopThread</span>() || callingPendingFunctors_)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// queueInLoop || queueInLoop</span></span><br><span class=\"line\">        <span class=\"comment\">//epoll_wait</span></span><br><span class=\"line\">        <span class=\"built_in\">wakeup</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::updateChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channel-&gt;<span class=\"built_in\">ownerLoop</span>() == <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    poller_-&gt;<span class=\"built_in\">updateChannel</span>(channel);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::removeChannel</span><span class=\"params\">(Channel* channel)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(channel-&gt;<span class=\"built_in\">ownerLoop</span>() == <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventHandling_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// channelremovechannelchannel</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(currentActiveChannel_ == channel ||</span><br><span class=\"line\">            std::<span class=\"built_in\">find</span>(activeChannels_.<span class=\"built_in\">begin</span>(), activeChannels_.<span class=\"built_in\">end</span>(), channel) == activeChannels_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poller_-&gt;<span class=\"built_in\">removeChannel</span>(channel);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::wakeup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> one = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// tickle</span></span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">write</span>(wakeupFd_, &amp;one, <span class=\"keyword\">sizeof</span> one);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n != <span class=\"keyword\">sizeof</span> one)&#123;</span><br><span class=\"line\">        LOG_ERROR &lt;&lt; <span class=\"string\">&quot;EventLoop::wakeup() writes &quot;</span> &lt;&lt; n &lt;&lt; <span class=\"string\">&quot; bytes instead of 8&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::handleRead</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> one = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// tickle </span></span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">read</span>(wakeupFd_, &amp;one, <span class=\"keyword\">sizeof</span> one);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n != <span class=\"keyword\">sizeof</span> one)&#123;</span><br><span class=\"line\">        LOG_ERROR &lt;&lt; <span class=\"string\">&quot;EventLoop::handleRead() reads &quot;</span> &lt;&lt; n &lt;&lt; <span class=\"string\">&quot; bytes instead of 8&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoop::doPendingFunctors</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    std::vector&lt;Functor&gt; functors;</span><br><span class=\"line\">    callingPendingFunctors_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        functors.<span class=\"built_in\">swap</span>(pendingFunctors_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Functor&amp; functor : functors)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">functor</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    callingPendingFunctors_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>EventLooppoller_timerQueue_EventLoopEventLooptimerQueue_poller_MuduotimerQueue_poller_</p>\n<h2 id=\"EventLoopThread\"><a href=\"#EventLoopThread\" class=\"headerlink\" title=\"EventLoopThread\"></a>EventLoopThread</h2><p>EventLoopEventLoop::loop()</p>\n<p>EventLoopThread</p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EventLoopThread</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(EventLoop*)&gt; ThreadInitCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">EventLoopThread</span>(<span class=\"type\">const</span> ThreadInitCallback&amp; cb = <span class=\"built_in\">ThreadInitCallback</span>(),</span><br><span class=\"line\">                    <span class=\"type\">const</span> string&amp; name = <span class=\"built_in\">string</span>());</span><br><span class=\"line\">    ~<span class=\"built_in\">EventLoopThread</span>();</span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">startLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">threadFunc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">EventLoop* loop_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> exiting_;  <span class=\"comment\">// living</span></span><br><span class=\"line\">    Thread thread_; <span class=\"comment\">// </span></span><br><span class=\"line\">    MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">Condition cond_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    ThreadInitCallback callback_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>EventLoopEventLoopThread<a href=\"./ThreadAndThreadPool.md\">muduo3</a>EventLoopThread</p>\n<ol>\n<li><p>EventLoopThread::startLoop() -&gt;</p>\n</li>\n<li><p>Thread::start()  -&gt; </p>\n</li>\n<li><p>pthread_create(, &amp;detail::startThread,)    -&gt; </p>\n</li>\n<li><p>startThread(void* obj)   -&gt;</p>\n</li>\n<li><p>ThreadData::runInThread()    -&gt; </p>\n</li>\n<li><p>Thread::func_()  -&gt;</p>\n</li>\n<li><p>EventLoopThread::threadFunc()    -&gt;</p>\n</li>\n<li><p>EventLoop::loop()</p>\n</li>\n</ol>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopThread::<span class=\"built_in\">EventLoopThread</span>(<span class=\"type\">const</span> ThreadInitCallback&amp; cb,</span><br><span class=\"line\">                                 <span class=\"type\">const</span> string&amp; name)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"literal\">NULL</span>),</span><br><span class=\"line\">    <span class=\"built_in\">exiting_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">thread_</span>(std::<span class=\"built_in\">bind</span>(&amp;EventLoopThread::threadFunc, <span class=\"keyword\">this</span>), name),</span><br><span class=\"line\">    <span class=\"built_in\">mutex_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">cond_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">callback_</span>(cb)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLoopThread::~<span class=\"built_in\">EventLoopThread</span>()&#123;</span><br><span class=\"line\">    exiting_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loop_ != <span class=\"literal\">NULL</span>)&#123; <span class=\"comment\">// not 100% race-free, eg. threadFunc could be running callback_.</span></span><br><span class=\"line\">        <span class=\"comment\">// still a tiny chance to call destructed object, if threadFunc exits just now.</span></span><br><span class=\"line\">        <span class=\"comment\">// but when EventLoopThread destructs, usually programming is exiting anyway.</span></span><br><span class=\"line\">        loop_-&gt;<span class=\"built_in\">quit</span>();</span><br><span class=\"line\">        thread_.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EventLoop* <span class=\"title\">EventLoopThread::startLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!thread_.<span class=\"built_in\">started</span>());</span><br><span class=\"line\">    thread_.<span class=\"built_in\">start</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (loop_ == <span class=\"literal\">NULL</span>)&#123;  <span class=\"comment\">// /</span></span><br><span class=\"line\">            cond_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        loop = loop_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">EventLoopThread::threadFunc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    EventLoop loop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">callback_</span>(&amp;loop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        loop_ = &amp;loop;</span><br><span class=\"line\">        cond_.<span class=\"built_in\">notify</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    loop.<span class=\"built_in\">loop</span>();</span><br><span class=\"line\">    <span class=\"comment\">//assert(exiting_);</span></span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    loop_ = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>MuduoEventLoop file descriptor</p>\n<ol>\n<li><p>  EventLoop </p>\n</li>\n<li><p> Multiplexing EventLoop  selectpollepoll </p>\n</li>\n<li><p> </p>\n</li>\n</ol>\n<p><strong>MuduoOne Loop Per Thread</strong></p>\n<hr>\n<p><strong></strong></p>"},{"title":"muduo1","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nMuduo[]Muduo\n\n## `Impl::stream_` + \n\n`stream()`LogStream`Impl::stream_`muduo`LogStream``>>`**/**`>>``Impl::stream_`std::cout\n\n\n<!-- more -->\n```cpp\n//\n// CAUTION: do not write:\n//\n// if (good)\n//   LOG_INFO << \"Good news\";\n// else\n//   LOG_WARN << \"Bad news\";\n//\n// this expends to\n//\n// if (good)\n//   if (logging_INFO)\n//     logInfoStream << \"Good news\";\n//   else\n//     logWarnStream << \"Bad news\";\n//\n#define LOG_TRACE if (muduo::Logger::logLevel() <= muduo::Logger::TRACE) \\\n  muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream()\n#define LOG_DEBUG if (muduo::Logger::logLevel() <= muduo::Logger::DEBUG) \\\n  muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream()\n#define LOG_INFO if (muduo::Logger::logLevel() <= muduo::Logger::INFO) \\\n  muduo::Logger(__FILE__, __LINE__).stream()\n#define LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream()\n#define LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream()\n#define LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream()\n#define LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream()\n#define LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream()\n```\n\n`Logger``LogStream`muduoLogger **detail::kSmallBuffer4000byte** \n\n## `Impl::stream_`\n\nmuduoLoggertidlogerrno0\n\n```cpp\nLogger::Impl::Impl(LogLevel level, int savedErrno, const SourceFile& file, int line)\n  : time_(Timestamp::now()),\n    stream_(),\n    level_(level),\n    line_(line),\n    basename_(file)\n{\n  formatTime(); // \n  CurrentThread::tid(); // tid\n  stream_ << T(CurrentThread::tidString(), CurrentThread::tidStringLength()); // tid\n  stream_ << T(LogLevelName[level], 6); //\n  if (savedErrno != 0)  //\n  {\n    stream_ << strerror_tl(savedErrno) << \" (errno=\" << savedErrno << \") \";\n  }\n}\n\n// ...\n\nLogger::Logger(SourceFile file, int line)\n  : impl_(INFO, 0, file, line)\n{\n}\n// ...\n```\n\n## `Impl::stream_` && `Impl::stream_`LogAppender\n\nLogAppenderstd::cout\n\nMuduog_outputCMuduo`g_output`****`Impl::stream_`****g_output`Logger::setOutput()``g_output`Muduo\n\n```cpp\nvoid defaultOutput(const char* msg, int len)\n{\n  // \n  size_t n = fwrite(msg, 1, len, stdout);\n  //FIXME check n\n  (void)n;\n}\n\nvoid defaultFlush()\n{\n  fflush(stdout);\n}\n\n/*\n* \n* typedef void (*OutputFunc)(const char* msg, int len);\n* typedef void (*FlushFunc)();\n*/\nLogger::OutputFunc g_output = defaultOutput;\nLogger::FlushFunc g_flush = defaultFlush;\n\n// ...\n\nvoid Logger::Impl::finish()\n{\n  stream_ << \" - \" << basename_ << ':' << line_ << '\\n';    //Impl::stream_\n}\n\n// ...\n\nLogger::~Logger()\n{\n  impl_.finish();\n  const LogStream::Buffer& buf(stream().buffer());  // Impl::stream_\n  g_output(buf.data(), buf.length());   // Impl::stream_stdout/file/database\n  if (impl_.level_ == FATAL)\n  {\n    g_flush();\n    abort();\n  }\n}\n```\n\n## \n|       LogHeader                    |   LogBody       |   LogTail               |\n|       ----                         |   ----          |   ----                  |\n|       Time ThreadID LogLevel       |   LogMessage    |    - FileName:LineNumber|\n```bash\n20240109 03:21:56.970321Z  3094 INFO  Hello - Logging_test.cc:69\n20240109 03:21:56.970363Z  3094 WARN  World - Logging_test.cc:70\n20240109 03:21:56.970367Z  3094 ERROR Error - Logging_test.cc:71\n```\n\n## \n\n Muduo  Impl \n\n1. \n Impl \n\n2. \nImpl  Muduo  Impl \n\n3. \n Impl \n\n4. \nImpl \n\nmuduo6SourceFile\n\n```cpp\ntemplate<int N>\nSourceFile(const char (&arr)[N])  // \n    : data_(arr),\n    size_(N-1)\n{\n    const char* slash = strrchr(data_, '/'); // builtin function\n    if (slash)\n    {\n    data_ = slash + 1;\n    size_ -= static_cast<int>(data_ - arr);\n    }\n}\n```\n\n---\n\n****","source":"_posts/muduo/SynLogging.md","raw":"---\ntitle: muduo1\ndate: 2024-11-02 12:00:00\ntags:\n  - \n---\n\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nMuduo[]Muduo\n\n## `Impl::stream_` + \n\n`stream()`LogStream`Impl::stream_`muduo`LogStream``>>`**/**`>>``Impl::stream_`std::cout\n\n\n<!-- more -->\n```cpp\n//\n// CAUTION: do not write:\n//\n// if (good)\n//   LOG_INFO << \"Good news\";\n// else\n//   LOG_WARN << \"Bad news\";\n//\n// this expends to\n//\n// if (good)\n//   if (logging_INFO)\n//     logInfoStream << \"Good news\";\n//   else\n//     logWarnStream << \"Bad news\";\n//\n#define LOG_TRACE if (muduo::Logger::logLevel() <= muduo::Logger::TRACE) \\\n  muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream()\n#define LOG_DEBUG if (muduo::Logger::logLevel() <= muduo::Logger::DEBUG) \\\n  muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream()\n#define LOG_INFO if (muduo::Logger::logLevel() <= muduo::Logger::INFO) \\\n  muduo::Logger(__FILE__, __LINE__).stream()\n#define LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream()\n#define LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream()\n#define LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream()\n#define LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream()\n#define LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream()\n```\n\n`Logger``LogStream`muduoLogger **detail::kSmallBuffer4000byte** \n\n## `Impl::stream_`\n\nmuduoLoggertidlogerrno0\n\n```cpp\nLogger::Impl::Impl(LogLevel level, int savedErrno, const SourceFile& file, int line)\n  : time_(Timestamp::now()),\n    stream_(),\n    level_(level),\n    line_(line),\n    basename_(file)\n{\n  formatTime(); // \n  CurrentThread::tid(); // tid\n  stream_ << T(CurrentThread::tidString(), CurrentThread::tidStringLength()); // tid\n  stream_ << T(LogLevelName[level], 6); //\n  if (savedErrno != 0)  //\n  {\n    stream_ << strerror_tl(savedErrno) << \" (errno=\" << savedErrno << \") \";\n  }\n}\n\n// ...\n\nLogger::Logger(SourceFile file, int line)\n  : impl_(INFO, 0, file, line)\n{\n}\n// ...\n```\n\n## `Impl::stream_` && `Impl::stream_`LogAppender\n\nLogAppenderstd::cout\n\nMuduog_outputCMuduo`g_output`****`Impl::stream_`****g_output`Logger::setOutput()``g_output`Muduo\n\n```cpp\nvoid defaultOutput(const char* msg, int len)\n{\n  // \n  size_t n = fwrite(msg, 1, len, stdout);\n  //FIXME check n\n  (void)n;\n}\n\nvoid defaultFlush()\n{\n  fflush(stdout);\n}\n\n/*\n* \n* typedef void (*OutputFunc)(const char* msg, int len);\n* typedef void (*FlushFunc)();\n*/\nLogger::OutputFunc g_output = defaultOutput;\nLogger::FlushFunc g_flush = defaultFlush;\n\n// ...\n\nvoid Logger::Impl::finish()\n{\n  stream_ << \" - \" << basename_ << ':' << line_ << '\\n';    //Impl::stream_\n}\n\n// ...\n\nLogger::~Logger()\n{\n  impl_.finish();\n  const LogStream::Buffer& buf(stream().buffer());  // Impl::stream_\n  g_output(buf.data(), buf.length());   // Impl::stream_stdout/file/database\n  if (impl_.level_ == FATAL)\n  {\n    g_flush();\n    abort();\n  }\n}\n```\n\n## \n|       LogHeader                    |   LogBody       |   LogTail               |\n|       ----                         |   ----          |   ----                  |\n|       Time ThreadID LogLevel       |   LogMessage    |    - FileName:LineNumber|\n```bash\n20240109 03:21:56.970321Z  3094 INFO  Hello - Logging_test.cc:69\n20240109 03:21:56.970363Z  3094 WARN  World - Logging_test.cc:70\n20240109 03:21:56.970367Z  3094 ERROR Error - Logging_test.cc:71\n```\n\n## \n\n Muduo  Impl \n\n1. \n Impl \n\n2. \nImpl  Muduo  Impl \n\n3. \n Impl \n\n4. \nImpl \n\nmuduo6SourceFile\n\n```cpp\ntemplate<int N>\nSourceFile(const char (&arr)[N])  // \n    : data_(arr),\n    size_(N-1)\n{\n    const char* slash = strrchr(data_, '/'); // builtin function\n    if (slash)\n    {\n    data_ = slash + 1;\n    size_ -= static_cast<int>(data_ - arr);\n    }\n}\n```\n\n---\n\n****","slug":"muduo/SynLogging","published":1,"updated":"2025-09-28T16:06:43.130Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9q000gq8wscd9u3po5","content":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>Muduo[]Muduo</p>\n<h2 id=\"Impl-stream--\"><a href=\"#Impl-stream--\" class=\"headerlink\" title=\"Impl::stream_ + \"></a><code>Impl::stream_</code> + </h2><p><code>stream()</code>LogStream<code>Impl::stream_</code>muduo<code>LogStream</code><code>&gt;&gt;</code><strong>&#x2F;</strong><code>&gt;&gt;</code><code>Impl::stream_</code>std::cout</p>\n<p></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// CAUTION: do not write:</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// if (good)</span></span><br><span class=\"line\"><span class=\"comment\">//   LOG_INFO &lt;&lt; &quot;Good news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">// else</span></span><br><span class=\"line\"><span class=\"comment\">//   LOG_WARN &lt;&lt; &quot;Bad news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// this expends to</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// if (good)</span></span><br><span class=\"line\"><span class=\"comment\">//   if (logging_INFO)</span></span><br><span class=\"line\"><span class=\"comment\">//     logInfoStream &lt;&lt; &quot;Good news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">//   else</span></span><br><span class=\"line\"><span class=\"comment\">//     logWarnStream &lt;&lt; &quot;Bad news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_TRACE <span class=\"keyword\">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::TRACE) \\</span></span><br><span class=\"line\"><span class=\"meta\">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_DEBUG <span class=\"keyword\">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::DEBUG) \\</span></span><br><span class=\"line\"><span class=\"meta\">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_INFO <span class=\"keyword\">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::INFO) \\</span></span><br><span class=\"line\"><span class=\"meta\">  muduo::Logger(__FILE__, __LINE__).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream()</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Logger</code><code>LogStream</code>muduoLogger <strong>detail::kSmallBuffer4000byte</strong> </p>\n<h2 id=\"Impl-stream\"><a href=\"#Impl-stream\" class=\"headerlink\" title=\"Impl::stream_\"></a><code>Impl::stream_</code></h2><p>muduoLoggertidlogerrno0</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Logger::Impl::<span class=\"built_in\">Impl</span>(LogLevel level, <span class=\"type\">int</span> savedErrno, <span class=\"type\">const</span> SourceFile&amp; file, <span class=\"type\">int</span> line)</span><br><span class=\"line\">  : <span class=\"built_in\">time_</span>(Timestamp::<span class=\"built_in\">now</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">stream_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">level_</span>(level),</span><br><span class=\"line\">    <span class=\"built_in\">line_</span>(line),</span><br><span class=\"line\">    <span class=\"built_in\">basename_</span>(file)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  formatTime(); <span class=\"comment\">// </span></span><br><span class=\"line\">  CurrentThread::<span class=\"built_in\">tid</span>(); <span class=\"comment\">// tid</span></span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"built_in\">T</span>(CurrentThread::<span class=\"built_in\">tidString</span>(), CurrentThread::<span class=\"built_in\">tidStringLength</span>()); <span class=\"comment\">// tid</span></span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"built_in\">T</span>(LogLevelName[level], <span class=\"number\">6</span>); <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (savedErrno != <span class=\"number\">0</span>)  <span class=\"comment\">//</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    stream_ &lt;&lt; <span class=\"built_in\">strerror_tl</span>(savedErrno) &lt;&lt; <span class=\"string\">&quot; (errno=&quot;</span> &lt;&lt; savedErrno &lt;&lt; <span class=\"string\">&quot;) &quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">Logger::<span class=\"built_in\">Logger</span>(SourceFile file, <span class=\"type\">int</span> line)</span><br><span class=\"line\">  : <span class=\"built_in\">impl_</span>(INFO, <span class=\"number\">0</span>, file, line)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Impl-stream-Impl-stream-LogAppender\"><a href=\"#Impl-stream-Impl-stream-LogAppender\" class=\"headerlink\" title=\"Impl::stream_ &amp;&amp; Impl::stream_LogAppender\"></a><code>Impl::stream_</code> &amp;&amp; <code>Impl::stream_</code>LogAppender</h2><p>LogAppenderstd::cout</p>\n<p>Muduog_outputCMuduo<code>g_output</code><strong></strong><code>Impl::stream_</code><strong></strong>g_output<code>Logger::setOutput()</code><code>g_output</code>Muduo</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">defaultOutput</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* msg, <span class=\"type\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">size_t</span> n = <span class=\"built_in\">fwrite</span>(msg, <span class=\"number\">1</span>, len, stdout);</span><br><span class=\"line\">  <span class=\"comment\">//FIXME check n</span></span><br><span class=\"line\">  (<span class=\"type\">void</span>)n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">defaultFlush</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">fflush</span>(stdout);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* </span></span><br><span class=\"line\"><span class=\"comment\">* typedef void (*OutputFunc)(const char* msg, int len);</span></span><br><span class=\"line\"><span class=\"comment\">* typedef void (*FlushFunc)();</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">Logger::OutputFunc g_output = defaultOutput;</span><br><span class=\"line\">Logger::FlushFunc g_flush = defaultFlush;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> Logger::Impl::<span class=\"built_in\">finish</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"string\">&quot; - &quot;</span> &lt;&lt; basename_ &lt;&lt; <span class=\"string\">&#x27;:&#x27;</span> &lt;&lt; line_ &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;    <span class=\"comment\">//Impl::stream_</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">Logger::~<span class=\"built_in\">Logger</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  impl_.<span class=\"built_in\">finish</span>();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">const</span> LogStream::Buffer&amp; <span class=\"title\">buf</span><span class=\"params\">(stream().buffer())</span></span>;  <span class=\"comment\">// Impl::stream_</span></span><br><span class=\"line\">  <span class=\"built_in\">g_output</span>(buf.<span class=\"built_in\">data</span>(), buf.<span class=\"built_in\">length</span>());   <span class=\"comment\">// Impl::stream_stdout/file/database</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (impl_.level_ == FATAL)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">g_flush</span>();</span><br><span class=\"line\">    <span class=\"built_in\">abort</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><table>\n<thead>\n<tr>\n<th>LogHeader</th>\n<th>LogBody</th>\n<th>LogTail</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Time ThreadID LogLevel</td>\n<td>LogMessage</td>\n<td>- FileName:LineNumber</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20240109 03:21:56.970321Z  3094 INFO  Hello - Logging_test.cc:69</span><br><span class=\"line\">20240109 03:21:56.970363Z  3094 WARN  World - Logging_test.cc:70</span><br><span class=\"line\">20240109 03:21:56.970367Z  3094 ERROR Error - Logging_test.cc:71</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p> Muduo  Impl </p>\n<ol>\n<li><p><br> Impl </p>\n</li>\n<li><p><br>Impl  Muduo  Impl </p>\n</li>\n<li><p><br> Impl </p>\n</li>\n<li><p><br>Impl </p>\n</li>\n</ol>\n<p>muduo6SourceFile</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">int</span> N&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">SourceFile</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> (&amp;arr)[N])</span>  <span class=\"comment\">// </span></span></span><br><span class=\"line\"><span class=\"function\">    : data_(arr),</span></span><br><span class=\"line\"><span class=\"function\">    size_(N<span class=\"number\">-1</span>)</span></span><br><span class=\"line\"><span class=\"function\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* slash = <span class=\"built_in\">strrchr</span>(data_, <span class=\"string\">&#x27;/&#x27;</span>); <span class=\"comment\">// builtin function</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slash)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    data_ = slash + <span class=\"number\">1</span>;</span><br><span class=\"line\">    size_ -= <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(data_ - arr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong></strong></p>\n","excerpt":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>Muduo[]Muduo</p>\n<h2 id=\"Impl-stream--\"><a href=\"#Impl-stream--\" class=\"headerlink\" title=\"Impl::stream_ + \"></a><code>Impl::stream_</code> + </h2><p><code>stream()</code>LogStream<code>Impl::stream_</code>muduo<code>LogStream</code><code>&gt;&gt;</code><strong>&#x2F;</strong><code>&gt;&gt;</code><code>Impl::stream_</code>std::cout</p>\n<p></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// CAUTION: do not write:</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// if (good)</span></span><br><span class=\"line\"><span class=\"comment\">//   LOG_INFO &lt;&lt; &quot;Good news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">// else</span></span><br><span class=\"line\"><span class=\"comment\">//   LOG_WARN &lt;&lt; &quot;Bad news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// this expends to</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// if (good)</span></span><br><span class=\"line\"><span class=\"comment\">//   if (logging_INFO)</span></span><br><span class=\"line\"><span class=\"comment\">//     logInfoStream &lt;&lt; &quot;Good news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">//   else</span></span><br><span class=\"line\"><span class=\"comment\">//     logWarnStream &lt;&lt; &quot;Bad news&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_TRACE <span class=\"keyword\">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::TRACE) \\</span></span><br><span class=\"line\"><span class=\"meta\">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_DEBUG <span class=\"keyword\">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::DEBUG) \\</span></span><br><span class=\"line\"><span class=\"meta\">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_INFO <span class=\"keyword\">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::INFO) \\</span></span><br><span class=\"line\"><span class=\"meta\">  muduo::Logger(__FILE__, __LINE__).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream()</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Logger</code><code>LogStream</code>muduoLogger <strong>detail::kSmallBuffer4000byte</strong> </p>\n<h2 id=\"Impl-stream\"><a href=\"#Impl-stream\" class=\"headerlink\" title=\"Impl::stream_\"></a><code>Impl::stream_</code></h2><p>muduoLoggertidlogerrno0</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Logger::Impl::<span class=\"built_in\">Impl</span>(LogLevel level, <span class=\"type\">int</span> savedErrno, <span class=\"type\">const</span> SourceFile&amp; file, <span class=\"type\">int</span> line)</span><br><span class=\"line\">  : <span class=\"built_in\">time_</span>(Timestamp::<span class=\"built_in\">now</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">stream_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">level_</span>(level),</span><br><span class=\"line\">    <span class=\"built_in\">line_</span>(line),</span><br><span class=\"line\">    <span class=\"built_in\">basename_</span>(file)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  formatTime(); <span class=\"comment\">// </span></span><br><span class=\"line\">  CurrentThread::<span class=\"built_in\">tid</span>(); <span class=\"comment\">// tid</span></span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"built_in\">T</span>(CurrentThread::<span class=\"built_in\">tidString</span>(), CurrentThread::<span class=\"built_in\">tidStringLength</span>()); <span class=\"comment\">// tid</span></span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"built_in\">T</span>(LogLevelName[level], <span class=\"number\">6</span>); <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (savedErrno != <span class=\"number\">0</span>)  <span class=\"comment\">//</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    stream_ &lt;&lt; <span class=\"built_in\">strerror_tl</span>(savedErrno) &lt;&lt; <span class=\"string\">&quot; (errno=&quot;</span> &lt;&lt; savedErrno &lt;&lt; <span class=\"string\">&quot;) &quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">Logger::<span class=\"built_in\">Logger</span>(SourceFile file, <span class=\"type\">int</span> line)</span><br><span class=\"line\">  : <span class=\"built_in\">impl_</span>(INFO, <span class=\"number\">0</span>, file, line)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Impl-stream-Impl-stream-LogAppender\"><a href=\"#Impl-stream-Impl-stream-LogAppender\" class=\"headerlink\" title=\"Impl::stream_ &amp;&amp; Impl::stream_LogAppender\"></a><code>Impl::stream_</code> &amp;&amp; <code>Impl::stream_</code>LogAppender</h2><p>LogAppenderstd::cout</p>\n<p>Muduog_outputCMuduo<code>g_output</code><strong></strong><code>Impl::stream_</code><strong></strong>g_output<code>Logger::setOutput()</code><code>g_output</code>Muduo</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">defaultOutput</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* msg, <span class=\"type\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">size_t</span> n = <span class=\"built_in\">fwrite</span>(msg, <span class=\"number\">1</span>, len, stdout);</span><br><span class=\"line\">  <span class=\"comment\">//FIXME check n</span></span><br><span class=\"line\">  (<span class=\"type\">void</span>)n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">defaultFlush</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">fflush</span>(stdout);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* </span></span><br><span class=\"line\"><span class=\"comment\">* typedef void (*OutputFunc)(const char* msg, int len);</span></span><br><span class=\"line\"><span class=\"comment\">* typedef void (*FlushFunc)();</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">Logger::OutputFunc g_output = defaultOutput;</span><br><span class=\"line\">Logger::FlushFunc g_flush = defaultFlush;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> Logger::Impl::<span class=\"built_in\">finish</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"string\">&quot; - &quot;</span> &lt;&lt; basename_ &lt;&lt; <span class=\"string\">&#x27;:&#x27;</span> &lt;&lt; line_ &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;    <span class=\"comment\">//Impl::stream_</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">Logger::~<span class=\"built_in\">Logger</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  impl_.<span class=\"built_in\">finish</span>();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">const</span> LogStream::Buffer&amp; <span class=\"title\">buf</span><span class=\"params\">(stream().buffer())</span></span>;  <span class=\"comment\">// Impl::stream_</span></span><br><span class=\"line\">  <span class=\"built_in\">g_output</span>(buf.<span class=\"built_in\">data</span>(), buf.<span class=\"built_in\">length</span>());   <span class=\"comment\">// Impl::stream_stdout/file/database</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (impl_.level_ == FATAL)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">g_flush</span>();</span><br><span class=\"line\">    <span class=\"built_in\">abort</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><table>\n<thead>\n<tr>\n<th>LogHeader</th>\n<th>LogBody</th>\n<th>LogTail</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Time ThreadID LogLevel</td>\n<td>LogMessage</td>\n<td>- FileName:LineNumber</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20240109 03:21:56.970321Z  3094 INFO  Hello - Logging_test.cc:69</span><br><span class=\"line\">20240109 03:21:56.970363Z  3094 WARN  World - Logging_test.cc:70</span><br><span class=\"line\">20240109 03:21:56.970367Z  3094 ERROR Error - Logging_test.cc:71</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p> Muduo  Impl </p>\n<ol>\n<li><p><br> Impl </p>\n</li>\n<li><p><br>Impl  Muduo  Impl </p>\n</li>\n<li><p><br> Impl </p>\n</li>\n<li><p><br>Impl </p>\n</li>\n</ol>\n<p>muduo6SourceFile</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">int</span> N&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">SourceFile</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> (&amp;arr)[N])</span>  <span class=\"comment\">// </span></span></span><br><span class=\"line\"><span class=\"function\">    : data_(arr),</span></span><br><span class=\"line\"><span class=\"function\">    size_(N<span class=\"number\">-1</span>)</span></span><br><span class=\"line\"><span class=\"function\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* slash = <span class=\"built_in\">strrchr</span>(data_, <span class=\"string\">&#x27;/&#x27;</span>); <span class=\"comment\">// builtin function</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slash)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    data_ = slash + <span class=\"number\">1</span>;</span><br><span class=\"line\">    size_ -= <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(data_ - arr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong></strong></p>"},{"title":"muduo11TcpClient","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n[muduo11TcpClient](./TcpClient.md)\n\n****\n\n\n\n1. TcpClient.h/ccTcpServerTcpClientTcpClientloopTcpConnectionsockfdTcpConnection\n\n2. Connector.h/ccMuduosockConnectorfdsockfdsockfdTcpClientTcpClientsockfdTcpConnectionConnectorTcpServerAcceptorConnectoripsockfdAcceptorlisten socksockfd\n\nTcpClient****TcpServer\n\n## Connector\n\n****\n\n<!-- more -->\n```cpp\nclass Connector : noncopyable,\n                  public std::enable_shared_from_this<Connector>{\npublic:\n    typedef std::function<void (int sockfd)> NewConnectionCallback;\n\n    Connector(EventLoop* loop, const InetAddress& serverAddr);\n    ~Connector();\n\n    void setNewConnectionCallback(const NewConnectionCallback& cb)\n    { newConnectionCallback_ = cb; }\n\n    void start();  // can be called in any thread\n    void restart();  // must be called in loop thread\n    void stop();  // can be called in any thread\n\n    const InetAddress& serverAddress() const { return serverAddr_; }\n\n    private:\n    enum States { kDisconnected, kConnecting, kConnected };\n    static const int kMaxRetryDelayMs = 30*1000;\n    static const int kInitRetryDelayMs = 500;\n\n    void setState(States s) { state_ = s; }\n    void startInLoop();\n    void stopInLoop();\n    void connect();\n    void connecting(int sockfd);\n    void handleWrite();\n    void handleError();\n    void retry(int sockfd);\n    int removeAndResetChannel();\n    void resetChannel();\n\n    EventLoop* loop_; // loop\n    InetAddress serverAddr_;  // \n    bool connect_; // atomic  // \n    States state_;  // FIXME: use atomic variable // \n    std::unique_ptr<Channel> channel_;  // fdepoll/poll/selectIO\n    NewConnectionCallback newConnectionCallback_; // TcpClient::newConnection\n    int retryDelayMs_;  // \n};\n```\n\n\n\nConnector::start()->\n\n1. connect_  true\n\n2. loopConnector::startInLoop()\n\n    1. Connector::startInLoop()\n\n    2. Connector::connect()\n\n        1. sock\n        \n        2. ::connect(sock, ...)\n        \n        3. Connector::connecting(int sockfd)\n\n            1. new channel(sockfd)channel_Connector::handleWrite()Connector::handleError()cahnnel\n\n            2. Pollersockfd\n\nsockfdConnector::handleWrite()->\n\n1. sockfdchannel_channel_ rest\n\n2. newConnectionCallback_TcpClient::newConnectionsockfdTcpClient\n\nstopretry\n\n****\n\n```cpp\n\nvoid Connector::start(){\n    connect_ = true;\n    loop_->runInLoop(std::bind(&Connector::startInLoop, this)); // FIXME: unsafe\n}\n\nvoid Connector::startInLoop(){\n    loop_->assertInLoopThread();\n    assert(state_ == kDisconnected);\n    if (connect_){\n        connect();\n    }else{\n        LOG_DEBUG << \"do not connect\";\n    }\n}\n\nvoid Connector::stop(){\n    connect_ = false;\n    loop_->queueInLoop(std::bind(&Connector::stopInLoop, this)); // FIXME: unsafe\n    // FIXME: cancel timer\n}\n\nvoid Connector::stopInLoop(){\n    loop_->assertInLoopThread();\n    if (state_ == kConnecting){\n        setState(kDisconnected);\n        int sockfd = removeAndResetChannel();\n        retry(sockfd);\n    }\n}\n\nvoid Connector::connect(){\n    int sockfd = sockets::createNonblockingOrDie(serverAddr_.family());\n    int ret = sockets::connect(sockfd, serverAddr_.getSockAddr());\n    int savedErrno = (ret == 0) ? 0 : errno;\n    switch (savedErrno){\n        case 0:\n        case EINPROGRESS:\n        case EINTR:\n        case EISCONN:\n            connecting(sockfd);\n            break;\n        /*...*/\n    }\n}\n\nvoid Connector::connecting(int sockfd){\n    setState(kConnecting);\n    assert(!channel_);\n    channel_.reset(new Channel(loop_, sockfd));\n    channel_->setWriteCallback(\n        std::bind(&Connector::handleWrite, this)); // FIXME: unsafe\n    channel_->setErrorCallback(\n        std::bind(&Connector::handleError, this)); // FIXME: unsafe\n\n    // channel_->tie(shared_from_this()); is not working,\n    // as channel_ is not managed by shared_ptr\n    channel_->enableWriting();\n}\n\nint Connector::removeAndResetChannel(){\n    channel_->disableAll();\n    channel_->remove();\n    int sockfd = channel_->fd();\n    // Can't reset channel_ here, because we are inside Channel::handleEvent\n    loop_->queueInLoop(std::bind(&Connector::resetChannel, this)); // FIXME: unsafe\n    return sockfd;\n}\n\nvoid Connector::resetChannel(){\n    channel_.reset();\n}\n\nvoid Connector::handleWrite(){\n    LOG_TRACE << \"Connector::handleWrite \" << state_;\n\n    if (state_ == kConnecting){\n        int sockfd = removeAndResetChannel();\n        int err = sockets::getSocketError(sockfd);\n\n        if (err){\n            LOG_WARN << \"Connector::handleWrite - SO_ERROR = \"\n                    << err << \" \" << strerror_tl(err);\n            retry(sockfd);\n        }else{\n            setState(kConnected);\n            if (connect_){\n                newConnectionCallback_(sockfd);\n            }else{\n                sockets::close(sockfd);\n            }\n        }\n    }else{\n        // what happened?\n        assert(state_ == kDisconnected);\n    }\n}\n\nvoid Connector::handleError(){\n    LOG_ERROR << \"Connector::handleError state=\" << state_;\n    if (state_ == kConnecting){\n        int sockfd = removeAndResetChannel();\n        int err = sockets::getSocketError(sockfd);\n        LOG_TRACE << \"SO_ERROR = \" << err << \" \" << strerror_tl(err);\n        retry(sockfd);\n    }\n}\n\nvoid Connector::retry(int sockfd){\n    sockets::close(sockfd);\n    setState(kDisconnected);\n    if (connect_){\n        LOG_INFO << \"Connector::retry - Retry connecting to \" << serverAddr_.toIpPort()\n                    << \" in \" << retryDelayMs_ << \" milliseconds. \";\n        loop_->runAfter(retryDelayMs_/1000.0, // \n                        std::bind(&Connector::startInLoop, shared_from_this()));\n        retryDelayMs_ = std::min(retryDelayMs_ * 2, kMaxRetryDelayMs);  // \n    }else{\n        LOG_DEBUG << \"do not connect\";\n    }\n}\n```\n\n## TcpClient\n\n****\n\n```cpp\nclass TcpClient : noncopyable\n{\npublic:\n    // TcpClient(EventLoop* loop);\n    // TcpClient(EventLoop* loop, const string& host, uint16_t port);\n    TcpClient(EventLoop* loop,\n            const InetAddress& serverAddr,\n            const string& nameArg);\n    ~TcpClient();  // force out-line dtor, for std::unique_ptr members.\n\n    void connect();\n    void disconnect();\n    void stop();\n\n    TcpConnectionPtr connection() const\n    {\n    MutexLockGuard lock(mutex_);\n    return connection_;\n    }\n\n    EventLoop* getLoop() const { return loop_; }\n    bool retry() const { return retry_; }\n    void enableRetry() { retry_ = true; }\n\n    const string& name() const\n    { return name_; }\n\n    /// Set connection callback.\n    /// Not thread safe.\n    void setConnectionCallback(ConnectionCallback cb)\n    { connectionCallback_ = std::move(cb); }\n\n    /// Set message callback.\n    /// Not thread safe.\n    void setMessageCallback(MessageCallback cb)\n    { messageCallback_ = std::move(cb); }\n\n    /// Set write complete callback.\n    /// Not thread safe.\n    void setWriteCompleteCallback(WriteCompleteCallback cb)\n    { writeCompleteCallback_ = std::move(cb); }\n\nprivate:\n    /// Not thread safe, but in loop\n    void newConnection(int sockfd);\n    /// Not thread safe, but in loop\n    void removeConnection(const TcpConnectionPtr& conn);\n\n    EventLoop* loop_; // loop\n    ConnectorPtr connector_; // avoid revealing Connector // \n    const string name_; // TcpClient\n    ConnectionCallback connectionCallback_;   // \n    MessageCallback messageCallback_;   // \n    WriteCompleteCallback writeCompleteCallback_;   // \n    bool retry_;   // atomic  \n    bool connect_; // atomic  // \n    // always in loop thread\n    int nextConnId_;  // \n    mutable MutexLock mutex_;\n    TcpConnectionPtr connection_ GUARDED_BY(mutex_);  // \n};\n```\n\nTcpClientTcpClient::newConnectionsockfdsockfdTcpConnectionfdTcpConnection\n\n****\n\n```cpp\nTcpClient::TcpClient(EventLoop* loop,\n                     const InetAddress& serverAddr,\n                     const string& nameArg)\n  : loop_(CHECK_NOTNULL(loop)),\n    connector_(new Connector(loop, serverAddr)),\n    name_(nameArg),\n    connectionCallback_(defaultConnectionCallback),\n    messageCallback_(defaultMessageCallback),\n    retry_(false),\n    connect_(true),\n    nextConnId_(1){\n    \n    connector_->setNewConnectionCallback(\n        std::bind(&TcpClient::newConnection, this, _1));\n    // FIXME setConnectFailedCallback\n    LOG_INFO << \"TcpClient::TcpClient[\" << name_\n            << \"] - connector \" << get_pointer(connector_);\n}\n\nvoid TcpClient::connect(){\n    // FIXME: check state\n    LOG_INFO << \"TcpClient::connect[\" << name_ << \"] - connecting to \"\n            << connector_->serverAddress().toIpPort();\n    connect_ = true;\n    connector_->start();\n}\n\nvoid TcpClient::disconnect(){\n    connect_ = false;\n\n    {\n        MutexLockGuard lock(mutex_);\n        if (connection_){\n            connection_->shutdown();\n        }\n    }\n}\n\nvoid TcpClient::stop(){\n    connect_ = false;\n    connector_->stop();\n}\n\nvoid TcpClient::newConnection(int sockfd){\n    loop_->assertInLoopThread();\n    InetAddress peerAddr(sockets::getPeerAddr(sockfd));\n    char buf[32];\n    snprintf(buf, sizeof buf, \":%s#%d\", peerAddr.toIpPort().c_str(), nextConnId_);\n    ++nextConnId_;\n    string connName = name_ + buf;\n\n    InetAddress localAddr(sockets::getLocalAddr(sockfd));\n    // FIXME poll with zero timeout to double confirm the new connection\n    // FIXME use make_shared if necessary\n    TcpConnectionPtr conn(new TcpConnection(loop_,\n                                            connName,\n                                            sockfd,\n                                            localAddr,\n                                            peerAddr));\n\n    conn->setConnectionCallback(connectionCallback_);\n    conn->setMessageCallback(messageCallback_);\n    conn->setWriteCompleteCallback(writeCompleteCallback_);\n    conn->setCloseCallback(\n        std::bind(&TcpClient::removeConnection, this, _1)); // FIXME: unsafe\n    {\n        MutexLockGuard lock(mutex_);\n        connection_ = conn;\n    }\n    conn->connectEstablished(); // loop\n}\n\nvoid TcpClient::removeConnection(const TcpConnectionPtr& conn){\n    loop_->assertInLoopThread();\n    assert(loop_ == conn->getLoop());\n\n    {\n        MutexLockGuard lock(mutex_);\n        assert(connection_ == conn);\n        connection_.reset();\n    }\n\n    loop_->queueInLoop(std::bind(&TcpConnection::connectDestroyed, conn));\n    if (retry_ && connect_){\n    LOG_INFO << \"TcpClient::connect[\" << name_ << \"] - Reconnecting to \"\n                << connector_->serverAddress().toIpPort();\n    connector_->restart();\n    }\n}\n```\n\n### \n\n****\n\nTcpConnection::handleClose()closesockfdTcpConnectionTcpConnection::connectDestroyed()closesockfd\n\n****\n\n TcpConnection TcpConnection  Socket Socket  RAII handler close(sockfd_) TcpConnection  /proc/pid/fd/ \n\nhttps://blog.csdn.net/Solstice/article/details/6208634\n\n## \n\nMuduoTcpServerTcpClientitbug","source":"_posts/muduo/TcpClient.md","raw":"---\ntitle: muduo11TcpClient\ndate: 2024-11-02 12:00:00\ntags:\n  - \n---\n\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n[muduo11TcpClient](./TcpClient.md)\n\n****\n\n\n\n1. TcpClient.h/ccTcpServerTcpClientTcpClientloopTcpConnectionsockfdTcpConnection\n\n2. Connector.h/ccMuduosockConnectorfdsockfdsockfdTcpClientTcpClientsockfdTcpConnectionConnectorTcpServerAcceptorConnectoripsockfdAcceptorlisten socksockfd\n\nTcpClient****TcpServer\n\n## Connector\n\n****\n\n<!-- more -->\n```cpp\nclass Connector : noncopyable,\n                  public std::enable_shared_from_this<Connector>{\npublic:\n    typedef std::function<void (int sockfd)> NewConnectionCallback;\n\n    Connector(EventLoop* loop, const InetAddress& serverAddr);\n    ~Connector();\n\n    void setNewConnectionCallback(const NewConnectionCallback& cb)\n    { newConnectionCallback_ = cb; }\n\n    void start();  // can be called in any thread\n    void restart();  // must be called in loop thread\n    void stop();  // can be called in any thread\n\n    const InetAddress& serverAddress() const { return serverAddr_; }\n\n    private:\n    enum States { kDisconnected, kConnecting, kConnected };\n    static const int kMaxRetryDelayMs = 30*1000;\n    static const int kInitRetryDelayMs = 500;\n\n    void setState(States s) { state_ = s; }\n    void startInLoop();\n    void stopInLoop();\n    void connect();\n    void connecting(int sockfd);\n    void handleWrite();\n    void handleError();\n    void retry(int sockfd);\n    int removeAndResetChannel();\n    void resetChannel();\n\n    EventLoop* loop_; // loop\n    InetAddress serverAddr_;  // \n    bool connect_; // atomic  // \n    States state_;  // FIXME: use atomic variable // \n    std::unique_ptr<Channel> channel_;  // fdepoll/poll/selectIO\n    NewConnectionCallback newConnectionCallback_; // TcpClient::newConnection\n    int retryDelayMs_;  // \n};\n```\n\n\n\nConnector::start()->\n\n1. connect_  true\n\n2. loopConnector::startInLoop()\n\n    1. Connector::startInLoop()\n\n    2. Connector::connect()\n\n        1. sock\n        \n        2. ::connect(sock, ...)\n        \n        3. Connector::connecting(int sockfd)\n\n            1. new channel(sockfd)channel_Connector::handleWrite()Connector::handleError()cahnnel\n\n            2. Pollersockfd\n\nsockfdConnector::handleWrite()->\n\n1. sockfdchannel_channel_ rest\n\n2. newConnectionCallback_TcpClient::newConnectionsockfdTcpClient\n\nstopretry\n\n****\n\n```cpp\n\nvoid Connector::start(){\n    connect_ = true;\n    loop_->runInLoop(std::bind(&Connector::startInLoop, this)); // FIXME: unsafe\n}\n\nvoid Connector::startInLoop(){\n    loop_->assertInLoopThread();\n    assert(state_ == kDisconnected);\n    if (connect_){\n        connect();\n    }else{\n        LOG_DEBUG << \"do not connect\";\n    }\n}\n\nvoid Connector::stop(){\n    connect_ = false;\n    loop_->queueInLoop(std::bind(&Connector::stopInLoop, this)); // FIXME: unsafe\n    // FIXME: cancel timer\n}\n\nvoid Connector::stopInLoop(){\n    loop_->assertInLoopThread();\n    if (state_ == kConnecting){\n        setState(kDisconnected);\n        int sockfd = removeAndResetChannel();\n        retry(sockfd);\n    }\n}\n\nvoid Connector::connect(){\n    int sockfd = sockets::createNonblockingOrDie(serverAddr_.family());\n    int ret = sockets::connect(sockfd, serverAddr_.getSockAddr());\n    int savedErrno = (ret == 0) ? 0 : errno;\n    switch (savedErrno){\n        case 0:\n        case EINPROGRESS:\n        case EINTR:\n        case EISCONN:\n            connecting(sockfd);\n            break;\n        /*...*/\n    }\n}\n\nvoid Connector::connecting(int sockfd){\n    setState(kConnecting);\n    assert(!channel_);\n    channel_.reset(new Channel(loop_, sockfd));\n    channel_->setWriteCallback(\n        std::bind(&Connector::handleWrite, this)); // FIXME: unsafe\n    channel_->setErrorCallback(\n        std::bind(&Connector::handleError, this)); // FIXME: unsafe\n\n    // channel_->tie(shared_from_this()); is not working,\n    // as channel_ is not managed by shared_ptr\n    channel_->enableWriting();\n}\n\nint Connector::removeAndResetChannel(){\n    channel_->disableAll();\n    channel_->remove();\n    int sockfd = channel_->fd();\n    // Can't reset channel_ here, because we are inside Channel::handleEvent\n    loop_->queueInLoop(std::bind(&Connector::resetChannel, this)); // FIXME: unsafe\n    return sockfd;\n}\n\nvoid Connector::resetChannel(){\n    channel_.reset();\n}\n\nvoid Connector::handleWrite(){\n    LOG_TRACE << \"Connector::handleWrite \" << state_;\n\n    if (state_ == kConnecting){\n        int sockfd = removeAndResetChannel();\n        int err = sockets::getSocketError(sockfd);\n\n        if (err){\n            LOG_WARN << \"Connector::handleWrite - SO_ERROR = \"\n                    << err << \" \" << strerror_tl(err);\n            retry(sockfd);\n        }else{\n            setState(kConnected);\n            if (connect_){\n                newConnectionCallback_(sockfd);\n            }else{\n                sockets::close(sockfd);\n            }\n        }\n    }else{\n        // what happened?\n        assert(state_ == kDisconnected);\n    }\n}\n\nvoid Connector::handleError(){\n    LOG_ERROR << \"Connector::handleError state=\" << state_;\n    if (state_ == kConnecting){\n        int sockfd = removeAndResetChannel();\n        int err = sockets::getSocketError(sockfd);\n        LOG_TRACE << \"SO_ERROR = \" << err << \" \" << strerror_tl(err);\n        retry(sockfd);\n    }\n}\n\nvoid Connector::retry(int sockfd){\n    sockets::close(sockfd);\n    setState(kDisconnected);\n    if (connect_){\n        LOG_INFO << \"Connector::retry - Retry connecting to \" << serverAddr_.toIpPort()\n                    << \" in \" << retryDelayMs_ << \" milliseconds. \";\n        loop_->runAfter(retryDelayMs_/1000.0, // \n                        std::bind(&Connector::startInLoop, shared_from_this()));\n        retryDelayMs_ = std::min(retryDelayMs_ * 2, kMaxRetryDelayMs);  // \n    }else{\n        LOG_DEBUG << \"do not connect\";\n    }\n}\n```\n\n## TcpClient\n\n****\n\n```cpp\nclass TcpClient : noncopyable\n{\npublic:\n    // TcpClient(EventLoop* loop);\n    // TcpClient(EventLoop* loop, const string& host, uint16_t port);\n    TcpClient(EventLoop* loop,\n            const InetAddress& serverAddr,\n            const string& nameArg);\n    ~TcpClient();  // force out-line dtor, for std::unique_ptr members.\n\n    void connect();\n    void disconnect();\n    void stop();\n\n    TcpConnectionPtr connection() const\n    {\n    MutexLockGuard lock(mutex_);\n    return connection_;\n    }\n\n    EventLoop* getLoop() const { return loop_; }\n    bool retry() const { return retry_; }\n    void enableRetry() { retry_ = true; }\n\n    const string& name() const\n    { return name_; }\n\n    /// Set connection callback.\n    /// Not thread safe.\n    void setConnectionCallback(ConnectionCallback cb)\n    { connectionCallback_ = std::move(cb); }\n\n    /// Set message callback.\n    /// Not thread safe.\n    void setMessageCallback(MessageCallback cb)\n    { messageCallback_ = std::move(cb); }\n\n    /// Set write complete callback.\n    /// Not thread safe.\n    void setWriteCompleteCallback(WriteCompleteCallback cb)\n    { writeCompleteCallback_ = std::move(cb); }\n\nprivate:\n    /// Not thread safe, but in loop\n    void newConnection(int sockfd);\n    /// Not thread safe, but in loop\n    void removeConnection(const TcpConnectionPtr& conn);\n\n    EventLoop* loop_; // loop\n    ConnectorPtr connector_; // avoid revealing Connector // \n    const string name_; // TcpClient\n    ConnectionCallback connectionCallback_;   // \n    MessageCallback messageCallback_;   // \n    WriteCompleteCallback writeCompleteCallback_;   // \n    bool retry_;   // atomic  \n    bool connect_; // atomic  // \n    // always in loop thread\n    int nextConnId_;  // \n    mutable MutexLock mutex_;\n    TcpConnectionPtr connection_ GUARDED_BY(mutex_);  // \n};\n```\n\nTcpClientTcpClient::newConnectionsockfdsockfdTcpConnectionfdTcpConnection\n\n****\n\n```cpp\nTcpClient::TcpClient(EventLoop* loop,\n                     const InetAddress& serverAddr,\n                     const string& nameArg)\n  : loop_(CHECK_NOTNULL(loop)),\n    connector_(new Connector(loop, serverAddr)),\n    name_(nameArg),\n    connectionCallback_(defaultConnectionCallback),\n    messageCallback_(defaultMessageCallback),\n    retry_(false),\n    connect_(true),\n    nextConnId_(1){\n    \n    connector_->setNewConnectionCallback(\n        std::bind(&TcpClient::newConnection, this, _1));\n    // FIXME setConnectFailedCallback\n    LOG_INFO << \"TcpClient::TcpClient[\" << name_\n            << \"] - connector \" << get_pointer(connector_);\n}\n\nvoid TcpClient::connect(){\n    // FIXME: check state\n    LOG_INFO << \"TcpClient::connect[\" << name_ << \"] - connecting to \"\n            << connector_->serverAddress().toIpPort();\n    connect_ = true;\n    connector_->start();\n}\n\nvoid TcpClient::disconnect(){\n    connect_ = false;\n\n    {\n        MutexLockGuard lock(mutex_);\n        if (connection_){\n            connection_->shutdown();\n        }\n    }\n}\n\nvoid TcpClient::stop(){\n    connect_ = false;\n    connector_->stop();\n}\n\nvoid TcpClient::newConnection(int sockfd){\n    loop_->assertInLoopThread();\n    InetAddress peerAddr(sockets::getPeerAddr(sockfd));\n    char buf[32];\n    snprintf(buf, sizeof buf, \":%s#%d\", peerAddr.toIpPort().c_str(), nextConnId_);\n    ++nextConnId_;\n    string connName = name_ + buf;\n\n    InetAddress localAddr(sockets::getLocalAddr(sockfd));\n    // FIXME poll with zero timeout to double confirm the new connection\n    // FIXME use make_shared if necessary\n    TcpConnectionPtr conn(new TcpConnection(loop_,\n                                            connName,\n                                            sockfd,\n                                            localAddr,\n                                            peerAddr));\n\n    conn->setConnectionCallback(connectionCallback_);\n    conn->setMessageCallback(messageCallback_);\n    conn->setWriteCompleteCallback(writeCompleteCallback_);\n    conn->setCloseCallback(\n        std::bind(&TcpClient::removeConnection, this, _1)); // FIXME: unsafe\n    {\n        MutexLockGuard lock(mutex_);\n        connection_ = conn;\n    }\n    conn->connectEstablished(); // loop\n}\n\nvoid TcpClient::removeConnection(const TcpConnectionPtr& conn){\n    loop_->assertInLoopThread();\n    assert(loop_ == conn->getLoop());\n\n    {\n        MutexLockGuard lock(mutex_);\n        assert(connection_ == conn);\n        connection_.reset();\n    }\n\n    loop_->queueInLoop(std::bind(&TcpConnection::connectDestroyed, conn));\n    if (retry_ && connect_){\n    LOG_INFO << \"TcpClient::connect[\" << name_ << \"] - Reconnecting to \"\n                << connector_->serverAddress().toIpPort();\n    connector_->restart();\n    }\n}\n```\n\n### \n\n****\n\nTcpConnection::handleClose()closesockfdTcpConnectionTcpConnection::connectDestroyed()closesockfd\n\n****\n\n TcpConnection TcpConnection  Socket Socket  RAII handler close(sockfd_) TcpConnection  /proc/pid/fd/ \n\nhttps://blog.csdn.net/Solstice/article/details/6208634\n\n## \n\nMuduoTcpServerTcpClientitbug","slug":"muduo/TcpClient","published":1,"updated":"2025-09-28T16:06:43.130Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9q000iq8ws6f7reaee","content":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><a href=\"./TcpClient.md\">muduo11TcpClient</a></p>\n<p><strong></strong></p>\n<p></p>\n<ol>\n<li><p>TcpClient.h&#x2F;ccTcpServerTcpClientTcpClientloopTcpConnectionsockfdTcpConnection</p>\n</li>\n<li><p>Connector.h&#x2F;ccMuduosockConnectorfdsockfdsockfdTcpClientTcpClientsockfdTcpConnectionConnectorTcpServerAcceptorConnectoripsockfdAcceptorlisten socksockfd</p>\n</li>\n</ol>\n<p>TcpClient<strong></strong>TcpServer</p>\n<h2 id=\"Connector\"><a href=\"#Connector\" class=\"headerlink\" title=\"Connector\"></a>Connector</h2><p><strong></strong></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Connector</span> : noncopyable,</span><br><span class=\"line\">                  <span class=\"keyword\">public</span> std::enable_shared_from_this&lt;Connector&gt;&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> (<span class=\"type\">int</span> sockfd)&gt; NewConnectionCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Connector</span>(EventLoop* loop, <span class=\"type\">const</span> InetAddress&amp; serverAddr);</span><br><span class=\"line\">    ~<span class=\"built_in\">Connector</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setNewConnectionCallback</span><span class=\"params\">(<span class=\"type\">const</span> NewConnectionCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; newConnectionCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// can be called in any thread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">restart</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// must be called in loop thread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// can be called in any thread</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> InetAddress&amp; <span class=\"title\">serverAddress</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> serverAddr_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"title class_\">States</span> &#123; kDisconnected, kConnecting, kConnected &#125;;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kMaxRetryDelayMs = <span class=\"number\">30</span>*<span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kInitRetryDelayMs = <span class=\"number\">500</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setState</span><span class=\"params\">(States s)</span> </span>&#123; state_ = s; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">startInLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stopInLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">connect</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">connecting</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleWrite</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleError</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">retry</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeAndResetChannel</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">resetChannel</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// loop</span></span><br><span class=\"line\">    InetAddress serverAddr_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> connect_; <span class=\"comment\">// atomic  // </span></span><br><span class=\"line\">    States state_;  <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use atomic variable // </span></span><br><span class=\"line\">    std::unique_ptr&lt;Channel&gt; channel_;  <span class=\"comment\">// fdepoll/poll/selectIO</span></span><br><span class=\"line\">    NewConnectionCallback newConnectionCallback_; <span class=\"comment\">// TcpClient::newConnection</span></span><br><span class=\"line\">    <span class=\"type\">int</span> retryDelayMs_;  <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p>Connector::start()-&gt;</p>\n<ol>\n<li><p>connect_  true</p>\n</li>\n<li><p>loopConnector::startInLoop()</p>\n<ol>\n<li><p>Connector::startInLoop()</p>\n</li>\n<li><p>Connector::connect()</p>\n<ol>\n<li><p>sock</p>\n</li>\n<li><p>::connect(sock, )</p>\n</li>\n<li><p>Connector::connecting(int sockfd)</p>\n<ol>\n<li><p>new channel(sockfd)channel_Connector::handleWrite()Connector::handleError()cahnnel</p>\n</li>\n<li><p>Pollersockfd</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>sockfdConnector::handleWrite()-&gt;</p>\n<ol>\n<li><p>sockfdchannel_channel_ rest</p>\n</li>\n<li><p>newConnectionCallback_TcpClient::newConnectionsockfdTcpClient</p>\n</li>\n</ol>\n<p>stopretry</p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;Connector::startInLoop, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::startInLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(state_ == kDisconnected);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">connect</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;do not connect&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::stop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;Connector::stopInLoop, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> cancel timer</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::stopInLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnecting)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = <span class=\"built_in\">removeAndResetChannel</span>();</span><br><span class=\"line\">        <span class=\"built_in\">retry</span>(sockfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::connect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> sockfd = sockets::<span class=\"built_in\">createNonblockingOrDie</span>(serverAddr_.<span class=\"built_in\">family</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = sockets::<span class=\"built_in\">connect</span>(sockfd, serverAddr_.<span class=\"built_in\">getSockAddr</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> savedErrno = (ret == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : errno;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (savedErrno)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EINPROGRESS:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EINTR:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EISCONN:</span><br><span class=\"line\">            <span class=\"built_in\">connecting</span>(sockfd);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::connecting</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kConnecting);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!channel_);</span><br><span class=\"line\">    channel_.<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Channel</span>(loop_, sockfd));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setWriteCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Connector::handleWrite, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setErrorCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Connector::handleError, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// channel_-&gt;tie(shared_from_this()); is not working,</span></span><br><span class=\"line\">    <span class=\"comment\">// as channel_ is not managed by shared_ptr</span></span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">enableWriting</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Connector::removeAndResetChannel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> sockfd = channel_-&gt;<span class=\"built_in\">fd</span>();</span><br><span class=\"line\">    <span class=\"comment\">// Can&#x27;t reset channel_ here, because we are inside Channel::handleEvent</span></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;Connector::resetChannel, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sockfd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::resetChannel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    channel_.<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::handleWrite</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;Connector::handleWrite &quot;</span> &lt;&lt; state_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnecting)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = <span class=\"built_in\">removeAndResetChannel</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> err = sockets::<span class=\"built_in\">getSocketError</span>(sockfd);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err)&#123;</span><br><span class=\"line\">            LOG_WARN &lt;&lt; <span class=\"string\">&quot;Connector::handleWrite - SO_ERROR = &quot;</span></span><br><span class=\"line\">                    &lt;&lt; err &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; <span class=\"built_in\">strerror_tl</span>(err);</span><br><span class=\"line\">            <span class=\"built_in\">retry</span>(sockfd);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">setState</span>(kConnected);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (connect_)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">newConnectionCallback_</span>(sockfd);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                sockets::<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// what happened?</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(state_ == kDisconnected);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::handleError</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    LOG_ERROR &lt;&lt; <span class=\"string\">&quot;Connector::handleError state=&quot;</span> &lt;&lt; state_;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnecting)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = <span class=\"built_in\">removeAndResetChannel</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> err = sockets::<span class=\"built_in\">getSocketError</span>(sockfd);</span><br><span class=\"line\">        LOG_TRACE &lt;&lt; <span class=\"string\">&quot;SO_ERROR = &quot;</span> &lt;&lt; err &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; <span class=\"built_in\">strerror_tl</span>(err);</span><br><span class=\"line\">        <span class=\"built_in\">retry</span>(sockfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::retry</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>&#123;</span><br><span class=\"line\">    sockets::<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect_)&#123;</span><br><span class=\"line\">        LOG_INFO &lt;&lt; <span class=\"string\">&quot;Connector::retry - Retry connecting to &quot;</span> &lt;&lt; serverAddr_.<span class=\"built_in\">toIpPort</span>()</span><br><span class=\"line\">                    &lt;&lt; <span class=\"string\">&quot; in &quot;</span> &lt;&lt; retryDelayMs_ &lt;&lt; <span class=\"string\">&quot; milliseconds. &quot;</span>;</span><br><span class=\"line\">        loop_-&gt;<span class=\"built_in\">runAfter</span>(retryDelayMs_/<span class=\"number\">1000.0</span>, <span class=\"comment\">// </span></span><br><span class=\"line\">                        std::<span class=\"built_in\">bind</span>(&amp;Connector::startInLoop, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">        retryDelayMs_ = std::<span class=\"built_in\">min</span>(retryDelayMs_ * <span class=\"number\">2</span>, kMaxRetryDelayMs);  <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;do not connect&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"TcpClient\"><a href=\"#TcpClient\" class=\"headerlink\" title=\"TcpClient\"></a>TcpClient</h2><p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TcpClient</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// TcpClient(EventLoop* loop);</span></span><br><span class=\"line\">    <span class=\"comment\">// TcpClient(EventLoop* loop, const string&amp; host, uint16_t port);</span></span><br><span class=\"line\">    <span class=\"built_in\">TcpClient</span>(EventLoop* loop,</span><br><span class=\"line\">            <span class=\"type\">const</span> InetAddress&amp; serverAddr,</span><br><span class=\"line\">            <span class=\"type\">const</span> string&amp; nameArg);</span><br><span class=\"line\">    ~<span class=\"built_in\">TcpClient</span>();  <span class=\"comment\">// force out-line dtor, for std::unique_ptr members.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">connect</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disconnect</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">connection</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> connection_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getLoop</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> loop_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">retry</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> retry_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enableRetry</span><span class=\"params\">()</span> </span>&#123; retry_ = <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set connection callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setConnectionCallback</span><span class=\"params\">(ConnectionCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; connectionCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set message callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setMessageCallback</span><span class=\"params\">(MessageCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; messageCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set write complete callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWriteCompleteCallback</span><span class=\"params\">(WriteCompleteCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; writeCompleteCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// loop</span></span><br><span class=\"line\">    ConnectorPtr connector_; <span class=\"comment\">// avoid revealing Connector // </span></span><br><span class=\"line\">    <span class=\"type\">const</span> string name_; <span class=\"comment\">// TcpClient</span></span><br><span class=\"line\">    ConnectionCallback connectionCallback_;   <span class=\"comment\">// </span></span><br><span class=\"line\">    MessageCallback messageCallback_;   <span class=\"comment\">// </span></span><br><span class=\"line\">    WriteCompleteCallback writeCompleteCallback_;   <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> retry_;   <span class=\"comment\">// atomic  </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> connect_; <span class=\"comment\">// atomic  // </span></span><br><span class=\"line\">    <span class=\"comment\">// always in loop thread</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nextConnId_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr connection_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>TcpClientTcpClient::newConnectionsockfdsockfdTcpConnectionfdTcpConnection</p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TcpClient::<span class=\"built_in\">TcpClient</span>(EventLoop* loop,</span><br><span class=\"line\">                     <span class=\"type\">const</span> InetAddress&amp; serverAddr,</span><br><span class=\"line\">                     <span class=\"type\">const</span> string&amp; nameArg)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"built_in\">CHECK_NOTNULL</span>(loop)),</span><br><span class=\"line\">    <span class=\"built_in\">connector_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Connector</span>(loop, serverAddr)),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(defaultConnectionCallback),</span><br><span class=\"line\">    <span class=\"built_in\">messageCallback_</span>(defaultMessageCallback),</span><br><span class=\"line\">    <span class=\"built_in\">retry_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">connect_</span>(<span class=\"literal\">true</span>),</span><br><span class=\"line\">    <span class=\"built_in\">nextConnId_</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">setNewConnectionCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpClient::newConnection, <span class=\"keyword\">this</span>, _1));</span><br><span class=\"line\">    <span class=\"comment\">// FIXME setConnectFailedCallback</span></span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpClient::TcpClient[&quot;</span> &lt;&lt; name_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] - connector &quot;</span> &lt;&lt; <span class=\"built_in\">get_pointer</span>(connector_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::connect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> check state</span></span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpClient::connect[&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;] - connecting to &quot;</span></span><br><span class=\"line\">            &lt;&lt; connector_-&gt;<span class=\"built_in\">serverAddress</span>().<span class=\"built_in\">toIpPort</span>();</span><br><span class=\"line\">    connect_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">start</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::disconnect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection_)&#123;</span><br><span class=\"line\">            connection_-&gt;<span class=\"built_in\">shutdown</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::stop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">stop</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"function\">InetAddress <span class=\"title\">peerAddr</span><span class=\"params\">(sockets::getPeerAddr(sockfd))</span></span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;:%s#%d&quot;</span>, peerAddr.<span class=\"built_in\">toIpPort</span>().<span class=\"built_in\">c_str</span>(), nextConnId_);</span><br><span class=\"line\">    ++nextConnId_;</span><br><span class=\"line\">    string connName = name_ + buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">InetAddress <span class=\"title\">localAddr</span><span class=\"params\">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class=\"line\">    <span class=\"comment\">// FIXME use make_shared if necessary</span></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">conn</span><span class=\"params\">(<span class=\"keyword\">new</span> TcpConnection(loop_,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            connName,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            sockfd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            localAddr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            peerAddr))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setConnectionCallback</span>(connectionCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setMessageCallback</span>(messageCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setCloseCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpClient::removeConnection, <span class=\"keyword\">this</span>, _1)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        connection_ = conn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">connectEstablished</span>(); <span class=\"comment\">// loop</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(loop_ == conn-&gt;<span class=\"built_in\">getLoop</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(connection_ == conn);</span><br><span class=\"line\">        connection_.<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retry_ &amp;&amp; connect_)&#123;</span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpClient::connect[&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;] - Reconnecting to &quot;</span></span><br><span class=\"line\">                &lt;&lt; connector_-&gt;<span class=\"built_in\">serverAddress</span>().<span class=\"built_in\">toIpPort</span>();</span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">restart</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p><strong></strong></p>\n<p>TcpConnection::handleClose()closesockfdTcpConnectionTcpConnection::connectDestroyed()closesockfd</p>\n<p><strong></strong></p>\n<p> TcpConnection TcpConnection  Socket Socket  RAII handler close(sockfd_) TcpConnection  &#x2F;proc&#x2F;pid&#x2F;fd&#x2F; </p>\n<p><a href=\"https://blog.csdn.net/Solstice/article/details/6208634\">https://blog.csdn.net/Solstice/article/details/6208634</a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>MuduoTcpServerTcpClientitbug</p>\n","excerpt":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><a href=\"./TcpClient.md\">muduo11TcpClient</a></p>\n<p><strong></strong></p>\n<p></p>\n<ol>\n<li><p>TcpClient.h&#x2F;ccTcpServerTcpClientTcpClientloopTcpConnectionsockfdTcpConnection</p>\n</li>\n<li><p>Connector.h&#x2F;ccMuduosockConnectorfdsockfdsockfdTcpClientTcpClientsockfdTcpConnectionConnectorTcpServerAcceptorConnectoripsockfdAcceptorlisten socksockfd</p>\n</li>\n</ol>\n<p>TcpClient<strong></strong>TcpServer</p>\n<h2 id=\"Connector\"><a href=\"#Connector\" class=\"headerlink\" title=\"Connector\"></a>Connector</h2><p><strong></strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Connector</span> : noncopyable,</span><br><span class=\"line\">                  <span class=\"keyword\">public</span> std::enable_shared_from_this&lt;Connector&gt;&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> (<span class=\"type\">int</span> sockfd)&gt; NewConnectionCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Connector</span>(EventLoop* loop, <span class=\"type\">const</span> InetAddress&amp; serverAddr);</span><br><span class=\"line\">    ~<span class=\"built_in\">Connector</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setNewConnectionCallback</span><span class=\"params\">(<span class=\"type\">const</span> NewConnectionCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; newConnectionCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// can be called in any thread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">restart</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// must be called in loop thread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>;  <span class=\"comment\">// can be called in any thread</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> InetAddress&amp; <span class=\"title\">serverAddress</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> serverAddr_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"title class_\">States</span> &#123; kDisconnected, kConnecting, kConnected &#125;;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kMaxRetryDelayMs = <span class=\"number\">30</span>*<span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kInitRetryDelayMs = <span class=\"number\">500</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setState</span><span class=\"params\">(States s)</span> </span>&#123; state_ = s; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">startInLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stopInLoop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">connect</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">connecting</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleWrite</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleError</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">retry</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeAndResetChannel</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">resetChannel</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// loop</span></span><br><span class=\"line\">    InetAddress serverAddr_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> connect_; <span class=\"comment\">// atomic  // </span></span><br><span class=\"line\">    States state_;  <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use atomic variable // </span></span><br><span class=\"line\">    std::unique_ptr&lt;Channel&gt; channel_;  <span class=\"comment\">// fdepoll/poll/selectIO</span></span><br><span class=\"line\">    NewConnectionCallback newConnectionCallback_; <span class=\"comment\">// TcpClient::newConnection</span></span><br><span class=\"line\">    <span class=\"type\">int</span> retryDelayMs_;  <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p>Connector::start()-&gt;</p>\n<ol>\n<li><p>connect_  true</p>\n</li>\n<li><p>loopConnector::startInLoop()</p>\n<ol>\n<li><p>Connector::startInLoop()</p>\n</li>\n<li><p>Connector::connect()</p>\n<ol>\n<li><p>sock</p>\n</li>\n<li><p>::connect(sock, )</p>\n</li>\n<li><p>Connector::connecting(int sockfd)</p>\n<ol>\n<li><p>new channel(sockfd)channel_Connector::handleWrite()Connector::handleError()cahnnel</p>\n</li>\n<li><p>Pollersockfd</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>sockfdConnector::handleWrite()-&gt;</p>\n<ol>\n<li><p>sockfdchannel_channel_ rest</p>\n</li>\n<li><p>newConnectionCallback_TcpClient::newConnectionsockfdTcpClient</p>\n</li>\n</ol>\n<p>stopretry</p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;Connector::startInLoop, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::startInLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(state_ == kDisconnected);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">connect</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;do not connect&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::stop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;Connector::stopInLoop, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> cancel timer</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::stopInLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnecting)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = <span class=\"built_in\">removeAndResetChannel</span>();</span><br><span class=\"line\">        <span class=\"built_in\">retry</span>(sockfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::connect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> sockfd = sockets::<span class=\"built_in\">createNonblockingOrDie</span>(serverAddr_.<span class=\"built_in\">family</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = sockets::<span class=\"built_in\">connect</span>(sockfd, serverAddr_.<span class=\"built_in\">getSockAddr</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> savedErrno = (ret == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : errno;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (savedErrno)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EINPROGRESS:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EINTR:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EISCONN:</span><br><span class=\"line\">            <span class=\"built_in\">connecting</span>(sockfd);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::connecting</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kConnecting);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!channel_);</span><br><span class=\"line\">    channel_.<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Channel</span>(loop_, sockfd));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setWriteCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Connector::handleWrite, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setErrorCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Connector::handleError, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// channel_-&gt;tie(shared_from_this()); is not working,</span></span><br><span class=\"line\">    <span class=\"comment\">// as channel_ is not managed by shared_ptr</span></span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">enableWriting</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Connector::removeAndResetChannel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> sockfd = channel_-&gt;<span class=\"built_in\">fd</span>();</span><br><span class=\"line\">    <span class=\"comment\">// Can&#x27;t reset channel_ here, because we are inside Channel::handleEvent</span></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;Connector::resetChannel, <span class=\"keyword\">this</span>)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sockfd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::resetChannel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    channel_.<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::handleWrite</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;Connector::handleWrite &quot;</span> &lt;&lt; state_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnecting)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = <span class=\"built_in\">removeAndResetChannel</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> err = sockets::<span class=\"built_in\">getSocketError</span>(sockfd);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err)&#123;</span><br><span class=\"line\">            LOG_WARN &lt;&lt; <span class=\"string\">&quot;Connector::handleWrite - SO_ERROR = &quot;</span></span><br><span class=\"line\">                    &lt;&lt; err &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; <span class=\"built_in\">strerror_tl</span>(err);</span><br><span class=\"line\">            <span class=\"built_in\">retry</span>(sockfd);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">setState</span>(kConnected);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (connect_)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">newConnectionCallback_</span>(sockfd);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                sockets::<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// what happened?</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(state_ == kDisconnected);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::handleError</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    LOG_ERROR &lt;&lt; <span class=\"string\">&quot;Connector::handleError state=&quot;</span> &lt;&lt; state_;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnecting)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = <span class=\"built_in\">removeAndResetChannel</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> err = sockets::<span class=\"built_in\">getSocketError</span>(sockfd);</span><br><span class=\"line\">        LOG_TRACE &lt;&lt; <span class=\"string\">&quot;SO_ERROR = &quot;</span> &lt;&lt; err &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; <span class=\"built_in\">strerror_tl</span>(err);</span><br><span class=\"line\">        <span class=\"built_in\">retry</span>(sockfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Connector::retry</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>&#123;</span><br><span class=\"line\">    sockets::<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect_)&#123;</span><br><span class=\"line\">        LOG_INFO &lt;&lt; <span class=\"string\">&quot;Connector::retry - Retry connecting to &quot;</span> &lt;&lt; serverAddr_.<span class=\"built_in\">toIpPort</span>()</span><br><span class=\"line\">                    &lt;&lt; <span class=\"string\">&quot; in &quot;</span> &lt;&lt; retryDelayMs_ &lt;&lt; <span class=\"string\">&quot; milliseconds. &quot;</span>;</span><br><span class=\"line\">        loop_-&gt;<span class=\"built_in\">runAfter</span>(retryDelayMs_/<span class=\"number\">1000.0</span>, <span class=\"comment\">// </span></span><br><span class=\"line\">                        std::<span class=\"built_in\">bind</span>(&amp;Connector::startInLoop, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">        retryDelayMs_ = std::<span class=\"built_in\">min</span>(retryDelayMs_ * <span class=\"number\">2</span>, kMaxRetryDelayMs);  <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;do not connect&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"TcpClient\"><a href=\"#TcpClient\" class=\"headerlink\" title=\"TcpClient\"></a>TcpClient</h2><p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TcpClient</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// TcpClient(EventLoop* loop);</span></span><br><span class=\"line\">    <span class=\"comment\">// TcpClient(EventLoop* loop, const string&amp; host, uint16_t port);</span></span><br><span class=\"line\">    <span class=\"built_in\">TcpClient</span>(EventLoop* loop,</span><br><span class=\"line\">            <span class=\"type\">const</span> InetAddress&amp; serverAddr,</span><br><span class=\"line\">            <span class=\"type\">const</span> string&amp; nameArg);</span><br><span class=\"line\">    ~<span class=\"built_in\">TcpClient</span>();  <span class=\"comment\">// force out-line dtor, for std::unique_ptr members.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">connect</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">disconnect</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">connection</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> connection_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getLoop</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> loop_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">retry</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> retry_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enableRetry</span><span class=\"params\">()</span> </span>&#123; retry_ = <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set connection callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setConnectionCallback</span><span class=\"params\">(ConnectionCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; connectionCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set message callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setMessageCallback</span><span class=\"params\">(MessageCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; messageCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set write complete callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWriteCompleteCallback</span><span class=\"params\">(WriteCompleteCallback cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; writeCompleteCallback_ = std::<span class=\"built_in\">move</span>(cb); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// loop</span></span><br><span class=\"line\">    ConnectorPtr connector_; <span class=\"comment\">// avoid revealing Connector // </span></span><br><span class=\"line\">    <span class=\"type\">const</span> string name_; <span class=\"comment\">// TcpClient</span></span><br><span class=\"line\">    ConnectionCallback connectionCallback_;   <span class=\"comment\">// </span></span><br><span class=\"line\">    MessageCallback messageCallback_;   <span class=\"comment\">// </span></span><br><span class=\"line\">    WriteCompleteCallback writeCompleteCallback_;   <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> retry_;   <span class=\"comment\">// atomic  </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> connect_; <span class=\"comment\">// atomic  // </span></span><br><span class=\"line\">    <span class=\"comment\">// always in loop thread</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nextConnId_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr connection_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;  <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>TcpClientTcpClient::newConnectionsockfdsockfdTcpConnectionfdTcpConnection</p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TcpClient::<span class=\"built_in\">TcpClient</span>(EventLoop* loop,</span><br><span class=\"line\">                     <span class=\"type\">const</span> InetAddress&amp; serverAddr,</span><br><span class=\"line\">                     <span class=\"type\">const</span> string&amp; nameArg)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"built_in\">CHECK_NOTNULL</span>(loop)),</span><br><span class=\"line\">    <span class=\"built_in\">connector_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Connector</span>(loop, serverAddr)),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(defaultConnectionCallback),</span><br><span class=\"line\">    <span class=\"built_in\">messageCallback_</span>(defaultMessageCallback),</span><br><span class=\"line\">    <span class=\"built_in\">retry_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">connect_</span>(<span class=\"literal\">true</span>),</span><br><span class=\"line\">    <span class=\"built_in\">nextConnId_</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">setNewConnectionCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpClient::newConnection, <span class=\"keyword\">this</span>, _1));</span><br><span class=\"line\">    <span class=\"comment\">// FIXME setConnectFailedCallback</span></span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpClient::TcpClient[&quot;</span> &lt;&lt; name_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] - connector &quot;</span> &lt;&lt; <span class=\"built_in\">get_pointer</span>(connector_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::connect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> check state</span></span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpClient::connect[&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;] - connecting to &quot;</span></span><br><span class=\"line\">            &lt;&lt; connector_-&gt;<span class=\"built_in\">serverAddress</span>().<span class=\"built_in\">toIpPort</span>();</span><br><span class=\"line\">    connect_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">start</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::disconnect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection_)&#123;</span><br><span class=\"line\">            connection_-&gt;<span class=\"built_in\">shutdown</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::stop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    connect_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">stop</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"function\">InetAddress <span class=\"title\">peerAddr</span><span class=\"params\">(sockets::getPeerAddr(sockfd))</span></span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;:%s#%d&quot;</span>, peerAddr.<span class=\"built_in\">toIpPort</span>().<span class=\"built_in\">c_str</span>(), nextConnId_);</span><br><span class=\"line\">    ++nextConnId_;</span><br><span class=\"line\">    string connName = name_ + buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">InetAddress <span class=\"title\">localAddr</span><span class=\"params\">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class=\"line\">    <span class=\"comment\">// FIXME use make_shared if necessary</span></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">conn</span><span class=\"params\">(<span class=\"keyword\">new</span> TcpConnection(loop_,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            connName,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            sockfd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            localAddr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            peerAddr))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setConnectionCallback</span>(connectionCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setMessageCallback</span>(messageCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setCloseCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpClient::removeConnection, <span class=\"keyword\">this</span>, _1)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        connection_ = conn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">connectEstablished</span>(); <span class=\"comment\">// loop</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpClient::removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(loop_ == conn-&gt;<span class=\"built_in\">getLoop</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(connection_ == conn);</span><br><span class=\"line\">        connection_.<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retry_ &amp;&amp; connect_)&#123;</span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpClient::connect[&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;] - Reconnecting to &quot;</span></span><br><span class=\"line\">                &lt;&lt; connector_-&gt;<span class=\"built_in\">serverAddress</span>().<span class=\"built_in\">toIpPort</span>();</span><br><span class=\"line\">    connector_-&gt;<span class=\"built_in\">restart</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p><strong></strong></p>\n<p>TcpConnection::handleClose()closesockfdTcpConnectionTcpConnection::connectDestroyed()closesockfd</p>\n<p><strong></strong></p>\n<p> TcpConnection TcpConnection  Socket Socket  RAII handler close(sockfd_) TcpConnection  &#x2F;proc&#x2F;pid&#x2F;fd&#x2F; </p>\n<p><a href=\"https://blog.csdn.net/Solstice/article/details/6208634\">https://blog.csdn.net/Solstice/article/details/6208634</a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>MuduoTcpServerTcpClientitbug</p>"},{"title":"muduo10TcpConnection","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nTcpConnectionBufferTcpConnectionBuffer\n\n## Buffer\n\nMuduoBuffervector\\<char\\>vectorTcpConnectionBuffer\n\nTcpConnection\n\n****\n\n<!-- more -->\n```cpp\nclass Buffer : public muduo::copyable{\npublic:\n    static const size_t kCheapPrepend = 8;  // prepend\n    static const size_t kInitialSize = 1024;    // \n\n    explicit Buffer(size_t initialSize = kInitialSize)\n    : buffer_(kCheapPrepend + initialSize),\n        readerIndex_(kCheapPrepend),\n        writerIndex_(kCheapPrepend){\n        assert(readableBytes() == 0);\n        assert(writableBytes() == initialSize);\n        assert(prependableBytes() == kCheapPrepend);\n    }\n    size_t readableBytes() const\n    { return writerIndex_ - readerIndex_; }\n\n    size_t writableBytes() const\n    { return buffer_.size() - writerIndex_; }\n\n    size_t prependableBytes() const\n    { return readerIndex_; }\n\n    const char* peek() const\n    { return begin() + readerIndex_; }\n    //\n    // ...\n\n    \n    void append(const char* /*restrict*/ data, size_t len){\n        ensureWritableBytes(len);\n        std::copy(data, data+len, beginWrite());\n        hasWritten(len);\n    }\n\n    void ensureWritableBytes(size_t len){\n        if (writableBytes() < len){\n            makeSpace(len);\n        }\n        assert(writableBytes() >= len);\n    }\n\n    void shrink(size_t reserve){    // \n        // FIXME: use vector::shrink_to_fit() in C++ 11 if possible.\n        Buffer other;\n        other.ensureWritableBytes(readableBytes()+reserve);\n        other.append(toStringPiece());\n        swap(other);\n    }\n\n    /// Read data directly into buffer.\n    ///\n    /// It may implement with readv(2)\n    /// @return result of read(2), @c errno is saved\n    ssize_t readFd(int fd, int* savedErrno);\n\nprivate:\n\n    char* begin()\n    { return &*buffer_.begin(); }\n\n    void makeSpace(size_t len){\n        if (writableBytes() + prependableBytes() < len + kCheapPrepend){ // \n            // FIXME: move readable data\n            buffer_.resize(writerIndex_+len);\n        }else{ // \n            // move readable data to the front, make space inside buffer\n            assert(kCheapPrepend < readerIndex_);\n            size_t readable = readableBytes();\n            std::copy(begin()+readerIndex_,\n                    begin()+writerIndex_,\n                    begin()+kCheapPrepend);\n            readerIndex_ = kCheapPrepend;\n            writerIndex_ = readerIndex_ + readable;\n            assert(readable == readableBytes());\n        }\n    }\n\nprivate:\n  std::vector<char> buffer_;\n  size_t readerIndex_;  // \n  size_t writerIndex_;  // \n};\n\n```\n\nBuffer\n\n```\n/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer\n///\n/// @code\n/// +-------------------+------------------+------------------+\n/// | prependable bytes |  readable bytes  |  writable bytes  |\n/// |                   |     (CONTENT)    |                  |\n/// +-------------------+------------------+------------------+\n/// |                   |                  |                  |\n/// 0      <=      readerIndex   <=   writerIndex    <=     size\n/// @endcode\n```\n\n****\n\n```cpp\n/*\n* sockfdbuffer\n*/\nssize_t Buffer::readFd(int fd, int* savedErrno){\n    // saved an ioctl()/FIONREAD call to tell how much to read\n    char extrabuf[65536];\n    struct iovec vec[2];\n    const size_t writable = writableBytes();\n    vec[0].iov_base = begin()+writerIndex_;\n    vec[0].iov_len = writable;\n    vec[1].iov_base = extrabuf;\n    vec[1].iov_len = sizeof extrabuf;\n    // when there is enough space in this buffer, don't read into extrabuf.\n    // when extrabuf is used, we read 128k-1 bytes at most.\n    // bufferbufferbufferextrabuf\n    const int iovcnt = (writable < sizeof extrabuf) ? 2 : 1;\n    const ssize_t n = sockets::readv(fd, vec, iovcnt);\n    if (n < 0){\n        *savedErrno = errno;\n    }else if (implicit_cast<size_t>(n) <= writable){\n        writerIndex_ += n;\n    }else{\n        writerIndex_ = buffer_.size();\n        append(extrabuf, n - writable); // extrabufappendbuffer\n    }\n    return n;\n}\n\n```\n\n## TcpConnection\n\nTimeQueueAcceptorTcpConnectionfdchannelTcpConnection\n\n**TcpConnection**\n\nsockfdloopsockfdchannelchannelsockfdSO_KEEPALIVETcpConnection::state_kConnecting\n\n\n\n```cpp\nTcpConnection::TcpConnection(EventLoop* loop,\n                             const string& nameArg,\n                             int sockfd,\n                             const InetAddress& localAddr,\n                             const InetAddress& peerAddr)\n  : loop_(CHECK_NOTNULL(loop)),\n    name_(nameArg),\n    state_(kConnecting),\n    reading_(true),\n    socket_(new Socket(sockfd)),\n    channel_(new Channel(loop, sockfd)),\n    localAddr_(localAddr),\n    peerAddr_(peerAddr),\n    highWaterMark_(64*1024*1024){\n\n    channel_->setReadCallback(  // \n        std::bind(&TcpConnection::handleRead, this, _1));\n    channel_->setWriteCallback( // \n        std::bind(&TcpConnection::handleWrite, this));\n    channel_->setCloseCallback( // sockfd\n        std::bind(&TcpConnection::handleClose, this));\n    channel_->setErrorCallback( // \n        std::bind(&TcpConnection::handleError, this));\n    LOG_DEBUG << \"TcpConnection::ctor[\" <<  name_ << \"] at \" << this\n            << \" fd=\" << sockfd;\n    socket_->setKeepAlive(true);    // \n}\n```\n\n****\n\n[muduo9TcpServer](./TcpServer.md)\n\n1. ioloop`TcpConnection::connectEstablished()`\n\n    1. TcpConnection::state_kConnected\n\n    2. channel_TcpConnectionTcpConnectionchannel\n\n    3. ioloopPollerchannel_\n\n    4. TcpConnection::connectionCallback_\n\n    5. \n\n\n\n```cpp\nvoid TcpConnection::connectEstablished(){\n    loop_->assertInLoopThread();\n    assert(state_ == kConnecting);\n    setState(kConnected);\n    channel_->tie(shared_from_this());\n    channel_->enableReading();  // \n\n    connectionCallback_(shared_from_this());\n}\n```\n\n****\n\n\n\n1. TcpConnection::inputBuffer_n\n\n2. \n    - n > 0TcpConnection::messageCallback_\n    - n == 0TcpConnection::handleClose()\n    - n < 0TcpConnection::handleError\n\n\n\n```cpp\nvoid TcpConnection::handleRead(Timestamp receiveTime){\n    loop_->assertInLoopThread();\n    int savedErrno = 0;\n    ssize_t n = inputBuffer_.readFd(channel_->fd(), &savedErrno);\n    if (n > 0){\n        messageCallback_(shared_from_this(), &inputBuffer_, receiveTime);\n    }else if (n == 0){\n        handleClose();\n    }else{\n        errno = savedErrno;\n        LOG_SYSERR << \"TcpConnection::handleRead\";\n        handleError();\n    }\n}\n```\n\n****\n\n\n\n1. TcpConnection::send\n\n    1. ioloopTcpConnection::sendInLoop()ioloopTcpConnection::sendInLoop()\n\n    2. TcpConnection::sendInLoop()\n        1. kDisconnected\n\n        2. ::writeerrno == EPIPE || errno == ECONNRESET\n\n        3. writeCompleteCallback_outputBuffer_channel_outputBuffer_outputBuffer_highWaterMarkCallback_\n\nsendInLoop\n\n```cpp\nvoid TcpConnection::sendInLoop(const void* data, size_t len){\n    loop_->assertInLoopThread();\n    ssize_t nwrote = 0;\n    size_t remaining = len; // \n    bool faultError = false;\n    if (state_ == kDisconnected){ // \n        LOG_WARN << \"disconnected, give up writing\";\n        return;\n    }\n    // if no thing in output queue, try writing directly\n    if (!channel_->isWriting() && outputBuffer_.readableBytes() == 0){ // Pollerconn fd && TcpConnection::outputBuffer_\n\n        // \n        // TCPPoller\n        nwrote = sockets::write(channel_->fd(), data, len); \n        if (nwrote >= 0){\n            remaining = len - nwrote;\n            if (remaining == 0 && writeCompleteCallback_){\n                loop_->queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));\n            }\n        }else{ // nwrote < 0\n            nwrote = 0;\n            if (errno != EWOULDBLOCK){\n                LOG_SYSERR << \"TcpConnection::sendInLoop\";\n                if (errno == EPIPE || errno == ECONNRESET) {// FIXME: any others?// socksockEPIPE || \n                    faultError = true;\n                }\n            }\n        }\n    }\n\n    assert(remaining <= len);\n    if (!faultError && remaining > 0){  // TCP\n        size_t oldLen = outputBuffer_.readableBytes();\n        if (oldLen + remaining >= highWaterMark_\n            && oldLen < highWaterMark_\n            && highWaterMarkCallback_){\n            loop_->queueInLoop(std::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));\n        }\n        outputBuffer_.append(static_cast<const char*>(data)+nwrote, remaining);\n        if (!channel_->isWriting()){\n            channel_->enableWriting();\n        }\n    }\n}\n```\n\n\n\nPoller\n\n1. PollerTcpConnection::handleWrite()\n\n    1. channel_->isWriting() == true\n\n    2. ::write()outputBuffer_\n\n    3. outputBuffer_cahnnel_writeCompleteCallback_ && kDisconnectingshutdownInLoop()\n\nhandleWrite()\n\n```cpp\nvoid TcpConnection::handleWrite(){\n    loop_->assertInLoopThread();\n    if (channel_->isWriting()){\n        ssize_t n = sockets::write(channel_->fd(),\n                                outputBuffer_.peek(),\n                                outputBuffer_.readableBytes());\n        if (n > 0){\n            outputBuffer_.retrieve(n);\n            if (outputBuffer_.readableBytes() == 0){\n                channel_->disableWriting();\n                if (writeCompleteCallback_){\n                    loop_->queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));\n                }\n                if (state_ == kDisconnecting){\n                    shutdownInLoop();\n                }\n            }\n        }else{\n            LOG_SYSERR << \"TcpConnection::handleWrite\";\n        }\n    }else{\n        LOG_TRACE << \"Connection fd = \" << channel_->fd()\n                << \" is down, no more writing\";\n    }\n}\n```\n\n****\n\n\n\n1. TcpConnection::forceClose\n\n2. kDisconnecting \n\n3. TcpConnection::forceCloseInLoop()\n\n    1. handleClose()\n\n        1. kDisconnected\n\n        2. channel_\n\n        3. connectionCallback_\n\n        4. closeCallback_TcpServer\n\n        5. TcpConnection::connectDestroyed\n\n            - channelPoller\n\n\n\n```cpp\nvoid TcpConnection::forceClose(){\n    // FIXME: use compare and swap\n    if (state_ == kConnected || state_ == kDisconnecting){\n        setState(kDisconnecting);\n        loop_->queueInLoop(std::bind(&TcpConnection::forceCloseInLoop, shared_from_this()));\n    }\n}\n\nvoid TcpConnection::forceCloseInLoop(){\n    loop_->assertInLoopThread();\n    if (state_ == kConnected || state_ == kDisconnecting){\n        // as if we received 0 byte in handleRead();\n        handleClose();\n    }\n}\n\nvoid TcpConnection::handleClose(){\n    loop_->assertInLoopThread();\n    LOG_TRACE << \"fd = \" << channel_->fd() << \" state = \" << stateToString();\n    assert(state_ == kConnected || state_ == kDisconnecting);\n    // we don't close fd, leave it to dtor, so we can find leaks easily.\n    setState(kDisconnected);\n    channel_->disableAll();\n\n    TcpConnectionPtr guardThis(shared_from_this());\n    connectionCallback_(guardThis);   // connectionCallback_TcpServer\n    // must be the last line\n    closeCallback_(guardThis);    // closeCallback_TcpServer\n}\n\nvoid TcpConnection::connectDestroyed(){\n    loop_->assertInLoopThread();\n    if (state_ == kConnected){\n        setState(kDisconnected);\n        channel_->disableAll();\n\n        connectionCallback_(shared_from_this());\n    }\n    channel_->remove();\n}\n```\n\n\n\n- TcpConnection::handleReadread0handleClose\n\n- Channel::handleEventWithGuardchannel_POLLHUPhandleClose\n\n## \n\n****\n\n muduo  shutdown() TCP\n\n****\n\n shutdown  close  muduo muduo  TCP \n\n shutdownWrite TCP FIN  0  muduo  0  muduo \n\nhttps://blog.csdn.net/Solstice/article/details/6208634\n\n## \n\nMuduoMuduo\n\nsylarLevelDBLevelDB\n\n---\n\n****","source":"_posts/muduo/TcpConnection.md","raw":"---\ntitle: muduo10TcpConnection\ndate: 2024-11-02 12:00:00\ntags:\n  - \n---\n\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nTcpConnectionBufferTcpConnectionBuffer\n\n## Buffer\n\nMuduoBuffervector\\<char\\>vectorTcpConnectionBuffer\n\nTcpConnection\n\n****\n\n<!-- more -->\n```cpp\nclass Buffer : public muduo::copyable{\npublic:\n    static const size_t kCheapPrepend = 8;  // prepend\n    static const size_t kInitialSize = 1024;    // \n\n    explicit Buffer(size_t initialSize = kInitialSize)\n    : buffer_(kCheapPrepend + initialSize),\n        readerIndex_(kCheapPrepend),\n        writerIndex_(kCheapPrepend){\n        assert(readableBytes() == 0);\n        assert(writableBytes() == initialSize);\n        assert(prependableBytes() == kCheapPrepend);\n    }\n    size_t readableBytes() const\n    { return writerIndex_ - readerIndex_; }\n\n    size_t writableBytes() const\n    { return buffer_.size() - writerIndex_; }\n\n    size_t prependableBytes() const\n    { return readerIndex_; }\n\n    const char* peek() const\n    { return begin() + readerIndex_; }\n    //\n    // ...\n\n    \n    void append(const char* /*restrict*/ data, size_t len){\n        ensureWritableBytes(len);\n        std::copy(data, data+len, beginWrite());\n        hasWritten(len);\n    }\n\n    void ensureWritableBytes(size_t len){\n        if (writableBytes() < len){\n            makeSpace(len);\n        }\n        assert(writableBytes() >= len);\n    }\n\n    void shrink(size_t reserve){    // \n        // FIXME: use vector::shrink_to_fit() in C++ 11 if possible.\n        Buffer other;\n        other.ensureWritableBytes(readableBytes()+reserve);\n        other.append(toStringPiece());\n        swap(other);\n    }\n\n    /// Read data directly into buffer.\n    ///\n    /// It may implement with readv(2)\n    /// @return result of read(2), @c errno is saved\n    ssize_t readFd(int fd, int* savedErrno);\n\nprivate:\n\n    char* begin()\n    { return &*buffer_.begin(); }\n\n    void makeSpace(size_t len){\n        if (writableBytes() + prependableBytes() < len + kCheapPrepend){ // \n            // FIXME: move readable data\n            buffer_.resize(writerIndex_+len);\n        }else{ // \n            // move readable data to the front, make space inside buffer\n            assert(kCheapPrepend < readerIndex_);\n            size_t readable = readableBytes();\n            std::copy(begin()+readerIndex_,\n                    begin()+writerIndex_,\n                    begin()+kCheapPrepend);\n            readerIndex_ = kCheapPrepend;\n            writerIndex_ = readerIndex_ + readable;\n            assert(readable == readableBytes());\n        }\n    }\n\nprivate:\n  std::vector<char> buffer_;\n  size_t readerIndex_;  // \n  size_t writerIndex_;  // \n};\n\n```\n\nBuffer\n\n```\n/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer\n///\n/// @code\n/// +-------------------+------------------+------------------+\n/// | prependable bytes |  readable bytes  |  writable bytes  |\n/// |                   |     (CONTENT)    |                  |\n/// +-------------------+------------------+------------------+\n/// |                   |                  |                  |\n/// 0      <=      readerIndex   <=   writerIndex    <=     size\n/// @endcode\n```\n\n****\n\n```cpp\n/*\n* sockfdbuffer\n*/\nssize_t Buffer::readFd(int fd, int* savedErrno){\n    // saved an ioctl()/FIONREAD call to tell how much to read\n    char extrabuf[65536];\n    struct iovec vec[2];\n    const size_t writable = writableBytes();\n    vec[0].iov_base = begin()+writerIndex_;\n    vec[0].iov_len = writable;\n    vec[1].iov_base = extrabuf;\n    vec[1].iov_len = sizeof extrabuf;\n    // when there is enough space in this buffer, don't read into extrabuf.\n    // when extrabuf is used, we read 128k-1 bytes at most.\n    // bufferbufferbufferextrabuf\n    const int iovcnt = (writable < sizeof extrabuf) ? 2 : 1;\n    const ssize_t n = sockets::readv(fd, vec, iovcnt);\n    if (n < 0){\n        *savedErrno = errno;\n    }else if (implicit_cast<size_t>(n) <= writable){\n        writerIndex_ += n;\n    }else{\n        writerIndex_ = buffer_.size();\n        append(extrabuf, n - writable); // extrabufappendbuffer\n    }\n    return n;\n}\n\n```\n\n## TcpConnection\n\nTimeQueueAcceptorTcpConnectionfdchannelTcpConnection\n\n**TcpConnection**\n\nsockfdloopsockfdchannelchannelsockfdSO_KEEPALIVETcpConnection::state_kConnecting\n\n\n\n```cpp\nTcpConnection::TcpConnection(EventLoop* loop,\n                             const string& nameArg,\n                             int sockfd,\n                             const InetAddress& localAddr,\n                             const InetAddress& peerAddr)\n  : loop_(CHECK_NOTNULL(loop)),\n    name_(nameArg),\n    state_(kConnecting),\n    reading_(true),\n    socket_(new Socket(sockfd)),\n    channel_(new Channel(loop, sockfd)),\n    localAddr_(localAddr),\n    peerAddr_(peerAddr),\n    highWaterMark_(64*1024*1024){\n\n    channel_->setReadCallback(  // \n        std::bind(&TcpConnection::handleRead, this, _1));\n    channel_->setWriteCallback( // \n        std::bind(&TcpConnection::handleWrite, this));\n    channel_->setCloseCallback( // sockfd\n        std::bind(&TcpConnection::handleClose, this));\n    channel_->setErrorCallback( // \n        std::bind(&TcpConnection::handleError, this));\n    LOG_DEBUG << \"TcpConnection::ctor[\" <<  name_ << \"] at \" << this\n            << \" fd=\" << sockfd;\n    socket_->setKeepAlive(true);    // \n}\n```\n\n****\n\n[muduo9TcpServer](./TcpServer.md)\n\n1. ioloop`TcpConnection::connectEstablished()`\n\n    1. TcpConnection::state_kConnected\n\n    2. channel_TcpConnectionTcpConnectionchannel\n\n    3. ioloopPollerchannel_\n\n    4. TcpConnection::connectionCallback_\n\n    5. \n\n\n\n```cpp\nvoid TcpConnection::connectEstablished(){\n    loop_->assertInLoopThread();\n    assert(state_ == kConnecting);\n    setState(kConnected);\n    channel_->tie(shared_from_this());\n    channel_->enableReading();  // \n\n    connectionCallback_(shared_from_this());\n}\n```\n\n****\n\n\n\n1. TcpConnection::inputBuffer_n\n\n2. \n    - n > 0TcpConnection::messageCallback_\n    - n == 0TcpConnection::handleClose()\n    - n < 0TcpConnection::handleError\n\n\n\n```cpp\nvoid TcpConnection::handleRead(Timestamp receiveTime){\n    loop_->assertInLoopThread();\n    int savedErrno = 0;\n    ssize_t n = inputBuffer_.readFd(channel_->fd(), &savedErrno);\n    if (n > 0){\n        messageCallback_(shared_from_this(), &inputBuffer_, receiveTime);\n    }else if (n == 0){\n        handleClose();\n    }else{\n        errno = savedErrno;\n        LOG_SYSERR << \"TcpConnection::handleRead\";\n        handleError();\n    }\n}\n```\n\n****\n\n\n\n1. TcpConnection::send\n\n    1. ioloopTcpConnection::sendInLoop()ioloopTcpConnection::sendInLoop()\n\n    2. TcpConnection::sendInLoop()\n        1. kDisconnected\n\n        2. ::writeerrno == EPIPE || errno == ECONNRESET\n\n        3. writeCompleteCallback_outputBuffer_channel_outputBuffer_outputBuffer_highWaterMarkCallback_\n\nsendInLoop\n\n```cpp\nvoid TcpConnection::sendInLoop(const void* data, size_t len){\n    loop_->assertInLoopThread();\n    ssize_t nwrote = 0;\n    size_t remaining = len; // \n    bool faultError = false;\n    if (state_ == kDisconnected){ // \n        LOG_WARN << \"disconnected, give up writing\";\n        return;\n    }\n    // if no thing in output queue, try writing directly\n    if (!channel_->isWriting() && outputBuffer_.readableBytes() == 0){ // Pollerconn fd && TcpConnection::outputBuffer_\n\n        // \n        // TCPPoller\n        nwrote = sockets::write(channel_->fd(), data, len); \n        if (nwrote >= 0){\n            remaining = len - nwrote;\n            if (remaining == 0 && writeCompleteCallback_){\n                loop_->queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));\n            }\n        }else{ // nwrote < 0\n            nwrote = 0;\n            if (errno != EWOULDBLOCK){\n                LOG_SYSERR << \"TcpConnection::sendInLoop\";\n                if (errno == EPIPE || errno == ECONNRESET) {// FIXME: any others?// socksockEPIPE || \n                    faultError = true;\n                }\n            }\n        }\n    }\n\n    assert(remaining <= len);\n    if (!faultError && remaining > 0){  // TCP\n        size_t oldLen = outputBuffer_.readableBytes();\n        if (oldLen + remaining >= highWaterMark_\n            && oldLen < highWaterMark_\n            && highWaterMarkCallback_){\n            loop_->queueInLoop(std::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));\n        }\n        outputBuffer_.append(static_cast<const char*>(data)+nwrote, remaining);\n        if (!channel_->isWriting()){\n            channel_->enableWriting();\n        }\n    }\n}\n```\n\n\n\nPoller\n\n1. PollerTcpConnection::handleWrite()\n\n    1. channel_->isWriting() == true\n\n    2. ::write()outputBuffer_\n\n    3. outputBuffer_cahnnel_writeCompleteCallback_ && kDisconnectingshutdownInLoop()\n\nhandleWrite()\n\n```cpp\nvoid TcpConnection::handleWrite(){\n    loop_->assertInLoopThread();\n    if (channel_->isWriting()){\n        ssize_t n = sockets::write(channel_->fd(),\n                                outputBuffer_.peek(),\n                                outputBuffer_.readableBytes());\n        if (n > 0){\n            outputBuffer_.retrieve(n);\n            if (outputBuffer_.readableBytes() == 0){\n                channel_->disableWriting();\n                if (writeCompleteCallback_){\n                    loop_->queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));\n                }\n                if (state_ == kDisconnecting){\n                    shutdownInLoop();\n                }\n            }\n        }else{\n            LOG_SYSERR << \"TcpConnection::handleWrite\";\n        }\n    }else{\n        LOG_TRACE << \"Connection fd = \" << channel_->fd()\n                << \" is down, no more writing\";\n    }\n}\n```\n\n****\n\n\n\n1. TcpConnection::forceClose\n\n2. kDisconnecting \n\n3. TcpConnection::forceCloseInLoop()\n\n    1. handleClose()\n\n        1. kDisconnected\n\n        2. channel_\n\n        3. connectionCallback_\n\n        4. closeCallback_TcpServer\n\n        5. TcpConnection::connectDestroyed\n\n            - channelPoller\n\n\n\n```cpp\nvoid TcpConnection::forceClose(){\n    // FIXME: use compare and swap\n    if (state_ == kConnected || state_ == kDisconnecting){\n        setState(kDisconnecting);\n        loop_->queueInLoop(std::bind(&TcpConnection::forceCloseInLoop, shared_from_this()));\n    }\n}\n\nvoid TcpConnection::forceCloseInLoop(){\n    loop_->assertInLoopThread();\n    if (state_ == kConnected || state_ == kDisconnecting){\n        // as if we received 0 byte in handleRead();\n        handleClose();\n    }\n}\n\nvoid TcpConnection::handleClose(){\n    loop_->assertInLoopThread();\n    LOG_TRACE << \"fd = \" << channel_->fd() << \" state = \" << stateToString();\n    assert(state_ == kConnected || state_ == kDisconnecting);\n    // we don't close fd, leave it to dtor, so we can find leaks easily.\n    setState(kDisconnected);\n    channel_->disableAll();\n\n    TcpConnectionPtr guardThis(shared_from_this());\n    connectionCallback_(guardThis);   // connectionCallback_TcpServer\n    // must be the last line\n    closeCallback_(guardThis);    // closeCallback_TcpServer\n}\n\nvoid TcpConnection::connectDestroyed(){\n    loop_->assertInLoopThread();\n    if (state_ == kConnected){\n        setState(kDisconnected);\n        channel_->disableAll();\n\n        connectionCallback_(shared_from_this());\n    }\n    channel_->remove();\n}\n```\n\n\n\n- TcpConnection::handleReadread0handleClose\n\n- Channel::handleEventWithGuardchannel_POLLHUPhandleClose\n\n## \n\n****\n\n muduo  shutdown() TCP\n\n****\n\n shutdown  close  muduo muduo  TCP \n\n shutdownWrite TCP FIN  0  muduo  0  muduo \n\nhttps://blog.csdn.net/Solstice/article/details/6208634\n\n## \n\nMuduoMuduo\n\nsylarLevelDBLevelDB\n\n---\n\n****","slug":"muduo/TcpConnection","published":1,"updated":"2025-09-28T16:06:43.130Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9q000kq8ws5wshe41s","content":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>TcpConnectionBufferTcpConnectionBuffer</p>\n<h2 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h2><p>MuduoBuffervector&lt;char&gt;vectorTcpConnectionBuffer</p>\n<p>TcpConnection</p>\n<p><strong></strong></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Buffer</span> : <span class=\"keyword\">public</span> muduo::copyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> kCheapPrepend = <span class=\"number\">8</span>;  <span class=\"comment\">// prepend</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> kInitialSize = <span class=\"number\">1024</span>;    <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Buffer</span><span class=\"params\">(<span class=\"type\">size_t</span> initialSize = kInitialSize)</span></span></span><br><span class=\"line\"><span class=\"function\">    : buffer_(kCheapPrepend + initialSize),</span></span><br><span class=\"line\"><span class=\"function\">        readerIndex_(kCheapPrepend),</span></span><br><span class=\"line\"><span class=\"function\">        writerIndex_(kCheapPrepend)&#123;</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">readableBytes</span>() == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">writableBytes</span>() == initialSize);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">prependableBytes</span>() == kCheapPrepend);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">readableBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> writerIndex_ - readerIndex_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">writableBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> buffer_.<span class=\"built_in\">size</span>() - writerIndex_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">prependableBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> readerIndex_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title\">peek</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">begin</span>() + readerIndex_; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"comment\">/*restrict*/</span> data, <span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">ensureWritableBytes</span>(len);</span><br><span class=\"line\">        std::<span class=\"built_in\">copy</span>(data, data+len, <span class=\"built_in\">beginWrite</span>());</span><br><span class=\"line\">        <span class=\"built_in\">hasWritten</span>(len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ensureWritableBytes</span><span class=\"params\">(<span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">writableBytes</span>() &lt; len)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">makeSpace</span>(len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">writableBytes</span>() &gt;= len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shrink</span><span class=\"params\">(<span class=\"type\">size_t</span> reserve)</span></span>&#123;    <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use vector::shrink_to_fit() in C++ 11 if possible.</span></span><br><span class=\"line\">        Buffer other;</span><br><span class=\"line\">        other.<span class=\"built_in\">ensureWritableBytes</span>(<span class=\"built_in\">readableBytes</span>()+reserve);</span><br><span class=\"line\">        other.<span class=\"built_in\">append</span>(<span class=\"built_in\">toStringPiece</span>());</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(other);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Read data directly into buffer.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// It may implement with readv(2)</span></span><br><span class=\"line\">    <span class=\"comment\">/// @return result of read(2), @c errno is saved</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">ssize_t</span> <span class=\"title\">readFd</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span>* savedErrno)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">char</span>* <span class=\"title\">begin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> &amp;*buffer_.<span class=\"built_in\">begin</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">makeSpace</span><span class=\"params\">(<span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">writableBytes</span>() + <span class=\"built_in\">prependableBytes</span>() &lt; len + kCheapPrepend)&#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> move readable data</span></span><br><span class=\"line\">            buffer_.<span class=\"built_in\">resize</span>(writerIndex_+len);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"comment\">// move readable data to the front, make space inside buffer</span></span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(kCheapPrepend &lt; readerIndex_);</span><br><span class=\"line\">            <span class=\"type\">size_t</span> readable = <span class=\"built_in\">readableBytes</span>();</span><br><span class=\"line\">            std::<span class=\"built_in\">copy</span>(<span class=\"built_in\">begin</span>()+readerIndex_,</span><br><span class=\"line\">                    <span class=\"built_in\">begin</span>()+writerIndex_,</span><br><span class=\"line\">                    <span class=\"built_in\">begin</span>()+kCheapPrepend);</span><br><span class=\"line\">            readerIndex_ = kCheapPrepend;</span><br><span class=\"line\">            writerIndex_ = readerIndex_ + readable;</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(readable == <span class=\"built_in\">readableBytes</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  std::vector&lt;<span class=\"type\">char</span>&gt; buffer_;</span><br><span class=\"line\">  <span class=\"type\">size_t</span> readerIndex_;  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">size_t</span> writerIndex_;  <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Buffer</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer</span><br><span class=\"line\">///</span><br><span class=\"line\">/// @code</span><br><span class=\"line\">/// +-------------------+------------------+------------------+</span><br><span class=\"line\">/// | prependable bytes |  readable bytes  |  writable bytes  |</span><br><span class=\"line\">/// |                   |     (CONTENT)    |                  |</span><br><span class=\"line\">/// +-------------------+------------------+------------------+</span><br><span class=\"line\">/// |                   |                  |                  |</span><br><span class=\"line\">/// 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size</span><br><span class=\"line\">/// @endcode</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* sockfdbuffer</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">ssize_t</span> <span class=\"title\">Buffer::readFd</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span>* savedErrno)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// saved an ioctl()/FIONREAD call to tell how much to read</span></span><br><span class=\"line\">    <span class=\"type\">char</span> extrabuf[<span class=\"number\">65536</span>];</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> vec[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">size_t</span> writable = <span class=\"built_in\">writableBytes</span>();</span><br><span class=\"line\">    vec[<span class=\"number\">0</span>].iov_base = <span class=\"built_in\">begin</span>()+writerIndex_;</span><br><span class=\"line\">    vec[<span class=\"number\">0</span>].iov_len = writable;</span><br><span class=\"line\">    vec[<span class=\"number\">1</span>].iov_base = extrabuf;</span><br><span class=\"line\">    vec[<span class=\"number\">1</span>].iov_len = <span class=\"keyword\">sizeof</span> extrabuf;</span><br><span class=\"line\">    <span class=\"comment\">// when there is enough space in this buffer, don&#x27;t read into extrabuf.</span></span><br><span class=\"line\">    <span class=\"comment\">// when extrabuf is used, we read 128k-1 bytes at most.</span></span><br><span class=\"line\">    <span class=\"comment\">// bufferbufferbufferextrabuf</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> iovcnt = (writable &lt; <span class=\"keyword\">sizeof</span> extrabuf) ? <span class=\"number\">2</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">readv</span>(fd, vec, iovcnt);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        *savedErrno = errno;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">implicit_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(n) &lt;= writable)&#123;</span><br><span class=\"line\">        writerIndex_ += n;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        writerIndex_ = buffer_.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">append</span>(extrabuf, n - writable); <span class=\"comment\">// extrabufappendbuffer</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"TcpConnection\"><a href=\"#TcpConnection\" class=\"headerlink\" title=\"TcpConnection\"></a>TcpConnection</h2><p>TimeQueueAcceptorTcpConnectionfdchannelTcpConnection</p>\n<p><strong>TcpConnection</strong></p>\n<p>sockfdloopsockfdchannelchannelsockfdSO_KEEPALIVETcpConnection::state_kConnecting</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TcpConnection::<span class=\"built_in\">TcpConnection</span>(EventLoop* loop,</span><br><span class=\"line\">                             <span class=\"type\">const</span> string&amp; nameArg,</span><br><span class=\"line\">                             <span class=\"type\">int</span> sockfd,</span><br><span class=\"line\">                             <span class=\"type\">const</span> InetAddress&amp; localAddr,</span><br><span class=\"line\">                             <span class=\"type\">const</span> InetAddress&amp; peerAddr)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"built_in\">CHECK_NOTNULL</span>(loop)),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">state_</span>(kConnecting),</span><br><span class=\"line\">    <span class=\"built_in\">reading_</span>(<span class=\"literal\">true</span>),</span><br><span class=\"line\">    <span class=\"built_in\">socket_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Socket</span>(sockfd)),</span><br><span class=\"line\">    <span class=\"built_in\">channel_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Channel</span>(loop, sockfd)),</span><br><span class=\"line\">    <span class=\"built_in\">localAddr_</span>(localAddr),</span><br><span class=\"line\">    <span class=\"built_in\">peerAddr_</span>(peerAddr),</span><br><span class=\"line\">    <span class=\"built_in\">highWaterMark_</span>(<span class=\"number\">64</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setReadCallback</span>(  <span class=\"comment\">// </span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleRead, <span class=\"keyword\">this</span>, _1));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setWriteCallback</span>( <span class=\"comment\">// </span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleWrite, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setCloseCallback</span>( <span class=\"comment\">// sockfd</span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleClose, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setErrorCallback</span>( <span class=\"comment\">// </span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleError, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;TcpConnection::ctor[&quot;</span> &lt;&lt;  name_ &lt;&lt; <span class=\"string\">&quot;] at &quot;</span> &lt;&lt; <span class=\"keyword\">this</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot; fd=&quot;</span> &lt;&lt; sockfd;</span><br><span class=\"line\">    socket_-&gt;<span class=\"built_in\">setKeepAlive</span>(<span class=\"literal\">true</span>);    <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<ol>\n<li><p>ioloop<code>TcpConnection::connectEstablished()</code></p>\n<ol>\n<li><p>TcpConnection::state_kConnected</p>\n</li>\n<li><p>channel_TcpConnectionTcpConnectionchannel</p>\n</li>\n<li><p>ioloopPollerchannel_</p>\n</li>\n<li><p>TcpConnection::connectionCallback_</p>\n</li>\n<li><p></p>\n</li>\n</ol>\n</li>\n</ol>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::connectEstablished</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(state_ == kConnecting);</span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kConnected);</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">tie</span>(<span class=\"built_in\">shared_from_this</span>());</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">enableReading</span>();  <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(<span class=\"built_in\">shared_from_this</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p></p>\n<ol>\n<li><p>TcpConnection::inputBuffer_n</p>\n</li>\n<li><ul>\n<li>n &gt; 0TcpConnection::messageCallback_</li>\n<li>n &#x3D;&#x3D; 0TcpConnection::handleClose()</li>\n<li>n &lt; 0TcpConnection::handleError</li>\n</ul>\n</li>\n</ol>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::handleRead</span><span class=\"params\">(Timestamp receiveTime)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> savedErrno = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> n = inputBuffer_.<span class=\"built_in\">readFd</span>(channel_-&gt;<span class=\"built_in\">fd</span>(), &amp;savedErrno);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">messageCallback_</span>(<span class=\"built_in\">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">handleClose</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        errno = savedErrno;</span><br><span class=\"line\">        LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;TcpConnection::handleRead&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">handleError</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p></p>\n<ol>\n<li><p>TcpConnection::send</p>\n<ol>\n<li><p>ioloopTcpConnection::sendInLoop()ioloopTcpConnection::sendInLoop()</p>\n</li>\n<li><p>TcpConnection::sendInLoop()</p>\n<ol>\n<li><p>kDisconnected</p>\n</li>\n<li><p>::writeerrno &#x3D;&#x3D; EPIPE || errno &#x3D;&#x3D; ECONNRESET</p>\n</li>\n<li><p>writeCompleteCallback_outputBuffer_channel_outputBuffer_outputBuffer_highWaterMarkCallback_</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>sendInLoop</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::sendInLoop</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* data, <span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> nwrote = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> remaining = len; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> faultError = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kDisconnected)&#123; <span class=\"comment\">// </span></span><br><span class=\"line\">        LOG_WARN &lt;&lt; <span class=\"string\">&quot;disconnected, give up writing&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// if no thing in output queue, try writing directly</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!channel_-&gt;<span class=\"built_in\">isWriting</span>() &amp;&amp; outputBuffer_.<span class=\"built_in\">readableBytes</span>() == <span class=\"number\">0</span>)&#123; <span class=\"comment\">// Pollerconn fd &amp;&amp; TcpConnection::outputBuffer_</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"comment\">// TCPPoller</span></span><br><span class=\"line\">        nwrote = sockets::<span class=\"built_in\">write</span>(channel_-&gt;<span class=\"built_in\">fd</span>(), data, len); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nwrote &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            remaining = len - nwrote;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remaining == <span class=\"number\">0</span> &amp;&amp; writeCompleteCallback_)&#123;</span><br><span class=\"line\">                loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(writeCompleteCallback_, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// nwrote &lt; 0</span></span><br><span class=\"line\">            nwrote = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (errno != EWOULDBLOCK)&#123;</span><br><span class=\"line\">                LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;TcpConnection::sendInLoop&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (errno == EPIPE || errno == ECONNRESET) &#123;<span class=\"comment\">// <span class=\"doctag\">FIXME:</span> any others?// socksockEPIPE || </span></span><br><span class=\"line\">                    faultError = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(remaining &lt;= len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!faultError &amp;&amp; remaining &gt; <span class=\"number\">0</span>)&#123;  <span class=\"comment\">// TCP</span></span><br><span class=\"line\">        <span class=\"type\">size_t</span> oldLen = outputBuffer_.<span class=\"built_in\">readableBytes</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldLen + remaining &gt;= highWaterMark_</span><br><span class=\"line\">            &amp;&amp; oldLen &lt; highWaterMark_</span><br><span class=\"line\">            &amp;&amp; highWaterMarkCallback_)&#123;</span><br><span class=\"line\">            loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(highWaterMarkCallback_, <span class=\"built_in\">shared_from_this</span>(), oldLen + remaining));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        outputBuffer_.<span class=\"built_in\">append</span>(<span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">const</span> <span class=\"type\">char</span>*&gt;(data)+nwrote, remaining);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!channel_-&gt;<span class=\"built_in\">isWriting</span>())&#123;</span><br><span class=\"line\">            channel_-&gt;<span class=\"built_in\">enableWriting</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p>Poller</p>\n<ol>\n<li><p>PollerTcpConnection::handleWrite()</p>\n<ol>\n<li><p>channel_-&gt;isWriting() &#x3D;&#x3D; true</p>\n</li>\n<li><p>::write()outputBuffer_</p>\n</li>\n<li><p>outputBuffer_cahnnel_writeCompleteCallback_ &amp;&amp; kDisconnectingshutdownInLoop()</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>handleWrite()</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::handleWrite</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel_-&gt;<span class=\"built_in\">isWriting</span>())&#123;</span><br><span class=\"line\">        <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">write</span>(channel_-&gt;<span class=\"built_in\">fd</span>(),</span><br><span class=\"line\">                                outputBuffer_.<span class=\"built_in\">peek</span>(),</span><br><span class=\"line\">                                outputBuffer_.<span class=\"built_in\">readableBytes</span>());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            outputBuffer_.<span class=\"built_in\">retrieve</span>(n);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (outputBuffer_.<span class=\"built_in\">readableBytes</span>() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                channel_-&gt;<span class=\"built_in\">disableWriting</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (writeCompleteCallback_)&#123;</span><br><span class=\"line\">                    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(writeCompleteCallback_, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (state_ == kDisconnecting)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">shutdownInLoop</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;TcpConnection::handleWrite&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_TRACE &lt;&lt; <span class=\"string\">&quot;Connection fd = &quot;</span> &lt;&lt; channel_-&gt;<span class=\"built_in\">fd</span>()</span><br><span class=\"line\">                &lt;&lt; <span class=\"string\">&quot; is down, no more writing&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p></p>\n<ol>\n<li><p>TcpConnection::forceClose</p>\n</li>\n<li><p>kDisconnecting </p>\n</li>\n<li><p>TcpConnection::forceCloseInLoop()</p>\n<ol>\n<li><p>handleClose()</p>\n<ol>\n<li><p>kDisconnected</p>\n</li>\n<li><p>channel_</p>\n</li>\n<li><p>connectionCallback_</p>\n</li>\n<li><p>closeCallback_TcpServer</p>\n</li>\n<li><p>TcpConnection::connectDestroyed</p>\n<ul>\n<li>channelPoller</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::forceClose</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use compare and swap</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnected || state_ == kDisconnecting)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setState</span>(kDisconnecting);</span><br><span class=\"line\">        loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::forceCloseInLoop, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::forceCloseInLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnected || state_ == kDisconnecting)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// as if we received 0 byte in handleRead();</span></span><br><span class=\"line\">        <span class=\"built_in\">handleClose</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::handleClose</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;fd = &quot;</span> &lt;&lt; channel_-&gt;<span class=\"built_in\">fd</span>() &lt;&lt; <span class=\"string\">&quot; state = &quot;</span> &lt;&lt; <span class=\"built_in\">stateToString</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(state_ == kConnected || state_ == kDisconnecting);</span><br><span class=\"line\">    <span class=\"comment\">// we don&#x27;t close fd, leave it to dtor, so we can find leaks easily.</span></span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">guardThis</span><span class=\"params\">(shared_from_this())</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(guardThis);   <span class=\"comment\">// connectionCallback_TcpServer</span></span><br><span class=\"line\">    <span class=\"comment\">// must be the last line</span></span><br><span class=\"line\">    <span class=\"built_in\">closeCallback_</span>(guardThis);    <span class=\"comment\">// closeCallback_TcpServer</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::connectDestroyed</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnected)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">        channel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">connectionCallback_</span>(<span class=\"built_in\">shared_from_this</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<ul>\n<li><p>TcpConnection::handleReadread0handleClose</p>\n</li>\n<li><p>Channel::handleEventWithGuardchannel_POLLHUPhandleClose</p>\n</li>\n</ul>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<p> muduo  shutdown() TCP</p>\n<p><strong></strong></p>\n<p> shutdown  close  muduo muduo  TCP </p>\n<p> shutdownWrite TCP FIN  0  muduo  0  muduo </p>\n<p><a href=\"https://blog.csdn.net/Solstice/article/details/6208634\">https://blog.csdn.net/Solstice/article/details/6208634</a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>MuduoMuduo</p>\n<p>sylarLevelDBLevelDB</p>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>TcpConnectionBufferTcpConnectionBuffer</p>\n<h2 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h2><p>MuduoBuffervector&lt;char&gt;vectorTcpConnectionBuffer</p>\n<p>TcpConnection</p>\n<p><strong></strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Buffer</span> : <span class=\"keyword\">public</span> muduo::copyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> kCheapPrepend = <span class=\"number\">8</span>;  <span class=\"comment\">// prepend</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> kInitialSize = <span class=\"number\">1024</span>;    <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Buffer</span><span class=\"params\">(<span class=\"type\">size_t</span> initialSize = kInitialSize)</span></span></span><br><span class=\"line\"><span class=\"function\">    : buffer_(kCheapPrepend + initialSize),</span></span><br><span class=\"line\"><span class=\"function\">        readerIndex_(kCheapPrepend),</span></span><br><span class=\"line\"><span class=\"function\">        writerIndex_(kCheapPrepend)&#123;</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">readableBytes</span>() == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">writableBytes</span>() == initialSize);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">prependableBytes</span>() == kCheapPrepend);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">readableBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> writerIndex_ - readerIndex_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">writableBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> buffer_.<span class=\"built_in\">size</span>() - writerIndex_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">prependableBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> readerIndex_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title\">peek</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">begin</span>() + readerIndex_; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"comment\">/*restrict*/</span> data, <span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">ensureWritableBytes</span>(len);</span><br><span class=\"line\">        std::<span class=\"built_in\">copy</span>(data, data+len, <span class=\"built_in\">beginWrite</span>());</span><br><span class=\"line\">        <span class=\"built_in\">hasWritten</span>(len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ensureWritableBytes</span><span class=\"params\">(<span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">writableBytes</span>() &lt; len)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">makeSpace</span>(len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">writableBytes</span>() &gt;= len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shrink</span><span class=\"params\">(<span class=\"type\">size_t</span> reserve)</span></span>&#123;    <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use vector::shrink_to_fit() in C++ 11 if possible.</span></span><br><span class=\"line\">        Buffer other;</span><br><span class=\"line\">        other.<span class=\"built_in\">ensureWritableBytes</span>(<span class=\"built_in\">readableBytes</span>()+reserve);</span><br><span class=\"line\">        other.<span class=\"built_in\">append</span>(<span class=\"built_in\">toStringPiece</span>());</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(other);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Read data directly into buffer.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// It may implement with readv(2)</span></span><br><span class=\"line\">    <span class=\"comment\">/// @return result of read(2), @c errno is saved</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">ssize_t</span> <span class=\"title\">readFd</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span>* savedErrno)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">char</span>* <span class=\"title\">begin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> &amp;*buffer_.<span class=\"built_in\">begin</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">makeSpace</span><span class=\"params\">(<span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">writableBytes</span>() + <span class=\"built_in\">prependableBytes</span>() &lt; len + kCheapPrepend)&#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> move readable data</span></span><br><span class=\"line\">            buffer_.<span class=\"built_in\">resize</span>(writerIndex_+len);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"comment\">// move readable data to the front, make space inside buffer</span></span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(kCheapPrepend &lt; readerIndex_);</span><br><span class=\"line\">            <span class=\"type\">size_t</span> readable = <span class=\"built_in\">readableBytes</span>();</span><br><span class=\"line\">            std::<span class=\"built_in\">copy</span>(<span class=\"built_in\">begin</span>()+readerIndex_,</span><br><span class=\"line\">                    <span class=\"built_in\">begin</span>()+writerIndex_,</span><br><span class=\"line\">                    <span class=\"built_in\">begin</span>()+kCheapPrepend);</span><br><span class=\"line\">            readerIndex_ = kCheapPrepend;</span><br><span class=\"line\">            writerIndex_ = readerIndex_ + readable;</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(readable == <span class=\"built_in\">readableBytes</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  std::vector&lt;<span class=\"type\">char</span>&gt; buffer_;</span><br><span class=\"line\">  <span class=\"type\">size_t</span> readerIndex_;  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">size_t</span> writerIndex_;  <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Buffer</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer</span><br><span class=\"line\">///</span><br><span class=\"line\">/// @code</span><br><span class=\"line\">/// +-------------------+------------------+------------------+</span><br><span class=\"line\">/// | prependable bytes |  readable bytes  |  writable bytes  |</span><br><span class=\"line\">/// |                   |     (CONTENT)    |                  |</span><br><span class=\"line\">/// +-------------------+------------------+------------------+</span><br><span class=\"line\">/// |                   |                  |                  |</span><br><span class=\"line\">/// 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size</span><br><span class=\"line\">/// @endcode</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* sockfdbuffer</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">ssize_t</span> <span class=\"title\">Buffer::readFd</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span>* savedErrno)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// saved an ioctl()/FIONREAD call to tell how much to read</span></span><br><span class=\"line\">    <span class=\"type\">char</span> extrabuf[<span class=\"number\">65536</span>];</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> vec[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">size_t</span> writable = <span class=\"built_in\">writableBytes</span>();</span><br><span class=\"line\">    vec[<span class=\"number\">0</span>].iov_base = <span class=\"built_in\">begin</span>()+writerIndex_;</span><br><span class=\"line\">    vec[<span class=\"number\">0</span>].iov_len = writable;</span><br><span class=\"line\">    vec[<span class=\"number\">1</span>].iov_base = extrabuf;</span><br><span class=\"line\">    vec[<span class=\"number\">1</span>].iov_len = <span class=\"keyword\">sizeof</span> extrabuf;</span><br><span class=\"line\">    <span class=\"comment\">// when there is enough space in this buffer, don&#x27;t read into extrabuf.</span></span><br><span class=\"line\">    <span class=\"comment\">// when extrabuf is used, we read 128k-1 bytes at most.</span></span><br><span class=\"line\">    <span class=\"comment\">// bufferbufferbufferextrabuf</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> iovcnt = (writable &lt; <span class=\"keyword\">sizeof</span> extrabuf) ? <span class=\"number\">2</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">readv</span>(fd, vec, iovcnt);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        *savedErrno = errno;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">implicit_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(n) &lt;= writable)&#123;</span><br><span class=\"line\">        writerIndex_ += n;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        writerIndex_ = buffer_.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">append</span>(extrabuf, n - writable); <span class=\"comment\">// extrabufappendbuffer</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"TcpConnection\"><a href=\"#TcpConnection\" class=\"headerlink\" title=\"TcpConnection\"></a>TcpConnection</h2><p>TimeQueueAcceptorTcpConnectionfdchannelTcpConnection</p>\n<p><strong>TcpConnection</strong></p>\n<p>sockfdloopsockfdchannelchannelsockfdSO_KEEPALIVETcpConnection::state_kConnecting</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TcpConnection::<span class=\"built_in\">TcpConnection</span>(EventLoop* loop,</span><br><span class=\"line\">                             <span class=\"type\">const</span> string&amp; nameArg,</span><br><span class=\"line\">                             <span class=\"type\">int</span> sockfd,</span><br><span class=\"line\">                             <span class=\"type\">const</span> InetAddress&amp; localAddr,</span><br><span class=\"line\">                             <span class=\"type\">const</span> InetAddress&amp; peerAddr)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"built_in\">CHECK_NOTNULL</span>(loop)),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">state_</span>(kConnecting),</span><br><span class=\"line\">    <span class=\"built_in\">reading_</span>(<span class=\"literal\">true</span>),</span><br><span class=\"line\">    <span class=\"built_in\">socket_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Socket</span>(sockfd)),</span><br><span class=\"line\">    <span class=\"built_in\">channel_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Channel</span>(loop, sockfd)),</span><br><span class=\"line\">    <span class=\"built_in\">localAddr_</span>(localAddr),</span><br><span class=\"line\">    <span class=\"built_in\">peerAddr_</span>(peerAddr),</span><br><span class=\"line\">    <span class=\"built_in\">highWaterMark_</span>(<span class=\"number\">64</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setReadCallback</span>(  <span class=\"comment\">// </span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleRead, <span class=\"keyword\">this</span>, _1));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setWriteCallback</span>( <span class=\"comment\">// </span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleWrite, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setCloseCallback</span>( <span class=\"comment\">// sockfd</span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleClose, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">setErrorCallback</span>( <span class=\"comment\">// </span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::handleError, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    LOG_DEBUG &lt;&lt; <span class=\"string\">&quot;TcpConnection::ctor[&quot;</span> &lt;&lt;  name_ &lt;&lt; <span class=\"string\">&quot;] at &quot;</span> &lt;&lt; <span class=\"keyword\">this</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot; fd=&quot;</span> &lt;&lt; sockfd;</span><br><span class=\"line\">    socket_-&gt;<span class=\"built_in\">setKeepAlive</span>(<span class=\"literal\">true</span>);    <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<ol>\n<li><p>ioloop<code>TcpConnection::connectEstablished()</code></p>\n<ol>\n<li><p>TcpConnection::state_kConnected</p>\n</li>\n<li><p>channel_TcpConnectionTcpConnectionchannel</p>\n</li>\n<li><p>ioloopPollerchannel_</p>\n</li>\n<li><p>TcpConnection::connectionCallback_</p>\n</li>\n<li><p></p>\n</li>\n</ol>\n</li>\n</ol>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::connectEstablished</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(state_ == kConnecting);</span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kConnected);</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">tie</span>(<span class=\"built_in\">shared_from_this</span>());</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">enableReading</span>();  <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(<span class=\"built_in\">shared_from_this</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p></p>\n<ol>\n<li><p>TcpConnection::inputBuffer_n</p>\n</li>\n<li><ul>\n<li>n &gt; 0TcpConnection::messageCallback_</li>\n<li>n &#x3D;&#x3D; 0TcpConnection::handleClose()</li>\n<li>n &lt; 0TcpConnection::handleError</li>\n</ul>\n</li>\n</ol>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::handleRead</span><span class=\"params\">(Timestamp receiveTime)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> savedErrno = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> n = inputBuffer_.<span class=\"built_in\">readFd</span>(channel_-&gt;<span class=\"built_in\">fd</span>(), &amp;savedErrno);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">messageCallback_</span>(<span class=\"built_in\">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">handleClose</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        errno = savedErrno;</span><br><span class=\"line\">        LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;TcpConnection::handleRead&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">handleError</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p></p>\n<ol>\n<li><p>TcpConnection::send</p>\n<ol>\n<li><p>ioloopTcpConnection::sendInLoop()ioloopTcpConnection::sendInLoop()</p>\n</li>\n<li><p>TcpConnection::sendInLoop()</p>\n<ol>\n<li><p>kDisconnected</p>\n</li>\n<li><p>::writeerrno &#x3D;&#x3D; EPIPE || errno &#x3D;&#x3D; ECONNRESET</p>\n</li>\n<li><p>writeCompleteCallback_outputBuffer_channel_outputBuffer_outputBuffer_highWaterMarkCallback_</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>sendInLoop</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::sendInLoop</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* data, <span class=\"type\">size_t</span> len)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> nwrote = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> remaining = len; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> faultError = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kDisconnected)&#123; <span class=\"comment\">// </span></span><br><span class=\"line\">        LOG_WARN &lt;&lt; <span class=\"string\">&quot;disconnected, give up writing&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// if no thing in output queue, try writing directly</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!channel_-&gt;<span class=\"built_in\">isWriting</span>() &amp;&amp; outputBuffer_.<span class=\"built_in\">readableBytes</span>() == <span class=\"number\">0</span>)&#123; <span class=\"comment\">// Pollerconn fd &amp;&amp; TcpConnection::outputBuffer_</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"comment\">// TCPPoller</span></span><br><span class=\"line\">        nwrote = sockets::<span class=\"built_in\">write</span>(channel_-&gt;<span class=\"built_in\">fd</span>(), data, len); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nwrote &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            remaining = len - nwrote;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remaining == <span class=\"number\">0</span> &amp;&amp; writeCompleteCallback_)&#123;</span><br><span class=\"line\">                loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(writeCompleteCallback_, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// nwrote &lt; 0</span></span><br><span class=\"line\">            nwrote = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (errno != EWOULDBLOCK)&#123;</span><br><span class=\"line\">                LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;TcpConnection::sendInLoop&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (errno == EPIPE || errno == ECONNRESET) &#123;<span class=\"comment\">// <span class=\"doctag\">FIXME:</span> any others?// socksockEPIPE || </span></span><br><span class=\"line\">                    faultError = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(remaining &lt;= len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!faultError &amp;&amp; remaining &gt; <span class=\"number\">0</span>)&#123;  <span class=\"comment\">// TCP</span></span><br><span class=\"line\">        <span class=\"type\">size_t</span> oldLen = outputBuffer_.<span class=\"built_in\">readableBytes</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldLen + remaining &gt;= highWaterMark_</span><br><span class=\"line\">            &amp;&amp; oldLen &lt; highWaterMark_</span><br><span class=\"line\">            &amp;&amp; highWaterMarkCallback_)&#123;</span><br><span class=\"line\">            loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(highWaterMarkCallback_, <span class=\"built_in\">shared_from_this</span>(), oldLen + remaining));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        outputBuffer_.<span class=\"built_in\">append</span>(<span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">const</span> <span class=\"type\">char</span>*&gt;(data)+nwrote, remaining);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!channel_-&gt;<span class=\"built_in\">isWriting</span>())&#123;</span><br><span class=\"line\">            channel_-&gt;<span class=\"built_in\">enableWriting</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p>Poller</p>\n<ol>\n<li><p>PollerTcpConnection::handleWrite()</p>\n<ol>\n<li><p>channel_-&gt;isWriting() &#x3D;&#x3D; true</p>\n</li>\n<li><p>::write()outputBuffer_</p>\n</li>\n<li><p>outputBuffer_cahnnel_writeCompleteCallback_ &amp;&amp; kDisconnectingshutdownInLoop()</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>handleWrite()</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::handleWrite</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel_-&gt;<span class=\"built_in\">isWriting</span>())&#123;</span><br><span class=\"line\">        <span class=\"type\">ssize_t</span> n = sockets::<span class=\"built_in\">write</span>(channel_-&gt;<span class=\"built_in\">fd</span>(),</span><br><span class=\"line\">                                outputBuffer_.<span class=\"built_in\">peek</span>(),</span><br><span class=\"line\">                                outputBuffer_.<span class=\"built_in\">readableBytes</span>());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            outputBuffer_.<span class=\"built_in\">retrieve</span>(n);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (outputBuffer_.<span class=\"built_in\">readableBytes</span>() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                channel_-&gt;<span class=\"built_in\">disableWriting</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (writeCompleteCallback_)&#123;</span><br><span class=\"line\">                    loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(writeCompleteCallback_, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (state_ == kDisconnecting)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">shutdownInLoop</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;TcpConnection::handleWrite&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_TRACE &lt;&lt; <span class=\"string\">&quot;Connection fd = &quot;</span> &lt;&lt; channel_-&gt;<span class=\"built_in\">fd</span>()</span><br><span class=\"line\">                &lt;&lt; <span class=\"string\">&quot; is down, no more writing&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p></p>\n<ol>\n<li><p>TcpConnection::forceClose</p>\n</li>\n<li><p>kDisconnecting </p>\n</li>\n<li><p>TcpConnection::forceCloseInLoop()</p>\n<ol>\n<li><p>handleClose()</p>\n<ol>\n<li><p>kDisconnected</p>\n</li>\n<li><p>channel_</p>\n</li>\n<li><p>connectionCallback_</p>\n</li>\n<li><p>closeCallback_TcpServer</p>\n</li>\n<li><p>TcpConnection::connectDestroyed</p>\n<ul>\n<li>channelPoller</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::forceClose</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use compare and swap</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnected || state_ == kDisconnecting)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setState</span>(kDisconnecting);</span><br><span class=\"line\">        loop_-&gt;<span class=\"built_in\">queueInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::forceCloseInLoop, <span class=\"built_in\">shared_from_this</span>()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::forceCloseInLoop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnected || state_ == kDisconnecting)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// as if we received 0 byte in handleRead();</span></span><br><span class=\"line\">        <span class=\"built_in\">handleClose</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::handleClose</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;fd = &quot;</span> &lt;&lt; channel_-&gt;<span class=\"built_in\">fd</span>() &lt;&lt; <span class=\"string\">&quot; state = &quot;</span> &lt;&lt; <span class=\"built_in\">stateToString</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(state_ == kConnected || state_ == kDisconnecting);</span><br><span class=\"line\">    <span class=\"comment\">// we don&#x27;t close fd, leave it to dtor, so we can find leaks easily.</span></span><br><span class=\"line\">    <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">guardThis</span><span class=\"params\">(shared_from_this())</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(guardThis);   <span class=\"comment\">// connectionCallback_TcpServer</span></span><br><span class=\"line\">    <span class=\"comment\">// must be the last line</span></span><br><span class=\"line\">    <span class=\"built_in\">closeCallback_</span>(guardThis);    <span class=\"comment\">// closeCallback_TcpServer</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpConnection::connectDestroyed</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state_ == kConnected)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setState</span>(kDisconnected);</span><br><span class=\"line\">        channel_-&gt;<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">connectionCallback_</span>(<span class=\"built_in\">shared_from_this</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    channel_-&gt;<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<ul>\n<li><p>TcpConnection::handleReadread0handleClose</p>\n</li>\n<li><p>Channel::handleEventWithGuardchannel_POLLHUPhandleClose</p>\n</li>\n</ul>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<p> muduo  shutdown() TCP</p>\n<p><strong></strong></p>\n<p> shutdown  close  muduo muduo  TCP </p>\n<p> shutdownWrite TCP FIN  0  muduo  0  muduo </p>\n<p><a href=\"https://blog.csdn.net/Solstice/article/details/6208634\">https://blog.csdn.net/Solstice/article/details/6208634</a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>MuduoMuduo</p>\n<p>sylarLevelDBLevelDB</p>\n<hr>\n<p><strong></strong></p>"},{"title":"muduo9TcpServer","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\n\n\n1. TcpServer.h/ccReactorTcpServerEventLoopsock fdIOLoop\n\n2. Acceptor.h/ccChannel\n\n3. Socket.h/ccsocketsocket\n\n4. SocketsOps.h/ccSocket.h/cc::socket()/::accept()socketfd\n\n5. InetAddress.h/ccsockaddr_in/sockaddr_in6\n\n12345\n\n## Acceptor\n\n****\n<!-- more -->\n\n```cpp\n///\n/// Acceptor of incoming TCP connections.\n///\nclass Acceptor : noncopyable{\npublic:\n    typedef std::function<void (int sockfd, const InetAddress&)> NewConnectionCallback;\n\n    Acceptor(EventLoop* loop, const InetAddress& listenAddr, bool reuseport);\n    ~Acceptor();\n\n    void setNewConnectionCallback(const NewConnectionCallback& cb)\n    { newConnectionCallback_ = cb; }\n\n    void listen();\n\n    bool listening() const { return listening_; }\n\n    // Deprecated, use the correct spelling one above.\n    // Leave the wrong spelling here in case one needs to grep it for error messages.\n    // bool listenning() const { return listening(); }\n\nprivate:\n    void handleRead();\n\n    EventLoop* loop_; // EventLoop\n    Socket acceptSocket_; // accept sock fd\n    Channel acceptChannel_; // accept sock fd channel\n    NewConnectionCallback newConnectionCallback_;   // sock fd\n    bool listening_;  // accept sock fdlisten\n    int idleFd_;  // fd\n};\n```\n\nAcceptorTimeQueue\n\n\n****\n\n```cpp\nAcceptor::Acceptor(EventLoop* loop, const InetAddress& listenAddr, bool reuseport)\n  : loop_(loop),\n    acceptSocket_(sockets::createNonblockingOrDie(listenAddr.family())),\n    acceptChannel_(loop, acceptSocket_.fd()),\n    listening_(false),\n    idleFd_(::open(\"/dev/null\", O_RDONLY | O_CLOEXEC)){\n\n    assert(idleFd_ >= 0);\n    acceptSocket_.setReuseAddr(true);       // \n    acceptSocket_.setReusePort(reuseport);  // \n    acceptSocket_.bindAddress(listenAddr);  // \n    acceptChannel_.setReadCallback(         // \n        std::bind(&Acceptor::handleRead, this));\n}\n\nAcceptor::~Acceptor(){\n    acceptChannel_.disableAll();\n    acceptChannel_.remove();\n    ::close(idleFd_);\n}\n\nvoid Acceptor::listen(){\n    loop_->assertInLoopThread();\n    listening_ = true;\n    acceptSocket_.listen(); // sock fd listen\n    acceptChannel_.enableReading(); // Pollersock fd\n}\n\nvoid Acceptor::handleRead(){\n    loop_->assertInLoopThread();\n    InetAddress peerAddr;\n    //FIXME loop until no more\n    int connfd = acceptSocket_.accept(&peerAddr);\n    if (connfd >= 0){\n        // string hostport = peerAddr.toIpPort();\n        // LOG_TRACE << \"Accepts of \" << hostport;\n        if (newConnectionCallback_){\n            newConnectionCallback_(connfd, peerAddr);   // \n        }else{\n            sockets::close(connfd);\n        }\n    }else{\n        LOG_SYSERR << \"in Acceptor::handleRead\";\n        // Read the section named \"The special problem of\n        // accept()ing when you can't\" in libev's doc.\n        // By Marc Lehmann, author of libev.\n        if (errno == EMFILE) { // \n            ::close(idleFd_);   // idleFd_idleFd_\n            idleFd_ = ::accept(acceptSocket_.fd(), NULL, NULL); // \n            // \n            ::close(idleFd_);\n            idleFd_ = ::open(\"/dev/null\", O_RDONLY | O_CLOEXEC);    // fd\n        }\n    }\n}\n```\n\n### \n\n****\n\nAcceptor::idleFd_Acceptor::handleReadEMFILEidleFd_::acceptidleFd_idleFd_\n\n****\n\nEMFILE idleFd_  ::accept  ::accept idleFd_\n\n## TcpServer\n\n****\n\n```cpp\n///\n/// TCP server, supports single-threaded and thread-pool models.\n///\n/// This is an interface class, so don't expose too much details.\nclass TcpServer : noncopyable{\npublic:\n    typedef std::function<void(EventLoop*)> ThreadInitCallback;\n    enum Option{\n        kNoReusePort,\n        kReusePort,\n    };\n    TcpServer(EventLoop* loop,\n            const InetAddress& listenAddr,\n            const string& nameArg,\n            Option option = kNoReusePort);\n    ~TcpServer();  // force out-line dtor, for std::unique_ptr members.\n\n    const string& ipPort() const { return ipPort_; }\n    const string& name() const { return name_; }\n    EventLoop* getLoop() const { return loop_; }\n\n    // start\n    void setThreadNum(int numThreads);\n    void setThreadInitCallback(const ThreadInitCallback& cb)\n    { threadInitCallback_ = cb; }\n    /// valid after calling start()\n    std::shared_ptr<EventLoopThreadPool> threadPool()\n    { return threadPool_; }\n\n    /// Starts the server if it's not listening.\n    ///\n    /// It's harmless to call it multiple times.\n    /// Thread safe.\n    void start();\n\n    /// Set connection callback.\n    /// Not thread safe.\n    void setConnectionCallback(const ConnectionCallback& cb)\n    { connectionCallback_ = cb; }\n\n    /// Set message callback.\n    /// Not thread safe.\n    void setMessageCallback(const MessageCallback& cb)\n    { messageCallback_ = cb; }\n\n    /// Set write complete callback.\n    /// Not thread safe.\n    void setWriteCompleteCallback(const WriteCompleteCallback& cb)\n    { writeCompleteCallback_ = cb; }\n\nprivate:\n    /// Not thread safe, but in loop\n    void newConnection(int sockfd, const InetAddress& peerAddr);\n    /// Thread safe.\n    void removeConnection(const TcpConnectionPtr& conn);\n    /// Not thread safe, but in loop\n    void removeConnectionInLoop(const TcpConnectionPtr& conn);\n\n    typedef std::map<string, TcpConnectionPtr> ConnectionMap;\n\n    EventLoop* loop_;  // the acceptor loop\n    const string ipPort_; // ip:port\n    const string name_; // TcpServer Name\n    std::unique_ptr<Acceptor> acceptor_; // avoid revealing Acceptor\n    std::shared_ptr<EventLoopThreadPool> threadPool_; // \n    ConnectionCallback connectionCallback_; // \n    MessageCallback messageCallback_;   // \n    WriteCompleteCallback writeCompleteCallback_;   // \n    ThreadInitCallback threadInitCallback_;\n    AtomicInt32 started_; // TcpServer\n    // always in loop thread\n    int nextConnId_;  // \n    ConnectionMap connections_; // \n};\n```\n\nTcpServer\n\n![TcpServer](./TcpServer/photo/TcpServer.drawio.png)\n\n\n\n1. \n\n2. listenEventLoopbase loopio\n\n3. base loop EventLoopThreadPoolio EventLoopioloop\n\n4. loopTCP\n\n---\n\n****\n\n```cpp\n\nTcpServer::TcpServer(EventLoop* loop,\n                     const InetAddress& listenAddr,\n                     const string& nameArg,\n                     Option option)\n  : loop_(CHECK_NOTNULL(loop)),\n    ipPort_(listenAddr.toIpPort()),\n    name_(nameArg),\n    acceptor_(new Acceptor(loop, listenAddr, option == kReusePort)),\n    threadPool_(new EventLoopThreadPool(loop, name_)),\n    connectionCallback_(defaultConnectionCallback),\n    messageCallback_(defaultMessageCallback),\n    nextConnId_(1){\n\n    acceptor_->setNewConnectionCallback(    // \n        std::bind(&TcpServer::newConnection, this, _1, _2));    \n}\n\nTcpServer::~TcpServer(){\n    loop_->assertInLoopThread();\n    LOG_TRACE << \"TcpServer::~TcpServer [\" << name_ << \"] destructing\";\n\n    for (auto& item : connections_){\n        TcpConnectionPtr conn(item.second);\n        item.second.reset();    // \n        conn->getLoop()->runInLoop( // loop\n            std::bind(&TcpConnection::connectDestroyed, conn));\n    }\n}\n// start\nvoid TcpServer::setThreadNum(int numThreads){\n    assert(0 <= numThreads);\n    threadPool_->setThreadNum(numThreads);\n}\n\nvoid TcpServer::start(){\n    if (started_.getAndSet(1) == 0){\n    threadPool_->start(threadInitCallback_);\n\n    assert(!acceptor_->listening());\n    loop_->runInLoop(\n        std::bind(&Acceptor::listen, get_pointer(acceptor_)));  // get_pointer(acceptor_)\n    }\n}\n\nvoid TcpServer::newConnection(int sockfd, const InetAddress& peerAddr){\n    loop_->assertInLoopThread();\n    EventLoop* ioLoop = threadPool_->getNextLoop();\n    char buf[64];\n    snprintf(buf, sizeof buf, \"-%s#%d\", ipPort_.c_str(), nextConnId_);\n    ++nextConnId_;\n    string connName = name_ + buf;\n\n    LOG_INFO << \"TcpServer::newConnection [\" << name_\n            << \"] - new connection [\" << connName\n            << \"] from \" << peerAddr.toIpPort();\n    InetAddress localAddr(sockets::getLocalAddr(sockfd));\n    // FIXME poll with zero timeout to double confirm the new connection\n    // FIXME use make_shared if necessary\n    TcpConnectionPtr conn(new TcpConnection(ioLoop,\n                                            connName,\n                                            sockfd,\n                                            localAddr,\n                                            peerAddr));\n    connections_[connName] = conn;\n    conn->setConnectionCallback(connectionCallback_);\n    conn->setMessageCallback(messageCallback_);\n    conn->setWriteCompleteCallback(writeCompleteCallback_);\n    conn->setCloseCallback(\n        std::bind(&TcpServer::removeConnection, this, _1)); // FIXME: unsafe\n    ioLoop->runInLoop(std::bind(&TcpConnection::connectEstablished, conn));\n}\n\nvoid TcpServer::removeConnection(const TcpConnectionPtr& conn){\n    // FIXME: unsafe\n    loop_->runInLoop(std::bind(&TcpServer::removeConnectionInLoop, this, conn));    // connbind\n}\n\nvoid TcpServer::removeConnectionInLoop(const TcpConnectionPtr& conn){\n    loop_->assertInLoopThread();\n    LOG_INFO << \"TcpServer::removeConnectionInLoop [\" << name_\n            << \"] - connection \" << conn->name();\n    size_t n = connections_.erase(conn->name());\n    (void)n;\n    assert(n == 1);\n    EventLoop* ioLoop = conn->getLoop();\n    ioLoop->queueInLoop(\n        std::bind(&TcpConnection::connectDestroyed, conn));\n}\n```\n\n****\n\n\n\n1. base looplistenAcceptor::handleReadAcceptor::acceptChannel_\n\n2. ::acceptsockfdsockfdAcceptor::newConnectionCallback_TcpServer::newConnectionTcpServer\n\n3. ioloopconnect namesockfdioloopTcpConnection **<key : connect name, value : TcpConnection>** TcpServer::connections_TcpConnectionioloopTcpConnection::connectEstablishedTcpConnection\n\n4. TcpConnection::connectEstablished\n\n\n\n\n1. TcpConnection::closeCallback_TcpServer::removeConnectionTcpConnection\n\n2. base loopTcpServer::removeConnectionInLoopTcpConnection\n\n3. TcpServer::removeConnectionInLoopTcpConnectionnameTcpServer::connections_TcpConnectionioloopTcpConnection::connectDestroyedTcpConnection\n\n****","source":"_posts/muduo/TcpServer.md","raw":"---\ntitle: muduo9TcpServer\ndate: 2024-11-02 12:00:00\ntags:\n  - \n---\n\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\n\n\n1. TcpServer.h/ccReactorTcpServerEventLoopsock fdIOLoop\n\n2. Acceptor.h/ccChannel\n\n3. Socket.h/ccsocketsocket\n\n4. SocketsOps.h/ccSocket.h/cc::socket()/::accept()socketfd\n\n5. InetAddress.h/ccsockaddr_in/sockaddr_in6\n\n12345\n\n## Acceptor\n\n****\n<!-- more -->\n\n```cpp\n///\n/// Acceptor of incoming TCP connections.\n///\nclass Acceptor : noncopyable{\npublic:\n    typedef std::function<void (int sockfd, const InetAddress&)> NewConnectionCallback;\n\n    Acceptor(EventLoop* loop, const InetAddress& listenAddr, bool reuseport);\n    ~Acceptor();\n\n    void setNewConnectionCallback(const NewConnectionCallback& cb)\n    { newConnectionCallback_ = cb; }\n\n    void listen();\n\n    bool listening() const { return listening_; }\n\n    // Deprecated, use the correct spelling one above.\n    // Leave the wrong spelling here in case one needs to grep it for error messages.\n    // bool listenning() const { return listening(); }\n\nprivate:\n    void handleRead();\n\n    EventLoop* loop_; // EventLoop\n    Socket acceptSocket_; // accept sock fd\n    Channel acceptChannel_; // accept sock fd channel\n    NewConnectionCallback newConnectionCallback_;   // sock fd\n    bool listening_;  // accept sock fdlisten\n    int idleFd_;  // fd\n};\n```\n\nAcceptorTimeQueue\n\n\n****\n\n```cpp\nAcceptor::Acceptor(EventLoop* loop, const InetAddress& listenAddr, bool reuseport)\n  : loop_(loop),\n    acceptSocket_(sockets::createNonblockingOrDie(listenAddr.family())),\n    acceptChannel_(loop, acceptSocket_.fd()),\n    listening_(false),\n    idleFd_(::open(\"/dev/null\", O_RDONLY | O_CLOEXEC)){\n\n    assert(idleFd_ >= 0);\n    acceptSocket_.setReuseAddr(true);       // \n    acceptSocket_.setReusePort(reuseport);  // \n    acceptSocket_.bindAddress(listenAddr);  // \n    acceptChannel_.setReadCallback(         // \n        std::bind(&Acceptor::handleRead, this));\n}\n\nAcceptor::~Acceptor(){\n    acceptChannel_.disableAll();\n    acceptChannel_.remove();\n    ::close(idleFd_);\n}\n\nvoid Acceptor::listen(){\n    loop_->assertInLoopThread();\n    listening_ = true;\n    acceptSocket_.listen(); // sock fd listen\n    acceptChannel_.enableReading(); // Pollersock fd\n}\n\nvoid Acceptor::handleRead(){\n    loop_->assertInLoopThread();\n    InetAddress peerAddr;\n    //FIXME loop until no more\n    int connfd = acceptSocket_.accept(&peerAddr);\n    if (connfd >= 0){\n        // string hostport = peerAddr.toIpPort();\n        // LOG_TRACE << \"Accepts of \" << hostport;\n        if (newConnectionCallback_){\n            newConnectionCallback_(connfd, peerAddr);   // \n        }else{\n            sockets::close(connfd);\n        }\n    }else{\n        LOG_SYSERR << \"in Acceptor::handleRead\";\n        // Read the section named \"The special problem of\n        // accept()ing when you can't\" in libev's doc.\n        // By Marc Lehmann, author of libev.\n        if (errno == EMFILE) { // \n            ::close(idleFd_);   // idleFd_idleFd_\n            idleFd_ = ::accept(acceptSocket_.fd(), NULL, NULL); // \n            // \n            ::close(idleFd_);\n            idleFd_ = ::open(\"/dev/null\", O_RDONLY | O_CLOEXEC);    // fd\n        }\n    }\n}\n```\n\n### \n\n****\n\nAcceptor::idleFd_Acceptor::handleReadEMFILEidleFd_::acceptidleFd_idleFd_\n\n****\n\nEMFILE idleFd_  ::accept  ::accept idleFd_\n\n## TcpServer\n\n****\n\n```cpp\n///\n/// TCP server, supports single-threaded and thread-pool models.\n///\n/// This is an interface class, so don't expose too much details.\nclass TcpServer : noncopyable{\npublic:\n    typedef std::function<void(EventLoop*)> ThreadInitCallback;\n    enum Option{\n        kNoReusePort,\n        kReusePort,\n    };\n    TcpServer(EventLoop* loop,\n            const InetAddress& listenAddr,\n            const string& nameArg,\n            Option option = kNoReusePort);\n    ~TcpServer();  // force out-line dtor, for std::unique_ptr members.\n\n    const string& ipPort() const { return ipPort_; }\n    const string& name() const { return name_; }\n    EventLoop* getLoop() const { return loop_; }\n\n    // start\n    void setThreadNum(int numThreads);\n    void setThreadInitCallback(const ThreadInitCallback& cb)\n    { threadInitCallback_ = cb; }\n    /// valid after calling start()\n    std::shared_ptr<EventLoopThreadPool> threadPool()\n    { return threadPool_; }\n\n    /// Starts the server if it's not listening.\n    ///\n    /// It's harmless to call it multiple times.\n    /// Thread safe.\n    void start();\n\n    /// Set connection callback.\n    /// Not thread safe.\n    void setConnectionCallback(const ConnectionCallback& cb)\n    { connectionCallback_ = cb; }\n\n    /// Set message callback.\n    /// Not thread safe.\n    void setMessageCallback(const MessageCallback& cb)\n    { messageCallback_ = cb; }\n\n    /// Set write complete callback.\n    /// Not thread safe.\n    void setWriteCompleteCallback(const WriteCompleteCallback& cb)\n    { writeCompleteCallback_ = cb; }\n\nprivate:\n    /// Not thread safe, but in loop\n    void newConnection(int sockfd, const InetAddress& peerAddr);\n    /// Thread safe.\n    void removeConnection(const TcpConnectionPtr& conn);\n    /// Not thread safe, but in loop\n    void removeConnectionInLoop(const TcpConnectionPtr& conn);\n\n    typedef std::map<string, TcpConnectionPtr> ConnectionMap;\n\n    EventLoop* loop_;  // the acceptor loop\n    const string ipPort_; // ip:port\n    const string name_; // TcpServer Name\n    std::unique_ptr<Acceptor> acceptor_; // avoid revealing Acceptor\n    std::shared_ptr<EventLoopThreadPool> threadPool_; // \n    ConnectionCallback connectionCallback_; // \n    MessageCallback messageCallback_;   // \n    WriteCompleteCallback writeCompleteCallback_;   // \n    ThreadInitCallback threadInitCallback_;\n    AtomicInt32 started_; // TcpServer\n    // always in loop thread\n    int nextConnId_;  // \n    ConnectionMap connections_; // \n};\n```\n\nTcpServer\n\n![TcpServer](./TcpServer/photo/TcpServer.drawio.png)\n\n\n\n1. \n\n2. listenEventLoopbase loopio\n\n3. base loop EventLoopThreadPoolio EventLoopioloop\n\n4. loopTCP\n\n---\n\n****\n\n```cpp\n\nTcpServer::TcpServer(EventLoop* loop,\n                     const InetAddress& listenAddr,\n                     const string& nameArg,\n                     Option option)\n  : loop_(CHECK_NOTNULL(loop)),\n    ipPort_(listenAddr.toIpPort()),\n    name_(nameArg),\n    acceptor_(new Acceptor(loop, listenAddr, option == kReusePort)),\n    threadPool_(new EventLoopThreadPool(loop, name_)),\n    connectionCallback_(defaultConnectionCallback),\n    messageCallback_(defaultMessageCallback),\n    nextConnId_(1){\n\n    acceptor_->setNewConnectionCallback(    // \n        std::bind(&TcpServer::newConnection, this, _1, _2));    \n}\n\nTcpServer::~TcpServer(){\n    loop_->assertInLoopThread();\n    LOG_TRACE << \"TcpServer::~TcpServer [\" << name_ << \"] destructing\";\n\n    for (auto& item : connections_){\n        TcpConnectionPtr conn(item.second);\n        item.second.reset();    // \n        conn->getLoop()->runInLoop( // loop\n            std::bind(&TcpConnection::connectDestroyed, conn));\n    }\n}\n// start\nvoid TcpServer::setThreadNum(int numThreads){\n    assert(0 <= numThreads);\n    threadPool_->setThreadNum(numThreads);\n}\n\nvoid TcpServer::start(){\n    if (started_.getAndSet(1) == 0){\n    threadPool_->start(threadInitCallback_);\n\n    assert(!acceptor_->listening());\n    loop_->runInLoop(\n        std::bind(&Acceptor::listen, get_pointer(acceptor_)));  // get_pointer(acceptor_)\n    }\n}\n\nvoid TcpServer::newConnection(int sockfd, const InetAddress& peerAddr){\n    loop_->assertInLoopThread();\n    EventLoop* ioLoop = threadPool_->getNextLoop();\n    char buf[64];\n    snprintf(buf, sizeof buf, \"-%s#%d\", ipPort_.c_str(), nextConnId_);\n    ++nextConnId_;\n    string connName = name_ + buf;\n\n    LOG_INFO << \"TcpServer::newConnection [\" << name_\n            << \"] - new connection [\" << connName\n            << \"] from \" << peerAddr.toIpPort();\n    InetAddress localAddr(sockets::getLocalAddr(sockfd));\n    // FIXME poll with zero timeout to double confirm the new connection\n    // FIXME use make_shared if necessary\n    TcpConnectionPtr conn(new TcpConnection(ioLoop,\n                                            connName,\n                                            sockfd,\n                                            localAddr,\n                                            peerAddr));\n    connections_[connName] = conn;\n    conn->setConnectionCallback(connectionCallback_);\n    conn->setMessageCallback(messageCallback_);\n    conn->setWriteCompleteCallback(writeCompleteCallback_);\n    conn->setCloseCallback(\n        std::bind(&TcpServer::removeConnection, this, _1)); // FIXME: unsafe\n    ioLoop->runInLoop(std::bind(&TcpConnection::connectEstablished, conn));\n}\n\nvoid TcpServer::removeConnection(const TcpConnectionPtr& conn){\n    // FIXME: unsafe\n    loop_->runInLoop(std::bind(&TcpServer::removeConnectionInLoop, this, conn));    // connbind\n}\n\nvoid TcpServer::removeConnectionInLoop(const TcpConnectionPtr& conn){\n    loop_->assertInLoopThread();\n    LOG_INFO << \"TcpServer::removeConnectionInLoop [\" << name_\n            << \"] - connection \" << conn->name();\n    size_t n = connections_.erase(conn->name());\n    (void)n;\n    assert(n == 1);\n    EventLoop* ioLoop = conn->getLoop();\n    ioLoop->queueInLoop(\n        std::bind(&TcpConnection::connectDestroyed, conn));\n}\n```\n\n****\n\n\n\n1. base looplistenAcceptor::handleReadAcceptor::acceptChannel_\n\n2. ::acceptsockfdsockfdAcceptor::newConnectionCallback_TcpServer::newConnectionTcpServer\n\n3. ioloopconnect namesockfdioloopTcpConnection **<key : connect name, value : TcpConnection>** TcpServer::connections_TcpConnectionioloopTcpConnection::connectEstablishedTcpConnection\n\n4. TcpConnection::connectEstablished\n\n\n\n\n1. TcpConnection::closeCallback_TcpServer::removeConnectionTcpConnection\n\n2. base loopTcpServer::removeConnectionInLoopTcpConnection\n\n3. TcpServer::removeConnectionInLoopTcpConnectionnameTcpServer::connections_TcpConnectionioloopTcpConnection::connectDestroyedTcpConnection\n\n****","slug":"muduo/TcpServer","published":1,"updated":"2025-09-28T16:06:43.130Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9r000mq8wsbnlaectd","content":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p></p>\n<ol>\n<li><p>TcpServer.h&#x2F;ccReactorTcpServerEventLoopsock fdIOLoop</p>\n</li>\n<li><p>Acceptor.h&#x2F;ccChannel</p>\n</li>\n<li><p>Socket.h&#x2F;ccsocketsocket</p>\n</li>\n<li><p>SocketsOps.h&#x2F;ccSocket.h&#x2F;cc::socket()&#x2F;::accept()socketfd</p>\n</li>\n<li><p>InetAddress.h&#x2F;ccsockaddr_in&#x2F;sockaddr_in6</p>\n</li>\n</ol>\n<p>12345</p>\n<h2 id=\"Acceptor\"><a href=\"#Acceptor\" class=\"headerlink\" title=\"Acceptor\"></a>Acceptor</h2><p><strong></strong></p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// Acceptor of incoming TCP connections.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Acceptor</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> (<span class=\"type\">int</span> sockfd, <span class=\"type\">const</span> InetAddress&amp;)&gt; NewConnectionCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Acceptor</span>(EventLoop* loop, <span class=\"type\">const</span> InetAddress&amp; listenAddr, <span class=\"type\">bool</span> reuseport);</span><br><span class=\"line\">    ~<span class=\"built_in\">Acceptor</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setNewConnectionCallback</span><span class=\"params\">(<span class=\"type\">const</span> NewConnectionCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; newConnectionCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">listen</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">listening</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> listening_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Deprecated, use the correct spelling one above.</span></span><br><span class=\"line\">    <span class=\"comment\">// Leave the wrong spelling here in case one needs to grep it for error messages.</span></span><br><span class=\"line\">    <span class=\"comment\">// bool listenning() const &#123; return listening(); &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">    Socket acceptSocket_; <span class=\"comment\">// accept sock fd</span></span><br><span class=\"line\">    Channel acceptChannel_; <span class=\"comment\">// accept sock fd channel</span></span><br><span class=\"line\">    NewConnectionCallback newConnectionCallback_;   <span class=\"comment\">// sock fd</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> listening_;  <span class=\"comment\">// accept sock fdlisten</span></span><br><span class=\"line\">    <span class=\"type\">int</span> idleFd_;  <span class=\"comment\">// fd</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>AcceptorTimeQueue</p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Acceptor::<span class=\"built_in\">Acceptor</span>(EventLoop* loop, <span class=\"type\">const</span> InetAddress&amp; listenAddr, <span class=\"type\">bool</span> reuseport)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(loop),</span><br><span class=\"line\">    <span class=\"built_in\">acceptSocket_</span>(sockets::<span class=\"built_in\">createNonblockingOrDie</span>(listenAddr.<span class=\"built_in\">family</span>())),</span><br><span class=\"line\">    <span class=\"built_in\">acceptChannel_</span>(loop, acceptSocket_.<span class=\"built_in\">fd</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">listening_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">idleFd_</span>(::<span class=\"built_in\">open</span>(<span class=\"string\">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(idleFd_ &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">setReuseAddr</span>(<span class=\"literal\">true</span>);       <span class=\"comment\">// </span></span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">setReusePort</span>(reuseport);  <span class=\"comment\">// </span></span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">bindAddress</span>(listenAddr);  <span class=\"comment\">// </span></span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">setReadCallback</span>(         <span class=\"comment\">// </span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Acceptor::handleRead, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Acceptor::~<span class=\"built_in\">Acceptor</span>()&#123;</span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    ::<span class=\"built_in\">close</span>(idleFd_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Acceptor::listen</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    listening_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">listen</span>(); <span class=\"comment\">// sock fd listen</span></span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">enableReading</span>(); <span class=\"comment\">// Pollersock fd</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Acceptor::handleRead</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    InetAddress peerAddr;</span><br><span class=\"line\">    <span class=\"comment\">//FIXME loop until no more</span></span><br><span class=\"line\">    <span class=\"type\">int</span> connfd = acceptSocket_.<span class=\"built_in\">accept</span>(&amp;peerAddr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connfd &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// string hostport = peerAddr.toIpPort();</span></span><br><span class=\"line\">        <span class=\"comment\">// LOG_TRACE &lt;&lt; &quot;Accepts of &quot; &lt;&lt; hostport;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newConnectionCallback_)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">newConnectionCallback_</span>(connfd, peerAddr);   <span class=\"comment\">// </span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            sockets::<span class=\"built_in\">close</span>(connfd);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;in Acceptor::handleRead&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Read the section named &quot;The special problem of</span></span><br><span class=\"line\">        <span class=\"comment\">// accept()ing when you can&#x27;t&quot; in libev&#x27;s doc.</span></span><br><span class=\"line\">        <span class=\"comment\">// By Marc Lehmann, author of libev.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EMFILE) &#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(idleFd_);   <span class=\"comment\">// idleFd_idleFd_</span></span><br><span class=\"line\">            idleFd_ = ::<span class=\"built_in\">accept</span>(acceptSocket_.<span class=\"built_in\">fd</span>(), <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>); <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"comment\">// </span></span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(idleFd_);</span><br><span class=\"line\">            idleFd_ = ::<span class=\"built_in\">open</span>(<span class=\"string\">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);    <span class=\"comment\">// fd</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p><strong></strong></p>\n<p>Acceptor::idleFd_Acceptor::handleReadEMFILEidleFd_::acceptidleFd_idleFd_</p>\n<p><strong></strong></p>\n<p>EMFILE idleFd_  ::accept  ::accept idleFd_</p>\n<h2 id=\"TcpServer\"><a href=\"#TcpServer\" class=\"headerlink\" title=\"TcpServer\"></a>TcpServer</h2><p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// TCP server, supports single-threaded and thread-pool models.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// This is an interface class, so don&#x27;t expose too much details.</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TcpServer</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(EventLoop*)&gt; ThreadInitCallback;</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"title class_\">Option</span>&#123;</span><br><span class=\"line\">        kNoReusePort,</span><br><span class=\"line\">        kReusePort,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">TcpServer</span>(EventLoop* loop,</span><br><span class=\"line\">            <span class=\"type\">const</span> InetAddress&amp; listenAddr,</span><br><span class=\"line\">            <span class=\"type\">const</span> string&amp; nameArg,</span><br><span class=\"line\">            Option option = kNoReusePort);</span><br><span class=\"line\">    ~<span class=\"built_in\">TcpServer</span>();  <span class=\"comment\">// force out-line dtor, for std::unique_ptr members.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">ipPort</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> ipPort_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getLoop</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> loop_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// start</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadNum</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadInitCallback</span><span class=\"params\">(<span class=\"type\">const</span> ThreadInitCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; threadInitCallback_ = cb; &#125;</span><br><span class=\"line\">    <span class=\"comment\">/// valid after calling start()</span></span><br><span class=\"line\">    <span class=\"function\">std::shared_ptr&lt;EventLoopThreadPool&gt; <span class=\"title\">threadPool</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> threadPool_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Starts the server if it&#x27;s not listening.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// It&#x27;s harmless to call it multiple times.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set connection callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setConnectionCallback</span><span class=\"params\">(<span class=\"type\">const</span> ConnectionCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; connectionCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set message callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setMessageCallback</span><span class=\"params\">(<span class=\"type\">const</span> MessageCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; messageCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set write complete callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWriteCompleteCallback</span><span class=\"params\">(<span class=\"type\">const</span> WriteCompleteCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; writeCompleteCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">const</span> InetAddress&amp; peerAddr)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeConnectionInLoop</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::map&lt;string, TcpConnectionPtr&gt; ConnectionMap;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_;  <span class=\"comment\">// the acceptor loop</span></span><br><span class=\"line\">    <span class=\"type\">const</span> string ipPort_; <span class=\"comment\">// ip:port</span></span><br><span class=\"line\">    <span class=\"type\">const</span> string name_; <span class=\"comment\">// TcpServer Name</span></span><br><span class=\"line\">    std::unique_ptr&lt;Acceptor&gt; acceptor_; <span class=\"comment\">// avoid revealing Acceptor</span></span><br><span class=\"line\">    std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_; <span class=\"comment\">// </span></span><br><span class=\"line\">    ConnectionCallback connectionCallback_; <span class=\"comment\">// </span></span><br><span class=\"line\">    MessageCallback messageCallback_;   <span class=\"comment\">// </span></span><br><span class=\"line\">    WriteCompleteCallback writeCompleteCallback_;   <span class=\"comment\">// </span></span><br><span class=\"line\">    ThreadInitCallback threadInitCallback_;</span><br><span class=\"line\">    AtomicInt32 started_; <span class=\"comment\">// TcpServer</span></span><br><span class=\"line\">    <span class=\"comment\">// always in loop thread</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nextConnId_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    ConnectionMap connections_; <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>TcpServer</p>\n<p><img src=\"/2024/11/02/muduo/TcpServer/photo/TcpServer.drawio.png\" alt=\"TcpServer\"></p>\n<p></p>\n<ol>\n<li><p></p>\n</li>\n<li><p>listenEventLoopbase loopio</p>\n</li>\n<li><p>base loop EventLoopThreadPoolio EventLoopioloop</p>\n</li>\n<li><p>loopTCP</p>\n</li>\n</ol>\n<hr>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">TcpServer::<span class=\"built_in\">TcpServer</span>(EventLoop* loop,</span><br><span class=\"line\">                     <span class=\"type\">const</span> InetAddress&amp; listenAddr,</span><br><span class=\"line\">                     <span class=\"type\">const</span> string&amp; nameArg,</span><br><span class=\"line\">                     Option option)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"built_in\">CHECK_NOTNULL</span>(loop)),</span><br><span class=\"line\">    <span class=\"built_in\">ipPort_</span>(listenAddr.<span class=\"built_in\">toIpPort</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">acceptor_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Acceptor</span>(loop, listenAddr, option == kReusePort)),</span><br><span class=\"line\">    <span class=\"built_in\">threadPool_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">EventLoopThreadPool</span>(loop, name_)),</span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(defaultConnectionCallback),</span><br><span class=\"line\">    <span class=\"built_in\">messageCallback_</span>(defaultMessageCallback),</span><br><span class=\"line\">    <span class=\"built_in\">nextConnId_</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    acceptor_-&gt;<span class=\"built_in\">setNewConnectionCallback</span>(    <span class=\"comment\">// </span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpServer::newConnection, <span class=\"keyword\">this</span>, _1, _2));    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TcpServer::~<span class=\"built_in\">TcpServer</span>()&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;TcpServer::~TcpServer [&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;] destructing&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; item : connections_)&#123;</span><br><span class=\"line\">        <span class=\"function\">TcpConnectionPtr <span class=\"title\">conn</span><span class=\"params\">(item.second)</span></span>;</span><br><span class=\"line\">        item.second.<span class=\"built_in\">reset</span>();    <span class=\"comment\">// </span></span><br><span class=\"line\">        conn-&gt;<span class=\"built_in\">getLoop</span>()-&gt;<span class=\"built_in\">runInLoop</span>( <span class=\"comment\">// loop</span></span><br><span class=\"line\">            std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// start</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::setThreadNum</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"number\">0</span> &lt;= numThreads);</span><br><span class=\"line\">    threadPool_-&gt;<span class=\"built_in\">setThreadNum</span>(numThreads);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (started_.<span class=\"built_in\">getAndSet</span>(<span class=\"number\">1</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    threadPool_-&gt;<span class=\"built_in\">start</span>(threadInitCallback_);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!acceptor_-&gt;<span class=\"built_in\">listening</span>());</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Acceptor::listen, <span class=\"built_in\">get_pointer</span>(acceptor_)));  <span class=\"comment\">// get_pointer(acceptor_)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">const</span> InetAddress&amp; peerAddr)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    EventLoop* ioLoop = threadPool_-&gt;<span class=\"built_in\">getNextLoop</span>();</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;-%s#%d&quot;</span>, ipPort_.<span class=\"built_in\">c_str</span>(), nextConnId_);</span><br><span class=\"line\">    ++nextConnId_;</span><br><span class=\"line\">    string connName = name_ + buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpServer::newConnection [&quot;</span> &lt;&lt; name_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] - new connection [&quot;</span> &lt;&lt; connName</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] from &quot;</span> &lt;&lt; peerAddr.<span class=\"built_in\">toIpPort</span>();</span><br><span class=\"line\">    <span class=\"function\">InetAddress <span class=\"title\">localAddr</span><span class=\"params\">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class=\"line\">    <span class=\"comment\">// FIXME use make_shared if necessary</span></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">conn</span><span class=\"params\">(<span class=\"keyword\">new</span> TcpConnection(ioLoop,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            connName,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            sockfd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            localAddr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            peerAddr))</span></span>;</span><br><span class=\"line\">    connections_[connName] = conn;</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setConnectionCallback</span>(connectionCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setMessageCallback</span>(messageCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setCloseCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpServer::removeConnection, <span class=\"keyword\">this</span>, _1)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    ioLoop-&gt;<span class=\"built_in\">runInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class=\"keyword\">this</span>, conn));    <span class=\"comment\">// connbind</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::removeConnectionInLoop</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpServer::removeConnectionInLoop [&quot;</span> &lt;&lt; name_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] - connection &quot;</span> &lt;&lt; conn-&gt;<span class=\"built_in\">name</span>();</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = connections_.<span class=\"built_in\">erase</span>(conn-&gt;<span class=\"built_in\">name</span>());</span><br><span class=\"line\">    (<span class=\"type\">void</span>)n;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(n == <span class=\"number\">1</span>);</span><br><span class=\"line\">    EventLoop* ioLoop = conn-&gt;<span class=\"built_in\">getLoop</span>();</span><br><span class=\"line\">    ioLoop-&gt;<span class=\"built_in\">queueInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p></p>\n<ol>\n<li><p>base looplistenAcceptor::handleReadAcceptor::acceptChannel_</p>\n</li>\n<li><p>::acceptsockfdsockfdAcceptor::newConnectionCallback_TcpServer::newConnectionTcpServer</p>\n</li>\n<li><p>ioloopconnect namesockfdioloopTcpConnection <strong>&lt;key : connect name, value : TcpConnection&gt;</strong> TcpServer::connections_TcpConnectionioloopTcpConnection::connectEstablishedTcpConnection</p>\n</li>\n<li><p>TcpConnection::connectEstablished</p>\n</li>\n</ol>\n<p></p>\n<ol>\n<li><p>TcpConnection::closeCallback_TcpServer::removeConnectionTcpConnection</p>\n</li>\n<li><p>base loopTcpServer::removeConnectionInLoopTcpConnection</p>\n</li>\n<li><p>TcpServer::removeConnectionInLoopTcpConnectionnameTcpServer::connections_TcpConnectionioloopTcpConnection::connectDestroyedTcpConnection</p>\n</li>\n</ol>\n<p><strong></strong></p>\n","excerpt":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p></p>\n<ol>\n<li><p>TcpServer.h&#x2F;ccReactorTcpServerEventLoopsock fdIOLoop</p>\n</li>\n<li><p>Acceptor.h&#x2F;ccChannel</p>\n</li>\n<li><p>Socket.h&#x2F;ccsocketsocket</p>\n</li>\n<li><p>SocketsOps.h&#x2F;ccSocket.h&#x2F;cc::socket()&#x2F;::accept()socketfd</p>\n</li>\n<li><p>InetAddress.h&#x2F;ccsockaddr_in&#x2F;sockaddr_in6</p>\n</li>\n</ol>\n<p>12345</p>\n<h2 id=\"Acceptor\"><a href=\"#Acceptor\" class=\"headerlink\" title=\"Acceptor\"></a>Acceptor</h2><p><strong></strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// Acceptor of incoming TCP connections.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Acceptor</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> (<span class=\"type\">int</span> sockfd, <span class=\"type\">const</span> InetAddress&amp;)&gt; NewConnectionCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Acceptor</span>(EventLoop* loop, <span class=\"type\">const</span> InetAddress&amp; listenAddr, <span class=\"type\">bool</span> reuseport);</span><br><span class=\"line\">    ~<span class=\"built_in\">Acceptor</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setNewConnectionCallback</span><span class=\"params\">(<span class=\"type\">const</span> NewConnectionCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; newConnectionCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">listen</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">listening</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> listening_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Deprecated, use the correct spelling one above.</span></span><br><span class=\"line\">    <span class=\"comment\">// Leave the wrong spelling here in case one needs to grep it for error messages.</span></span><br><span class=\"line\">    <span class=\"comment\">// bool listenning() const &#123; return listening(); &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">    Socket acceptSocket_; <span class=\"comment\">// accept sock fd</span></span><br><span class=\"line\">    Channel acceptChannel_; <span class=\"comment\">// accept sock fd channel</span></span><br><span class=\"line\">    NewConnectionCallback newConnectionCallback_;   <span class=\"comment\">// sock fd</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> listening_;  <span class=\"comment\">// accept sock fdlisten</span></span><br><span class=\"line\">    <span class=\"type\">int</span> idleFd_;  <span class=\"comment\">// fd</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>AcceptorTimeQueue</p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Acceptor::<span class=\"built_in\">Acceptor</span>(EventLoop* loop, <span class=\"type\">const</span> InetAddress&amp; listenAddr, <span class=\"type\">bool</span> reuseport)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(loop),</span><br><span class=\"line\">    <span class=\"built_in\">acceptSocket_</span>(sockets::<span class=\"built_in\">createNonblockingOrDie</span>(listenAddr.<span class=\"built_in\">family</span>())),</span><br><span class=\"line\">    <span class=\"built_in\">acceptChannel_</span>(loop, acceptSocket_.<span class=\"built_in\">fd</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">listening_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">idleFd_</span>(::<span class=\"built_in\">open</span>(<span class=\"string\">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(idleFd_ &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">setReuseAddr</span>(<span class=\"literal\">true</span>);       <span class=\"comment\">// </span></span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">setReusePort</span>(reuseport);  <span class=\"comment\">// </span></span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">bindAddress</span>(listenAddr);  <span class=\"comment\">// </span></span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">setReadCallback</span>(         <span class=\"comment\">// </span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Acceptor::handleRead, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Acceptor::~<span class=\"built_in\">Acceptor</span>()&#123;</span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">disableAll</span>();</span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    ::<span class=\"built_in\">close</span>(idleFd_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Acceptor::listen</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    listening_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    acceptSocket_.<span class=\"built_in\">listen</span>(); <span class=\"comment\">// sock fd listen</span></span><br><span class=\"line\">    acceptChannel_.<span class=\"built_in\">enableReading</span>(); <span class=\"comment\">// Pollersock fd</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Acceptor::handleRead</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    InetAddress peerAddr;</span><br><span class=\"line\">    <span class=\"comment\">//FIXME loop until no more</span></span><br><span class=\"line\">    <span class=\"type\">int</span> connfd = acceptSocket_.<span class=\"built_in\">accept</span>(&amp;peerAddr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connfd &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// string hostport = peerAddr.toIpPort();</span></span><br><span class=\"line\">        <span class=\"comment\">// LOG_TRACE &lt;&lt; &quot;Accepts of &quot; &lt;&lt; hostport;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newConnectionCallback_)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">newConnectionCallback_</span>(connfd, peerAddr);   <span class=\"comment\">// </span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            sockets::<span class=\"built_in\">close</span>(connfd);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        LOG_SYSERR &lt;&lt; <span class=\"string\">&quot;in Acceptor::handleRead&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Read the section named &quot;The special problem of</span></span><br><span class=\"line\">        <span class=\"comment\">// accept()ing when you can&#x27;t&quot; in libev&#x27;s doc.</span></span><br><span class=\"line\">        <span class=\"comment\">// By Marc Lehmann, author of libev.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EMFILE) &#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(idleFd_);   <span class=\"comment\">// idleFd_idleFd_</span></span><br><span class=\"line\">            idleFd_ = ::<span class=\"built_in\">accept</span>(acceptSocket_.<span class=\"built_in\">fd</span>(), <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>); <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"comment\">// </span></span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(idleFd_);</span><br><span class=\"line\">            idleFd_ = ::<span class=\"built_in\">open</span>(<span class=\"string\">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);    <span class=\"comment\">// fd</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p><strong></strong></p>\n<p>Acceptor::idleFd_Acceptor::handleReadEMFILEidleFd_::acceptidleFd_idleFd_</p>\n<p><strong></strong></p>\n<p>EMFILE idleFd_  ::accept  ::accept idleFd_</p>\n<h2 id=\"TcpServer\"><a href=\"#TcpServer\" class=\"headerlink\" title=\"TcpServer\"></a>TcpServer</h2><p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// TCP server, supports single-threaded and thread-pool models.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// This is an interface class, so don&#x27;t expose too much details.</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TcpServer</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(EventLoop*)&gt; ThreadInitCallback;</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"title class_\">Option</span>&#123;</span><br><span class=\"line\">        kNoReusePort,</span><br><span class=\"line\">        kReusePort,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">TcpServer</span>(EventLoop* loop,</span><br><span class=\"line\">            <span class=\"type\">const</span> InetAddress&amp; listenAddr,</span><br><span class=\"line\">            <span class=\"type\">const</span> string&amp; nameArg,</span><br><span class=\"line\">            Option option = kNoReusePort);</span><br><span class=\"line\">    ~<span class=\"built_in\">TcpServer</span>();  <span class=\"comment\">// force out-line dtor, for std::unique_ptr members.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">ipPort</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> ipPort_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\">    <span class=\"function\">EventLoop* <span class=\"title\">getLoop</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> loop_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// start</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadNum</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadInitCallback</span><span class=\"params\">(<span class=\"type\">const</span> ThreadInitCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; threadInitCallback_ = cb; &#125;</span><br><span class=\"line\">    <span class=\"comment\">/// valid after calling start()</span></span><br><span class=\"line\">    <span class=\"function\">std::shared_ptr&lt;EventLoopThreadPool&gt; <span class=\"title\">threadPool</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> threadPool_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Starts the server if it&#x27;s not listening.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// It&#x27;s harmless to call it multiple times.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set connection callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setConnectionCallback</span><span class=\"params\">(<span class=\"type\">const</span> ConnectionCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; connectionCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set message callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setMessageCallback</span><span class=\"params\">(<span class=\"type\">const</span> MessageCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; messageCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set write complete callback.</span></span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWriteCompleteCallback</span><span class=\"params\">(<span class=\"type\">const</span> WriteCompleteCallback&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; writeCompleteCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">const</span> InetAddress&amp; peerAddr)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Thread safe.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/// Not thread safe, but in loop</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeConnectionInLoop</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::map&lt;string, TcpConnectionPtr&gt; ConnectionMap;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_;  <span class=\"comment\">// the acceptor loop</span></span><br><span class=\"line\">    <span class=\"type\">const</span> string ipPort_; <span class=\"comment\">// ip:port</span></span><br><span class=\"line\">    <span class=\"type\">const</span> string name_; <span class=\"comment\">// TcpServer Name</span></span><br><span class=\"line\">    std::unique_ptr&lt;Acceptor&gt; acceptor_; <span class=\"comment\">// avoid revealing Acceptor</span></span><br><span class=\"line\">    std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_; <span class=\"comment\">// </span></span><br><span class=\"line\">    ConnectionCallback connectionCallback_; <span class=\"comment\">// </span></span><br><span class=\"line\">    MessageCallback messageCallback_;   <span class=\"comment\">// </span></span><br><span class=\"line\">    WriteCompleteCallback writeCompleteCallback_;   <span class=\"comment\">// </span></span><br><span class=\"line\">    ThreadInitCallback threadInitCallback_;</span><br><span class=\"line\">    AtomicInt32 started_; <span class=\"comment\">// TcpServer</span></span><br><span class=\"line\">    <span class=\"comment\">// always in loop thread</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nextConnId_;  <span class=\"comment\">// </span></span><br><span class=\"line\">    ConnectionMap connections_; <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>TcpServer</p>\n<p><img src=\"/2024/11/02/muduo/TcpServer/photo/TcpServer.drawio.png\" alt=\"TcpServer\"></p>\n<p></p>\n<ol>\n<li><p></p>\n</li>\n<li><p>listenEventLoopbase loopio</p>\n</li>\n<li><p>base loop EventLoopThreadPoolio EventLoopioloop</p>\n</li>\n<li><p>loopTCP</p>\n</li>\n</ol>\n<hr>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">TcpServer::<span class=\"built_in\">TcpServer</span>(EventLoop* loop,</span><br><span class=\"line\">                     <span class=\"type\">const</span> InetAddress&amp; listenAddr,</span><br><span class=\"line\">                     <span class=\"type\">const</span> string&amp; nameArg,</span><br><span class=\"line\">                     Option option)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(<span class=\"built_in\">CHECK_NOTNULL</span>(loop)),</span><br><span class=\"line\">    <span class=\"built_in\">ipPort_</span>(listenAddr.<span class=\"built_in\">toIpPort</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">acceptor_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Acceptor</span>(loop, listenAddr, option == kReusePort)),</span><br><span class=\"line\">    <span class=\"built_in\">threadPool_</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">EventLoopThreadPool</span>(loop, name_)),</span><br><span class=\"line\">    <span class=\"built_in\">connectionCallback_</span>(defaultConnectionCallback),</span><br><span class=\"line\">    <span class=\"built_in\">messageCallback_</span>(defaultMessageCallback),</span><br><span class=\"line\">    <span class=\"built_in\">nextConnId_</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    acceptor_-&gt;<span class=\"built_in\">setNewConnectionCallback</span>(    <span class=\"comment\">// </span></span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpServer::newConnection, <span class=\"keyword\">this</span>, _1, _2));    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TcpServer::~<span class=\"built_in\">TcpServer</span>()&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    LOG_TRACE &lt;&lt; <span class=\"string\">&quot;TcpServer::~TcpServer [&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;] destructing&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; item : connections_)&#123;</span><br><span class=\"line\">        <span class=\"function\">TcpConnectionPtr <span class=\"title\">conn</span><span class=\"params\">(item.second)</span></span>;</span><br><span class=\"line\">        item.second.<span class=\"built_in\">reset</span>();    <span class=\"comment\">// </span></span><br><span class=\"line\">        conn-&gt;<span class=\"built_in\">getLoop</span>()-&gt;<span class=\"built_in\">runInLoop</span>( <span class=\"comment\">// loop</span></span><br><span class=\"line\">            std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// start</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::setThreadNum</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"number\">0</span> &lt;= numThreads);</span><br><span class=\"line\">    threadPool_-&gt;<span class=\"built_in\">setThreadNum</span>(numThreads);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (started_.<span class=\"built_in\">getAndSet</span>(<span class=\"number\">1</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    threadPool_-&gt;<span class=\"built_in\">start</span>(threadInitCallback_);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!acceptor_-&gt;<span class=\"built_in\">listening</span>());</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;Acceptor::listen, <span class=\"built_in\">get_pointer</span>(acceptor_)));  <span class=\"comment\">// get_pointer(acceptor_)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::newConnection</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">const</span> InetAddress&amp; peerAddr)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    EventLoop* ioLoop = threadPool_-&gt;<span class=\"built_in\">getNextLoop</span>();</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;-%s#%d&quot;</span>, ipPort_.<span class=\"built_in\">c_str</span>(), nextConnId_);</span><br><span class=\"line\">    ++nextConnId_;</span><br><span class=\"line\">    string connName = name_ + buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpServer::newConnection [&quot;</span> &lt;&lt; name_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] - new connection [&quot;</span> &lt;&lt; connName</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] from &quot;</span> &lt;&lt; peerAddr.<span class=\"built_in\">toIpPort</span>();</span><br><span class=\"line\">    <span class=\"function\">InetAddress <span class=\"title\">localAddr</span><span class=\"params\">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class=\"line\">    <span class=\"comment\">// FIXME use make_shared if necessary</span></span><br><span class=\"line\">    <span class=\"function\">TcpConnectionPtr <span class=\"title\">conn</span><span class=\"params\">(<span class=\"keyword\">new</span> TcpConnection(ioLoop,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            connName,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            sockfd,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            localAddr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                            peerAddr))</span></span>;</span><br><span class=\"line\">    connections_[connName] = conn;</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setConnectionCallback</span>(connectionCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setMessageCallback</span>(messageCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class=\"line\">    conn-&gt;<span class=\"built_in\">setCloseCallback</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpServer::removeConnection, <span class=\"keyword\">this</span>, _1)); <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    ioLoop-&gt;<span class=\"built_in\">runInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::removeConnection</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> unsafe</span></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(std::<span class=\"built_in\">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class=\"keyword\">this</span>, conn));    <span class=\"comment\">// connbind</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TcpServer::removeConnectionInLoop</span><span class=\"params\">(<span class=\"type\">const</span> TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    LOG_INFO &lt;&lt; <span class=\"string\">&quot;TcpServer::removeConnectionInLoop [&quot;</span> &lt;&lt; name_</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;] - connection &quot;</span> &lt;&lt; conn-&gt;<span class=\"built_in\">name</span>();</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = connections_.<span class=\"built_in\">erase</span>(conn-&gt;<span class=\"built_in\">name</span>());</span><br><span class=\"line\">    (<span class=\"type\">void</span>)n;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(n == <span class=\"number\">1</span>);</span><br><span class=\"line\">    EventLoop* ioLoop = conn-&gt;<span class=\"built_in\">getLoop</span>();</span><br><span class=\"line\">    ioLoop-&gt;<span class=\"built_in\">queueInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p></p>\n<ol>\n<li><p>base looplistenAcceptor::handleReadAcceptor::acceptChannel_</p>\n</li>\n<li><p>::acceptsockfdsockfdAcceptor::newConnectionCallback_TcpServer::newConnectionTcpServer</p>\n</li>\n<li><p>ioloopconnect namesockfdioloopTcpConnection <strong>&lt;key : connect name, value : TcpConnection&gt;</strong> TcpServer::connections_TcpConnectionioloopTcpConnection::connectEstablishedTcpConnection</p>\n</li>\n<li><p>TcpConnection::connectEstablished</p>\n</li>\n</ol>\n<p></p>\n<ol>\n<li><p>TcpConnection::closeCallback_TcpServer::removeConnectionTcpConnection</p>\n</li>\n<li><p>base loopTcpServer::removeConnectionInLoopTcpConnection</p>\n</li>\n<li><p>TcpServer::removeConnectionInLoopTcpConnectionnameTcpServer::connections_TcpConnectionioloopTcpConnection::connectDestroyedTcpConnection</p>\n</li>\n</ol>\n<p><strong></strong></p>"},{"title":"muduo3","date":"2024-11-02T04:00:00.000Z","_content":"\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nMuduo300\n\n## \n\ncpp.h\n\n****\n\n<!-- more -->\n```cpp\nclass Thread : noncopyable {\npublic:\n    typedef std::function<void ()> ThreadFunc;\n\n    explicit Thread(ThreadFunc, const string& name = string());\n    // FIXME: make it movable in C++11\n    ~Thread();\n\n    void start();\n    int join(); // return pthread_join()\n\n    bool started() const { return started_; }\n    // pthread_t pthreadId() const { return pthreadId_; }\n    pid_t tid() const { return tid_; }\n    const string& name() const { return name_; }\n\n    static int numCreated() { return numCreated_.get(); }\n\nprivate:\n    void setDefaultName();\n\n    bool       started_;    // \n    bool       joined_;     // join\n    pthread_t  pthreadId_;  // Posixid\n    pid_t      tid_;        // idid\n    ThreadFunc func_;       // \n    string     name_;       // \n    CountDownLatch latch_;  // \n\n    static AtomicInt32 numCreated_; // \n};\n```\n\n****\n\n1. Thread::start()  -> \n\n    2. pthread_create(..., &detail::startThread,...)    -> \n\n        3. startThread(void* obj)   ->\n\n            4. ThreadData::runInThread()    -> \n\n                5. Thread::func_()\n\n****\n\n```cpp\n\nstruct ThreadData {\n    typedef muduo::Thread::ThreadFunc ThreadFunc;\n    ThreadFunc func_;\n    string name_;\n    pid_t* tid_;\n    CountDownLatch* latch_;\n\n    ThreadData(ThreadFunc func,\n                const string& name,\n                pid_t* tid,\n                CountDownLatch* latch)\n    : func_(std::move(func)),\n        name_(name),\n        tid_(tid),\n        latch_(latch)\n    { }\n\n    void runInThread(){\n        *tid_ = muduo::CurrentThread::tid();  // &&tidThread::tid_\n        tid_ = NULL;  // Thread::tid_\n        latch_->countDown();  // 01\n        latch_ = NULL;  // Thread::latch__\n\n        muduo::CurrentThread::t_threadName = name_.empty() ? \"muduoThread\" : name_.c_str(); // \n        ::prctl(PR_SET_NAME, muduo::CurrentThread::t_threadName); // \n        try{\n            func_();  // Thread\n            muduo::CurrentThread::t_threadName = \"finished\";\n        }\n        catch (...){\n            // ...\n        }\n    }\n};\n\n/*\n* pthread_create\n*/\nvoid* startThread(void* obj){\n    ThreadData* data = static_cast<ThreadData*>(obj);\n    data->runInThread();\n    delete data;\n    return NULL;\n}\n\nThread::Thread(ThreadFunc func, const string& n)\n  : started_(false),\n    joined_(false),\n    pthreadId_(0),\n    tid_(0),\n    func_(std::move(func)),\n    name_(n),\n    latch_(1){\n    setDefaultName();\n}\n\nThread::~Thread(){\n    /*\n    * joinpthread_detach\n    * \n    */\n    if (started_ && !joined_){\n        pthread_detach(pthreadId_);\n    }\n}\n\nvoid Thread::setDefaultName(){\n    int num = numCreated_.incrementAndGet();  // \n    if (name_.empty()){  // name\n        char buf[32];\n        snprintf(buf, sizeof buf, \"Thread%d\", num); // numCreated_name\n        name_ = buf;\n    }\n}\n\nvoid Thread::start(){\n    assert(!started_);\n    started_ = true;\n    /*\n    * ThreadDataThread\n    * Thread\n    * tid\n    */\n    // FIXME: move(func_)\n    detail::ThreadData* data = new detail::ThreadData(func_, name_, &tid_, &latch_);\n    if (pthread_create(&pthreadId_, NULL, &detail::startThread, data)){\n        started_ = false;\n        delete data; // or no delete?\n        LOG_SYSFATAL << \"Failed in pthread_create\";\n    }else{\n        latch_.wait();  // latch_.down()\n        assert(tid_ > 0);\n    }\n}\n  /*\n  * join\n  */\nint Thread::join(){\n    assert(started_);\n    assert(!joined_);\n    joined_ = true;\n    return pthread_join(pthreadId_, NULL);\n}\n```\n\n### \n\n****\n\nMuduoThreadThreadThreadData\n\n****\n\nMuduoThreadThreadDataThread\n\n1.  ThreadThreadThreadThreadData\n\n2.  ThreadDataThreadThreadThreadData\n\n3.  ThreadDataThreadDataThread\n\n4.  ThreadDataThreadThreadThreadData\n\n**MuduoPosixfork:**\n\n**** deamoposixforkfork\n\n**Muduo** MuduoThreadNameInitializerpthread_atforkchile`afterFork()``afterFork()`t_cachedTidt_threadName\n\n\n\n```cpp\nvoid afterFork(){\n    muduo::CurrentThread::t_cachedTid = 0;\n    muduo::CurrentThread::t_threadName = \"main\";\n    CurrentThread::tid();\n    // no need to call pthread_atfork(NULL, NULL, &afterFork);\n}\n```\n\n## \n\nMuduo****\n\n****\n\n\n![](./ThreadAndThreadPool/photo/ThreadPool.drawio.png)\n\nwhile\n\n1. \n2. \n3. 1\n\n\n\n****\n\n```cpp\nclass ThreadPool : noncopyable{\npublic:\n    typedef std::function<void ()> Task;\n\n    explicit ThreadPool(const string& nameArg = string(\"ThreadPool\"));\n    ~ThreadPool();\n\n    // Must be called before start().\n    void setMaxQueueSize(int maxSize) { maxQueueSize_ = maxSize; }\n    void setThreadInitCallback(const Task& cb)\n    { threadInitCallback_ = cb; }\n\n    void start(int numThreads);\n    void stop();\n\n    const string& name() const\n    { return name_; }\n\n    size_t queueSize() const;\n\n    // Could block if maxQueueSize > 0\n    // Call after stop() will return immediately.\n    // There is no move-only version of std::function in C++ as of C++14.\n    // So we don't need to overload a const& and an && versions\n    // as we do in (Bounded)BlockingQueue.\n    // https://stackoverflow.com/a/25408989\n    void run(Task f);\n\nprivate:\n    bool isFull() const REQUIRES(mutex_);\n    void runInThread();\n    Task take();\n\n    mutable MutexLock mutex_;                       // \n    Condition notEmpty_ GUARDED_BY(mutex_);         // \n    Condition notFull_ GUARDED_BY(mutex_);          // \n    string name_;                                   //\n    Task threadInitCallback_;                       // \n    std::vector<std::unique_ptr<muduo::Thread>> threads_; // startmutex\n    std::deque<Task> queue_ GUARDED_BY(mutex_);     // \n    size_t maxQueueSize_;                           //\n    bool running_;                                  // \n};\n```\n\n****\n\n`ThreadPool::start()``ThreadPool::setMaxQueueSize`\n\n****\n\n```cpp\nThreadPool::ThreadPool(const string& nameArg)\n  : mutex_(),\n    notEmpty_(mutex_),\n    notFull_(mutex_),\n    name_(nameArg),\n    maxQueueSize_(0),\n    running_(false){\n}\n\nThreadPool::~ThreadPool(){\n    /*\n    * stop()\n    */\n    if (running_){\n        stop();\n    }\n}\n/*\n* start\n* \n*/\nvoid ThreadPool::start(int numThreads){\n    assert(threads_.empty());\n    running_ = true;\n    threads_.reserve(numThreads);   // \n    for (int i = 0; i < numThreads; ++i){   // numThreads\n        char id[32];\n        snprintf(id, sizeof id, \"%d\", i+1);\n        threads_.emplace_back(new muduo::Thread(\n                std::bind(&ThreadPool::runInThread, this), name_+id));\n        threads_[i]->start();   // \n    }\n    if (numThreads == 0 && threadInitCallback_){\n        // numThreads\n        threadInitCallback_();\n    }\n}\n\nvoid ThreadPool::stop(){\n    {\n        MutexLockGuard lock(mutex_);\n        running_ = false;\n        notEmpty_.notifyAll();  // notFull_.wait()\n        notFull_.notifyAll();   // notEmpty_.wait()\n    }\n    for (auto& thr : threads_){\n        // startmutex\n        thr->join();\n    }\n}\n\nsize_t ThreadPool::queueSize() const{\n    MutexLockGuard lock(mutex_);\n    return queue_.size();\n}\n\nvoid ThreadPool::run(Task task){\n    if (threads_.empty()){  // \n        task();\n    }else{\n        MutexLockGuard lock(mutex_);\n        while (isFull() && running_){\n            // whiletakestop\n            notFull_.wait();\n        }\n        if (!running_) return;\n        assert(!isFull());\n\n        queue_.push_back(std::move(task));  // \n        notEmpty_.notify(); // notEmpty_.notify();\n    }\n}\n\nThreadPool::Task ThreadPool::take(){\n    MutexLockGuard lock(mutex_);\n  // always use a while-loop, due to spurious wakeup\n    while (queue_.empty() && running_){\n        // whilerunstop\n        notEmpty_.wait();\n    }\n\n    Task task;\n    if (!queue_.empty()){   // stop\n        task = queue_.front();  // \n        queue_.pop_front();     // pop\n\n        if (maxQueueSize_ > 0){ \n            /*\n            * run\n            * notFull_.wait()take\n            * notFull_.notify()\n            * run\n            */\n            notFull_.notify();  \n        }// else maxQueueSize_ == 0notFull_.wait()notFull_.notify()\n    }\n    return task;\n}\n\nbool ThreadPool::isFull() const{\n    mutex_.assertLocked();\n    return maxQueueSize_ > 0 && queue_.size() >= maxQueueSize_;\n}\n\nvoid ThreadPool::runInThread(){\n    try{\n        if (threadInitCallback_){\n            threadInitCallback_();  // \n        }\n        while (running_){   // \n            Task task(take());  // \n            if (task){  // \n                task(); // \n            }\n        }\n    }catch (...){\n        // ...\n    }\n}\n\n```\n\n### \n\n****\n\nMuduomaxQueueSize_\n\n****\n\nMuduomaxQueueSize_\n\n1.  \n\n2.  \n\n3.  **Muduo**\n\n****\n\nThreadPool::runInThreadrunning_ == falseMuduoThreadPool::runInThread()\n\n****\n\n\n\n1. Graceful Shutdown running_false\n\n2.  \n\n\n\nMuduorunning_falseMuduo\n\n**maxQueueSize_ == 0**\n\nMuduomaxQueueSize_0ThreadPool::isFullfalseThreadPool::runThreadPool::takemaxQueueSize_ == 0notFull_.notify()ThreadPool::runmaxQueueSize_ == 0ThreadPool::run\n\n---\n\n****","source":"_posts/muduo/ThreadAndThreadPool.md","raw":"---\ntitle: muduo3\ndate: 2024-11-02 12:00:00\ntags:\n  - \n---\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nMuduo300\n\n## \n\ncpp.h\n\n****\n\n<!-- more -->\n```cpp\nclass Thread : noncopyable {\npublic:\n    typedef std::function<void ()> ThreadFunc;\n\n    explicit Thread(ThreadFunc, const string& name = string());\n    // FIXME: make it movable in C++11\n    ~Thread();\n\n    void start();\n    int join(); // return pthread_join()\n\n    bool started() const { return started_; }\n    // pthread_t pthreadId() const { return pthreadId_; }\n    pid_t tid() const { return tid_; }\n    const string& name() const { return name_; }\n\n    static int numCreated() { return numCreated_.get(); }\n\nprivate:\n    void setDefaultName();\n\n    bool       started_;    // \n    bool       joined_;     // join\n    pthread_t  pthreadId_;  // Posixid\n    pid_t      tid_;        // idid\n    ThreadFunc func_;       // \n    string     name_;       // \n    CountDownLatch latch_;  // \n\n    static AtomicInt32 numCreated_; // \n};\n```\n\n****\n\n1. Thread::start()  -> \n\n    2. pthread_create(..., &detail::startThread,...)    -> \n\n        3. startThread(void* obj)   ->\n\n            4. ThreadData::runInThread()    -> \n\n                5. Thread::func_()\n\n****\n\n```cpp\n\nstruct ThreadData {\n    typedef muduo::Thread::ThreadFunc ThreadFunc;\n    ThreadFunc func_;\n    string name_;\n    pid_t* tid_;\n    CountDownLatch* latch_;\n\n    ThreadData(ThreadFunc func,\n                const string& name,\n                pid_t* tid,\n                CountDownLatch* latch)\n    : func_(std::move(func)),\n        name_(name),\n        tid_(tid),\n        latch_(latch)\n    { }\n\n    void runInThread(){\n        *tid_ = muduo::CurrentThread::tid();  // &&tidThread::tid_\n        tid_ = NULL;  // Thread::tid_\n        latch_->countDown();  // 01\n        latch_ = NULL;  // Thread::latch__\n\n        muduo::CurrentThread::t_threadName = name_.empty() ? \"muduoThread\" : name_.c_str(); // \n        ::prctl(PR_SET_NAME, muduo::CurrentThread::t_threadName); // \n        try{\n            func_();  // Thread\n            muduo::CurrentThread::t_threadName = \"finished\";\n        }\n        catch (...){\n            // ...\n        }\n    }\n};\n\n/*\n* pthread_create\n*/\nvoid* startThread(void* obj){\n    ThreadData* data = static_cast<ThreadData*>(obj);\n    data->runInThread();\n    delete data;\n    return NULL;\n}\n\nThread::Thread(ThreadFunc func, const string& n)\n  : started_(false),\n    joined_(false),\n    pthreadId_(0),\n    tid_(0),\n    func_(std::move(func)),\n    name_(n),\n    latch_(1){\n    setDefaultName();\n}\n\nThread::~Thread(){\n    /*\n    * joinpthread_detach\n    * \n    */\n    if (started_ && !joined_){\n        pthread_detach(pthreadId_);\n    }\n}\n\nvoid Thread::setDefaultName(){\n    int num = numCreated_.incrementAndGet();  // \n    if (name_.empty()){  // name\n        char buf[32];\n        snprintf(buf, sizeof buf, \"Thread%d\", num); // numCreated_name\n        name_ = buf;\n    }\n}\n\nvoid Thread::start(){\n    assert(!started_);\n    started_ = true;\n    /*\n    * ThreadDataThread\n    * Thread\n    * tid\n    */\n    // FIXME: move(func_)\n    detail::ThreadData* data = new detail::ThreadData(func_, name_, &tid_, &latch_);\n    if (pthread_create(&pthreadId_, NULL, &detail::startThread, data)){\n        started_ = false;\n        delete data; // or no delete?\n        LOG_SYSFATAL << \"Failed in pthread_create\";\n    }else{\n        latch_.wait();  // latch_.down()\n        assert(tid_ > 0);\n    }\n}\n  /*\n  * join\n  */\nint Thread::join(){\n    assert(started_);\n    assert(!joined_);\n    joined_ = true;\n    return pthread_join(pthreadId_, NULL);\n}\n```\n\n### \n\n****\n\nMuduoThreadThreadThreadData\n\n****\n\nMuduoThreadThreadDataThread\n\n1.  ThreadThreadThreadThreadData\n\n2.  ThreadDataThreadThreadThreadData\n\n3.  ThreadDataThreadDataThread\n\n4.  ThreadDataThreadThreadThreadData\n\n**MuduoPosixfork:**\n\n**** deamoposixforkfork\n\n**Muduo** MuduoThreadNameInitializerpthread_atforkchile`afterFork()``afterFork()`t_cachedTidt_threadName\n\n\n\n```cpp\nvoid afterFork(){\n    muduo::CurrentThread::t_cachedTid = 0;\n    muduo::CurrentThread::t_threadName = \"main\";\n    CurrentThread::tid();\n    // no need to call pthread_atfork(NULL, NULL, &afterFork);\n}\n```\n\n## \n\nMuduo****\n\n****\n\n\n![](./ThreadAndThreadPool/photo/ThreadPool.drawio.png)\n\nwhile\n\n1. \n2. \n3. 1\n\n\n\n****\n\n```cpp\nclass ThreadPool : noncopyable{\npublic:\n    typedef std::function<void ()> Task;\n\n    explicit ThreadPool(const string& nameArg = string(\"ThreadPool\"));\n    ~ThreadPool();\n\n    // Must be called before start().\n    void setMaxQueueSize(int maxSize) { maxQueueSize_ = maxSize; }\n    void setThreadInitCallback(const Task& cb)\n    { threadInitCallback_ = cb; }\n\n    void start(int numThreads);\n    void stop();\n\n    const string& name() const\n    { return name_; }\n\n    size_t queueSize() const;\n\n    // Could block if maxQueueSize > 0\n    // Call after stop() will return immediately.\n    // There is no move-only version of std::function in C++ as of C++14.\n    // So we don't need to overload a const& and an && versions\n    // as we do in (Bounded)BlockingQueue.\n    // https://stackoverflow.com/a/25408989\n    void run(Task f);\n\nprivate:\n    bool isFull() const REQUIRES(mutex_);\n    void runInThread();\n    Task take();\n\n    mutable MutexLock mutex_;                       // \n    Condition notEmpty_ GUARDED_BY(mutex_);         // \n    Condition notFull_ GUARDED_BY(mutex_);          // \n    string name_;                                   //\n    Task threadInitCallback_;                       // \n    std::vector<std::unique_ptr<muduo::Thread>> threads_; // startmutex\n    std::deque<Task> queue_ GUARDED_BY(mutex_);     // \n    size_t maxQueueSize_;                           //\n    bool running_;                                  // \n};\n```\n\n****\n\n`ThreadPool::start()``ThreadPool::setMaxQueueSize`\n\n****\n\n```cpp\nThreadPool::ThreadPool(const string& nameArg)\n  : mutex_(),\n    notEmpty_(mutex_),\n    notFull_(mutex_),\n    name_(nameArg),\n    maxQueueSize_(0),\n    running_(false){\n}\n\nThreadPool::~ThreadPool(){\n    /*\n    * stop()\n    */\n    if (running_){\n        stop();\n    }\n}\n/*\n* start\n* \n*/\nvoid ThreadPool::start(int numThreads){\n    assert(threads_.empty());\n    running_ = true;\n    threads_.reserve(numThreads);   // \n    for (int i = 0; i < numThreads; ++i){   // numThreads\n        char id[32];\n        snprintf(id, sizeof id, \"%d\", i+1);\n        threads_.emplace_back(new muduo::Thread(\n                std::bind(&ThreadPool::runInThread, this), name_+id));\n        threads_[i]->start();   // \n    }\n    if (numThreads == 0 && threadInitCallback_){\n        // numThreads\n        threadInitCallback_();\n    }\n}\n\nvoid ThreadPool::stop(){\n    {\n        MutexLockGuard lock(mutex_);\n        running_ = false;\n        notEmpty_.notifyAll();  // notFull_.wait()\n        notFull_.notifyAll();   // notEmpty_.wait()\n    }\n    for (auto& thr : threads_){\n        // startmutex\n        thr->join();\n    }\n}\n\nsize_t ThreadPool::queueSize() const{\n    MutexLockGuard lock(mutex_);\n    return queue_.size();\n}\n\nvoid ThreadPool::run(Task task){\n    if (threads_.empty()){  // \n        task();\n    }else{\n        MutexLockGuard lock(mutex_);\n        while (isFull() && running_){\n            // whiletakestop\n            notFull_.wait();\n        }\n        if (!running_) return;\n        assert(!isFull());\n\n        queue_.push_back(std::move(task));  // \n        notEmpty_.notify(); // notEmpty_.notify();\n    }\n}\n\nThreadPool::Task ThreadPool::take(){\n    MutexLockGuard lock(mutex_);\n  // always use a while-loop, due to spurious wakeup\n    while (queue_.empty() && running_){\n        // whilerunstop\n        notEmpty_.wait();\n    }\n\n    Task task;\n    if (!queue_.empty()){   // stop\n        task = queue_.front();  // \n        queue_.pop_front();     // pop\n\n        if (maxQueueSize_ > 0){ \n            /*\n            * run\n            * notFull_.wait()take\n            * notFull_.notify()\n            * run\n            */\n            notFull_.notify();  \n        }// else maxQueueSize_ == 0notFull_.wait()notFull_.notify()\n    }\n    return task;\n}\n\nbool ThreadPool::isFull() const{\n    mutex_.assertLocked();\n    return maxQueueSize_ > 0 && queue_.size() >= maxQueueSize_;\n}\n\nvoid ThreadPool::runInThread(){\n    try{\n        if (threadInitCallback_){\n            threadInitCallback_();  // \n        }\n        while (running_){   // \n            Task task(take());  // \n            if (task){  // \n                task(); // \n            }\n        }\n    }catch (...){\n        // ...\n    }\n}\n\n```\n\n### \n\n****\n\nMuduomaxQueueSize_\n\n****\n\nMuduomaxQueueSize_\n\n1.  \n\n2.  \n\n3.  **Muduo**\n\n****\n\nThreadPool::runInThreadrunning_ == falseMuduoThreadPool::runInThread()\n\n****\n\n\n\n1. Graceful Shutdown running_false\n\n2.  \n\n\n\nMuduorunning_falseMuduo\n\n**maxQueueSize_ == 0**\n\nMuduomaxQueueSize_0ThreadPool::isFullfalseThreadPool::runThreadPool::takemaxQueueSize_ == 0notFull_.notify()ThreadPool::runmaxQueueSize_ == 0ThreadPool::run\n\n---\n\n****","slug":"muduo/ThreadAndThreadPool","published":1,"updated":"2025-09-28T16:06:43.135Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9r000oq8ws4u2pb7o9","content":"<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>Muduo300</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>cpp.h</p>\n<p><strong></strong></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Thread</span> : noncopyable &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> ()&gt; ThreadFunc;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Thread</span><span class=\"params\">(ThreadFunc, <span class=\"type\">const</span> string&amp; name = string())</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> make it movable in C++11</span></span><br><span class=\"line\">    ~<span class=\"built_in\">Thread</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">join</span><span class=\"params\">()</span></span>; <span class=\"comment\">// return pthread_join()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">started</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> started_; &#125;</span><br><span class=\"line\">    <span class=\"comment\">// pthread_t pthreadId() const &#123; return pthreadId_; &#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">tid</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> tid_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">numCreated</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> numCreated_.<span class=\"built_in\">get</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setDefaultName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span>       started_;    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span>       joined_;     <span class=\"comment\">// join</span></span><br><span class=\"line\">    <span class=\"type\">pthread_t</span>  pthreadId_;  <span class=\"comment\">// Posixid</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span>      tid_;        <span class=\"comment\">// idid</span></span><br><span class=\"line\">    ThreadFunc func_;       <span class=\"comment\">// </span></span><br><span class=\"line\">    string     name_;       <span class=\"comment\">// </span></span><br><span class=\"line\">    CountDownLatch latch_;  <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">static</span> AtomicInt32 numCreated_; <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<ol>\n<li><p>Thread::start()  -&gt; </p>\n<ol start=\"2\">\n<li><p>pthread_create(, &amp;detail::startThread,)    -&gt; </p>\n<ol start=\"3\">\n<li><p>startThread(void* obj)   -&gt;</p>\n<ol start=\"4\">\n<li><p>ThreadData::runInThread()    -&gt; </p>\n<ol start=\"5\">\n<li>Thread::func_()</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ThreadData</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> muduo::Thread::ThreadFunc ThreadFunc;</span><br><span class=\"line\">    ThreadFunc func_;</span><br><span class=\"line\">    string name_;</span><br><span class=\"line\">    <span class=\"type\">pid_t</span>* tid_;</span><br><span class=\"line\">    CountDownLatch* latch_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">ThreadData</span>(ThreadFunc func,</span><br><span class=\"line\">                <span class=\"type\">const</span> string&amp; name,</span><br><span class=\"line\">                <span class=\"type\">pid_t</span>* tid,</span><br><span class=\"line\">                CountDownLatch* latch)</span><br><span class=\"line\">    : <span class=\"built_in\">func_</span>(std::<span class=\"built_in\">move</span>(func)),</span><br><span class=\"line\">        <span class=\"built_in\">name_</span>(name),</span><br><span class=\"line\">        <span class=\"built_in\">tid_</span>(tid),</span><br><span class=\"line\">        <span class=\"built_in\">latch_</span>(latch)</span><br><span class=\"line\">    &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">runInThread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        *tid_ = muduo::CurrentThread::<span class=\"built_in\">tid</span>();  <span class=\"comment\">// &amp;&amp;tidThread::tid_</span></span><br><span class=\"line\">        tid_ = <span class=\"literal\">NULL</span>;  <span class=\"comment\">// Thread::tid_</span></span><br><span class=\"line\">        latch_-&gt;<span class=\"built_in\">countDown</span>();  <span class=\"comment\">// 01</span></span><br><span class=\"line\">        latch_ = <span class=\"literal\">NULL</span>;  <span class=\"comment\">// Thread::latch__</span></span><br><span class=\"line\"></span><br><span class=\"line\">        muduo::CurrentThread::t_threadName = name_.<span class=\"built_in\">empty</span>() ? <span class=\"string\">&quot;muduoThread&quot;</span> : name_.<span class=\"built_in\">c_str</span>(); <span class=\"comment\">// </span></span><br><span class=\"line\">        ::<span class=\"built_in\">prctl</span>(PR_SET_NAME, muduo::CurrentThread::t_threadName); <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">func_</span>();  <span class=\"comment\">// Thread</span></span><br><span class=\"line\">            muduo::CurrentThread::t_threadName = <span class=\"string\">&quot;finished&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">catch</span> (...)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* pthread_create</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span>* <span class=\"title\">startThread</span><span class=\"params\">(<span class=\"type\">void</span>* obj)</span></span>&#123;</span><br><span class=\"line\">    ThreadData* data = <span class=\"built_in\">static_cast</span>&lt;ThreadData*&gt;(obj);</span><br><span class=\"line\">    data-&gt;<span class=\"built_in\">runInThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> data;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Thread::<span class=\"built_in\">Thread</span>(ThreadFunc func, <span class=\"type\">const</span> string&amp; n)</span><br><span class=\"line\">  : <span class=\"built_in\">started_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">joined_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">pthreadId_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">tid_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">func_</span>(std::<span class=\"built_in\">move</span>(func)),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(n),</span><br><span class=\"line\">    <span class=\"built_in\">latch_</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setDefaultName</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Thread::~<span class=\"built_in\">Thread</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * joinpthread_detach</span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (started_ &amp;&amp; !joined_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">pthread_detach</span>(pthreadId_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Thread::setDefaultName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> num = numCreated_.<span class=\"built_in\">incrementAndGet</span>();  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name_.<span class=\"built_in\">empty</span>())&#123;  <span class=\"comment\">// name</span></span><br><span class=\"line\">        <span class=\"type\">char</span> buf[<span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;Thread%d&quot;</span>, num); <span class=\"comment\">// numCreated_name</span></span><br><span class=\"line\">        name_ = buf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Thread::start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!started_);</span><br><span class=\"line\">    started_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * ThreadDataThread</span></span><br><span class=\"line\"><span class=\"comment\">    * Thread</span></span><br><span class=\"line\"><span class=\"comment\">    * tid</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> move(func_)</span></span><br><span class=\"line\">    detail::ThreadData* data = <span class=\"keyword\">new</span> detail::<span class=\"built_in\">ThreadData</span>(func_, name_, &amp;tid_, &amp;latch_);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_create</span>(&amp;pthreadId_, <span class=\"literal\">NULL</span>, &amp;detail::startThread, data))&#123;</span><br><span class=\"line\">        started_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> data; <span class=\"comment\">// or no delete?</span></span><br><span class=\"line\">        LOG_SYSFATAL &lt;&lt; <span class=\"string\">&quot;Failed in pthread_create&quot;</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        latch_.<span class=\"built_in\">wait</span>();  <span class=\"comment\">// latch_.down()</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(tid_ &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  * join</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Thread::join</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(started_);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!joined_);</span><br><span class=\"line\">    joined_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">pthread_join</span>(pthreadId_, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p><strong></strong></p>\n<p>MuduoThreadThreadThreadData</p>\n<p><strong></strong></p>\n<p>MuduoThreadThreadDataThread</p>\n<ol>\n<li><p> ThreadThreadThreadThreadData</p>\n</li>\n<li><p> ThreadDataThreadThreadThreadData</p>\n</li>\n<li><p> ThreadDataThreadDataThread</p>\n</li>\n<li><p> ThreadDataThreadThreadThreadData</p>\n</li>\n</ol>\n<p><strong>MuduoPosixfork:</strong></p>\n<p><strong></strong> deamoposixforkfork</p>\n<p><strong>Muduo</strong> MuduoThreadNameInitializerpthread_atforkchile<code>afterFork()</code><code>afterFork()</code>t_cachedTidt_threadName</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">afterFork</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    muduo::CurrentThread::t_cachedTid = <span class=\"number\">0</span>;</span><br><span class=\"line\">    muduo::CurrentThread::t_threadName = <span class=\"string\">&quot;main&quot;</span>;</span><br><span class=\"line\">    CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    <span class=\"comment\">// no need to call pthread_atfork(NULL, NULL, &amp;afterFork);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>Muduo<strong></strong></p>\n<p><strong></strong><br></p>\n<p><img src=\"/2024/11/02/muduo/ThreadAndThreadPool/photo/ThreadPool.drawio.png\" alt=\"\"></p>\n<p>while</p>\n<ol>\n<li></li>\n<li></li>\n<li>1</li>\n</ol>\n<p></p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPool</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> ()&gt; Task;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadPool</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; nameArg = string(<span class=\"string\">&quot;ThreadPool&quot;</span>))</span></span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">ThreadPool</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Must be called before start().</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setMaxQueueSize</span><span class=\"params\">(<span class=\"type\">int</span> maxSize)</span> </span>&#123; maxQueueSize_ = maxSize; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadInitCallback</span><span class=\"params\">(<span class=\"type\">const</span> Task&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; threadInitCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">queueSize</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Could block if maxQueueSize &gt; 0</span></span><br><span class=\"line\">    <span class=\"comment\">// Call after stop() will return immediately.</span></span><br><span class=\"line\">    <span class=\"comment\">// There is no move-only version of std::function in C++ as of C++14.</span></span><br><span class=\"line\">    <span class=\"comment\">// So we don&#x27;t need to overload a const&amp; and an &amp;&amp; versions</span></span><br><span class=\"line\">    <span class=\"comment\">// as we do in (Bounded)BlockingQueue.</span></span><br><span class=\"line\">    <span class=\"comment\">// https://stackoverflow.com/a/25408989</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">run</span><span class=\"params\">(Task f)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"title\">REQUIRES</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">runInThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Task <span class=\"title\">take</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_;                       <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"function\">Condition notEmpty_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;         <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"function\">Condition notFull_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;          <span class=\"comment\">// </span></span><br><span class=\"line\">    string name_;                                   <span class=\"comment\">//</span></span><br><span class=\"line\">    Task threadInitCallback_;                       <span class=\"comment\">// </span></span><br><span class=\"line\">    std::vector&lt;std::unique_ptr&lt;muduo::Thread&gt;&gt; threads_; <span class=\"comment\">// startmutex</span></span><br><span class=\"line\">    <span class=\"function\">std::deque&lt;Task&gt; queue_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;     <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> maxQueueSize_;                           <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> running_;                                  <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p><code>ThreadPool::start()</code><code>ThreadPool::setMaxQueueSize</code></p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPool::<span class=\"built_in\">ThreadPool</span>(<span class=\"type\">const</span> string&amp; nameArg)</span><br><span class=\"line\">  : <span class=\"built_in\">mutex_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">notEmpty_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">notFull_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">maxQueueSize_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">running_</span>(<span class=\"literal\">false</span>)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ThreadPool::~<span class=\"built_in\">ThreadPool</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * stop()</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (running_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* start</span></span><br><span class=\"line\"><span class=\"comment\">* </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::start</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(threads_.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\">    running_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    threads_.<span class=\"built_in\">reserve</span>(numThreads);   <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; numThreads; ++i)&#123;   <span class=\"comment\">// numThreads</span></span><br><span class=\"line\">        <span class=\"type\">char</span> id[<span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(id, <span class=\"keyword\">sizeof</span> id, <span class=\"string\">&quot;%d&quot;</span>, i<span class=\"number\">+1</span>);</span><br><span class=\"line\">        threads_.<span class=\"built_in\">emplace_back</span>(<span class=\"keyword\">new</span> muduo::<span class=\"built_in\">Thread</span>(</span><br><span class=\"line\">                std::<span class=\"built_in\">bind</span>(&amp;ThreadPool::runInThread, <span class=\"keyword\">this</span>), name_+id));</span><br><span class=\"line\">        threads_[i]-&gt;<span class=\"built_in\">start</span>();   <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numThreads == <span class=\"number\">0</span> &amp;&amp; threadInitCallback_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// numThreads</span></span><br><span class=\"line\">        <span class=\"built_in\">threadInitCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::stop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        running_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">notifyAll</span>();  <span class=\"comment\">// notFull_.wait()</span></span><br><span class=\"line\">        notFull_.<span class=\"built_in\">notifyAll</span>();   <span class=\"comment\">// notEmpty_.wait()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; thr : threads_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// startmutex</span></span><br><span class=\"line\">        thr-&gt;<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">ThreadPool::queueSize</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue_.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::run</span><span class=\"params\">(Task task)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (threads_.<span class=\"built_in\">empty</span>())&#123;  <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"built_in\">task</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        MutexLockGuard <span class=\"built_in\">lock</span>(mutex_);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">isFull</span>() &amp;&amp; running_)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// whiletakestop</span></span><br><span class=\"line\">            notFull_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!running_) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(!<span class=\"built_in\">isFull</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        queue_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(task));  <span class=\"comment\">// </span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">notify</span>(); <span class=\"comment\">// notEmpty_.notify();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ThreadPool::Task <span class=\"title\">ThreadPool::take</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">// always use a while-loop, due to spurious wakeup</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue_.<span class=\"built_in\">empty</span>() &amp;&amp; running_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// whilerunstop</span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Task task;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!queue_.<span class=\"built_in\">empty</span>())&#123;   <span class=\"comment\">// stop</span></span><br><span class=\"line\">        task = queue_.<span class=\"built_in\">front</span>();  <span class=\"comment\">// </span></span><br><span class=\"line\">        queue_.<span class=\"built_in\">pop_front</span>();     <span class=\"comment\">// pop</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxQueueSize_ &gt; <span class=\"number\">0</span>)&#123; </span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * run</span></span><br><span class=\"line\"><span class=\"comment\">            * notFull_.wait()take</span></span><br><span class=\"line\"><span class=\"comment\">            * notFull_.notify()</span></span><br><span class=\"line\"><span class=\"comment\">            * run</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            notFull_.<span class=\"built_in\">notify</span>();  </span><br><span class=\"line\">        &#125;<span class=\"comment\">// else maxQueueSize_ == 0notFull_.wait()notFull_.notify()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ThreadPool::isFull</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    mutex_.<span class=\"built_in\">assertLocked</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxQueueSize_ &gt; <span class=\"number\">0</span> &amp;&amp; queue_.<span class=\"built_in\">size</span>() &gt;= maxQueueSize_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::runInThread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (threadInitCallback_)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">threadInitCallback_</span>();  <span class=\"comment\">// </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (running_)&#123;   <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"function\">Task <span class=\"title\">task</span><span class=\"params\">(take())</span></span>;  <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (task)&#123;  <span class=\"comment\">// </span></span><br><span class=\"line\">                <span class=\"built_in\">task</span>(); <span class=\"comment\">// </span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"built_in\">catch</span> (...)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h3><p><strong></strong></p>\n<p>MuduomaxQueueSize_</p>\n<p><strong></strong></p>\n<p>MuduomaxQueueSize_</p>\n<ol>\n<li><p> </p>\n</li>\n<li><p> </p>\n</li>\n<li><p> <strong>Muduo</strong></p>\n</li>\n</ol>\n<p><strong></strong></p>\n<p>ThreadPool::runInThreadrunning_ &#x3D;&#x3D; falseMuduoThreadPool::runInThread()</p>\n<p><strong></strong></p>\n<p></p>\n<ol>\n<li><p>Graceful Shutdown running_false</p>\n</li>\n<li><p> </p>\n</li>\n</ol>\n<p></p>\n<p>Muduorunning_falseMuduo</p>\n<p><strong>maxQueueSize_ &#x3D;&#x3D; 0</strong></p>\n<p>MuduomaxQueueSize_0ThreadPool::isFullfalseThreadPool::runThreadPool::takemaxQueueSize_ &#x3D;&#x3D; 0notFull_.notify()ThreadPool::runmaxQueueSize_ &#x3D;&#x3D; 0ThreadPool::run</p>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>Muduo300</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>cpp.h</p>\n<p><strong></strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Thread</span> : noncopyable &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> ()&gt; ThreadFunc;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Thread</span><span class=\"params\">(ThreadFunc, <span class=\"type\">const</span> string&amp; name = string())</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> make it movable in C++11</span></span><br><span class=\"line\">    ~<span class=\"built_in\">Thread</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">join</span><span class=\"params\">()</span></span>; <span class=\"comment\">// return pthread_join()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">started</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> started_; &#125;</span><br><span class=\"line\">    <span class=\"comment\">// pthread_t pthreadId() const &#123; return pthreadId_; &#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">tid</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> tid_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">numCreated</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> numCreated_.<span class=\"built_in\">get</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setDefaultName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span>       started_;    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span>       joined_;     <span class=\"comment\">// join</span></span><br><span class=\"line\">    <span class=\"type\">pthread_t</span>  pthreadId_;  <span class=\"comment\">// Posixid</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span>      tid_;        <span class=\"comment\">// idid</span></span><br><span class=\"line\">    ThreadFunc func_;       <span class=\"comment\">// </span></span><br><span class=\"line\">    string     name_;       <span class=\"comment\">// </span></span><br><span class=\"line\">    CountDownLatch latch_;  <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">static</span> AtomicInt32 numCreated_; <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<ol>\n<li><p>Thread::start()  -&gt; </p>\n<ol start=\"2\">\n<li><p>pthread_create(, &amp;detail::startThread,)    -&gt; </p>\n<ol start=\"3\">\n<li><p>startThread(void* obj)   -&gt;</p>\n<ol start=\"4\">\n<li><p>ThreadData::runInThread()    -&gt; </p>\n<ol start=\"5\">\n<li>Thread::func_()</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ThreadData</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> muduo::Thread::ThreadFunc ThreadFunc;</span><br><span class=\"line\">    ThreadFunc func_;</span><br><span class=\"line\">    string name_;</span><br><span class=\"line\">    <span class=\"type\">pid_t</span>* tid_;</span><br><span class=\"line\">    CountDownLatch* latch_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">ThreadData</span>(ThreadFunc func,</span><br><span class=\"line\">                <span class=\"type\">const</span> string&amp; name,</span><br><span class=\"line\">                <span class=\"type\">pid_t</span>* tid,</span><br><span class=\"line\">                CountDownLatch* latch)</span><br><span class=\"line\">    : <span class=\"built_in\">func_</span>(std::<span class=\"built_in\">move</span>(func)),</span><br><span class=\"line\">        <span class=\"built_in\">name_</span>(name),</span><br><span class=\"line\">        <span class=\"built_in\">tid_</span>(tid),</span><br><span class=\"line\">        <span class=\"built_in\">latch_</span>(latch)</span><br><span class=\"line\">    &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">runInThread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        *tid_ = muduo::CurrentThread::<span class=\"built_in\">tid</span>();  <span class=\"comment\">// &amp;&amp;tidThread::tid_</span></span><br><span class=\"line\">        tid_ = <span class=\"literal\">NULL</span>;  <span class=\"comment\">// Thread::tid_</span></span><br><span class=\"line\">        latch_-&gt;<span class=\"built_in\">countDown</span>();  <span class=\"comment\">// 01</span></span><br><span class=\"line\">        latch_ = <span class=\"literal\">NULL</span>;  <span class=\"comment\">// Thread::latch__</span></span><br><span class=\"line\"></span><br><span class=\"line\">        muduo::CurrentThread::t_threadName = name_.<span class=\"built_in\">empty</span>() ? <span class=\"string\">&quot;muduoThread&quot;</span> : name_.<span class=\"built_in\">c_str</span>(); <span class=\"comment\">// </span></span><br><span class=\"line\">        ::<span class=\"built_in\">prctl</span>(PR_SET_NAME, muduo::CurrentThread::t_threadName); <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">func_</span>();  <span class=\"comment\">// Thread</span></span><br><span class=\"line\">            muduo::CurrentThread::t_threadName = <span class=\"string\">&quot;finished&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">catch</span> (...)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* pthread_create</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span>* <span class=\"title\">startThread</span><span class=\"params\">(<span class=\"type\">void</span>* obj)</span></span>&#123;</span><br><span class=\"line\">    ThreadData* data = <span class=\"built_in\">static_cast</span>&lt;ThreadData*&gt;(obj);</span><br><span class=\"line\">    data-&gt;<span class=\"built_in\">runInThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> data;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Thread::<span class=\"built_in\">Thread</span>(ThreadFunc func, <span class=\"type\">const</span> string&amp; n)</span><br><span class=\"line\">  : <span class=\"built_in\">started_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">joined_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    <span class=\"built_in\">pthreadId_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">tid_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">func_</span>(std::<span class=\"built_in\">move</span>(func)),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(n),</span><br><span class=\"line\">    <span class=\"built_in\">latch_</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setDefaultName</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Thread::~<span class=\"built_in\">Thread</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * joinpthread_detach</span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (started_ &amp;&amp; !joined_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">pthread_detach</span>(pthreadId_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Thread::setDefaultName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> num = numCreated_.<span class=\"built_in\">incrementAndGet</span>();  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name_.<span class=\"built_in\">empty</span>())&#123;  <span class=\"comment\">// name</span></span><br><span class=\"line\">        <span class=\"type\">char</span> buf[<span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span> buf, <span class=\"string\">&quot;Thread%d&quot;</span>, num); <span class=\"comment\">// numCreated_name</span></span><br><span class=\"line\">        name_ = buf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Thread::start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!started_);</span><br><span class=\"line\">    started_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * ThreadDataThread</span></span><br><span class=\"line\"><span class=\"comment\">    * Thread</span></span><br><span class=\"line\"><span class=\"comment\">    * tid</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> move(func_)</span></span><br><span class=\"line\">    detail::ThreadData* data = <span class=\"keyword\">new</span> detail::<span class=\"built_in\">ThreadData</span>(func_, name_, &amp;tid_, &amp;latch_);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_create</span>(&amp;pthreadId_, <span class=\"literal\">NULL</span>, &amp;detail::startThread, data))&#123;</span><br><span class=\"line\">        started_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> data; <span class=\"comment\">// or no delete?</span></span><br><span class=\"line\">        LOG_SYSFATAL &lt;&lt; <span class=\"string\">&quot;Failed in pthread_create&quot;</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        latch_.<span class=\"built_in\">wait</span>();  <span class=\"comment\">// latch_.down()</span></span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(tid_ &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  * join</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Thread::join</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(started_);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(!joined_);</span><br><span class=\"line\">    joined_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">pthread_join</span>(pthreadId_, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p><strong></strong></p>\n<p>MuduoThreadThreadThreadData</p>\n<p><strong></strong></p>\n<p>MuduoThreadThreadDataThread</p>\n<ol>\n<li><p> ThreadThreadThreadThreadData</p>\n</li>\n<li><p> ThreadDataThreadThreadThreadData</p>\n</li>\n<li><p> ThreadDataThreadDataThread</p>\n</li>\n<li><p> ThreadDataThreadThreadThreadData</p>\n</li>\n</ol>\n<p><strong>MuduoPosixfork:</strong></p>\n<p><strong></strong> deamoposixforkfork</p>\n<p><strong>Muduo</strong> MuduoThreadNameInitializerpthread_atforkchile<code>afterFork()</code><code>afterFork()</code>t_cachedTidt_threadName</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">afterFork</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    muduo::CurrentThread::t_cachedTid = <span class=\"number\">0</span>;</span><br><span class=\"line\">    muduo::CurrentThread::t_threadName = <span class=\"string\">&quot;main&quot;</span>;</span><br><span class=\"line\">    CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    <span class=\"comment\">// no need to call pthread_atfork(NULL, NULL, &amp;afterFork);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>Muduo<strong></strong></p>\n<p><strong></strong><br></p>\n<p><img src=\"/2024/11/02/muduo/ThreadAndThreadPool/photo/ThreadPool.drawio.png\" alt=\"\"></p>\n<p>while</p>\n<ol>\n<li></li>\n<li></li>\n<li>1</li>\n</ol>\n<p></p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPool</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span> ()&gt; Task;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadPool</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; nameArg = string(<span class=\"string\">&quot;ThreadPool&quot;</span>))</span></span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">ThreadPool</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Must be called before start().</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setMaxQueueSize</span><span class=\"params\">(<span class=\"type\">int</span> maxSize)</span> </span>&#123; maxQueueSize_ = maxSize; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setThreadInitCallback</span><span class=\"params\">(<span class=\"type\">const</span> Task&amp; cb)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; threadInitCallback_ = cb; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> string&amp; <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">queueSize</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Could block if maxQueueSize &gt; 0</span></span><br><span class=\"line\">    <span class=\"comment\">// Call after stop() will return immediately.</span></span><br><span class=\"line\">    <span class=\"comment\">// There is no move-only version of std::function in C++ as of C++14.</span></span><br><span class=\"line\">    <span class=\"comment\">// So we don&#x27;t need to overload a const&amp; and an &amp;&amp; versions</span></span><br><span class=\"line\">    <span class=\"comment\">// as we do in (Bounded)BlockingQueue.</span></span><br><span class=\"line\">    <span class=\"comment\">// https://stackoverflow.com/a/25408989</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">run</span><span class=\"params\">(Task f)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"title\">REQUIRES</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">runInThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Task <span class=\"title\">take</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_;                       <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"function\">Condition notEmpty_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;         <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"function\">Condition notFull_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;          <span class=\"comment\">// </span></span><br><span class=\"line\">    string name_;                                   <span class=\"comment\">//</span></span><br><span class=\"line\">    Task threadInitCallback_;                       <span class=\"comment\">// </span></span><br><span class=\"line\">    std::vector&lt;std::unique_ptr&lt;muduo::Thread&gt;&gt; threads_; <span class=\"comment\">// startmutex</span></span><br><span class=\"line\">    <span class=\"function\">std::deque&lt;Task&gt; queue_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;     <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> maxQueueSize_;                           <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> running_;                                  <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<p><code>ThreadPool::start()</code><code>ThreadPool::setMaxQueueSize</code></p>\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPool::<span class=\"built_in\">ThreadPool</span>(<span class=\"type\">const</span> string&amp; nameArg)</span><br><span class=\"line\">  : <span class=\"built_in\">mutex_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">notEmpty_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">notFull_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">name_</span>(nameArg),</span><br><span class=\"line\">    <span class=\"built_in\">maxQueueSize_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">running_</span>(<span class=\"literal\">false</span>)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ThreadPool::~<span class=\"built_in\">ThreadPool</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * stop()</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (running_)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* start</span></span><br><span class=\"line\"><span class=\"comment\">* </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::start</span><span class=\"params\">(<span class=\"type\">int</span> numThreads)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(threads_.<span class=\"built_in\">empty</span>());</span><br><span class=\"line\">    running_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    threads_.<span class=\"built_in\">reserve</span>(numThreads);   <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; numThreads; ++i)&#123;   <span class=\"comment\">// numThreads</span></span><br><span class=\"line\">        <span class=\"type\">char</span> id[<span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(id, <span class=\"keyword\">sizeof</span> id, <span class=\"string\">&quot;%d&quot;</span>, i<span class=\"number\">+1</span>);</span><br><span class=\"line\">        threads_.<span class=\"built_in\">emplace_back</span>(<span class=\"keyword\">new</span> muduo::<span class=\"built_in\">Thread</span>(</span><br><span class=\"line\">                std::<span class=\"built_in\">bind</span>(&amp;ThreadPool::runInThread, <span class=\"keyword\">this</span>), name_+id));</span><br><span class=\"line\">        threads_[i]-&gt;<span class=\"built_in\">start</span>();   <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numThreads == <span class=\"number\">0</span> &amp;&amp; threadInitCallback_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// numThreads</span></span><br><span class=\"line\">        <span class=\"built_in\">threadInitCallback_</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::stop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        running_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">notifyAll</span>();  <span class=\"comment\">// notFull_.wait()</span></span><br><span class=\"line\">        notFull_.<span class=\"built_in\">notifyAll</span>();   <span class=\"comment\">// notEmpty_.wait()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; thr : threads_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// startmutex</span></span><br><span class=\"line\">        thr-&gt;<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">ThreadPool::queueSize</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue_.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::run</span><span class=\"params\">(Task task)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (threads_.<span class=\"built_in\">empty</span>())&#123;  <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"built_in\">task</span>();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        MutexLockGuard <span class=\"built_in\">lock</span>(mutex_);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">isFull</span>() &amp;&amp; running_)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// whiletakestop</span></span><br><span class=\"line\">            notFull_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!running_) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(!<span class=\"built_in\">isFull</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        queue_.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(task));  <span class=\"comment\">// </span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">notify</span>(); <span class=\"comment\">// notEmpty_.notify();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ThreadPool::Task <span class=\"title\">ThreadPool::take</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">// always use a while-loop, due to spurious wakeup</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue_.<span class=\"built_in\">empty</span>() &amp;&amp; running_)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// whilerunstop</span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Task task;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!queue_.<span class=\"built_in\">empty</span>())&#123;   <span class=\"comment\">// stop</span></span><br><span class=\"line\">        task = queue_.<span class=\"built_in\">front</span>();  <span class=\"comment\">// </span></span><br><span class=\"line\">        queue_.<span class=\"built_in\">pop_front</span>();     <span class=\"comment\">// pop</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxQueueSize_ &gt; <span class=\"number\">0</span>)&#123; </span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * run</span></span><br><span class=\"line\"><span class=\"comment\">            * notFull_.wait()take</span></span><br><span class=\"line\"><span class=\"comment\">            * notFull_.notify()</span></span><br><span class=\"line\"><span class=\"comment\">            * run</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            notFull_.<span class=\"built_in\">notify</span>();  </span><br><span class=\"line\">        &#125;<span class=\"comment\">// else maxQueueSize_ == 0notFull_.wait()notFull_.notify()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ThreadPool::isFull</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    mutex_.<span class=\"built_in\">assertLocked</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxQueueSize_ &gt; <span class=\"number\">0</span> &amp;&amp; queue_.<span class=\"built_in\">size</span>() &gt;= maxQueueSize_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadPool::runInThread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (threadInitCallback_)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">threadInitCallback_</span>();  <span class=\"comment\">// </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (running_)&#123;   <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"function\">Task <span class=\"title\">task</span><span class=\"params\">(take())</span></span>;  <span class=\"comment\">// </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (task)&#123;  <span class=\"comment\">// </span></span><br><span class=\"line\">                <span class=\"built_in\">task</span>(); <span class=\"comment\">// </span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"built_in\">catch</span> (...)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h3><p><strong></strong></p>\n<p>MuduomaxQueueSize_</p>\n<p><strong></strong></p>\n<p>MuduomaxQueueSize_</p>\n<ol>\n<li><p> </p>\n</li>\n<li><p> </p>\n</li>\n<li><p> <strong>Muduo</strong></p>\n</li>\n</ol>\n<p><strong></strong></p>\n<p>ThreadPool::runInThreadrunning_ &#x3D;&#x3D; falseMuduoThreadPool::runInThread()</p>\n<p><strong></strong></p>\n<p></p>\n<ol>\n<li><p>Graceful Shutdown running_false</p>\n</li>\n<li><p> </p>\n</li>\n</ol>\n<p></p>\n<p>Muduorunning_falseMuduo</p>\n<p><strong>maxQueueSize_ &#x3D;&#x3D; 0</strong></p>\n<p>MuduomaxQueueSize_0ThreadPool::isFullfalseThreadPool::runThreadPool::takemaxQueueSize_ &#x3D;&#x3D; 0notFull_.notify()ThreadPool::runmaxQueueSize_ &#x3D;&#x3D; 0ThreadPool::run</p>\n<hr>\n<p><strong></strong></p>"},{"title":"muduo2CAPI","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nmuduoCAPI\n\nmuduomuduo\n## \n\nc++ std::atomic\n\nmuduogccapi\n\n<!-- more -->\n```cpp\ntemplate<typename T>\nclass AtomicIntegerT : noncopyable\n{\npublic:\n    AtomicIntegerT()\n    : value_(0)\n    {\n    }\n    T get()\n    {\n        return __sync_val_compare_and_swap(&value_, 0, 0);\n    }\n\n    T getAndAdd(T x)\n    {\n        return __sync_fetch_and_add(&value_, x);\n    }\n\n    T addAndGet(T x)\n    {\n        return getAndAdd(x) + x;\n    }\n\n    T incrementAndGet()\n    {\n        return addAndGet(1);\n    }\n\n    T decrementAndGet()\n    {\n        return addAndGet(-1);\n    }\n\n    void add(T x)\n    {\n        getAndAdd(x);\n    }\n\n    void increment()\n    {\n        incrementAndGet();\n    }\n\n    void decrement()\n    {\n        decrementAndGet();\n    }\n\n    T getAndSet(T newValue)\n    {\n        return __sync_lock_test_and_set(&value_, newValue);\n    }\n\nprivate:\n    volatile T value_;\n};\n```\n\n1. `type __sync_val_compare_and_swap(type *ptr, type oldval, type newval, ...)`\n\n    ****\n\n    - type\n    - ptr CAS \n    - oldval\n    - newval\n\n    ****\n\n     \\*ptr  oldval \\*ptr  newval** \\*ptr ** \\*ptr  oldval** \\*ptr **\n\n    CAS \n\n2. `type __sync_fetch_and_add(type *ptr, type value, ...)`\n\n    ****\n\n    - type\n    - ptr\n    - value \\*ptr \n\n    ****\n\n     \\*ptr  value ** \\*ptr **\n\n3. `type __sync_lock_test_and_set(type *ptr, type value, ...)`\n\n    ****\n\n    - type\n    - ptr\n    - value \\*ptr \n\n    ****\n\n    ** \\*ptr ** \\*ptr  value\n\n## \n\nmuduoPosix\n\n\n```cpp\nclass CAPABILITY(\"mutex\") MutexLock : noncopyable\n{\npublic:\n    MutexLock()\n    : holder_(0)\n    {\n        MCHECK(pthread_mutex_init(&mutex_, NULL));\n    }\n\n    ~MutexLock()\n    {\n        assert(holder_ == 0);\n        MCHECK(pthread_mutex_destroy(&mutex_));\n    }\n\n    // must be called when locked, i.e. for assertion\n    bool isLockedByThisThread() const\n    {\n        return holder_ == CurrentThread::tid();\n    }\n\n    void assertLocked() const ASSERT_CAPABILITY(this)\n    {\n        assert(isLockedByThisThread());\n    }\n\n    // internal usage\n\n    void lock() ACQUIRE()\n    {\n        MCHECK(pthread_mutex_lock(&mutex_));\n        assignHolder();\n    }\n\n    void unlock() RELEASE()\n    {\n        unassignHolder();\n        MCHECK(pthread_mutex_unlock(&mutex_));\n    }\n\n    pthread_mutex_t* getPthreadMutex() /* non-const */\n    {\n        return &mutex_;\n    }\n\nprivate:\n    friend class Condition;\n\n    /*\n    * RAIIfor\n    * \n    */\n    class UnassignGuard : noncopyable\n    {\n    public:\n        explicit UnassignGuard(MutexLock& owner)\n            : owner_(owner)\n        {\n            owner_.unassignHolder();\n        }\n\n        ~UnassignGuard()\n        {\n            owner_.assignHolder();\n        }\n\n    private:\n        MutexLock& owner_;\n    };\n\n    void unassignHolder()\n    {\n        holder_ = 0;\n    }\n\n    void assignHolder()\n    {\n        holder_ = CurrentThread::tid();\n    }\n\n    pthread_mutex_t mutex_;\n    pid_t holder_;\n};\n```\n\n\n\n```cpp\n/*\n* RAII\n*/\n// Use as a stack variable, eg.\n// int Foo::size() const\n// {\n//   MutexLockGuard lock(mutex_);\n//   return data_.size();\n// }\nclass SCOPED_CAPABILITY MutexLockGuard : noncopyable\n{\npublic:\n    explicit MutexLockGuard(MutexLock& mutex) ACQUIRE(mutex)\n    : mutex_(mutex)\n    {\n        mutex_.lock();\n    }\n\n    ~MutexLockGuard() RELEASE()\n    {\n        mutex_.unlock();\n    }\n\nprivate:\n\n    MutexLock& mutex_;\n};\n```\n\nC++RAII\n\n**RAII ** \n\n****\n\n1. **** \n\n2. **** \n\n3. **** \n\n4. **** \n\n**RAII**\n\n\n\n## \n\nmuduo`pthread_cond_wait`whilemuduowhile`CountDownLatch`\n\n```cpp\nclass Condition : noncopyable\n{\npublic:\n    explicit Condition(MutexLock& mutex)\n    : mutex_(mutex)\n    {\n        MCHECK(pthread_cond_init(&pcond_, NULL));\n    }\n\n    ~Condition()\n    {\n        MCHECK(pthread_cond_destroy(&pcond_));\n    }\n\n    void wait()\n    {\n        /*\n        * raiiMutexLockholder_\n        * mutexidmutextidholder_\n        * mutexholder_mutex\n        * /holder_muduoCondition\n        * UnassignGuardraii\n        * holder_holder_\n        * tidholder_mutex\n        */\n        MutexLock::UnassignGuard ug(mutex_);\n        MCHECK(pthread_cond_wait(&pcond_, mutex_.getPthreadMutex()));\n    }\n\n    // returns true if time out, false otherwise.\n    bool waitForSeconds(double seconds);\n\n    void notify()\n    {\n        MCHECK(pthread_cond_signal(&pcond_));\n    }\n\n    void notifyAll()\n    {\n        MCHECK(pthread_cond_broadcast(&pcond_));\n    }\n\nprivate:\n    MutexLock& mutex_;\n    pthread_cond_t pcond_;\n};\n```\n\n**mark**\n\n****\n\n1. post****post\n\n## CountDownLatch\n\n****\n\n1.  CountDownLatch \n\n2.   CountDownLatch \n\n\n\n```cpp\nclass CountDownLatch : noncopyable\n{\npublic:\n\n    explicit CountDownLatch(int count);\n\n    void wait();\n\n    void countDown();\n\n    int getCount() const;\n\nprivate:\n    mutable MutexLock mutex_;\n    Condition condition_ GUARDED_BY(mutex_);\n    int count_ GUARDED_BY(mutex_);\n};\n```\n\n\n\n```cpp\nCountDownLatch::CountDownLatch(int count)\n  : mutex_(),\n    condition_(mutex_),\n    count_(count)\n{\n}\n\nvoid CountDownLatch::wait()\n{\n    MutexLockGuard lock(mutex_);\n    while (count_ > 0)\n    {   // while\n        condition_.wait();\n    }\n}\n\nvoid CountDownLatch::countDown()\n{\n    MutexLockGuard lock(mutex_);\n    --count_;\n    if (count_ == 0)\n    {\n        // \n        condition_.notifyAll();\n    }\n}\n\nint CountDownLatch::getCount() const\n{\n    MutexLockGuard lock(mutex_);\n    return count_;\n}\n```\n\n****\ndemoA`pthread_cond_broadcast``pthread_cond_wait`B\n\n---\n\n****","source":"_posts/muduo/ThreadSafeAndSync.md","raw":"---\ntitle: muduo2CAPI\ndate: 2024-11-02 12:00:00\ntags:\n  - \n---\n\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nmuduoCAPI\n\nmuduomuduo\n## \n\nc++ std::atomic\n\nmuduogccapi\n\n<!-- more -->\n```cpp\ntemplate<typename T>\nclass AtomicIntegerT : noncopyable\n{\npublic:\n    AtomicIntegerT()\n    : value_(0)\n    {\n    }\n    T get()\n    {\n        return __sync_val_compare_and_swap(&value_, 0, 0);\n    }\n\n    T getAndAdd(T x)\n    {\n        return __sync_fetch_and_add(&value_, x);\n    }\n\n    T addAndGet(T x)\n    {\n        return getAndAdd(x) + x;\n    }\n\n    T incrementAndGet()\n    {\n        return addAndGet(1);\n    }\n\n    T decrementAndGet()\n    {\n        return addAndGet(-1);\n    }\n\n    void add(T x)\n    {\n        getAndAdd(x);\n    }\n\n    void increment()\n    {\n        incrementAndGet();\n    }\n\n    void decrement()\n    {\n        decrementAndGet();\n    }\n\n    T getAndSet(T newValue)\n    {\n        return __sync_lock_test_and_set(&value_, newValue);\n    }\n\nprivate:\n    volatile T value_;\n};\n```\n\n1. `type __sync_val_compare_and_swap(type *ptr, type oldval, type newval, ...)`\n\n    ****\n\n    - type\n    - ptr CAS \n    - oldval\n    - newval\n\n    ****\n\n     \\*ptr  oldval \\*ptr  newval** \\*ptr ** \\*ptr  oldval** \\*ptr **\n\n    CAS \n\n2. `type __sync_fetch_and_add(type *ptr, type value, ...)`\n\n    ****\n\n    - type\n    - ptr\n    - value \\*ptr \n\n    ****\n\n     \\*ptr  value ** \\*ptr **\n\n3. `type __sync_lock_test_and_set(type *ptr, type value, ...)`\n\n    ****\n\n    - type\n    - ptr\n    - value \\*ptr \n\n    ****\n\n    ** \\*ptr ** \\*ptr  value\n\n## \n\nmuduoPosix\n\n\n```cpp\nclass CAPABILITY(\"mutex\") MutexLock : noncopyable\n{\npublic:\n    MutexLock()\n    : holder_(0)\n    {\n        MCHECK(pthread_mutex_init(&mutex_, NULL));\n    }\n\n    ~MutexLock()\n    {\n        assert(holder_ == 0);\n        MCHECK(pthread_mutex_destroy(&mutex_));\n    }\n\n    // must be called when locked, i.e. for assertion\n    bool isLockedByThisThread() const\n    {\n        return holder_ == CurrentThread::tid();\n    }\n\n    void assertLocked() const ASSERT_CAPABILITY(this)\n    {\n        assert(isLockedByThisThread());\n    }\n\n    // internal usage\n\n    void lock() ACQUIRE()\n    {\n        MCHECK(pthread_mutex_lock(&mutex_));\n        assignHolder();\n    }\n\n    void unlock() RELEASE()\n    {\n        unassignHolder();\n        MCHECK(pthread_mutex_unlock(&mutex_));\n    }\n\n    pthread_mutex_t* getPthreadMutex() /* non-const */\n    {\n        return &mutex_;\n    }\n\nprivate:\n    friend class Condition;\n\n    /*\n    * RAIIfor\n    * \n    */\n    class UnassignGuard : noncopyable\n    {\n    public:\n        explicit UnassignGuard(MutexLock& owner)\n            : owner_(owner)\n        {\n            owner_.unassignHolder();\n        }\n\n        ~UnassignGuard()\n        {\n            owner_.assignHolder();\n        }\n\n    private:\n        MutexLock& owner_;\n    };\n\n    void unassignHolder()\n    {\n        holder_ = 0;\n    }\n\n    void assignHolder()\n    {\n        holder_ = CurrentThread::tid();\n    }\n\n    pthread_mutex_t mutex_;\n    pid_t holder_;\n};\n```\n\n\n\n```cpp\n/*\n* RAII\n*/\n// Use as a stack variable, eg.\n// int Foo::size() const\n// {\n//   MutexLockGuard lock(mutex_);\n//   return data_.size();\n// }\nclass SCOPED_CAPABILITY MutexLockGuard : noncopyable\n{\npublic:\n    explicit MutexLockGuard(MutexLock& mutex) ACQUIRE(mutex)\n    : mutex_(mutex)\n    {\n        mutex_.lock();\n    }\n\n    ~MutexLockGuard() RELEASE()\n    {\n        mutex_.unlock();\n    }\n\nprivate:\n\n    MutexLock& mutex_;\n};\n```\n\nC++RAII\n\n**RAII ** \n\n****\n\n1. **** \n\n2. **** \n\n3. **** \n\n4. **** \n\n**RAII**\n\n\n\n## \n\nmuduo`pthread_cond_wait`whilemuduowhile`CountDownLatch`\n\n```cpp\nclass Condition : noncopyable\n{\npublic:\n    explicit Condition(MutexLock& mutex)\n    : mutex_(mutex)\n    {\n        MCHECK(pthread_cond_init(&pcond_, NULL));\n    }\n\n    ~Condition()\n    {\n        MCHECK(pthread_cond_destroy(&pcond_));\n    }\n\n    void wait()\n    {\n        /*\n        * raiiMutexLockholder_\n        * mutexidmutextidholder_\n        * mutexholder_mutex\n        * /holder_muduoCondition\n        * UnassignGuardraii\n        * holder_holder_\n        * tidholder_mutex\n        */\n        MutexLock::UnassignGuard ug(mutex_);\n        MCHECK(pthread_cond_wait(&pcond_, mutex_.getPthreadMutex()));\n    }\n\n    // returns true if time out, false otherwise.\n    bool waitForSeconds(double seconds);\n\n    void notify()\n    {\n        MCHECK(pthread_cond_signal(&pcond_));\n    }\n\n    void notifyAll()\n    {\n        MCHECK(pthread_cond_broadcast(&pcond_));\n    }\n\nprivate:\n    MutexLock& mutex_;\n    pthread_cond_t pcond_;\n};\n```\n\n**mark**\n\n****\n\n1. post****post\n\n## CountDownLatch\n\n****\n\n1.  CountDownLatch \n\n2.   CountDownLatch \n\n\n\n```cpp\nclass CountDownLatch : noncopyable\n{\npublic:\n\n    explicit CountDownLatch(int count);\n\n    void wait();\n\n    void countDown();\n\n    int getCount() const;\n\nprivate:\n    mutable MutexLock mutex_;\n    Condition condition_ GUARDED_BY(mutex_);\n    int count_ GUARDED_BY(mutex_);\n};\n```\n\n\n\n```cpp\nCountDownLatch::CountDownLatch(int count)\n  : mutex_(),\n    condition_(mutex_),\n    count_(count)\n{\n}\n\nvoid CountDownLatch::wait()\n{\n    MutexLockGuard lock(mutex_);\n    while (count_ > 0)\n    {   // while\n        condition_.wait();\n    }\n}\n\nvoid CountDownLatch::countDown()\n{\n    MutexLockGuard lock(mutex_);\n    --count_;\n    if (count_ == 0)\n    {\n        // \n        condition_.notifyAll();\n    }\n}\n\nint CountDownLatch::getCount() const\n{\n    MutexLockGuard lock(mutex_);\n    return count_;\n}\n```\n\n****\ndemoA`pthread_cond_broadcast``pthread_cond_wait`B\n\n---\n\n****","slug":"muduo/ThreadSafeAndSync","published":1,"updated":"2025-09-28T16:06:43.135Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9s000qq8wsfjymfkx3","content":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>muduoCAPI</p>\n<p>muduomuduo</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>c++ std::atomic</p>\n<p>muduogccapi</p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AtomicIntegerT</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">AtomicIntegerT</span>()</span><br><span class=\"line\">    : <span class=\"built_in\">value_</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __sync_val_compare_and_swap(&amp;value_, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">getAndAdd</span><span class=\"params\">(T x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __sync_fetch_and_add(&amp;value_, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">addAndGet</span><span class=\"params\">(T x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">getAndAdd</span>(x) + x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">incrementAndGet</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">addAndGet</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">decrementAndGet</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">addAndGet</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(T x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">getAndAdd</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">incrementAndGet</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">decrement</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">decrementAndGet</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">getAndSet</span><span class=\"params\">(T newValue)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __sync_lock_test_and_set(&amp;value_, newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> T value_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><code>type __sync_val_compare_and_swap(type *ptr, type oldval, type newval, ...)</code></p>\n<p> <strong></strong></p>\n<ul>\n<li>type</li>\n<li>ptr CAS </li>\n<li>oldval</li>\n<li>newval</li>\n</ul>\n<p> <strong></strong></p>\n<p>  *ptr  oldval *ptr  newval<strong> *ptr </strong> *ptr  oldval<strong> *ptr </strong></p>\n<p> CAS </p>\n</li>\n<li><p><code>type __sync_fetch_and_add(type *ptr, type value, ...)</code></p>\n<p> <strong></strong></p>\n<ul>\n<li>type</li>\n<li>ptr</li>\n<li>value *ptr </li>\n</ul>\n<p> <strong></strong></p>\n<p>  *ptr  value <strong> *ptr </strong></p>\n</li>\n<li><p><code>type __sync_lock_test_and_set(type *ptr, type value, ...)</code></p>\n<p> <strong></strong></p>\n<ul>\n<li>type</li>\n<li>ptr</li>\n<li>value *ptr </li>\n</ul>\n<p> <strong></strong></p>\n<p> <strong> *ptr </strong> *ptr  value</p>\n</li>\n</ol>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>muduoPosix</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> <span class=\"title\">CAPABILITY</span><span class=\"params\">(<span class=\"string\">&quot;mutex&quot;</span>)</span> MutexLock : noncopyable</span></span><br><span class=\"line\"><span class=\"function\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MutexLock</span>()</span><br><span class=\"line\">    : <span class=\"built_in\">holder_</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_init</span>(&amp;mutex_, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">MutexLock</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(holder_ == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_destroy</span>(&amp;mutex_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// must be called when locked, i.e. for assertion</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isLockedByThisThread</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> holder_ == CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assertLocked</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"title\">ASSERT_CAPABILITY</span><span class=\"params\">(<span class=\"keyword\">this</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">isLockedByThisThread</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// internal usage</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> <span class=\"title\">ACQUIRE</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_lock</span>(&amp;mutex_));</span><br><span class=\"line\">        <span class=\"built_in\">assignHolder</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> <span class=\"title\">RELEASE</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unassignHolder</span>();</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;mutex_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">pthread_mutex_t</span>* <span class=\"title\">getPthreadMutex</span><span class=\"params\">()</span> <span class=\"comment\">/* non-const */</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;mutex_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Condition</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * RAIIfor</span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">UnassignGuard</span> : noncopyable</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">UnassignGuard</span><span class=\"params\">(MutexLock&amp; owner)</span></span></span><br><span class=\"line\"><span class=\"function\">            : owner_(owner)</span></span><br><span class=\"line\"><span class=\"function\">        &#123;</span></span><br><span class=\"line\">            owner_.<span class=\"built_in\">unassignHolder</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ~<span class=\"built_in\">UnassignGuard</span>()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            owner_.<span class=\"built_in\">assignHolder</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        MutexLock&amp; owner_;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unassignHolder</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        holder_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assignHolder</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        holder_ = CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pthread_mutex_t</span> mutex_;</span><br><span class=\"line\">    <span class=\"type\">pid_t</span> holder_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* RAII</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// Use as a stack variable, eg.</span></span><br><span class=\"line\"><span class=\"comment\">// int Foo::size() const</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   MutexLockGuard lock(mutex_);</span></span><br><span class=\"line\"><span class=\"comment\">//   return data_.size();</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SCOPED_CAPABILITY</span> MutexLockGuard : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">MutexLockGuard</span><span class=\"params\">(MutexLock&amp; mutex)</span> <span class=\"title\">ACQUIRE</span><span class=\"params\">(mutex)</span></span></span><br><span class=\"line\"><span class=\"function\">    : mutex_(mutex)</span></span><br><span class=\"line\"><span class=\"function\">    &#123;</span></span><br><span class=\"line\">        mutex_.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">MutexLockGuard</span>() <span class=\"built_in\">RELEASE</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        mutex_.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    MutexLock&amp; mutex_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>C++RAII</p>\n<p><strong>RAII </strong> </p>\n<p><strong></strong></p>\n<ol>\n<li><p><strong></strong> </p>\n</li>\n<li><p><strong></strong> </p>\n</li>\n<li><p><strong></strong> </p>\n</li>\n<li><p><strong></strong> </p>\n</li>\n</ol>\n<p><strong>RAII</strong></p>\n<p></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>muduo<code>pthread_cond_wait</code>whilemuduowhile<code>CountDownLatch</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Condition</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Condition</span><span class=\"params\">(MutexLock&amp; mutex)</span></span></span><br><span class=\"line\"><span class=\"function\">    : mutex_(mutex)</span></span><br><span class=\"line\"><span class=\"function\">    &#123;</span></span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_init</span>(&amp;pcond_, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">Condition</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_destroy</span>(&amp;pcond_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wait</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * raiiMutexLockholder_</span></span><br><span class=\"line\"><span class=\"comment\">        * mutexidmutextidholder_</span></span><br><span class=\"line\"><span class=\"comment\">        * mutexholder_mutex</span></span><br><span class=\"line\"><span class=\"comment\">        * /holder_muduoCondition</span></span><br><span class=\"line\"><span class=\"comment\">        * UnassignGuardraii</span></span><br><span class=\"line\"><span class=\"comment\">        * holder_holder_</span></span><br><span class=\"line\"><span class=\"comment\">        * tidholder_mutex</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"function\">MutexLock::UnassignGuard <span class=\"title\">ug</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_wait</span>(&amp;pcond_, mutex_.<span class=\"built_in\">getPthreadMutex</span>()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// returns true if time out, false otherwise.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">waitForSeconds</span><span class=\"params\">(<span class=\"type\">double</span> seconds)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">notify</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_signal</span>(&amp;pcond_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">notifyAll</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_broadcast</span>(&amp;pcond_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    MutexLock&amp; mutex_;</span><br><span class=\"line\">    <span class=\"type\">pthread_cond_t</span> pcond_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>mark</strong></p>\n<p><strong></strong></p>\n<ol>\n<li>post<strong></strong>post</li>\n</ol>\n<h2 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h2><p><strong></strong></p>\n<ol>\n<li><p> CountDownLatch </p>\n</li>\n<li><p>  CountDownLatch </p>\n</li>\n</ol>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CountDownLatch</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">CountDownLatch</span><span class=\"params\">(<span class=\"type\">int</span> count)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wait</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">countDown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">Condition condition_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> count_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CountDownLatch::<span class=\"built_in\">CountDownLatch</span>(<span class=\"type\">int</span> count)</span><br><span class=\"line\">  : <span class=\"built_in\">mutex_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">condition_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">count_</span>(count)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CountDownLatch::wait</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (count_ &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;   <span class=\"comment\">// while</span></span><br><span class=\"line\">        condition_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CountDownLatch::countDown</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    --count_;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count_ == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        condition_.<span class=\"built_in\">notifyAll</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">CountDownLatch::getCount</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong><br>demoA<code>pthread_cond_broadcast</code><code>pthread_cond_wait</code>B</p>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>muduoCAPI</p>\n<p>muduomuduo</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>c++ std::atomic</p>\n<p>muduogccapi</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AtomicIntegerT</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">AtomicIntegerT</span>()</span><br><span class=\"line\">    : <span class=\"built_in\">value_</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __sync_val_compare_and_swap(&amp;value_, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">getAndAdd</span><span class=\"params\">(T x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __sync_fetch_and_add(&amp;value_, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">addAndGet</span><span class=\"params\">(T x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">getAndAdd</span>(x) + x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">incrementAndGet</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">addAndGet</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">decrementAndGet</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">addAndGet</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(T x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">getAndAdd</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">incrementAndGet</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">decrement</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">decrementAndGet</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">getAndSet</span><span class=\"params\">(T newValue)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __sync_lock_test_and_set(&amp;value_, newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> T value_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><code>type __sync_val_compare_and_swap(type *ptr, type oldval, type newval, ...)</code></p>\n<p> <strong></strong></p>\n<ul>\n<li>type</li>\n<li>ptr CAS </li>\n<li>oldval</li>\n<li>newval</li>\n</ul>\n<p> <strong></strong></p>\n<p>  *ptr  oldval *ptr  newval<strong> *ptr </strong> *ptr  oldval<strong> *ptr </strong></p>\n<p> CAS </p>\n</li>\n<li><p><code>type __sync_fetch_and_add(type *ptr, type value, ...)</code></p>\n<p> <strong></strong></p>\n<ul>\n<li>type</li>\n<li>ptr</li>\n<li>value *ptr </li>\n</ul>\n<p> <strong></strong></p>\n<p>  *ptr  value <strong> *ptr </strong></p>\n</li>\n<li><p><code>type __sync_lock_test_and_set(type *ptr, type value, ...)</code></p>\n<p> <strong></strong></p>\n<ul>\n<li>type</li>\n<li>ptr</li>\n<li>value *ptr </li>\n</ul>\n<p> <strong></strong></p>\n<p> <strong> *ptr </strong> *ptr  value</p>\n</li>\n</ol>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>muduoPosix</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> <span class=\"title\">CAPABILITY</span><span class=\"params\">(<span class=\"string\">&quot;mutex&quot;</span>)</span> MutexLock : noncopyable</span></span><br><span class=\"line\"><span class=\"function\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MutexLock</span>()</span><br><span class=\"line\">    : <span class=\"built_in\">holder_</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_init</span>(&amp;mutex_, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">MutexLock</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(holder_ == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_destroy</span>(&amp;mutex_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// must be called when locked, i.e. for assertion</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isLockedByThisThread</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> holder_ == CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assertLocked</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"title\">ASSERT_CAPABILITY</span><span class=\"params\">(<span class=\"keyword\">this</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"built_in\">isLockedByThisThread</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// internal usage</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> <span class=\"title\">ACQUIRE</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_lock</span>(&amp;mutex_));</span><br><span class=\"line\">        <span class=\"built_in\">assignHolder</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> <span class=\"title\">RELEASE</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unassignHolder</span>();</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;mutex_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">pthread_mutex_t</span>* <span class=\"title\">getPthreadMutex</span><span class=\"params\">()</span> <span class=\"comment\">/* non-const */</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;mutex_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Condition</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * RAIIfor</span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">UnassignGuard</span> : noncopyable</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">UnassignGuard</span><span class=\"params\">(MutexLock&amp; owner)</span></span></span><br><span class=\"line\"><span class=\"function\">            : owner_(owner)</span></span><br><span class=\"line\"><span class=\"function\">        &#123;</span></span><br><span class=\"line\">            owner_.<span class=\"built_in\">unassignHolder</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ~<span class=\"built_in\">UnassignGuard</span>()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            owner_.<span class=\"built_in\">assignHolder</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        MutexLock&amp; owner_;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unassignHolder</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        holder_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assignHolder</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        holder_ = CurrentThread::<span class=\"built_in\">tid</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pthread_mutex_t</span> mutex_;</span><br><span class=\"line\">    <span class=\"type\">pid_t</span> holder_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* RAII</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// Use as a stack variable, eg.</span></span><br><span class=\"line\"><span class=\"comment\">// int Foo::size() const</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   MutexLockGuard lock(mutex_);</span></span><br><span class=\"line\"><span class=\"comment\">//   return data_.size();</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SCOPED_CAPABILITY</span> MutexLockGuard : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">MutexLockGuard</span><span class=\"params\">(MutexLock&amp; mutex)</span> <span class=\"title\">ACQUIRE</span><span class=\"params\">(mutex)</span></span></span><br><span class=\"line\"><span class=\"function\">    : mutex_(mutex)</span></span><br><span class=\"line\"><span class=\"function\">    &#123;</span></span><br><span class=\"line\">        mutex_.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">MutexLockGuard</span>() <span class=\"built_in\">RELEASE</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        mutex_.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    MutexLock&amp; mutex_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>C++RAII</p>\n<p><strong>RAII </strong> </p>\n<p><strong></strong></p>\n<ol>\n<li><p><strong></strong> </p>\n</li>\n<li><p><strong></strong> </p>\n</li>\n<li><p><strong></strong> </p>\n</li>\n<li><p><strong></strong> </p>\n</li>\n</ol>\n<p><strong>RAII</strong></p>\n<p></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>muduo<code>pthread_cond_wait</code>whilemuduowhile<code>CountDownLatch</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Condition</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Condition</span><span class=\"params\">(MutexLock&amp; mutex)</span></span></span><br><span class=\"line\"><span class=\"function\">    : mutex_(mutex)</span></span><br><span class=\"line\"><span class=\"function\">    &#123;</span></span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_init</span>(&amp;pcond_, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">Condition</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_destroy</span>(&amp;pcond_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wait</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * raiiMutexLockholder_</span></span><br><span class=\"line\"><span class=\"comment\">        * mutexidmutextidholder_</span></span><br><span class=\"line\"><span class=\"comment\">        * mutexholder_mutex</span></span><br><span class=\"line\"><span class=\"comment\">        * /holder_muduoCondition</span></span><br><span class=\"line\"><span class=\"comment\">        * UnassignGuardraii</span></span><br><span class=\"line\"><span class=\"comment\">        * holder_holder_</span></span><br><span class=\"line\"><span class=\"comment\">        * tidholder_mutex</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"function\">MutexLock::UnassignGuard <span class=\"title\">ug</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_wait</span>(&amp;pcond_, mutex_.<span class=\"built_in\">getPthreadMutex</span>()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// returns true if time out, false otherwise.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">waitForSeconds</span><span class=\"params\">(<span class=\"type\">double</span> seconds)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">notify</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_signal</span>(&amp;pcond_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">notifyAll</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">MCHECK</span>(<span class=\"built_in\">pthread_cond_broadcast</span>(&amp;pcond_));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    MutexLock&amp; mutex_;</span><br><span class=\"line\">    <span class=\"type\">pthread_cond_t</span> pcond_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>mark</strong></p>\n<p><strong></strong></p>\n<ol>\n<li>post<strong></strong>post</li>\n</ol>\n<h2 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h2><p><strong></strong></p>\n<ol>\n<li><p> CountDownLatch </p>\n</li>\n<li><p>  CountDownLatch </p>\n</li>\n</ol>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CountDownLatch</span> : noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">CountDownLatch</span><span class=\"params\">(<span class=\"type\">int</span> count)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wait</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">countDown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> MutexLock mutex_;</span><br><span class=\"line\">    <span class=\"function\">Condition condition_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> count_ <span class=\"title\">GUARDED_BY</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CountDownLatch::<span class=\"built_in\">CountDownLatch</span>(<span class=\"type\">int</span> count)</span><br><span class=\"line\">  : <span class=\"built_in\">mutex_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">condition_</span>(mutex_),</span><br><span class=\"line\">    <span class=\"built_in\">count_</span>(count)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CountDownLatch::wait</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (count_ &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;   <span class=\"comment\">// while</span></span><br><span class=\"line\">        condition_.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CountDownLatch::countDown</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    --count_;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count_ == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        condition_.<span class=\"built_in\">notifyAll</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">CountDownLatch::getCount</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong><br>demoA<code>pthread_cond_broadcast</code><code>pthread_cond_wait</code>B</p>\n<hr>\n<p><strong></strong></p>"},{"title":"muduo8TimerQueue","date":"2024-11-02T04:00:00.000Z","_content":"\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nPollerMuduo\n\n## \n\n****\n\n<!-- more -->\n```cpp\nclass TimerQueue : noncopyable{\npublic:\n    explicit TimerQueue(EventLoop* loop);\n    ~TimerQueue();\n\n    ///\n    /// Schedules the callback to be run at given time,\n    /// repeats if @c interval > 0.0.\n    ///\n    /// Must be thread safe. Usually be called from other threads.\n    TimerId addTimer(TimerCallback cb,\n                    Timestamp when,\n                    double interval);\n\n    void cancel(TimerId timerId);\n\nprivate:\n\n    // FIXME: use unique_ptr<Timer> instead of raw pointers.\n    // This requires heterogeneous comparison lookup (N3465) from C++14\n    // so that we can find an T* in a set<unique_ptr<T>>.\n    typedef std::pair<Timestamp, Timer*> Entry;\n    typedef std::set<Entry> TimerList;\n    typedef std::pair<Timer*, int64_t> ActiveTimer;\n    typedef std::set<ActiveTimer> ActiveTimerSet;\n\n    void addTimerInLoop(Timer* timer);\n    void cancelInLoop(TimerId timerId);\n    // called when timerfd alarms\n    void handleRead();\n    // move out all expired timers\n    std::vector<Entry> getExpired(Timestamp now);\n    void reset(const std::vector<Entry>& expired, Timestamp now);\n\n    bool insert(Timer* timer);\n\n    EventLoop* loop_; // EventLoop\n    const int timerfd_; // timerfd_\n    Channel timerfdChannel_;  // timerfd_Channel\n    // Timer list sorted by expiration\n    TimerList timers_;  // setTimestampTimer*\n\n    // for cancel()\n    ActiveTimerSet activeTimers_;\n    bool callingExpiredTimers_; /* atomic */\n    ActiveTimerSet cancelingTimers_;  // Timer*int64_t\n};\n```\n****\n\nEventLoop`TimerQueue`EventLoopthisTimerQueueTimerQueuetimerfdEventLoopPollertimerfdPollerAcceptorTcpConnection\n\n\n\n```cpp\n/*\n* @param: EventLoopthis\n*/\nTimerQueue::TimerQueue(EventLoop* loop)\n  : loop_(loop),\n    timerfd_(createTimerfd()),\n    timerfdChannel_(loop, timerfd_),\n    timers_(),\n    callingExpiredTimers_(false)\n{\n  timerfdChannel_.setReadCallback(\n      std::bind(&TimerQueue::handleRead, this));\n  // we are always reading the timerfd, we disarm it with timerfd_settime.\n  timerfdChannel_.enableReading();  // looptimerfd\n}\n```\n\n**<**\n\nstd::set<<findset\n\nstd::seta < b == false && b < a == false a == bTimestamp<std::set\n\n\n<<==>>=<=[](https://blog.csdn.net/huangjh2017/article/details/74357003)\n\nboost::less_than_comparable<Timestamp>\n\n```cpp\n//\nfriend bool operator<(const T& x, const T& y)  { /*...*/}\n\n// |\n// V\n\n//\nfriend bool operator>(const T& x, const T& y)  { return y < x; }\nfriend bool operator<=(const T& x, const T& y) { return !static_cast<bool>(y < x); }\nfriend bool operator>=(const T& x, const T& y) { return !static_cast<bool>(x < y); }\n```\n\n****\n\n```cpp\nTimerId TimerQueue::addTimer(TimerCallback cb,\n                             Timestamp when,\n                             double interval){\n    Timer* timer = new Timer(std::move(cb), when, interval);\n    loop_->runInLoop(\n        std::bind(&TimerQueue::addTimerInLoop, this, timer));\n    return TimerId(timer, timer->sequence());\n}\n\nvoid TimerQueue::cancel(TimerId timerId){\n    loop_->runInLoop(\n        std::bind(&TimerQueue::cancelInLoop, this, timerId));\n}\n\nvoid TimerQueue::addTimerInLoop(Timer* timer){\n    loop_->assertInLoopThread();\n    bool earliestChanged = insert(timer); // timer\n\n    if (earliestChanged){ \n        // timerfd_\n        resetTimerfd(timerfd_, timer->expiration());\n    }\n}\n\nvoid TimerQueue::cancelInLoop(TimerId timerId){\n    loop_->assertInLoopThread();\n    assert(timers_.size() == activeTimers_.size());\n    ActiveTimer timer(timerId.timer_, timerId.sequence_);\n    ActiveTimerSet::iterator it = activeTimers_.find(timer);\n    if (it != activeTimers_.end()){ // activeTimers_\n        // timers_timerId\n        delete it->first; // FIXME: no delete please\n        // activeTimers_timerId\n    }else if (callingExpiredTimers_){   // timerIdactiveTimers_handleRead::expired\n        // timerIdcancelingTimers_activeTimers_handleReadreset\n        cancelingTimers_.insert(timer);\n    }\n    assert(timers_.size() == activeTimers_.size());\n}\n\nvoid TimerQueue::handleRead(){ // timerfd_\n    loop_->assertInLoopThread();\n    Timestamp now(Timestamp::now());\n    readTimerfd(timerfd_, now); // timerfd_\n\n    std::vector<Entry> expired = getExpired(now);\n\n    callingExpiredTimers_ = true;\n    cancelingTimers_.clear();\n    // safe to callback outside critical section\n    for (const Entry& it : expired){\n        it.second->run();   // \n    }\n    callingExpiredTimers_ = false;\n\n    reset(expired, now);    // delete\n}\n\nstd::vector<TimerQueue::Entry> TimerQueue::getExpired(Timestamp now){\n    assert(timers_.size() == activeTimers_.size());\n    std::vector<Entry> expired;\n\n    // nowtimers_expired\n    // ...\n\n    for (const Entry& it : expired){ \n        // activeTimers_  timers_\n        // ...\n    }\n\n    assert(timers_.size() == activeTimers_.size());\n    return expired;\n}\n\nvoid TimerQueue::reset(const std::vector<Entry>& expired, Timestamp now){\n    Timestamp nextExpire;\n\n    for (const Entry& it : expired){\n        ActiveTimer timer(it.second, it.second->sequence());\n        if (it.second->repeat()\n            && cancelingTimers_.find(timer) == cancelingTimers_.end()){ // \n            it.second->restart(now);\n            insert(it.second);\n        }else{\n            // FIXME move to a free list\n            delete it.second; // FIXME: no delete please\n        }\n    }\n\n    if (!timers_.empty()){\n        nextExpire = timers_.begin()->second->expiration();\n    }\n\n    if (nextExpire.valid()){\n        resetTimerfd(timerfd_, nextExpire);\n    }\n}\n\nbool TimerQueue::insert(Timer* timer){\n    loop_->assertInLoopThread();\n    assert(timers_.size() == activeTimers_.size());\n    bool earliestChanged = false;\n    Timestamp when = timer->expiration(); // timer\n    TimerList::iterator it = timers_.begin(); // \n    if (it == timers_.end() || when < it->first){ \n        // timers_ ||   timers_ \n        // timeFd\n        earliestChanged = true;\n    }\n    // timers_\n    // std::set::insert\n\n    // activeTimers_\n    // std::set::insert\n    return earliestChanged;\n}\n```\n\n## \n\n****\n\n\n\n****\n\n1.  Muduo\n\n2.  Muduo\n\n3. \n\n---\n\n****","source":"_posts/muduo/TimerQueue.md","raw":"---\ntitle: muduo8TimerQueue\ndate: 2024-11-02 12:00:00\ntags:\n  - \n---\n\n**Muduo**\n\n[muduo0muduo](./Start.md)\n\n[muduo1](./SynLogging.md)\n\n[muduo2CAPI](./ThreadSafeAndSync.md)\n\n[muduo3](./ThreadAndThreadPool.md)\n\n[muduo4](./AsyncLogging.md)\n\n[muduo5ChannelPoller](./ChannelAndPoller.md)\n\n[muduo6ExevntLoopThread](./EvevntLoopAndThread.md)\n\n[muduo7EventLoopThreadPool](./EventLoopThreadPool.md)\n\n[muduo8TimerQueue](./TimerQueue.md)\n\n[muduo9TcpServer](./TcpServer.md)\n\n[muduo10TcpConnection](./TcpConnection.md)\n\n****\n\nPollerMuduo\n\n## \n\n****\n\n<!-- more -->\n```cpp\nclass TimerQueue : noncopyable{\npublic:\n    explicit TimerQueue(EventLoop* loop);\n    ~TimerQueue();\n\n    ///\n    /// Schedules the callback to be run at given time,\n    /// repeats if @c interval > 0.0.\n    ///\n    /// Must be thread safe. Usually be called from other threads.\n    TimerId addTimer(TimerCallback cb,\n                    Timestamp when,\n                    double interval);\n\n    void cancel(TimerId timerId);\n\nprivate:\n\n    // FIXME: use unique_ptr<Timer> instead of raw pointers.\n    // This requires heterogeneous comparison lookup (N3465) from C++14\n    // so that we can find an T* in a set<unique_ptr<T>>.\n    typedef std::pair<Timestamp, Timer*> Entry;\n    typedef std::set<Entry> TimerList;\n    typedef std::pair<Timer*, int64_t> ActiveTimer;\n    typedef std::set<ActiveTimer> ActiveTimerSet;\n\n    void addTimerInLoop(Timer* timer);\n    void cancelInLoop(TimerId timerId);\n    // called when timerfd alarms\n    void handleRead();\n    // move out all expired timers\n    std::vector<Entry> getExpired(Timestamp now);\n    void reset(const std::vector<Entry>& expired, Timestamp now);\n\n    bool insert(Timer* timer);\n\n    EventLoop* loop_; // EventLoop\n    const int timerfd_; // timerfd_\n    Channel timerfdChannel_;  // timerfd_Channel\n    // Timer list sorted by expiration\n    TimerList timers_;  // setTimestampTimer*\n\n    // for cancel()\n    ActiveTimerSet activeTimers_;\n    bool callingExpiredTimers_; /* atomic */\n    ActiveTimerSet cancelingTimers_;  // Timer*int64_t\n};\n```\n****\n\nEventLoop`TimerQueue`EventLoopthisTimerQueueTimerQueuetimerfdEventLoopPollertimerfdPollerAcceptorTcpConnection\n\n\n\n```cpp\n/*\n* @param: EventLoopthis\n*/\nTimerQueue::TimerQueue(EventLoop* loop)\n  : loop_(loop),\n    timerfd_(createTimerfd()),\n    timerfdChannel_(loop, timerfd_),\n    timers_(),\n    callingExpiredTimers_(false)\n{\n  timerfdChannel_.setReadCallback(\n      std::bind(&TimerQueue::handleRead, this));\n  // we are always reading the timerfd, we disarm it with timerfd_settime.\n  timerfdChannel_.enableReading();  // looptimerfd\n}\n```\n\n**<**\n\nstd::set<<findset\n\nstd::seta < b == false && b < a == false a == bTimestamp<std::set\n\n\n<<==>>=<=[](https://blog.csdn.net/huangjh2017/article/details/74357003)\n\nboost::less_than_comparable<Timestamp>\n\n```cpp\n//\nfriend bool operator<(const T& x, const T& y)  { /*...*/}\n\n// |\n// V\n\n//\nfriend bool operator>(const T& x, const T& y)  { return y < x; }\nfriend bool operator<=(const T& x, const T& y) { return !static_cast<bool>(y < x); }\nfriend bool operator>=(const T& x, const T& y) { return !static_cast<bool>(x < y); }\n```\n\n****\n\n```cpp\nTimerId TimerQueue::addTimer(TimerCallback cb,\n                             Timestamp when,\n                             double interval){\n    Timer* timer = new Timer(std::move(cb), when, interval);\n    loop_->runInLoop(\n        std::bind(&TimerQueue::addTimerInLoop, this, timer));\n    return TimerId(timer, timer->sequence());\n}\n\nvoid TimerQueue::cancel(TimerId timerId){\n    loop_->runInLoop(\n        std::bind(&TimerQueue::cancelInLoop, this, timerId));\n}\n\nvoid TimerQueue::addTimerInLoop(Timer* timer){\n    loop_->assertInLoopThread();\n    bool earliestChanged = insert(timer); // timer\n\n    if (earliestChanged){ \n        // timerfd_\n        resetTimerfd(timerfd_, timer->expiration());\n    }\n}\n\nvoid TimerQueue::cancelInLoop(TimerId timerId){\n    loop_->assertInLoopThread();\n    assert(timers_.size() == activeTimers_.size());\n    ActiveTimer timer(timerId.timer_, timerId.sequence_);\n    ActiveTimerSet::iterator it = activeTimers_.find(timer);\n    if (it != activeTimers_.end()){ // activeTimers_\n        // timers_timerId\n        delete it->first; // FIXME: no delete please\n        // activeTimers_timerId\n    }else if (callingExpiredTimers_){   // timerIdactiveTimers_handleRead::expired\n        // timerIdcancelingTimers_activeTimers_handleReadreset\n        cancelingTimers_.insert(timer);\n    }\n    assert(timers_.size() == activeTimers_.size());\n}\n\nvoid TimerQueue::handleRead(){ // timerfd_\n    loop_->assertInLoopThread();\n    Timestamp now(Timestamp::now());\n    readTimerfd(timerfd_, now); // timerfd_\n\n    std::vector<Entry> expired = getExpired(now);\n\n    callingExpiredTimers_ = true;\n    cancelingTimers_.clear();\n    // safe to callback outside critical section\n    for (const Entry& it : expired){\n        it.second->run();   // \n    }\n    callingExpiredTimers_ = false;\n\n    reset(expired, now);    // delete\n}\n\nstd::vector<TimerQueue::Entry> TimerQueue::getExpired(Timestamp now){\n    assert(timers_.size() == activeTimers_.size());\n    std::vector<Entry> expired;\n\n    // nowtimers_expired\n    // ...\n\n    for (const Entry& it : expired){ \n        // activeTimers_  timers_\n        // ...\n    }\n\n    assert(timers_.size() == activeTimers_.size());\n    return expired;\n}\n\nvoid TimerQueue::reset(const std::vector<Entry>& expired, Timestamp now){\n    Timestamp nextExpire;\n\n    for (const Entry& it : expired){\n        ActiveTimer timer(it.second, it.second->sequence());\n        if (it.second->repeat()\n            && cancelingTimers_.find(timer) == cancelingTimers_.end()){ // \n            it.second->restart(now);\n            insert(it.second);\n        }else{\n            // FIXME move to a free list\n            delete it.second; // FIXME: no delete please\n        }\n    }\n\n    if (!timers_.empty()){\n        nextExpire = timers_.begin()->second->expiration();\n    }\n\n    if (nextExpire.valid()){\n        resetTimerfd(timerfd_, nextExpire);\n    }\n}\n\nbool TimerQueue::insert(Timer* timer){\n    loop_->assertInLoopThread();\n    assert(timers_.size() == activeTimers_.size());\n    bool earliestChanged = false;\n    Timestamp when = timer->expiration(); // timer\n    TimerList::iterator it = timers_.begin(); // \n    if (it == timers_.end() || when < it->first){ \n        // timers_ ||   timers_ \n        // timeFd\n        earliestChanged = true;\n    }\n    // timers_\n    // std::set::insert\n\n    // activeTimers_\n    // std::set::insert\n    return earliestChanged;\n}\n```\n\n## \n\n****\n\n\n\n****\n\n1.  Muduo\n\n2.  Muduo\n\n3. \n\n---\n\n****","slug":"muduo/TimerQueue","published":1,"updated":"2025-09-28T16:06:43.135Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9s000sq8ws8wi65amy","content":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>PollerMuduo</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TimerQueue</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">TimerQueue</span><span class=\"params\">(EventLoop* loop)</span></span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">TimerQueue</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Schedules the callback to be run at given time,</span></span><br><span class=\"line\">    <span class=\"comment\">/// repeats if @c interval &gt; 0.0.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be thread safe. Usually be called from other threads.</span></span><br><span class=\"line\">    <span class=\"function\">TimerId <span class=\"title\">addTimer</span><span class=\"params\">(TimerCallback cb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                    Timestamp when,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                    <span class=\"type\">double</span> interval)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cancel</span><span class=\"params\">(TimerId timerId)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use unique_ptr&lt;Timer&gt; instead of raw pointers.</span></span><br><span class=\"line\">    <span class=\"comment\">// This requires heterogeneous comparison lookup (N3465) from C++14</span></span><br><span class=\"line\">    <span class=\"comment\">// so that we can find an T* in a set&lt;unique_ptr&lt;T&gt;&gt;.</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::pair&lt;Timestamp, Timer*&gt; Entry;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::set&lt;Entry&gt; TimerList;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::pair&lt;Timer*, <span class=\"type\">int64_t</span>&gt; ActiveTimer;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::set&lt;ActiveTimer&gt; ActiveTimerSet;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addTimerInLoop</span><span class=\"params\">(Timer* timer)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cancelInLoop</span><span class=\"params\">(TimerId timerId)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// called when timerfd alarms</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// move out all expired timers</span></span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;Entry&gt; <span class=\"title\">getExpired</span><span class=\"params\">(Timestamp now)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Entry&gt;&amp; expired, Timestamp now)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">insert</span><span class=\"params\">(Timer* timer)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> timerfd_; <span class=\"comment\">// timerfd_</span></span><br><span class=\"line\">    Channel timerfdChannel_;  <span class=\"comment\">// timerfd_Channel</span></span><br><span class=\"line\">    <span class=\"comment\">// Timer list sorted by expiration</span></span><br><span class=\"line\">    TimerList timers_;  <span class=\"comment\">// setTimestampTimer*</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for cancel()</span></span><br><span class=\"line\">    ActiveTimerSet activeTimers_;</span><br><span class=\"line\">    <span class=\"type\">bool</span> callingExpiredTimers_; <span class=\"comment\">/* atomic */</span></span><br><span class=\"line\">    ActiveTimerSet cancelingTimers_;  <span class=\"comment\">// Timer*int64_t</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong></strong></p>\n<p>EventLoop<code>TimerQueue</code>EventLoopthisTimerQueueTimerQueuetimerfdEventLoopPollertimerfdPollerAcceptorTcpConnection</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* @param: EventLoopthis</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">TimerQueue::<span class=\"built_in\">TimerQueue</span>(EventLoop* loop)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(loop),</span><br><span class=\"line\">    <span class=\"built_in\">timerfd_</span>(<span class=\"built_in\">createTimerfd</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">timerfdChannel_</span>(loop, timerfd_),</span><br><span class=\"line\">    <span class=\"built_in\">timers_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">callingExpiredTimers_</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  timerfdChannel_.<span class=\"built_in\">setReadCallback</span>(</span><br><span class=\"line\">      std::<span class=\"built_in\">bind</span>(&amp;TimerQueue::handleRead, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">  <span class=\"comment\">// we are always reading the timerfd, we disarm it with timerfd_settime.</span></span><br><span class=\"line\">  timerfdChannel_.<span class=\"built_in\">enableReading</span>();  <span class=\"comment\">// looptimerfd</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>&lt;</strong></p>\n<p>std::set&lt;&lt;findset</p>\n<p>std::seta &lt; b &#x3D;&#x3D; false &amp;&amp; b &lt; a &#x3D;&#x3D; false a &#x3D;&#x3D; bTimestamp&lt;std::set</p>\n<p>&lt;&lt;&#x3D;&#x3D;&gt;&gt;&#x3D;&lt;&#x3D;<a href=\"https://blog.csdn.net/huangjh2017/article/details/74357003\"></a></p>\n<p>boost::less_than_comparable<Timestamp></Timestamp></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"built_in\">operator</span>&lt;(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y)  &#123; <span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// |</span></span><br><span class=\"line\"><span class=\"comment\">// V</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y)  &#123; <span class=\"keyword\">return</span> y &lt; x; &#125;</span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;=(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y) &#123; <span class=\"keyword\">return</span> !<span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">bool</span>&gt;(y &lt; x); &#125;</span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;=(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y) &#123; <span class=\"keyword\">return</span> !<span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">bool</span>&gt;(x &lt; y); &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TimerId <span class=\"title\">TimerQueue::addTimer</span><span class=\"params\">(TimerCallback cb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             Timestamp when,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             <span class=\"type\">double</span> interval)</span></span>&#123;</span><br><span class=\"line\">    Timer* timer = <span class=\"keyword\">new</span> <span class=\"built_in\">Timer</span>(std::<span class=\"built_in\">move</span>(cb), when, interval);</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TimerQueue::addTimerInLoop, <span class=\"keyword\">this</span>, timer));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">TimerId</span>(timer, timer-&gt;<span class=\"built_in\">sequence</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::cancel</span><span class=\"params\">(TimerId timerId)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TimerQueue::cancelInLoop, <span class=\"keyword\">this</span>, timerId));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::addTimerInLoop</span><span class=\"params\">(Timer* timer)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"type\">bool</span> earliestChanged = <span class=\"built_in\">insert</span>(timer); <span class=\"comment\">// timer</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (earliestChanged)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// timerfd_</span></span><br><span class=\"line\">        <span class=\"built_in\">resetTimerfd</span>(timerfd_, timer-&gt;<span class=\"built_in\">expiration</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::cancelInLoop</span><span class=\"params\">(TimerId timerId)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    <span class=\"function\">ActiveTimer <span class=\"title\">timer</span><span class=\"params\">(timerId.timer_, timerId.sequence_)</span></span>;</span><br><span class=\"line\">    ActiveTimerSet::iterator it = activeTimers_.<span class=\"built_in\">find</span>(timer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it != activeTimers_.<span class=\"built_in\">end</span>())&#123; <span class=\"comment\">// activeTimers_</span></span><br><span class=\"line\">        <span class=\"comment\">// timers_timerId</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> it-&gt;first; <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> no delete please</span></span><br><span class=\"line\">        <span class=\"comment\">// activeTimers_timerId</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (callingExpiredTimers_)&#123;   <span class=\"comment\">// timerIdactiveTimers_handleRead::expired</span></span><br><span class=\"line\">        <span class=\"comment\">// timerIdcancelingTimers_activeTimers_handleReadreset</span></span><br><span class=\"line\">        cancelingTimers_.<span class=\"built_in\">insert</span>(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::handleRead</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// timerfd_</span></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"function\">Timestamp <span class=\"title\">now</span><span class=\"params\">(Timestamp::now())</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">readTimerfd</span>(timerfd_, now); <span class=\"comment\">// timerfd_</span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::vector&lt;Entry&gt; expired = <span class=\"built_in\">getExpired</span>(now);</span><br><span class=\"line\"></span><br><span class=\"line\">    callingExpiredTimers_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    cancelingTimers_.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    <span class=\"comment\">// safe to callback outside critical section</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Entry&amp; it : expired)&#123;</span><br><span class=\"line\">        it.second-&gt;<span class=\"built_in\">run</span>();   <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    callingExpiredTimers_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">reset</span>(expired, now);    <span class=\"comment\">// delete</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;TimerQueue::Entry&gt; <span class=\"title\">TimerQueue::getExpired</span><span class=\"params\">(Timestamp now)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    std::vector&lt;Entry&gt; expired;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// nowtimers_expired</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Entry&amp; it : expired)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// activeTimers_  timers_</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> expired;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::reset</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Entry&gt;&amp; expired, Timestamp now)</span></span>&#123;</span><br><span class=\"line\">    Timestamp nextExpire;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Entry&amp; it : expired)&#123;</span><br><span class=\"line\">        <span class=\"function\">ActiveTimer <span class=\"title\">timer</span><span class=\"params\">(it.second, it.second-&gt;sequence())</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it.second-&gt;<span class=\"built_in\">repeat</span>()</span><br><span class=\"line\">            &amp;&amp; cancelingTimers_.<span class=\"built_in\">find</span>(timer) == cancelingTimers_.<span class=\"built_in\">end</span>())&#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            it.second-&gt;<span class=\"built_in\">restart</span>(now);</span><br><span class=\"line\">            <span class=\"built_in\">insert</span>(it.second);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// FIXME move to a free list</span></span><br><span class=\"line\">            <span class=\"keyword\">delete</span> it.second; <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> no delete please</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timers_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        nextExpire = timers_.<span class=\"built_in\">begin</span>()-&gt;second-&gt;<span class=\"built_in\">expiration</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextExpire.<span class=\"built_in\">valid</span>())&#123;</span><br><span class=\"line\">        <span class=\"built_in\">resetTimerfd</span>(timerfd_, nextExpire);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TimerQueue::insert</span><span class=\"params\">(Timer* timer)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    <span class=\"type\">bool</span> earliestChanged = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    Timestamp when = timer-&gt;<span class=\"built_in\">expiration</span>(); <span class=\"comment\">// timer</span></span><br><span class=\"line\">    TimerList::iterator it = timers_.<span class=\"built_in\">begin</span>(); <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it == timers_.<span class=\"built_in\">end</span>() || when &lt; it-&gt;first)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// timers_ ||   timers_ </span></span><br><span class=\"line\">        <span class=\"comment\">// timeFd</span></span><br><span class=\"line\">        earliestChanged = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// timers_</span></span><br><span class=\"line\">    <span class=\"comment\">// std::set::insert</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// activeTimers_</span></span><br><span class=\"line\">    <span class=\"comment\">// std::set::insert</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> earliestChanged;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<p></p>\n<p><strong></strong></p>\n<ol>\n<li><p> Muduo</p>\n</li>\n<li><p> Muduo</p>\n</li>\n<li><p></p>\n</li>\n</ol>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<p><strong>Muduo</strong></p>\n<p><a href=\"./Start.md\">muduo0muduo</a></p>\n<p><a href=\"./SynLogging.md\">muduo1</a></p>\n<p><a href=\"./ThreadSafeAndSync.md\">muduo2CAPI</a></p>\n<p><a href=\"./ThreadAndThreadPool.md\">muduo3</a></p>\n<p><a href=\"./AsyncLogging.md\">muduo4</a></p>\n<p><a href=\"./ChannelAndPoller.md\">muduo5ChannelPoller</a></p>\n<p><a href=\"./EvevntLoopAndThread.md\">muduo6ExevntLoopThread</a></p>\n<p><a href=\"./EventLoopThreadPool.md\">muduo7EventLoopThreadPool</a></p>\n<p><a href=\"./TimerQueue.md\">muduo8TimerQueue</a></p>\n<p><a href=\"./TcpServer.md\">muduo9TcpServer</a></p>\n<p><a href=\"./TcpConnection.md\">muduo10TcpConnection</a></p>\n<p><strong></strong></p>\n<p>PollerMuduo</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TimerQueue</span> : noncopyable&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">TimerQueue</span><span class=\"params\">(EventLoop* loop)</span></span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">TimerQueue</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Schedules the callback to be run at given time,</span></span><br><span class=\"line\">    <span class=\"comment\">/// repeats if @c interval &gt; 0.0.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Must be thread safe. Usually be called from other threads.</span></span><br><span class=\"line\">    <span class=\"function\">TimerId <span class=\"title\">addTimer</span><span class=\"params\">(TimerCallback cb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                    Timestamp when,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                    <span class=\"type\">double</span> interval)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cancel</span><span class=\"params\">(TimerId timerId)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> use unique_ptr&lt;Timer&gt; instead of raw pointers.</span></span><br><span class=\"line\">    <span class=\"comment\">// This requires heterogeneous comparison lookup (N3465) from C++14</span></span><br><span class=\"line\">    <span class=\"comment\">// so that we can find an T* in a set&lt;unique_ptr&lt;T&gt;&gt;.</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::pair&lt;Timestamp, Timer*&gt; Entry;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::set&lt;Entry&gt; TimerList;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::pair&lt;Timer*, <span class=\"type\">int64_t</span>&gt; ActiveTimer;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::set&lt;ActiveTimer&gt; ActiveTimerSet;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addTimerInLoop</span><span class=\"params\">(Timer* timer)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cancelInLoop</span><span class=\"params\">(TimerId timerId)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// called when timerfd alarms</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// move out all expired timers</span></span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;Entry&gt; <span class=\"title\">getExpired</span><span class=\"params\">(Timestamp now)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Entry&gt;&amp; expired, Timestamp now)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">insert</span><span class=\"params\">(Timer* timer)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoop* loop_; <span class=\"comment\">// EventLoop</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> timerfd_; <span class=\"comment\">// timerfd_</span></span><br><span class=\"line\">    Channel timerfdChannel_;  <span class=\"comment\">// timerfd_Channel</span></span><br><span class=\"line\">    <span class=\"comment\">// Timer list sorted by expiration</span></span><br><span class=\"line\">    TimerList timers_;  <span class=\"comment\">// setTimestampTimer*</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for cancel()</span></span><br><span class=\"line\">    ActiveTimerSet activeTimers_;</span><br><span class=\"line\">    <span class=\"type\">bool</span> callingExpiredTimers_; <span class=\"comment\">/* atomic */</span></span><br><span class=\"line\">    ActiveTimerSet cancelingTimers_;  <span class=\"comment\">// Timer*int64_t</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong></strong></p>\n<p>EventLoop<code>TimerQueue</code>EventLoopthisTimerQueueTimerQueuetimerfdEventLoopPollertimerfdPollerAcceptorTcpConnection</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* @param: EventLoopthis</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">TimerQueue::<span class=\"built_in\">TimerQueue</span>(EventLoop* loop)</span><br><span class=\"line\">  : <span class=\"built_in\">loop_</span>(loop),</span><br><span class=\"line\">    <span class=\"built_in\">timerfd_</span>(<span class=\"built_in\">createTimerfd</span>()),</span><br><span class=\"line\">    <span class=\"built_in\">timerfdChannel_</span>(loop, timerfd_),</span><br><span class=\"line\">    <span class=\"built_in\">timers_</span>(),</span><br><span class=\"line\">    <span class=\"built_in\">callingExpiredTimers_</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  timerfdChannel_.<span class=\"built_in\">setReadCallback</span>(</span><br><span class=\"line\">      std::<span class=\"built_in\">bind</span>(&amp;TimerQueue::handleRead, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">  <span class=\"comment\">// we are always reading the timerfd, we disarm it with timerfd_settime.</span></span><br><span class=\"line\">  timerfdChannel_.<span class=\"built_in\">enableReading</span>();  <span class=\"comment\">// looptimerfd</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>&lt;</strong></p>\n<p>std::set&lt;&lt;findset</p>\n<p>std::seta &lt; b &#x3D;&#x3D; false &amp;&amp; b &lt; a &#x3D;&#x3D; false a &#x3D;&#x3D; bTimestamp&lt;std::set</p>\n<p>&lt;&lt;&#x3D;&#x3D;&gt;&gt;&#x3D;&lt;&#x3D;<a href=\"https://blog.csdn.net/huangjh2017/article/details/74357003\"></a></p>\n<p>boost::less_than_comparable<Timestamp></Timestamp></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"built_in\">operator</span>&lt;(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y)  &#123; <span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// |</span></span><br><span class=\"line\"><span class=\"comment\">// V</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y)  &#123; <span class=\"keyword\">return</span> y &lt; x; &#125;</span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;=(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y) &#123; <span class=\"keyword\">return</span> !<span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">bool</span>&gt;(y &lt; x); &#125;</span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;=(<span class=\"type\">const</span> T&amp; x, <span class=\"type\">const</span> T&amp; y) &#123; <span class=\"keyword\">return</span> !<span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">bool</span>&gt;(x &lt; y); &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TimerId <span class=\"title\">TimerQueue::addTimer</span><span class=\"params\">(TimerCallback cb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             Timestamp when,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             <span class=\"type\">double</span> interval)</span></span>&#123;</span><br><span class=\"line\">    Timer* timer = <span class=\"keyword\">new</span> <span class=\"built_in\">Timer</span>(std::<span class=\"built_in\">move</span>(cb), when, interval);</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TimerQueue::addTimerInLoop, <span class=\"keyword\">this</span>, timer));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">TimerId</span>(timer, timer-&gt;<span class=\"built_in\">sequence</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::cancel</span><span class=\"params\">(TimerId timerId)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">runInLoop</span>(</span><br><span class=\"line\">        std::<span class=\"built_in\">bind</span>(&amp;TimerQueue::cancelInLoop, <span class=\"keyword\">this</span>, timerId));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::addTimerInLoop</span><span class=\"params\">(Timer* timer)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"type\">bool</span> earliestChanged = <span class=\"built_in\">insert</span>(timer); <span class=\"comment\">// timer</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (earliestChanged)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// timerfd_</span></span><br><span class=\"line\">        <span class=\"built_in\">resetTimerfd</span>(timerfd_, timer-&gt;<span class=\"built_in\">expiration</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::cancelInLoop</span><span class=\"params\">(TimerId timerId)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    <span class=\"function\">ActiveTimer <span class=\"title\">timer</span><span class=\"params\">(timerId.timer_, timerId.sequence_)</span></span>;</span><br><span class=\"line\">    ActiveTimerSet::iterator it = activeTimers_.<span class=\"built_in\">find</span>(timer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it != activeTimers_.<span class=\"built_in\">end</span>())&#123; <span class=\"comment\">// activeTimers_</span></span><br><span class=\"line\">        <span class=\"comment\">// timers_timerId</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> it-&gt;first; <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> no delete please</span></span><br><span class=\"line\">        <span class=\"comment\">// activeTimers_timerId</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (callingExpiredTimers_)&#123;   <span class=\"comment\">// timerIdactiveTimers_handleRead::expired</span></span><br><span class=\"line\">        <span class=\"comment\">// timerIdcancelingTimers_activeTimers_handleReadreset</span></span><br><span class=\"line\">        cancelingTimers_.<span class=\"built_in\">insert</span>(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::handleRead</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// timerfd_</span></span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"function\">Timestamp <span class=\"title\">now</span><span class=\"params\">(Timestamp::now())</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">readTimerfd</span>(timerfd_, now); <span class=\"comment\">// timerfd_</span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::vector&lt;Entry&gt; expired = <span class=\"built_in\">getExpired</span>(now);</span><br><span class=\"line\"></span><br><span class=\"line\">    callingExpiredTimers_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    cancelingTimers_.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    <span class=\"comment\">// safe to callback outside critical section</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Entry&amp; it : expired)&#123;</span><br><span class=\"line\">        it.second-&gt;<span class=\"built_in\">run</span>();   <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    callingExpiredTimers_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">reset</span>(expired, now);    <span class=\"comment\">// delete</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;TimerQueue::Entry&gt; <span class=\"title\">TimerQueue::getExpired</span><span class=\"params\">(Timestamp now)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    std::vector&lt;Entry&gt; expired;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// nowtimers_expired</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Entry&amp; it : expired)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// activeTimers_  timers_</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> expired;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TimerQueue::reset</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Entry&gt;&amp; expired, Timestamp now)</span></span>&#123;</span><br><span class=\"line\">    Timestamp nextExpire;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Entry&amp; it : expired)&#123;</span><br><span class=\"line\">        <span class=\"function\">ActiveTimer <span class=\"title\">timer</span><span class=\"params\">(it.second, it.second-&gt;sequence())</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it.second-&gt;<span class=\"built_in\">repeat</span>()</span><br><span class=\"line\">            &amp;&amp; cancelingTimers_.<span class=\"built_in\">find</span>(timer) == cancelingTimers_.<span class=\"built_in\">end</span>())&#123; <span class=\"comment\">// </span></span><br><span class=\"line\">            it.second-&gt;<span class=\"built_in\">restart</span>(now);</span><br><span class=\"line\">            <span class=\"built_in\">insert</span>(it.second);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// FIXME move to a free list</span></span><br><span class=\"line\">            <span class=\"keyword\">delete</span> it.second; <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> no delete please</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timers_.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        nextExpire = timers_.<span class=\"built_in\">begin</span>()-&gt;second-&gt;<span class=\"built_in\">expiration</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextExpire.<span class=\"built_in\">valid</span>())&#123;</span><br><span class=\"line\">        <span class=\"built_in\">resetTimerfd</span>(timerfd_, nextExpire);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TimerQueue::insert</span><span class=\"params\">(Timer* timer)</span></span>&#123;</span><br><span class=\"line\">    loop_-&gt;<span class=\"built_in\">assertInLoopThread</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(timers_.<span class=\"built_in\">size</span>() == activeTimers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    <span class=\"type\">bool</span> earliestChanged = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    Timestamp when = timer-&gt;<span class=\"built_in\">expiration</span>(); <span class=\"comment\">// timer</span></span><br><span class=\"line\">    TimerList::iterator it = timers_.<span class=\"built_in\">begin</span>(); <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it == timers_.<span class=\"built_in\">end</span>() || when &lt; it-&gt;first)&#123; </span><br><span class=\"line\">        <span class=\"comment\">// timers_ ||   timers_ </span></span><br><span class=\"line\">        <span class=\"comment\">// timeFd</span></span><br><span class=\"line\">        earliestChanged = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// timers_</span></span><br><span class=\"line\">    <span class=\"comment\">// std::set::insert</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// activeTimers_</span></span><br><span class=\"line\">    <span class=\"comment\">// std::set::insert</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> earliestChanged;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><strong></strong></p>\n<p></p>\n<p><strong></strong></p>\n<ol>\n<li><p> Muduo</p>\n</li>\n<li><p> Muduo</p>\n</li>\n<li><p></p>\n</li>\n</ol>\n<hr>\n<p><strong></strong></p>"},{"title":"WorkFlowCommunicatorTCPServer","date":"2024-11-02T04:00:00.000Z","_content":"\n[WorkFlowGO-Task ](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\n## \n\nWorkFlow GO-TaskWorkFlow Tcp ServerTCPServerpollerIOCommunicatorTCPServerTCPServerIO\n\n<!-- more -->\n\n\n\nworkflowworkflow200workflow\n\n/workflow****\n\nWorkflowTcpServerCommServiceCommServiceTCPServerCommServiceudptcptcpTcpServerCommService\n\nTcpServer\n\npoller ->  -> poller_node ->  -> IO\n\n## IOIO\n\npoller.cworkflowepolllinuxIOapiworkflow\n\n### \n\n__poller\n\n```cpp\ntypedef struct __poller poller_t;   // \n\nstruct __poller\n{\n\tsize_t max_open_files;                              // epollfdfd\n\tvoid (*callback)(struct poller_result *, void *);   // CommunicatorCommunicatorpoller_result.poller_data.operation\n\tvoid *context;                                      // callback\n\n\tpthread_t tid;                                      // epollfdid\n\tint pfd;                                            // epollfd\n\tint timerfd;\n\tint pipe_rd;                                        // /__poller_node\n\tint pipe_wr;                                        // \n\tint stopped;\n\tstruct rb_root timeo_tree;                          // __poller_node[]\n\tstruct rb_node *tree_first;\n\tstruct rb_node *tree_last;\n\tstruct list_head timeo_list;                        // __poller_node\n\tstruct list_head no_timeo_list;                     // __poller_node\n\tstruct __poller_node **nodes;                       // fd__poller_node\n\tpthread_mutex_t mutex;\n\tchar buf[POLLER_BUFSIZE];                           // buffer\n};\n```\n\npoller\n\n__poller_node\n\n1. __poller_node__poller_node\n\n    1. timeo_tree\n\n    2. timeo_list\n\n2. __poller_nodeno_timeo_list\n\n__poller_node\n\n\n\n```cpp\nstruct __poller_node\n{\n\tint state;                  // __poller_node\n\tint error;\n\tstruct poller_data data;    // \n#pragma pack(1)\n\tunion\n\t{\n\t\tstruct list_head list;  // \n\t\tstruct rb_node rb;      // \n\t};\n#pragma pack()\n\tchar in_rbtree;             // \n\tchar removed;               // epoll/node\n\tint event;                  // epoll\n\tstruct timespec timeout;    // fd\n\tstruct __poller_node *res;  // PS\n};\n```\n\nMuduo__poller + __poller_nodeMuduoEPollPollerMuduotimerfd_Muduostd::setworkflowworkflow__poller_node\n\n__poller_nodedataMuduodataMuduoChannelpoller_dataCommunicator\n\npoller_datajworkflow\n\n```cpp\nstruct poller_data\n{\n// poll\n#define PD_OP_TIMER\t\t\t0\n#define PD_OP_READ\t\t\t1\n#define PD_OP_WRITE\t\t\t2\n#define PD_OP_LISTEN\t\t3\n#define PD_OP_CONNECT\t\t4\n#define PD_OP_RECVFROM\t\t5\n/* ... */\n#define PD_OP_EVENT\t\t\t9\n#define PD_OP_NOTIFY\t\t10\n\tshort operation;\n\tunsigned short iovcnt;\n\tint fd;\n\tSSL *ssl;\n\tunion\n\t{\n\t\tpoller_message_t *(*create_message)(void *);    // \n\t\tint (*partial_written)(size_t, void *);\n\t\tvoid *(*accept)(const struct sockaddr *, socklen_t, int, void *);\n\t\tvoid *(*recvfrom)(const struct sockaddr *, socklen_t,\n\t\t\t\t\t\t  const void *, size_t, void *);\n\t\tvoid *(*event)(void *);\n\t\tvoid *(*notify)(void *, void *);\n\t};\n\tvoid *context;\n\tunion\n\t{\n\t\tpoller_message_t *message;      // create_message\n\t\tstruct iovec *write_iov;        // \n\t\tvoid *result;\n\t};\n};\n```\n\n|\t\t\t|\t\t|\n|\t:-:\t\t\t\t|\t:-:\t\t|\n|\tcreate_message\t|\tfdreadmsgfdmsg0pollercallbackCommunicator|\n|\tpartial_written\t|\tfdwritefd****\t|\n| accept\t\t\t|\tfdreadlisten fdsockfdsockfdCommServiceTarget\t|\n|\trecvfrom\t\t|\tfdreadudptcpworkflowtcp\t|\n|\tevent\t\t\t|\tfdreadfdsocket fd\t|\n|\tnotify\t|\tevent\t|\n\n\npoller_result__poller_nodepoller.cpoller_result__poller_nodeCpoller_result__poller_node**__poller_nodepoller_result*__poller_node**\n\n```cpp\n\nstruct poller_result\n{\n#define PR_ST_SUCCESS\t\t0\n#define PR_ST_FINISHED\t\t1\n#define PR_ST_ERROR\t\t\t2\n#define PR_ST_DELETED\t\t3\n#define PR_ST_MODIFIED\t\t4\n#define PR_ST_STOPPED\t\t5\n\tint state;\n\tint error;\n\tstruct poller_data data;\n\t/* In callback, spaces of six pointers are available from here. */\n};\n```\n\npoller/workflowpollerepollfd//\n\nworkflowmuduosylarepollepollioioworkflowpoller\n\n### Event Loop --- \n\nepoll/pollIOIOIO__poller  \n\n__poller__poller__mpoller__mpoller__poller__mpoller__pollermanager__pollerepollfd__mpollersocketfd__poller__poller__poller_nodesocket fd__poller__poller_nodemanager__mpoller__poller\n\n```cpp\nstatic int __mpoller_create(const struct poller_params *params,\n\t\t\t\t\t\t\tmpoller_t *mpoller) {\n\tvoid **nodes_buf = (void **)calloc(params->max_open_files, sizeof (void *));\n\tunsigned int i;\n\n\tif (nodes_buf) {\n\t\tfor (i = 0; i < mpoller->nthreads; i++) {\n\t\t\tmpoller->poller[i] = __poller_create(nodes_buf, params);\n\t\t\tif (!mpoller->poller[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == mpoller->nthreads) {\n\t\t\tmpoller->nodes_buf = nodes_buf;\n\t\t\treturn 0;\n\t\t}\n\t\t// ...\n\t}\n\n\treturn -1;\n}\n```\n\nmax_open_filesnodes_buf__poller_createnodes_buf__poller__poller_create__poller__pollernodesnodes_bufnodessocket fd__poller_node **__pollernodes_buf**\n\n **{nodessocket fd__poller_node}** linuxfd__poller__pollernodes_bufsocket fd__poller_node****__poller_nodesocket fd**__pollernodes_bufnodes_bufentry**\n\n__pollermpollermpoller_start__poller__pollerpoller_start\n\n```cpp\nint poller_start(poller_t *poller) {\n\tpthread_t tid;\n\tint ret;\n\n\tpthread_mutex_lock(&poller->mutex);\n\tif (__poller_open_pipe(poller) >= 0) {\n\t\tret = pthread_create(&tid, NULL, __poller_thread_routine, poller);\n\t\tif (ret == 0) {\n\t\t\tpoller->tid = tid;\n\t\t\tpoller->stopped = 0;\n\t\t}\n\t\telse {\n\t\t\terrno = ret;\n\t\t\tclose(poller->pipe_wr);\n\t\t\tclose(poller->pipe_rd);\n\t\t}\n\t}\n\n\tpthread_mutex_unlock(&poller->mutex);\n\treturn -poller->stopped;\n}\n```\n\n\n\n1. __poller_open_pipepipfdpipfdepollfdpipfd__pollerPSpipfd\n\n2. \n\nMuduo****One loop per threadworkflow__pollerMuduoMuduoOne loop per threadMuduoworkflowOne loop per threadloopMuduoworkflow__poller\n\n__poller_thread_routine\n\n```cpp\nstatic void *__poller_thread_routine(void *arg) {\n\tpoller_t *poller = (poller_t *)arg;\n\t__poller_event_t events[POLLER_EVENTS_MAX];\n\tstruct __poller_node time_node;\n\tstruct __poller_node *node;\n\tint has_pipe_event;\n\tint nevents;\n\tint i;\n\n\twhile (1) {\n\t\t// \n\t\t__poller_set_timer(poller);\n\t\t// \n\t\tnevents = __poller_wait(events, POLLER_EVENTS_MAX, poller);\n\t\t// \n\t\tclock_gettime(CLOCK_MONOTONIC, &time_node.timeout);\n\t\t// pipfd\n\t\thas_pipe_event = 0;\n\t\tfor (i = 0; i < nevents; i++) {\n\t\t\t// private__poller_node*\n\t\t\tnode = (struct __poller_node *)__poller_event_data(&events[i]);\n\t\t\tif (node <= (struct __poller_node *)1) {\t// pipfd\n\t\t\t\tif (node == (struct __poller_node *)1)\n\t\t\t\t\thas_pipe_event = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// __poller_node.dataoperation\n\t\t\tswitch (node->data.operation) {\n\t\t\tcase PD_OP_READ:\n\t\t\t\t__poller_handle_read(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_WRITE:\n\t\t\t\t__poller_handle_write(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_LISTEN:\n\t\t\t\t__poller_handle_listen(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_CONNECT:\n\t\t\t\t__poller_handle_connect(node, poller);\n\t\t\t\tbreak;\n\t\t\t/* SSLUDP... */\n\t\t\tcase PD_OP_EVENT:\n\t\t\t\t__poller_handle_event(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_NOTIFY:\n\t\t\t\t__poller_handle_notify(node, poller);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (has_pipe_event) {\n\t\t\t// \n\t\t\tif (__poller_handle_pipe(poller))\n\t\t\t\tbreak;\n\t\t}\n\t\t// __poller_node\n\t\t__poller_handle_timeout(&time_node, poller);\n\t}\n\n\treturn NULL;\n}\n```\n\n\n\n![](./TCPServer_1/photo/EventLoopFlowChart.drawio.png)\n\nMuduoone loop per thread\n\n![](./TCPServer_1/photo/EventLoopThreadPool.drawio.png)\n\n[Muduoone loop per thread](../muduo/EventLoopThreadPool.md)[xv6](../xv6/Scheduler.md)workflow__poller\n\n### poller_node\n\npollerpoller_nodepoller_addpoller_delpoller_mod\n\n****\n\nsylarmuduo\n\n```bash\npoller_add -> pollerpoller_node;\n\npoller_del -> poller_node;\n\npoller_mod -> poller_node;\n```\n\n****\n\n1. poller_addpoller_node.data.fd/****epollpoller_node.timeoutpoller_node**timefd**\n\n2. poller_delpoller_node.data.fd/epoll****\n\n3. poller_mod****epollpoller_node.data.fd/poller_node****poller_node/**timefd**\n\n****\n\npoller\n\npoller_nodepoller_node/poller_addpoller_modpoller__poller_insert_node**poller_node/poller_nodetimefd**\n\npoller_node\n\n```cpp\n\nstatic void __poller_insert_node(struct __poller_node *node,\n\t\t\t\t\t\t\t\t poller_t *poller) {\n\tstruct __poller_node *end;\n\n\tend = list_entry(poller->timeo_list.prev, struct __poller_node, list);\n\tif (list_empty(&poller->timeo_list)) {\n\t\tlist_add(&node->list, &poller->timeo_list);\n\t\tend = rb_entry(poller->tree_first, struct __poller_node, rb);\n\t} else if (__timeout_cmp(node, end) >= 0) {\n\t\tlist_add_tail(&node->list, &poller->timeo_list);\n\t\treturn;\n\t} else {\n\t\t__poller_tree_insert(node, poller);\n\t\tif (&node->rb != poller->tree_first)\n\t\t\treturn;\n\n\t\tend = list_entry(poller->timeo_list.next, struct __poller_node, list);\n\t}\n\n\tif (!poller->tree_first || __timeout_cmp(node, end) < 0)\n\t\t__poller_set_timerfd(poller->timerfd, &node->timeout, poller);\n}\n```\n\n\n\nnodepoller_node\n\n0. \n\n1. nodepoller_nodenodepoller_nodetimefdnode\n\n2. nodepoller_nodenodetimefd\n\n3. nodenodenodenodenodetimefdnode\n\nnode/nodetimefd\n\n1. \n\n2. \n\npoller\n\npoller_addpoller_mod__poller_new_nodemallocpoller_node\n\npoller_delpoller_node/**poller_nodepipepipepoller->callback**\n\npoller_del\n\n```cpp\nint poller_del(int fd, poller_t *poller) {\n\tstruct __poller_node *node;\n\tint stopped = 0;\n\n\tpthread_mutex_lock(&poller->mutex);\n\tnode = poller->nodes[fd];\n\tif (node) {\n\t\tpoller->nodes[fd] = NULL;\n\n\t\tif (node->in_rbtree)\n\t\t\t__poller_tree_erase(node, poller);\n\t\telse\n\t\t\t// list_del\n\t\t\tlist_del(&node->list);\n\n\t\t__poller_del_fd(fd, node->event, poller);\n\n\t\tnode->error = 0;\n\t\tnode->state = PR_ST_DELETED;\n\t\tstopped = poller->stopped;\n\t\tif (!stopped) {\n\t\t\tnode->removed = 1;\n\t\t\t// pipepipe\n\t\t\twrite(poller->pipe_wr, &node, sizeof (void *));\n\t\t}\n\t}\n\telse\n\t\terrno = ENOENT;\n\n\tpthread_mutex_unlock(&poller->mutex);\n\tif (stopped) {\n\t\t// pipe\n\t\tfree(node->res);\n\t\tpoller->callback((struct poller_result *)node, poller->context);\n\t}\n\n\treturn -!node;\n}\n```\n\n### \n\npollerpoller_add_timerpoller_del_timer\n\n  \n\n- n ms1\n\n- ioHTTPkeepalived\n\n****io****\n\npollerfd-1__poller_nodeepoll/IO\n\npoller_add_timer\n\n```cpp\nint poller_add_timer(const struct timespec *value, void *context, void **timer,\n\t\t\t\t\t poller_t *poller) {\n\tstruct __poller_node *node;\n\n\tnode = (struct __poller_node *)malloc(sizeof (struct __poller_node));\n\tif (node) {\n\t\tnode->data.operation = PD_OP_TIMER;\n\t\tnode->data.fd = -1;\t\t\t\t\t// \n\t\tnode->data.context = context;\n\n\t\t/* ... */\n\t\tclock_gettime(CLOCK_MONOTONIC, &node->timeout);\n\t\tnode->timeout.tv_sec += value->tv_sec;\n\t\tnode->timeout.tv_nsec += value->tv_nsec;\n\t\tif (node->timeout.tv_nsec >= 1000000000) {\n\t\t\tnode->timeout.tv_nsec -= 1000000000;\n\t\t\tnode->timeout.tv_sec++;\n\t\t}\n\n\t\t*timer = node;\n\t\tpthread_mutex_lock(&poller->mutex);\n\t\t__poller_insert_node(node, poller);\t// poller_node/\n\t\tpthread_mutex_unlock(&poller->mutex);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n```\n\n__poller_insert_nodepoller_del_timerpoller_del\n\n### \n\npollerIOworkflowTCPServerTCP\n\n```\n\t+-----------+\n\t|\tsocket\t|\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tbind\t|\tCommunicator\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tlisten\t|\n\t+-----------+\n\t\t|\t\t\t______________________________________________\n\t\tV\n\t+-----------+\n\t|\taccept\t|\t\n\t+-----------+\n\t|\t|\t|\t|\n\tV\tV\tV\tV\n\tfd\tfd\tfd\t...\n\t\t/\\\n\tread  write\n```\n\n\n\n======================================================\n\naccept__poller_handle_listen\n\n```cpp\n\nstatic void __poller_handle_listen(struct __poller_node *node,\n\t\t\t\t\t\t\t\t   poller_t *poller) {\n\tstruct __poller_node *res = node->res;\n\t/* ... */\n\twhile (1) {\n\t\taddrlen = sizeof (struct sockaddr_storage);\n\t\tsockfd = accept(node->data.fd, addr, &addrlen);\n\t\tif (sockfd < 0) {\n\t\t\tif (errno == EAGAIN || errno == EMFILE || errno == ENFILE)\n\t\t\t\treturn;\n\t\t\telse if (errno == ECONNABORTED)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tresult = node->data.accept(addr, addrlen, sockfd, node->data.context);\n\t\tif (!result)\n\t\t\tbreak;\n\n\t\tres->data = node->data;\n\t\tres->data.result = result;\n\t\tres->error = 0;\n\t\tres->state = PR_ST_SUCCESS;\n\t\tpoller->callback((struct poller_result *)res, poller->context);\n\n\t\tres = (struct __poller_node *)malloc(sizeof (struct __poller_node));\n\t\tnode->res = res;\n\t\tif (!res)\n\t\t\tbreak;\n\t}\n\n\tif (__poller_remove_node(node, poller))\t// epollfd\n\t\treturn;\n\n\tnode->error = errno;\n\tnode->state = PR_ST_ERROR;\n\tfree(node->res);\n\tpoller->callback((struct poller_result *)node, poller->context);\t// server\t\n}\n```\n\nwhile\n\n1. acceptEAGAINEMFILEENFILEECONNABORTEDreturnreturncontinuecontinue\n\n2. ioscoketfdnode->data.accept Communicator::acceptCommServiceTarget**sockfd**CommServiceTargetCommunicatorCommServiceTargetIO\n\n3. poller->callbackreadwriteiopoller->callbackCommunicatorsockfd****poller_nodepoller\n\n======================================================\n\nread__poller_handle_readSSL\n\n```cpp\nstatic int __poller_append_message(const void *buf, size_t *n,\n\t\t\t\t\t\t\t\t   struct __poller_node *node,\n\t\t\t\t\t\t\t\t   poller_t *poller) {\n\tpoller_message_t *msg = node->data.message;\n\tstruct __poller_node *res;\n\tint ret;\n\n\tif (!msg) {\t// msg\n\t\tres = (struct __poller_node *)malloc(sizeof (struct __poller_node));\n\t\tif (!res)\n\t\t\treturn -1;\n\n\t\tmsg = node->data.create_message(node->data.context);\n\t\tif (!msg) {\n\t\t\tfree(res);\n\t\t\treturn -1;\n\t\t}\n\n\t\tnode->data.message = msg;\n\t\tnode->res = res;\n\t}\n\telse\n\t\tres = node->res;\n\n\tret = msg->append(buf, n, msg);\t// msgPStcp\n\tif (ret > 0) {\n\t\tres->data = node->data;\n\t\tres->error = 0;\n\t\tres->state = PR_ST_SUCCESS;\n\t\t// msgpoller->callback\n\t\tpoller->callback((struct poller_result *)res, poller->context);\n\n\t\tnode->data.message = NULL;\t// \n\t\tnode->res = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic void __poller_handle_read(struct __poller_node *node,\n\t\t\t\t\t\t\t\t poller_t *poller) {\n\tssize_t nleft;\n\tsize_t n;\n\tchar *p;\n\n\twhile (1) {\n\t\tp = poller->buf;\n\t\tnleft = read(node->data.fd, p, POLLER_BUFSIZE);\n\t\tif (nleft < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (nleft <= 0)\n\t\t\tbreak;\n\n\t\tdo {\n\t\t\tn = nleft;\n\t\t\tif (__poller_append_message(p, &n, node, poller) >= 0) {\n\t\t\t\tnleft -= n;\n\t\t\t\tp += n;\n\t\t\t}\n\t\t\telse\n\t\t\t\tnleft = -1;\n\t\t} while (nleft > 0);\n\n\t\tif (nleft < 0)\n\t\t\tbreak;\n\t}\t// \n\n\tif (__poller_remove_node(node, poller))\n\t\treturn;\n\n\tif (nleft == 0) {\n\t\tnode->error = 0;\n\t\tnode->state = PR_ST_FINISHED;\n\t} else {\n\t\tnode->error = errno;\n\t\tnode->state = PR_ST_ERROR;\n\t}\n\n\tfree(node->res);\n\tpoller->callback((struct poller_result *)node, poller->context);\n}\n```\n\nread__poller_handle_readread__poller_append_messagepoller->callback**__poller_append_messagemsg->appendHTTPDNS**\n\nreadbufferpoller->bufpollerfdreadbufferread\n\npollerIO\n\n__poller_handle_read__poller_handle_readpoller->buf__poller_append_messagemsg->append****poller->bufreadpoller->buf\n\n======================================================\n\nwrite__poller_handle_write\n\n```cpp\nstatic void __poller_handle_write(struct __poller_node *node,\n\t\t\t\t\t\t\t\t  poller_t *poller)\n{\n\tstruct iovec *iov = node->data.write_iov;\n\tsize_t count = 0;\n\tssize_t nleft;\n\tint iovcnt;\n\tint ret;\n\n\twhile (node->data.iovcnt > 0) {\n\t\tiovcnt = node->data.iovcnt;\n\t\tif (iovcnt > IOV_MAX)\n\t\t\tiovcnt = IOV_MAX;\n\n\t\tnleft = writev(node->data.fd, iov, iovcnt);\n\t\tif (nleft < 0) {\n\t\t\tret = errno == EAGAIN ? 0 : -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount += nleft;\n\t\tdo {\t\t\t\t\t\t\t// iov\n\t\t\tif (nleft >= iov->iov_len) {\n\t\t\t\tnleft -= iov->iov_len;\n\t\t\t\tiov->iov_base = (char *)iov->iov_base + iov->iov_len;\n\t\t\t\tiov->iov_len = 0;\n\t\t\t\tiov++;\n\t\t\t\tnode->data.iovcnt--;\n\t\t\t} else {\n\t\t\t\tiov->iov_base = (char *)iov->iov_base + nleft;\n\t\t\t\tiov->iov_len -= nleft;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (node->data.iovcnt > 0);\n\t}\n\n\tnode->data.write_iov = iov;\n\tif (node->data.iovcnt > 0 && ret >= 0) {\n\t\tif (count == 0)\n\t\t\treturn;\n\n\t\tif (node->data.partial_written(count, node->data.context) >= 0)\t// \n\t\t\treturn;\n\t}\n\n\tif (__poller_remove_node(node, poller))\n\t\treturn;\n\n\tif (node->data.iovcnt == 0) {\t// \n\t\tnode->error = 0;\n\t\tnode->state = PR_ST_FINISHED;\t\n\t} else {\t\t\t\t\t\t// \n\t\tnode->error = errno;\n\t\tnode->state = PR_ST_ERROR;\t\t\n\t}\n\n\tpoller->callback((struct poller_result *)node, poller->context);\n}\n```\n\nwritepollersocketfdwritevwritevbufferwritevstruct iovecwritevwhiledo whiletcpdo whilebufferiovwhile\n\nEAGAINwhilenode->data.partial_writtenpoller_nodeepollpoller->callback\n\n---\n\n****","source":"_posts/workflow/TCPServer_1.md","raw":"---\ntitle: WorkFlowCommunicatorTCPServer\ndate: 2024-11-02 12:00:00\ntags:\n  - \n---\n\n[WorkFlowGO-Task ](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\n## \n\nWorkFlow GO-TaskWorkFlow Tcp ServerTCPServerpollerIOCommunicatorTCPServerTCPServerIO\n\n<!-- more -->\n\n\n\nworkflowworkflow200workflow\n\n/workflow****\n\nWorkflowTcpServerCommServiceCommServiceTCPServerCommServiceudptcptcpTcpServerCommService\n\nTcpServer\n\npoller ->  -> poller_node ->  -> IO\n\n## IOIO\n\npoller.cworkflowepolllinuxIOapiworkflow\n\n### \n\n__poller\n\n```cpp\ntypedef struct __poller poller_t;   // \n\nstruct __poller\n{\n\tsize_t max_open_files;                              // epollfdfd\n\tvoid (*callback)(struct poller_result *, void *);   // CommunicatorCommunicatorpoller_result.poller_data.operation\n\tvoid *context;                                      // callback\n\n\tpthread_t tid;                                      // epollfdid\n\tint pfd;                                            // epollfd\n\tint timerfd;\n\tint pipe_rd;                                        // /__poller_node\n\tint pipe_wr;                                        // \n\tint stopped;\n\tstruct rb_root timeo_tree;                          // __poller_node[]\n\tstruct rb_node *tree_first;\n\tstruct rb_node *tree_last;\n\tstruct list_head timeo_list;                        // __poller_node\n\tstruct list_head no_timeo_list;                     // __poller_node\n\tstruct __poller_node **nodes;                       // fd__poller_node\n\tpthread_mutex_t mutex;\n\tchar buf[POLLER_BUFSIZE];                           // buffer\n};\n```\n\npoller\n\n__poller_node\n\n1. __poller_node__poller_node\n\n    1. timeo_tree\n\n    2. timeo_list\n\n2. __poller_nodeno_timeo_list\n\n__poller_node\n\n\n\n```cpp\nstruct __poller_node\n{\n\tint state;                  // __poller_node\n\tint error;\n\tstruct poller_data data;    // \n#pragma pack(1)\n\tunion\n\t{\n\t\tstruct list_head list;  // \n\t\tstruct rb_node rb;      // \n\t};\n#pragma pack()\n\tchar in_rbtree;             // \n\tchar removed;               // epoll/node\n\tint event;                  // epoll\n\tstruct timespec timeout;    // fd\n\tstruct __poller_node *res;  // PS\n};\n```\n\nMuduo__poller + __poller_nodeMuduoEPollPollerMuduotimerfd_Muduostd::setworkflowworkflow__poller_node\n\n__poller_nodedataMuduodataMuduoChannelpoller_dataCommunicator\n\npoller_datajworkflow\n\n```cpp\nstruct poller_data\n{\n// poll\n#define PD_OP_TIMER\t\t\t0\n#define PD_OP_READ\t\t\t1\n#define PD_OP_WRITE\t\t\t2\n#define PD_OP_LISTEN\t\t3\n#define PD_OP_CONNECT\t\t4\n#define PD_OP_RECVFROM\t\t5\n/* ... */\n#define PD_OP_EVENT\t\t\t9\n#define PD_OP_NOTIFY\t\t10\n\tshort operation;\n\tunsigned short iovcnt;\n\tint fd;\n\tSSL *ssl;\n\tunion\n\t{\n\t\tpoller_message_t *(*create_message)(void *);    // \n\t\tint (*partial_written)(size_t, void *);\n\t\tvoid *(*accept)(const struct sockaddr *, socklen_t, int, void *);\n\t\tvoid *(*recvfrom)(const struct sockaddr *, socklen_t,\n\t\t\t\t\t\t  const void *, size_t, void *);\n\t\tvoid *(*event)(void *);\n\t\tvoid *(*notify)(void *, void *);\n\t};\n\tvoid *context;\n\tunion\n\t{\n\t\tpoller_message_t *message;      // create_message\n\t\tstruct iovec *write_iov;        // \n\t\tvoid *result;\n\t};\n};\n```\n\n|\t\t\t|\t\t|\n|\t:-:\t\t\t\t|\t:-:\t\t|\n|\tcreate_message\t|\tfdreadmsgfdmsg0pollercallbackCommunicator|\n|\tpartial_written\t|\tfdwritefd****\t|\n| accept\t\t\t|\tfdreadlisten fdsockfdsockfdCommServiceTarget\t|\n|\trecvfrom\t\t|\tfdreadudptcpworkflowtcp\t|\n|\tevent\t\t\t|\tfdreadfdsocket fd\t|\n|\tnotify\t|\tevent\t|\n\n\npoller_result__poller_nodepoller.cpoller_result__poller_nodeCpoller_result__poller_node**__poller_nodepoller_result*__poller_node**\n\n```cpp\n\nstruct poller_result\n{\n#define PR_ST_SUCCESS\t\t0\n#define PR_ST_FINISHED\t\t1\n#define PR_ST_ERROR\t\t\t2\n#define PR_ST_DELETED\t\t3\n#define PR_ST_MODIFIED\t\t4\n#define PR_ST_STOPPED\t\t5\n\tint state;\n\tint error;\n\tstruct poller_data data;\n\t/* In callback, spaces of six pointers are available from here. */\n};\n```\n\npoller/workflowpollerepollfd//\n\nworkflowmuduosylarepollepollioioworkflowpoller\n\n### Event Loop --- \n\nepoll/pollIOIOIO__poller  \n\n__poller__poller__mpoller__mpoller__poller__mpoller__pollermanager__pollerepollfd__mpollersocketfd__poller__poller__poller_nodesocket fd__poller__poller_nodemanager__mpoller__poller\n\n```cpp\nstatic int __mpoller_create(const struct poller_params *params,\n\t\t\t\t\t\t\tmpoller_t *mpoller) {\n\tvoid **nodes_buf = (void **)calloc(params->max_open_files, sizeof (void *));\n\tunsigned int i;\n\n\tif (nodes_buf) {\n\t\tfor (i = 0; i < mpoller->nthreads; i++) {\n\t\t\tmpoller->poller[i] = __poller_create(nodes_buf, params);\n\t\t\tif (!mpoller->poller[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == mpoller->nthreads) {\n\t\t\tmpoller->nodes_buf = nodes_buf;\n\t\t\treturn 0;\n\t\t}\n\t\t// ...\n\t}\n\n\treturn -1;\n}\n```\n\nmax_open_filesnodes_buf__poller_createnodes_buf__poller__poller_create__poller__pollernodesnodes_bufnodessocket fd__poller_node **__pollernodes_buf**\n\n **{nodessocket fd__poller_node}** linuxfd__poller__pollernodes_bufsocket fd__poller_node****__poller_nodesocket fd**__pollernodes_bufnodes_bufentry**\n\n__pollermpollermpoller_start__poller__pollerpoller_start\n\n```cpp\nint poller_start(poller_t *poller) {\n\tpthread_t tid;\n\tint ret;\n\n\tpthread_mutex_lock(&poller->mutex);\n\tif (__poller_open_pipe(poller) >= 0) {\n\t\tret = pthread_create(&tid, NULL, __poller_thread_routine, poller);\n\t\tif (ret == 0) {\n\t\t\tpoller->tid = tid;\n\t\t\tpoller->stopped = 0;\n\t\t}\n\t\telse {\n\t\t\terrno = ret;\n\t\t\tclose(poller->pipe_wr);\n\t\t\tclose(poller->pipe_rd);\n\t\t}\n\t}\n\n\tpthread_mutex_unlock(&poller->mutex);\n\treturn -poller->stopped;\n}\n```\n\n\n\n1. __poller_open_pipepipfdpipfdepollfdpipfd__pollerPSpipfd\n\n2. \n\nMuduo****One loop per threadworkflow__pollerMuduoMuduoOne loop per threadMuduoworkflowOne loop per threadloopMuduoworkflow__poller\n\n__poller_thread_routine\n\n```cpp\nstatic void *__poller_thread_routine(void *arg) {\n\tpoller_t *poller = (poller_t *)arg;\n\t__poller_event_t events[POLLER_EVENTS_MAX];\n\tstruct __poller_node time_node;\n\tstruct __poller_node *node;\n\tint has_pipe_event;\n\tint nevents;\n\tint i;\n\n\twhile (1) {\n\t\t// \n\t\t__poller_set_timer(poller);\n\t\t// \n\t\tnevents = __poller_wait(events, POLLER_EVENTS_MAX, poller);\n\t\t// \n\t\tclock_gettime(CLOCK_MONOTONIC, &time_node.timeout);\n\t\t// pipfd\n\t\thas_pipe_event = 0;\n\t\tfor (i = 0; i < nevents; i++) {\n\t\t\t// private__poller_node*\n\t\t\tnode = (struct __poller_node *)__poller_event_data(&events[i]);\n\t\t\tif (node <= (struct __poller_node *)1) {\t// pipfd\n\t\t\t\tif (node == (struct __poller_node *)1)\n\t\t\t\t\thas_pipe_event = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// __poller_node.dataoperation\n\t\t\tswitch (node->data.operation) {\n\t\t\tcase PD_OP_READ:\n\t\t\t\t__poller_handle_read(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_WRITE:\n\t\t\t\t__poller_handle_write(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_LISTEN:\n\t\t\t\t__poller_handle_listen(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_CONNECT:\n\t\t\t\t__poller_handle_connect(node, poller);\n\t\t\t\tbreak;\n\t\t\t/* SSLUDP... */\n\t\t\tcase PD_OP_EVENT:\n\t\t\t\t__poller_handle_event(node, poller);\n\t\t\t\tbreak;\n\t\t\tcase PD_OP_NOTIFY:\n\t\t\t\t__poller_handle_notify(node, poller);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (has_pipe_event) {\n\t\t\t// \n\t\t\tif (__poller_handle_pipe(poller))\n\t\t\t\tbreak;\n\t\t}\n\t\t// __poller_node\n\t\t__poller_handle_timeout(&time_node, poller);\n\t}\n\n\treturn NULL;\n}\n```\n\n\n\n![](./TCPServer_1/photo/EventLoopFlowChart.drawio.png)\n\nMuduoone loop per thread\n\n![](./TCPServer_1/photo/EventLoopThreadPool.drawio.png)\n\n[Muduoone loop per thread](../muduo/EventLoopThreadPool.md)[xv6](../xv6/Scheduler.md)workflow__poller\n\n### poller_node\n\npollerpoller_nodepoller_addpoller_delpoller_mod\n\n****\n\nsylarmuduo\n\n```bash\npoller_add -> pollerpoller_node;\n\npoller_del -> poller_node;\n\npoller_mod -> poller_node;\n```\n\n****\n\n1. poller_addpoller_node.data.fd/****epollpoller_node.timeoutpoller_node**timefd**\n\n2. poller_delpoller_node.data.fd/epoll****\n\n3. poller_mod****epollpoller_node.data.fd/poller_node****poller_node/**timefd**\n\n****\n\npoller\n\npoller_nodepoller_node/poller_addpoller_modpoller__poller_insert_node**poller_node/poller_nodetimefd**\n\npoller_node\n\n```cpp\n\nstatic void __poller_insert_node(struct __poller_node *node,\n\t\t\t\t\t\t\t\t poller_t *poller) {\n\tstruct __poller_node *end;\n\n\tend = list_entry(poller->timeo_list.prev, struct __poller_node, list);\n\tif (list_empty(&poller->timeo_list)) {\n\t\tlist_add(&node->list, &poller->timeo_list);\n\t\tend = rb_entry(poller->tree_first, struct __poller_node, rb);\n\t} else if (__timeout_cmp(node, end) >= 0) {\n\t\tlist_add_tail(&node->list, &poller->timeo_list);\n\t\treturn;\n\t} else {\n\t\t__poller_tree_insert(node, poller);\n\t\tif (&node->rb != poller->tree_first)\n\t\t\treturn;\n\n\t\tend = list_entry(poller->timeo_list.next, struct __poller_node, list);\n\t}\n\n\tif (!poller->tree_first || __timeout_cmp(node, end) < 0)\n\t\t__poller_set_timerfd(poller->timerfd, &node->timeout, poller);\n}\n```\n\n\n\nnodepoller_node\n\n0. \n\n1. nodepoller_nodenodepoller_nodetimefdnode\n\n2. nodepoller_nodenodetimefd\n\n3. nodenodenodenodenodetimefdnode\n\nnode/nodetimefd\n\n1. \n\n2. \n\npoller\n\npoller_addpoller_mod__poller_new_nodemallocpoller_node\n\npoller_delpoller_node/**poller_nodepipepipepoller->callback**\n\npoller_del\n\n```cpp\nint poller_del(int fd, poller_t *poller) {\n\tstruct __poller_node *node;\n\tint stopped = 0;\n\n\tpthread_mutex_lock(&poller->mutex);\n\tnode = poller->nodes[fd];\n\tif (node) {\n\t\tpoller->nodes[fd] = NULL;\n\n\t\tif (node->in_rbtree)\n\t\t\t__poller_tree_erase(node, poller);\n\t\telse\n\t\t\t// list_del\n\t\t\tlist_del(&node->list);\n\n\t\t__poller_del_fd(fd, node->event, poller);\n\n\t\tnode->error = 0;\n\t\tnode->state = PR_ST_DELETED;\n\t\tstopped = poller->stopped;\n\t\tif (!stopped) {\n\t\t\tnode->removed = 1;\n\t\t\t// pipepipe\n\t\t\twrite(poller->pipe_wr, &node, sizeof (void *));\n\t\t}\n\t}\n\telse\n\t\terrno = ENOENT;\n\n\tpthread_mutex_unlock(&poller->mutex);\n\tif (stopped) {\n\t\t// pipe\n\t\tfree(node->res);\n\t\tpoller->callback((struct poller_result *)node, poller->context);\n\t}\n\n\treturn -!node;\n}\n```\n\n### \n\npollerpoller_add_timerpoller_del_timer\n\n  \n\n- n ms1\n\n- ioHTTPkeepalived\n\n****io****\n\npollerfd-1__poller_nodeepoll/IO\n\npoller_add_timer\n\n```cpp\nint poller_add_timer(const struct timespec *value, void *context, void **timer,\n\t\t\t\t\t poller_t *poller) {\n\tstruct __poller_node *node;\n\n\tnode = (struct __poller_node *)malloc(sizeof (struct __poller_node));\n\tif (node) {\n\t\tnode->data.operation = PD_OP_TIMER;\n\t\tnode->data.fd = -1;\t\t\t\t\t// \n\t\tnode->data.context = context;\n\n\t\t/* ... */\n\t\tclock_gettime(CLOCK_MONOTONIC, &node->timeout);\n\t\tnode->timeout.tv_sec += value->tv_sec;\n\t\tnode->timeout.tv_nsec += value->tv_nsec;\n\t\tif (node->timeout.tv_nsec >= 1000000000) {\n\t\t\tnode->timeout.tv_nsec -= 1000000000;\n\t\t\tnode->timeout.tv_sec++;\n\t\t}\n\n\t\t*timer = node;\n\t\tpthread_mutex_lock(&poller->mutex);\n\t\t__poller_insert_node(node, poller);\t// poller_node/\n\t\tpthread_mutex_unlock(&poller->mutex);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n```\n\n__poller_insert_nodepoller_del_timerpoller_del\n\n### \n\npollerIOworkflowTCPServerTCP\n\n```\n\t+-----------+\n\t|\tsocket\t|\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tbind\t|\tCommunicator\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tlisten\t|\n\t+-----------+\n\t\t|\t\t\t______________________________________________\n\t\tV\n\t+-----------+\n\t|\taccept\t|\t\n\t+-----------+\n\t|\t|\t|\t|\n\tV\tV\tV\tV\n\tfd\tfd\tfd\t...\n\t\t/\\\n\tread  write\n```\n\n\n\n======================================================\n\naccept__poller_handle_listen\n\n```cpp\n\nstatic void __poller_handle_listen(struct __poller_node *node,\n\t\t\t\t\t\t\t\t   poller_t *poller) {\n\tstruct __poller_node *res = node->res;\n\t/* ... */\n\twhile (1) {\n\t\taddrlen = sizeof (struct sockaddr_storage);\n\t\tsockfd = accept(node->data.fd, addr, &addrlen);\n\t\tif (sockfd < 0) {\n\t\t\tif (errno == EAGAIN || errno == EMFILE || errno == ENFILE)\n\t\t\t\treturn;\n\t\t\telse if (errno == ECONNABORTED)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tresult = node->data.accept(addr, addrlen, sockfd, node->data.context);\n\t\tif (!result)\n\t\t\tbreak;\n\n\t\tres->data = node->data;\n\t\tres->data.result = result;\n\t\tres->error = 0;\n\t\tres->state = PR_ST_SUCCESS;\n\t\tpoller->callback((struct poller_result *)res, poller->context);\n\n\t\tres = (struct __poller_node *)malloc(sizeof (struct __poller_node));\n\t\tnode->res = res;\n\t\tif (!res)\n\t\t\tbreak;\n\t}\n\n\tif (__poller_remove_node(node, poller))\t// epollfd\n\t\treturn;\n\n\tnode->error = errno;\n\tnode->state = PR_ST_ERROR;\n\tfree(node->res);\n\tpoller->callback((struct poller_result *)node, poller->context);\t// server\t\n}\n```\n\nwhile\n\n1. acceptEAGAINEMFILEENFILEECONNABORTEDreturnreturncontinuecontinue\n\n2. ioscoketfdnode->data.accept Communicator::acceptCommServiceTarget**sockfd**CommServiceTargetCommunicatorCommServiceTargetIO\n\n3. poller->callbackreadwriteiopoller->callbackCommunicatorsockfd****poller_nodepoller\n\n======================================================\n\nread__poller_handle_readSSL\n\n```cpp\nstatic int __poller_append_message(const void *buf, size_t *n,\n\t\t\t\t\t\t\t\t   struct __poller_node *node,\n\t\t\t\t\t\t\t\t   poller_t *poller) {\n\tpoller_message_t *msg = node->data.message;\n\tstruct __poller_node *res;\n\tint ret;\n\n\tif (!msg) {\t// msg\n\t\tres = (struct __poller_node *)malloc(sizeof (struct __poller_node));\n\t\tif (!res)\n\t\t\treturn -1;\n\n\t\tmsg = node->data.create_message(node->data.context);\n\t\tif (!msg) {\n\t\t\tfree(res);\n\t\t\treturn -1;\n\t\t}\n\n\t\tnode->data.message = msg;\n\t\tnode->res = res;\n\t}\n\telse\n\t\tres = node->res;\n\n\tret = msg->append(buf, n, msg);\t// msgPStcp\n\tif (ret > 0) {\n\t\tres->data = node->data;\n\t\tres->error = 0;\n\t\tres->state = PR_ST_SUCCESS;\n\t\t// msgpoller->callback\n\t\tpoller->callback((struct poller_result *)res, poller->context);\n\n\t\tnode->data.message = NULL;\t// \n\t\tnode->res = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic void __poller_handle_read(struct __poller_node *node,\n\t\t\t\t\t\t\t\t poller_t *poller) {\n\tssize_t nleft;\n\tsize_t n;\n\tchar *p;\n\n\twhile (1) {\n\t\tp = poller->buf;\n\t\tnleft = read(node->data.fd, p, POLLER_BUFSIZE);\n\t\tif (nleft < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (nleft <= 0)\n\t\t\tbreak;\n\n\t\tdo {\n\t\t\tn = nleft;\n\t\t\tif (__poller_append_message(p, &n, node, poller) >= 0) {\n\t\t\t\tnleft -= n;\n\t\t\t\tp += n;\n\t\t\t}\n\t\t\telse\n\t\t\t\tnleft = -1;\n\t\t} while (nleft > 0);\n\n\t\tif (nleft < 0)\n\t\t\tbreak;\n\t}\t// \n\n\tif (__poller_remove_node(node, poller))\n\t\treturn;\n\n\tif (nleft == 0) {\n\t\tnode->error = 0;\n\t\tnode->state = PR_ST_FINISHED;\n\t} else {\n\t\tnode->error = errno;\n\t\tnode->state = PR_ST_ERROR;\n\t}\n\n\tfree(node->res);\n\tpoller->callback((struct poller_result *)node, poller->context);\n}\n```\n\nread__poller_handle_readread__poller_append_messagepoller->callback**__poller_append_messagemsg->appendHTTPDNS**\n\nreadbufferpoller->bufpollerfdreadbufferread\n\npollerIO\n\n__poller_handle_read__poller_handle_readpoller->buf__poller_append_messagemsg->append****poller->bufreadpoller->buf\n\n======================================================\n\nwrite__poller_handle_write\n\n```cpp\nstatic void __poller_handle_write(struct __poller_node *node,\n\t\t\t\t\t\t\t\t  poller_t *poller)\n{\n\tstruct iovec *iov = node->data.write_iov;\n\tsize_t count = 0;\n\tssize_t nleft;\n\tint iovcnt;\n\tint ret;\n\n\twhile (node->data.iovcnt > 0) {\n\t\tiovcnt = node->data.iovcnt;\n\t\tif (iovcnt > IOV_MAX)\n\t\t\tiovcnt = IOV_MAX;\n\n\t\tnleft = writev(node->data.fd, iov, iovcnt);\n\t\tif (nleft < 0) {\n\t\t\tret = errno == EAGAIN ? 0 : -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount += nleft;\n\t\tdo {\t\t\t\t\t\t\t// iov\n\t\t\tif (nleft >= iov->iov_len) {\n\t\t\t\tnleft -= iov->iov_len;\n\t\t\t\tiov->iov_base = (char *)iov->iov_base + iov->iov_len;\n\t\t\t\tiov->iov_len = 0;\n\t\t\t\tiov++;\n\t\t\t\tnode->data.iovcnt--;\n\t\t\t} else {\n\t\t\t\tiov->iov_base = (char *)iov->iov_base + nleft;\n\t\t\t\tiov->iov_len -= nleft;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (node->data.iovcnt > 0);\n\t}\n\n\tnode->data.write_iov = iov;\n\tif (node->data.iovcnt > 0 && ret >= 0) {\n\t\tif (count == 0)\n\t\t\treturn;\n\n\t\tif (node->data.partial_written(count, node->data.context) >= 0)\t// \n\t\t\treturn;\n\t}\n\n\tif (__poller_remove_node(node, poller))\n\t\treturn;\n\n\tif (node->data.iovcnt == 0) {\t// \n\t\tnode->error = 0;\n\t\tnode->state = PR_ST_FINISHED;\t\n\t} else {\t\t\t\t\t\t// \n\t\tnode->error = errno;\n\t\tnode->state = PR_ST_ERROR;\t\t\n\t}\n\n\tpoller->callback((struct poller_result *)node, poller->context);\n}\n```\n\nwritepollersocketfdwritevwritevbufferwritevstruct iovecwritevwhiledo whiletcpdo whilebufferiovwhile\n\nEAGAINwhilenode->data.partial_writtenpoller_nodeepollpoller->callback\n\n---\n\n****","slug":"workflow/TCPServer_1","published":1,"updated":"2025-09-28T14:33:27.743Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9s000uq8ws80lh02fu","content":"<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlowGO-Task </a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlowCommunicatorTCPServer</a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>WorkFlow GO-TaskWorkFlow Tcp ServerTCPServerpollerIOCommunicatorTCPServerTCPServerIO</p>\n<span id=\"more\"></span>\n\n<p></p>\n<p>workflowworkflow200workflow</p>\n<p>&#x2F;workflow<strong></strong></p>\n<p>WorkflowTcpServerCommServiceCommServiceTCPServerCommServiceudptcptcpTcpServerCommService</p>\n<p>TcpServer</p>\n<p>poller -&gt;  -&gt; poller_node -&gt;  -&gt; IO</p>\n<h2 id=\"IOIO\"><a href=\"#IOIO\" class=\"headerlink\" title=\"IOIO\"></a>IOIO</h2><p>poller.cworkflowepolllinuxIOapiworkflow</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>__poller</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">__poller</span> <span class=\"type\">poller_t</span>;   <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">__poller</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> max_open_files;                              <span class=\"comment\">// epollfdfd</span></span><br><span class=\"line\">\t<span class=\"built_in\">void</span> (*callback)(<span class=\"keyword\">struct</span> poller_result *, <span class=\"type\">void</span> *);   <span class=\"comment\">// CommunicatorCommunicatorpoller_result.poller_data.operation</span></span><br><span class=\"line\">\t<span class=\"type\">void</span> *context;                                      <span class=\"comment\">// callback</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">pthread_t</span> tid;                                      <span class=\"comment\">// epollfdid</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> pfd;                                            <span class=\"comment\">// epollfd</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> timerfd;</span><br><span class=\"line\">\t<span class=\"type\">int</span> pipe_rd;                                        <span class=\"comment\">// /__poller_node</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> pipe_wr;                                        <span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"type\">int</span> stopped;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_root</span> timeo_tree;                          <span class=\"comment\">// __poller_node[]</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_node</span> *tree_first;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_node</span> *tree_last;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> timeo_list;                        <span class=\"comment\">// __poller_node</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> no_timeo_list;                     <span class=\"comment\">// __poller_node</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> **nodes;                       <span class=\"comment\">// fd__poller_node</span></span><br><span class=\"line\">\t<span class=\"type\">pthread_mutex_t</span> mutex;</span><br><span class=\"line\">\t<span class=\"type\">char</span> buf[POLLER_BUFSIZE];                           <span class=\"comment\">// buffer</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>poller</p>\n<p>__poller_node</p>\n<ol>\n<li><p>__poller_node__poller_node</p>\n<ol>\n<li><p>timeo_tree</p>\n</li>\n<li><p>timeo_list</p>\n</li>\n</ol>\n</li>\n<li><p>__poller_nodeno_timeo_list</p>\n</li>\n</ol>\n<p>__poller_node</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> state;                  <span class=\"comment\">// __poller_node</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> error;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span> data;    <span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack(1)</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> list;  <span class=\"comment\">// </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_node</span> rb;      <span class=\"comment\">// </span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack()</span></span><br><span class=\"line\">\t<span class=\"type\">char</span> in_rbtree;             <span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"type\">char</span> removed;               <span class=\"comment\">// epoll/node</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> event;                  <span class=\"comment\">// epoll</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">timespec</span> timeout;    <span class=\"comment\">// fd</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *res;  <span class=\"comment\">// PS</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Muduo__poller + __poller_nodeMuduoEPollPollerMuduotimerfd_Muduostd::setworkflowworkflow__poller_node</p>\n<p>__poller_nodedataMuduodataMuduoChannelpoller_dataCommunicator</p>\n<p>poller_datajworkflow</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">// poll</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_TIMER\t\t\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_READ\t\t\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_WRITE\t\t\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_LISTEN\t\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_CONNECT\t\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_RECVFROM\t\t5</span></span><br><span class=\"line\"><span class=\"comment\">/* ... */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_EVENT\t\t\t9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_NOTIFY\t\t10</span></span><br><span class=\"line\">\t<span class=\"type\">short</span> operation;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">short</span> iovcnt;</span><br><span class=\"line\">\t<span class=\"type\">int</span> fd;</span><br><span class=\"line\">\tSSL *ssl;</span><br><span class=\"line\">\t<span class=\"keyword\">union</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">poller_message_t</span> *(*create_message)(<span class=\"type\">void</span> *);    <span class=\"comment\">// </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">int</span> (*partial_written)(<span class=\"type\">size_t</span>, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*accept)(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *, <span class=\"type\">socklen_t</span>, <span class=\"type\">int</span>, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*recvfrom)(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *, <span class=\"type\">socklen_t</span>,</span><br><span class=\"line\">\t\t\t\t\t\t  <span class=\"type\">const</span> <span class=\"type\">void</span> *, <span class=\"type\">size_t</span>, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*event)(<span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*notify)(<span class=\"type\">void</span> *, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"type\">void</span> *context;</span><br><span class=\"line\">\t<span class=\"keyword\">union</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">poller_message_t</span> *message;      <span class=\"comment\">// create_message</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> *write_iov;        <span class=\"comment\">// </span></span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *result;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>|\t\t\t|\t\t|<br>|\t:-:\t\t\t\t|\t:-:\t\t|<br>|\tcreate_message\t|\tfdreadmsgfdmsg0pollercallbackCommunicator|<br>|\tpartial_written\t|\tfdwritefd<strong></strong>\t|<br>| accept\t\t\t|\tfdreadlisten fdsockfdsockfdCommServiceTarget\t|<br>|\trecvfrom\t\t|\tfdreadudptcpworkflowtcp\t|<br>|\tevent\t\t\t|\tfdreadfdsocket fd\t|<br>|\tnotify\t|\tevent\t|</p>\n<p>poller_result__poller_nodepoller.cpoller_result__poller_nodeCpoller_result__poller_node<strong>__poller_nodepoller_result*__poller_node</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">poller_result</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_SUCCESS\t\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_FINISHED\t\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_ERROR\t\t\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_DELETED\t\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_MODIFIED\t\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_STOPPED\t\t5</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> state;</span><br><span class=\"line\">\t<span class=\"type\">int</span> error;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span> data;</span><br><span class=\"line\">\t<span class=\"comment\">/* In callback, spaces of six pointers are available from here. */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>poller&#x2F;workflowpollerepollfd&#x2F;&#x2F;</p>\n<p>workflowmuduosylarepollepollioioworkflowpoller</p>\n<h3 id=\"Event-Loop--\"><a href=\"#Event-Loop--\" class=\"headerlink\" title=\"Event Loop  \"></a>Event Loop  </h3><p>epoll&#x2F;pollIOIOIO__poller  </p>\n<p>__poller__poller__mpoller__mpoller__poller__mpoller__pollermanager__pollerepollfd__mpollersocketfd__poller__poller__poller_nodesocket fd__poller__poller_nodemanager__mpoller__poller</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __mpoller_create(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> poller_params *params,</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"type\">mpoller_t</span> *mpoller) &#123;</span><br><span class=\"line\">\t<span class=\"type\">void</span> **nodes_buf = (<span class=\"type\">void</span> **)<span class=\"built_in\">calloc</span>(params-&gt;max_open_files, <span class=\"built_in\">sizeof</span> (<span class=\"type\">void</span> *));</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (nodes_buf) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; mpoller-&gt;nthreads; i++) &#123;</span><br><span class=\"line\">\t\t\tmpoller-&gt;poller[i] = __poller_create(nodes_buf, params);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!mpoller-&gt;poller[i])</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == mpoller-&gt;nthreads) &#123;</span><br><span class=\"line\">\t\t\tmpoller-&gt;nodes_buf = nodes_buf;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>max_open_filesnodes_buf__poller_createnodes_buf__poller__poller_create__poller__pollernodesnodes_bufnodessocket fd__poller_node <strong>__pollernodes_buf</strong></p>\n<p> <strong>{nodessocket fd__poller_node}</strong> linuxfd__poller__pollernodes_bufsocket fd__poller_node<strong></strong>__poller_nodesocket fd<strong>__pollernodes_bufnodes_bufentry</strong></p>\n<p>__pollermpollermpoller_start__poller__pollerpoller_start</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">poller_start</span><span class=\"params\">(<span class=\"type\">poller_t</span> *poller)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">pthread_t</span> tid;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_open_pipe(poller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tret = <span class=\"built_in\">pthread_create</span>(&amp;tid, <span class=\"literal\">NULL</span>, __poller_thread_routine, poller);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tpoller-&gt;tid = tid;</span><br><span class=\"line\">\t\t\tpoller-&gt;stopped = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\terrno = ret;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(poller-&gt;pipe_wr);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(poller-&gt;pipe_rd);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -poller-&gt;stopped;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<ol>\n<li><p>__poller_open_pipepipfdpipfdepollfdpipfd__pollerPSpipfd</p>\n</li>\n<li><p></p>\n</li>\n</ol>\n<p>Muduo<strong></strong>One loop per threadworkflow__pollerMuduoMuduoOne loop per threadMuduoworkflowOne loop per threadloopMuduoworkflow__poller</p>\n<p>__poller_thread_routine</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *__poller_thread_routine(<span class=\"type\">void</span> *arg) &#123;</span><br><span class=\"line\">\t<span class=\"type\">poller_t</span> *poller = (<span class=\"type\">poller_t</span> *)arg;</span><br><span class=\"line\">\t<span class=\"type\">__poller_event_t</span> events[POLLER_EVENTS_MAX];</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> time_node;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *node;</span><br><span class=\"line\">\t<span class=\"type\">int</span> has_pipe_event;</span><br><span class=\"line\">\t<span class=\"type\">int</span> nevents;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t__poller_set_timer(poller);</span><br><span class=\"line\">\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\tnevents = __poller_wait(events, POLLER_EVENTS_MAX, poller);</span><br><span class=\"line\">\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">clock_gettime</span>(CLOCK_MONOTONIC, &amp;time_node.timeout);</span><br><span class=\"line\">\t\t<span class=\"comment\">// pipfd</span></span><br><span class=\"line\">\t\thas_pipe_event = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nevents; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// private__poller_node*</span></span><br><span class=\"line\">\t\t\tnode = (<span class=\"keyword\">struct</span> __poller_node *)__poller_event_data(&amp;events[i]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (node &lt;= (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"number\">1</span>) &#123;\t<span class=\"comment\">// pipfd</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (node == (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t\thas_pipe_event = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// __poller_node.dataoperation</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (node-&gt;data.operation) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_READ:</span><br><span class=\"line\">\t\t\t\t__poller_handle_read(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_WRITE:</span><br><span class=\"line\">\t\t\t\t__poller_handle_write(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_LISTEN:</span><br><span class=\"line\">\t\t\t\t__poller_handle_listen(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_CONNECT:</span><br><span class=\"line\">\t\t\t\t__poller_handle_connect(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* SSLUDP... */</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_EVENT:</span><br><span class=\"line\">\t\t\t\t__poller_handle_event(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_NOTIFY:</span><br><span class=\"line\">\t\t\t\t__poller_handle_notify(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (has_pipe_event) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (__poller_handle_pipe(poller))</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// __poller_node</span></span><br><span class=\"line\">\t\t__poller_handle_timeout(&amp;time_node, poller);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p><img src=\"/2024/11/02/workflow/TCPServer_1/photo/EventLoopFlowChart.drawio.png\"></p>\n<p>Muduoone loop per thread</p>\n<p><img src=\"/2024/11/02/workflow/TCPServer_1/photo/EventLoopThreadPool.drawio.png\"></p>\n<p><a href=\"../muduo/EventLoopThreadPool.md\">Muduoone loop per thread</a><a href=\"../xv6/Scheduler.md\">xv6</a>workflow__poller</p>\n<h3 id=\"poller-node\"><a href=\"#poller-node\" class=\"headerlink\" title=\"poller_node\"></a>poller_node</h3><p>pollerpoller_nodepoller_addpoller_delpoller_mod</p>\n<p><strong></strong></p>\n<p>sylarmuduo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">poller_add -&gt; pollerpoller_node;</span><br><span class=\"line\"></span><br><span class=\"line\">poller_del -&gt; poller_node;</span><br><span class=\"line\"></span><br><span class=\"line\">poller_mod -&gt; poller_node;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<ol>\n<li><p>poller_addpoller_node.data.fd&#x2F;<strong></strong>epollpoller_node.timeoutpoller_node<strong>timefd</strong></p>\n</li>\n<li><p>poller_delpoller_node.data.fd&#x2F;epoll<strong></strong></p>\n</li>\n<li><p>poller_mod<strong></strong>epollpoller_node.data.fd&#x2F;poller_node<strong></strong>poller_node&#x2F;<strong>timefd</strong></p>\n</li>\n</ol>\n<p><strong></strong></p>\n<p>poller</p>\n<p>poller_nodepoller_node&#x2F;poller_addpoller_modpoller__poller_insert_node<strong>poller_node&#x2F;poller_nodetimefd</strong></p>\n<p>poller_node</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_insert_node(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *end;</span><br><span class=\"line\"></span><br><span class=\"line\">\tend = <span class=\"built_in\">list_entry</span>(poller-&gt;timeo_list.prev, <span class=\"keyword\">struct</span> __poller_node, list);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">list_empty</span>(&amp;poller-&gt;timeo_list)) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_add</span>(&amp;node-&gt;list, &amp;poller-&gt;timeo_list);</span><br><span class=\"line\">\t\tend = <span class=\"built_in\">rb_entry</span>(poller-&gt;tree_first, <span class=\"keyword\">struct</span> __poller_node, rb);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__timeout_cmp(node, end) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_add_tail</span>(&amp;node-&gt;list, &amp;poller-&gt;timeo_list);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t__poller_tree_insert(node, poller);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (&amp;node-&gt;rb != poller-&gt;tree_first)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tend = <span class=\"built_in\">list_entry</span>(poller-&gt;timeo_list.next, <span class=\"keyword\">struct</span> __poller_node, list);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!poller-&gt;tree_first || __timeout_cmp(node, end) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t__poller_set_timerfd(poller-&gt;timerfd, &amp;node-&gt;timeout, poller);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p>nodepoller_node</p>\n<ol start=\"0\">\n<li><p></p>\n</li>\n<li><p>nodepoller_nodenodepoller_nodetimefdnode</p>\n</li>\n<li><p>nodepoller_nodenodetimefd</p>\n</li>\n<li><p>nodenodenodenodenodetimefdnode</p>\n</li>\n</ol>\n<p>node&#x2F;nodetimefd</p>\n<ol>\n<li><p></p>\n</li>\n<li><p></p>\n</li>\n</ol>\n<p>poller</p>\n<p>poller_addpoller_mod__poller_new_nodemallocpoller_node</p>\n<p>poller_delpoller_node&#x2F;<strong>poller_nodepipepipepoller-&gt;callback</strong></p>\n<p>poller_del</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">poller_del</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">poller_t</span> *poller)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *node;</span><br><span class=\"line\">\t<span class=\"type\">int</span> stopped = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\tnode = poller-&gt;nodes[fd];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">\t\tpoller-&gt;nodes[fd] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node-&gt;in_rbtree)</span><br><span class=\"line\">\t\t\t__poller_tree_erase(node, poller);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// list_del</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">list_del</span>(&amp;node-&gt;list);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t__poller_del_fd(fd, node-&gt;event, poller);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnode-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_DELETED;</span><br><span class=\"line\">\t\tstopped = poller-&gt;stopped;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!stopped) &#123;</span><br><span class=\"line\">\t\t\tnode-&gt;removed = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// pipepipe</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">write</span>(poller-&gt;pipe_wr, &amp;node, <span class=\"built_in\">sizeof</span> (<span class=\"type\">void</span> *));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\terrno = ENOENT;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stopped) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// pipe</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(node-&gt;res);</span><br><span class=\"line\">\t\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -!node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>pollerpoller_add_timerpoller_del_timer</p>\n<p>  </p>\n<ul>\n<li><p>n ms1</p>\n</li>\n<li><p>ioHTTPkeepalived</p>\n</li>\n</ul>\n<p><strong></strong>io<strong></strong></p>\n<p>pollerfd-1__poller_nodeepoll&#x2F;IO</p>\n<p>poller_add_timer</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">poller_add_timer</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> timespec *value, <span class=\"type\">void</span> *context, <span class=\"type\">void</span> **timer,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t\t <span class=\"type\">poller_t</span> *poller)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *node;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode = (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> __poller_node));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">\t\tnode-&gt;data.operation = PD_OP_TIMER;</span><br><span class=\"line\">\t\tnode-&gt;data.fd = <span class=\"number\">-1</span>;\t\t\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\tnode-&gt;data.context = context;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">clock_gettime</span>(CLOCK_MONOTONIC, &amp;node-&gt;timeout);</span><br><span class=\"line\">\t\tnode-&gt;timeout.tv_sec += value-&gt;tv_sec;</span><br><span class=\"line\">\t\tnode-&gt;timeout.tv_nsec += value-&gt;tv_nsec;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node-&gt;timeout.tv_nsec &gt;= <span class=\"number\">1000000000</span>) &#123;</span><br><span class=\"line\">\t\t\tnode-&gt;timeout.tv_nsec -= <span class=\"number\">1000000000</span>;</span><br><span class=\"line\">\t\t\tnode-&gt;timeout.tv_sec++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t*timer = node;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t\t__poller_insert_node(node, poller);\t<span class=\"comment\">// poller_node/</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>__poller_insert_nodepoller_del_timerpoller_del</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>pollerIOworkflowTCPServerTCP</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tsocket\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tbind\t|\tCommunicator</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tlisten\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|\t\t\t______________________________________________</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\taccept\t|\t</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\t|\t|\t|</span><br><span class=\"line\">V\tV\tV\tV</span><br><span class=\"line\">fd\tfd\tfd\t...</span><br><span class=\"line\">\t/\\</span><br><span class=\"line\">read  write</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>accept__poller_handle_listen</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_handle_listen(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t   <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *res = node-&gt;res;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\taddrlen = <span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> sockaddr_storage);</span><br><span class=\"line\">\t\tsockfd = <span class=\"built_in\">accept</span>(node-&gt;data.fd, addr, &amp;addrlen);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sockfd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (errno == EAGAIN || errno == EMFILE || errno == ENFILE)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (errno == ECONNABORTED)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tresult = node-&gt;data.<span class=\"built_in\">accept</span>(addr, addrlen, sockfd, node-&gt;data.context);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!result)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tres-&gt;data = node-&gt;data;</span><br><span class=\"line\">\t\tres-&gt;data.result = result;</span><br><span class=\"line\">\t\tres-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tres-&gt;state = PR_ST_SUCCESS;</span><br><span class=\"line\">\t\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)res, poller-&gt;context);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tres = (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> __poller_node));</span><br><span class=\"line\">\t\tnode-&gt;res = res;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!res)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_remove_node(node, poller))\t<span class=\"comment\">// epollfd</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode-&gt;error = errno;</span><br><span class=\"line\">\tnode-&gt;state = PR_ST_ERROR;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(node-&gt;res);</span><br><span class=\"line\">\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);\t<span class=\"comment\">// server\t</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>while</p>\n<ol>\n<li><p>acceptEAGAINEMFILEENFILEECONNABORTEDreturnreturncontinuecontinue</p>\n</li>\n<li><p>ioscoketfdnode-&gt;data.accept Communicator::acceptCommServiceTarget<strong>sockfd</strong>CommServiceTargetCommunicatorCommServiceTargetIO</p>\n</li>\n<li><p>poller-&gt;callbackreadwriteiopoller-&gt;callbackCommunicatorsockfd<strong></strong>poller_nodepoller</p>\n</li>\n</ol>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>read__poller_handle_readSSL</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __poller_append_message(<span class=\"type\">const</span> <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> *n,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t   <span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t   <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"type\">poller_message_t</span> *msg = node-&gt;data.message;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *res;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!msg) &#123;\t<span class=\"comment\">// msg</span></span><br><span class=\"line\">\t\tres = (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> __poller_node));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!res)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmsg = node-&gt;data.<span class=\"built_in\">create_message</span>(node-&gt;data.context);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!msg) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">free</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnode-&gt;data.message = msg;</span><br><span class=\"line\">\t\tnode-&gt;res = res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tres = node-&gt;res;</span><br><span class=\"line\"></span><br><span class=\"line\">\tret = msg-&gt;<span class=\"built_in\">append</span>(buf, n, msg);\t<span class=\"comment\">// msgPStcp</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ret &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tres-&gt;data = node-&gt;data;</span><br><span class=\"line\">\t\tres-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tres-&gt;state = PR_ST_SUCCESS;</span><br><span class=\"line\">\t\t<span class=\"comment\">// msgpoller-&gt;callback</span></span><br><span class=\"line\">\t\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)res, poller-&gt;context);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnode-&gt;data.message = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\tnode-&gt;res = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_handle_read(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> nleft;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> n;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *p;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tp = poller-&gt;buf;</span><br><span class=\"line\">\t\tnleft = <span class=\"built_in\">read</span>(node-&gt;data.fd, p, POLLER_BUFSIZE);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (errno == EAGAIN)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\tn = nleft;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (__poller_append_message(p, &amp;n, node, poller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tnleft -= n;</span><br><span class=\"line\">\t\t\t\tp += n;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\tnleft = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> (nleft &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;\t<span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_remove_node(node, poller))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (nleft == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tnode-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_FINISHED;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tnode-&gt;error = errno;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_ERROR;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(node-&gt;res);</span><br><span class=\"line\">\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>read__poller_handle_readread__poller_append_messagepoller-&gt;callback<strong>__poller_append_messagemsg-&gt;appendHTTPDNS</strong></p>\n<p>readbufferpoller-&gt;bufpollerfdreadbufferread</p>\n<p>pollerIO</p>\n<p>__poller_handle_read__poller_handle_readpoller-&gt;buf__poller_append_messagemsg-&gt;append<strong></strong>poller-&gt;bufreadpoller-&gt;buf</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>write__poller_handle_write</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_handle_write(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t  <span class=\"type\">poller_t</span> *poller)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> *iov = node-&gt;data.write_iov;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> nleft;</span><br><span class=\"line\">\t<span class=\"type\">int</span> iovcnt;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (node-&gt;data.iovcnt &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tiovcnt = node-&gt;data.iovcnt;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (iovcnt &gt; IOV_MAX)</span><br><span class=\"line\">\t\t\tiovcnt = IOV_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnleft = <span class=\"built_in\">writev</span>(node-&gt;data.fd, iov, iovcnt);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tret = errno == EAGAIN ? <span class=\"number\">0</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcount += nleft;</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;\t\t\t\t\t\t\t<span class=\"comment\">// iov</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (nleft &gt;= iov-&gt;iov_len) &#123;</span><br><span class=\"line\">\t\t\t\tnleft -= iov-&gt;iov_len;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_base = (<span class=\"type\">char</span> *)iov-&gt;iov_base + iov-&gt;iov_len;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_len = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\tiov++;</span><br><span class=\"line\">\t\t\t\tnode-&gt;data.iovcnt--;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_base = (<span class=\"type\">char</span> *)iov-&gt;iov_base + nleft;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_len -= nleft;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> (node-&gt;data.iovcnt &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode-&gt;data.write_iov = iov;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node-&gt;data.iovcnt &gt; <span class=\"number\">0</span> &amp;&amp; ret &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node-&gt;data.<span class=\"built_in\">partial_written</span>(count, node-&gt;data.context) &gt;= <span class=\"number\">0</span>)\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_remove_node(node, poller))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node-&gt;data.iovcnt == <span class=\"number\">0</span>) &#123;\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\tnode-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_FINISHED;\t</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;\t\t\t\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\tnode-&gt;error = errno;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_ERROR;\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>writepollersocketfdwritevwritevbufferwritevstruct iovecwritevwhiledo whiletcpdo whilebufferiovwhile</p>\n<p>EAGAINwhilenode-&gt;data.partial_writtenpoller_nodeepollpoller-&gt;callback</p>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlowGO-Task </a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlowCommunicatorTCPServer</a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>WorkFlow GO-TaskWorkFlow Tcp ServerTCPServerpollerIOCommunicatorTCPServerTCPServerIO</p>","more":"<p></p>\n<p>workflowworkflow200workflow</p>\n<p>&#x2F;workflow<strong></strong></p>\n<p>WorkflowTcpServerCommServiceCommServiceTCPServerCommServiceudptcptcpTcpServerCommService</p>\n<p>TcpServer</p>\n<p>poller -&gt;  -&gt; poller_node -&gt;  -&gt; IO</p>\n<h2 id=\"IOIO\"><a href=\"#IOIO\" class=\"headerlink\" title=\"IOIO\"></a>IOIO</h2><p>poller.cworkflowepolllinuxIOapiworkflow</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>__poller</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">__poller</span> <span class=\"type\">poller_t</span>;   <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">__poller</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> max_open_files;                              <span class=\"comment\">// epollfdfd</span></span><br><span class=\"line\">\t<span class=\"built_in\">void</span> (*callback)(<span class=\"keyword\">struct</span> poller_result *, <span class=\"type\">void</span> *);   <span class=\"comment\">// CommunicatorCommunicatorpoller_result.poller_data.operation</span></span><br><span class=\"line\">\t<span class=\"type\">void</span> *context;                                      <span class=\"comment\">// callback</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">pthread_t</span> tid;                                      <span class=\"comment\">// epollfdid</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> pfd;                                            <span class=\"comment\">// epollfd</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> timerfd;</span><br><span class=\"line\">\t<span class=\"type\">int</span> pipe_rd;                                        <span class=\"comment\">// /__poller_node</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> pipe_wr;                                        <span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"type\">int</span> stopped;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_root</span> timeo_tree;                          <span class=\"comment\">// __poller_node[]</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_node</span> *tree_first;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_node</span> *tree_last;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> timeo_list;                        <span class=\"comment\">// __poller_node</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> no_timeo_list;                     <span class=\"comment\">// __poller_node</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> **nodes;                       <span class=\"comment\">// fd__poller_node</span></span><br><span class=\"line\">\t<span class=\"type\">pthread_mutex_t</span> mutex;</span><br><span class=\"line\">\t<span class=\"type\">char</span> buf[POLLER_BUFSIZE];                           <span class=\"comment\">// buffer</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>poller</p>\n<p>__poller_node</p>\n<ol>\n<li><p>__poller_node__poller_node</p>\n<ol>\n<li><p>timeo_tree</p>\n</li>\n<li><p>timeo_list</p>\n</li>\n</ol>\n</li>\n<li><p>__poller_nodeno_timeo_list</p>\n</li>\n</ol>\n<p>__poller_node</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> state;                  <span class=\"comment\">// __poller_node</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> error;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span> data;    <span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack(1)</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> list;  <span class=\"comment\">// </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">rb_node</span> rb;      <span class=\"comment\">// </span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack()</span></span><br><span class=\"line\">\t<span class=\"type\">char</span> in_rbtree;             <span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"type\">char</span> removed;               <span class=\"comment\">// epoll/node</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> event;                  <span class=\"comment\">// epoll</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">timespec</span> timeout;    <span class=\"comment\">// fd</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *res;  <span class=\"comment\">// PS</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Muduo__poller + __poller_nodeMuduoEPollPollerMuduotimerfd_Muduostd::setworkflowworkflow__poller_node</p>\n<p>__poller_nodedataMuduodataMuduoChannelpoller_dataCommunicator</p>\n<p>poller_datajworkflow</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">// poll</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_TIMER\t\t\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_READ\t\t\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_WRITE\t\t\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_LISTEN\t\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_CONNECT\t\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_RECVFROM\t\t5</span></span><br><span class=\"line\"><span class=\"comment\">/* ... */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_EVENT\t\t\t9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PD_OP_NOTIFY\t\t10</span></span><br><span class=\"line\">\t<span class=\"type\">short</span> operation;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">short</span> iovcnt;</span><br><span class=\"line\">\t<span class=\"type\">int</span> fd;</span><br><span class=\"line\">\tSSL *ssl;</span><br><span class=\"line\">\t<span class=\"keyword\">union</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">poller_message_t</span> *(*create_message)(<span class=\"type\">void</span> *);    <span class=\"comment\">// </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">int</span> (*partial_written)(<span class=\"type\">size_t</span>, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*accept)(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *, <span class=\"type\">socklen_t</span>, <span class=\"type\">int</span>, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*recvfrom)(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *, <span class=\"type\">socklen_t</span>,</span><br><span class=\"line\">\t\t\t\t\t\t  <span class=\"type\">const</span> <span class=\"type\">void</span> *, <span class=\"type\">size_t</span>, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*event)(<span class=\"type\">void</span> *);</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *(*notify)(<span class=\"type\">void</span> *, <span class=\"type\">void</span> *);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"type\">void</span> *context;</span><br><span class=\"line\">\t<span class=\"keyword\">union</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">poller_message_t</span> *message;      <span class=\"comment\">// create_message</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> *write_iov;        <span class=\"comment\">// </span></span><br><span class=\"line\">\t\t<span class=\"type\">void</span> *result;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>|\t\t\t|\t\t|<br>|\t:-:\t\t\t\t|\t:-:\t\t|<br>|\tcreate_message\t|\tfdreadmsgfdmsg0pollercallbackCommunicator|<br>|\tpartial_written\t|\tfdwritefd<strong></strong>\t|<br>| accept\t\t\t|\tfdreadlisten fdsockfdsockfdCommServiceTarget\t|<br>|\trecvfrom\t\t|\tfdreadudptcpworkflowtcp\t|<br>|\tevent\t\t\t|\tfdreadfdsocket fd\t|<br>|\tnotify\t|\tevent\t|</p>\n<p>poller_result__poller_nodepoller.cpoller_result__poller_nodeCpoller_result__poller_node<strong>__poller_nodepoller_result*__poller_node</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">poller_result</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_SUCCESS\t\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_FINISHED\t\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_ERROR\t\t\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_DELETED\t\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_MODIFIED\t\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_ST_STOPPED\t\t5</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> state;</span><br><span class=\"line\">\t<span class=\"type\">int</span> error;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span> data;</span><br><span class=\"line\">\t<span class=\"comment\">/* In callback, spaces of six pointers are available from here. */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>poller&#x2F;workflowpollerepollfd&#x2F;&#x2F;</p>\n<p>workflowmuduosylarepollepollioioworkflowpoller</p>\n<h3 id=\"Event-Loop--\"><a href=\"#Event-Loop--\" class=\"headerlink\" title=\"Event Loop  \"></a>Event Loop  </h3><p>epoll&#x2F;pollIOIOIO__poller  </p>\n<p>__poller__poller__mpoller__mpoller__poller__mpoller__pollermanager__pollerepollfd__mpollersocketfd__poller__poller__poller_nodesocket fd__poller__poller_nodemanager__mpoller__poller</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __mpoller_create(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> poller_params *params,</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"type\">mpoller_t</span> *mpoller) &#123;</span><br><span class=\"line\">\t<span class=\"type\">void</span> **nodes_buf = (<span class=\"type\">void</span> **)<span class=\"built_in\">calloc</span>(params-&gt;max_open_files, <span class=\"built_in\">sizeof</span> (<span class=\"type\">void</span> *));</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (nodes_buf) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; mpoller-&gt;nthreads; i++) &#123;</span><br><span class=\"line\">\t\t\tmpoller-&gt;poller[i] = __poller_create(nodes_buf, params);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!mpoller-&gt;poller[i])</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == mpoller-&gt;nthreads) &#123;</span><br><span class=\"line\">\t\t\tmpoller-&gt;nodes_buf = nodes_buf;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>max_open_filesnodes_buf__poller_createnodes_buf__poller__poller_create__poller__pollernodesnodes_bufnodessocket fd__poller_node <strong>__pollernodes_buf</strong></p>\n<p> <strong>{nodessocket fd__poller_node}</strong> linuxfd__poller__pollernodes_bufsocket fd__poller_node<strong></strong>__poller_nodesocket fd<strong>__pollernodes_bufnodes_bufentry</strong></p>\n<p>__pollermpollermpoller_start__poller__pollerpoller_start</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">poller_start</span><span class=\"params\">(<span class=\"type\">poller_t</span> *poller)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">pthread_t</span> tid;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_open_pipe(poller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tret = <span class=\"built_in\">pthread_create</span>(&amp;tid, <span class=\"literal\">NULL</span>, __poller_thread_routine, poller);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tpoller-&gt;tid = tid;</span><br><span class=\"line\">\t\t\tpoller-&gt;stopped = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\terrno = ret;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(poller-&gt;pipe_wr);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(poller-&gt;pipe_rd);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -poller-&gt;stopped;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<ol>\n<li><p>__poller_open_pipepipfdpipfdepollfdpipfd__pollerPSpipfd</p>\n</li>\n<li><p></p>\n</li>\n</ol>\n<p>Muduo<strong></strong>One loop per threadworkflow__pollerMuduoMuduoOne loop per threadMuduoworkflowOne loop per threadloopMuduoworkflow__poller</p>\n<p>__poller_thread_routine</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *__poller_thread_routine(<span class=\"type\">void</span> *arg) &#123;</span><br><span class=\"line\">\t<span class=\"type\">poller_t</span> *poller = (<span class=\"type\">poller_t</span> *)arg;</span><br><span class=\"line\">\t<span class=\"type\">__poller_event_t</span> events[POLLER_EVENTS_MAX];</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> time_node;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *node;</span><br><span class=\"line\">\t<span class=\"type\">int</span> has_pipe_event;</span><br><span class=\"line\">\t<span class=\"type\">int</span> nevents;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t__poller_set_timer(poller);</span><br><span class=\"line\">\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\tnevents = __poller_wait(events, POLLER_EVENTS_MAX, poller);</span><br><span class=\"line\">\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">clock_gettime</span>(CLOCK_MONOTONIC, &amp;time_node.timeout);</span><br><span class=\"line\">\t\t<span class=\"comment\">// pipfd</span></span><br><span class=\"line\">\t\thas_pipe_event = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nevents; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// private__poller_node*</span></span><br><span class=\"line\">\t\t\tnode = (<span class=\"keyword\">struct</span> __poller_node *)__poller_event_data(&amp;events[i]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (node &lt;= (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"number\">1</span>) &#123;\t<span class=\"comment\">// pipfd</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (node == (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t\thas_pipe_event = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// __poller_node.dataoperation</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (node-&gt;data.operation) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_READ:</span><br><span class=\"line\">\t\t\t\t__poller_handle_read(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_WRITE:</span><br><span class=\"line\">\t\t\t\t__poller_handle_write(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_LISTEN:</span><br><span class=\"line\">\t\t\t\t__poller_handle_listen(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_CONNECT:</span><br><span class=\"line\">\t\t\t\t__poller_handle_connect(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* SSLUDP... */</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_EVENT:</span><br><span class=\"line\">\t\t\t\t__poller_handle_event(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> PD_OP_NOTIFY:</span><br><span class=\"line\">\t\t\t\t__poller_handle_notify(node, poller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (has_pipe_event) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (__poller_handle_pipe(poller))</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// __poller_node</span></span><br><span class=\"line\">\t\t__poller_handle_timeout(&amp;time_node, poller);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p><img src=\"/2024/11/02/workflow/TCPServer_1/photo/EventLoopFlowChart.drawio.png\"></p>\n<p>Muduoone loop per thread</p>\n<p><img src=\"/2024/11/02/workflow/TCPServer_1/photo/EventLoopThreadPool.drawio.png\"></p>\n<p><a href=\"../muduo/EventLoopThreadPool.md\">Muduoone loop per thread</a><a href=\"../xv6/Scheduler.md\">xv6</a>workflow__poller</p>\n<h3 id=\"poller-node\"><a href=\"#poller-node\" class=\"headerlink\" title=\"poller_node\"></a>poller_node</h3><p>pollerpoller_nodepoller_addpoller_delpoller_mod</p>\n<p><strong></strong></p>\n<p>sylarmuduo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">poller_add -&gt; pollerpoller_node;</span><br><span class=\"line\"></span><br><span class=\"line\">poller_del -&gt; poller_node;</span><br><span class=\"line\"></span><br><span class=\"line\">poller_mod -&gt; poller_node;</span><br></pre></td></tr></table></figure>\n\n<p><strong></strong></p>\n<ol>\n<li><p>poller_addpoller_node.data.fd&#x2F;<strong></strong>epollpoller_node.timeoutpoller_node<strong>timefd</strong></p>\n</li>\n<li><p>poller_delpoller_node.data.fd&#x2F;epoll<strong></strong></p>\n</li>\n<li><p>poller_mod<strong></strong>epollpoller_node.data.fd&#x2F;poller_node<strong></strong>poller_node&#x2F;<strong>timefd</strong></p>\n</li>\n</ol>\n<p><strong></strong></p>\n<p>poller</p>\n<p>poller_nodepoller_node&#x2F;poller_addpoller_modpoller__poller_insert_node<strong>poller_node&#x2F;poller_nodetimefd</strong></p>\n<p>poller_node</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_insert_node(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *end;</span><br><span class=\"line\"></span><br><span class=\"line\">\tend = <span class=\"built_in\">list_entry</span>(poller-&gt;timeo_list.prev, <span class=\"keyword\">struct</span> __poller_node, list);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">list_empty</span>(&amp;poller-&gt;timeo_list)) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_add</span>(&amp;node-&gt;list, &amp;poller-&gt;timeo_list);</span><br><span class=\"line\">\t\tend = <span class=\"built_in\">rb_entry</span>(poller-&gt;tree_first, <span class=\"keyword\">struct</span> __poller_node, rb);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__timeout_cmp(node, end) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_add_tail</span>(&amp;node-&gt;list, &amp;poller-&gt;timeo_list);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t__poller_tree_insert(node, poller);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (&amp;node-&gt;rb != poller-&gt;tree_first)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tend = <span class=\"built_in\">list_entry</span>(poller-&gt;timeo_list.next, <span class=\"keyword\">struct</span> __poller_node, list);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!poller-&gt;tree_first || __timeout_cmp(node, end) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t__poller_set_timerfd(poller-&gt;timerfd, &amp;node-&gt;timeout, poller);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p>nodepoller_node</p>\n<ol start=\"0\">\n<li><p></p>\n</li>\n<li><p>nodepoller_nodenodepoller_nodetimefdnode</p>\n</li>\n<li><p>nodepoller_nodenodetimefd</p>\n</li>\n<li><p>nodenodenodenodenodetimefdnode</p>\n</li>\n</ol>\n<p>node&#x2F;nodetimefd</p>\n<ol>\n<li><p></p>\n</li>\n<li><p></p>\n</li>\n</ol>\n<p>poller</p>\n<p>poller_addpoller_mod__poller_new_nodemallocpoller_node</p>\n<p>poller_delpoller_node&#x2F;<strong>poller_nodepipepipepoller-&gt;callback</strong></p>\n<p>poller_del</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">poller_del</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">poller_t</span> *poller)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *node;</span><br><span class=\"line\">\t<span class=\"type\">int</span> stopped = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\tnode = poller-&gt;nodes[fd];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">\t\tpoller-&gt;nodes[fd] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node-&gt;in_rbtree)</span><br><span class=\"line\">\t\t\t__poller_tree_erase(node, poller);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// list_del</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">list_del</span>(&amp;node-&gt;list);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t__poller_del_fd(fd, node-&gt;event, poller);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnode-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_DELETED;</span><br><span class=\"line\">\t\tstopped = poller-&gt;stopped;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!stopped) &#123;</span><br><span class=\"line\">\t\t\tnode-&gt;removed = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// pipepipe</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">write</span>(poller-&gt;pipe_wr, &amp;node, <span class=\"built_in\">sizeof</span> (<span class=\"type\">void</span> *));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\terrno = ENOENT;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stopped) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// pipe</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(node-&gt;res);</span><br><span class=\"line\">\t\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -!node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>pollerpoller_add_timerpoller_del_timer</p>\n<p>  </p>\n<ul>\n<li><p>n ms1</p>\n</li>\n<li><p>ioHTTPkeepalived</p>\n</li>\n</ul>\n<p><strong></strong>io<strong></strong></p>\n<p>pollerfd-1__poller_nodeepoll&#x2F;IO</p>\n<p>poller_add_timer</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">poller_add_timer</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> timespec *value, <span class=\"type\">void</span> *context, <span class=\"type\">void</span> **timer,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t\t <span class=\"type\">poller_t</span> *poller)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *node;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode = (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> __poller_node));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">\t\tnode-&gt;data.operation = PD_OP_TIMER;</span><br><span class=\"line\">\t\tnode-&gt;data.fd = <span class=\"number\">-1</span>;\t\t\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\tnode-&gt;data.context = context;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">clock_gettime</span>(CLOCK_MONOTONIC, &amp;node-&gt;timeout);</span><br><span class=\"line\">\t\tnode-&gt;timeout.tv_sec += value-&gt;tv_sec;</span><br><span class=\"line\">\t\tnode-&gt;timeout.tv_nsec += value-&gt;tv_nsec;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node-&gt;timeout.tv_nsec &gt;= <span class=\"number\">1000000000</span>) &#123;</span><br><span class=\"line\">\t\t\tnode-&gt;timeout.tv_nsec -= <span class=\"number\">1000000000</span>;</span><br><span class=\"line\">\t\t\tnode-&gt;timeout.tv_sec++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t*timer = node;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t\t__poller_insert_node(node, poller);\t<span class=\"comment\">// poller_node/</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;poller-&gt;mutex);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>__poller_insert_nodepoller_del_timerpoller_del</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>pollerIOworkflowTCPServerTCP</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tsocket\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tbind\t|\tCommunicator</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tlisten\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|\t\t\t______________________________________________</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\taccept\t|\t</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\t|\t|\t|</span><br><span class=\"line\">V\tV\tV\tV</span><br><span class=\"line\">fd\tfd\tfd\t...</span><br><span class=\"line\">\t/\\</span><br><span class=\"line\">read  write</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>accept__poller_handle_listen</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_handle_listen(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t   <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *res = node-&gt;res;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\taddrlen = <span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> sockaddr_storage);</span><br><span class=\"line\">\t\tsockfd = <span class=\"built_in\">accept</span>(node-&gt;data.fd, addr, &amp;addrlen);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sockfd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (errno == EAGAIN || errno == EMFILE || errno == ENFILE)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (errno == ECONNABORTED)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tresult = node-&gt;data.<span class=\"built_in\">accept</span>(addr, addrlen, sockfd, node-&gt;data.context);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!result)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tres-&gt;data = node-&gt;data;</span><br><span class=\"line\">\t\tres-&gt;data.result = result;</span><br><span class=\"line\">\t\tres-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tres-&gt;state = PR_ST_SUCCESS;</span><br><span class=\"line\">\t\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)res, poller-&gt;context);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tres = (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> __poller_node));</span><br><span class=\"line\">\t\tnode-&gt;res = res;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!res)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_remove_node(node, poller))\t<span class=\"comment\">// epollfd</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode-&gt;error = errno;</span><br><span class=\"line\">\tnode-&gt;state = PR_ST_ERROR;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(node-&gt;res);</span><br><span class=\"line\">\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);\t<span class=\"comment\">// server\t</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>while</p>\n<ol>\n<li><p>acceptEAGAINEMFILEENFILEECONNABORTEDreturnreturncontinuecontinue</p>\n</li>\n<li><p>ioscoketfdnode-&gt;data.accept Communicator::acceptCommServiceTarget<strong>sockfd</strong>CommServiceTargetCommunicatorCommServiceTargetIO</p>\n</li>\n<li><p>poller-&gt;callbackreadwriteiopoller-&gt;callbackCommunicatorsockfd<strong></strong>poller_nodepoller</p>\n</li>\n</ol>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>read__poller_handle_readSSL</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __poller_append_message(<span class=\"type\">const</span> <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> *n,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t   <span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t   <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"type\">poller_message_t</span> *msg = node-&gt;data.message;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">__poller_node</span> *res;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!msg) &#123;\t<span class=\"comment\">// msg</span></span><br><span class=\"line\">\t\tres = (<span class=\"keyword\">struct</span> __poller_node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> __poller_node));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!res)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmsg = node-&gt;data.<span class=\"built_in\">create_message</span>(node-&gt;data.context);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!msg) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">free</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnode-&gt;data.message = msg;</span><br><span class=\"line\">\t\tnode-&gt;res = res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tres = node-&gt;res;</span><br><span class=\"line\"></span><br><span class=\"line\">\tret = msg-&gt;<span class=\"built_in\">append</span>(buf, n, msg);\t<span class=\"comment\">// msgPStcp</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ret &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tres-&gt;data = node-&gt;data;</span><br><span class=\"line\">\t\tres-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tres-&gt;state = PR_ST_SUCCESS;</span><br><span class=\"line\">\t\t<span class=\"comment\">// msgpoller-&gt;callback</span></span><br><span class=\"line\">\t\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)res, poller-&gt;context);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnode-&gt;data.message = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\tnode-&gt;res = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_handle_read(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t <span class=\"type\">poller_t</span> *poller) &#123;</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> nleft;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> n;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *p;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tp = poller-&gt;buf;</span><br><span class=\"line\">\t\tnleft = <span class=\"built_in\">read</span>(node-&gt;data.fd, p, POLLER_BUFSIZE);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (errno == EAGAIN)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\tn = nleft;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (__poller_append_message(p, &amp;n, node, poller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tnleft -= n;</span><br><span class=\"line\">\t\t\t\tp += n;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\tnleft = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> (nleft &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;\t<span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_remove_node(node, poller))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (nleft == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tnode-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_FINISHED;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tnode-&gt;error = errno;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_ERROR;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(node-&gt;res);</span><br><span class=\"line\">\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>read__poller_handle_readread__poller_append_messagepoller-&gt;callback<strong>__poller_append_messagemsg-&gt;appendHTTPDNS</strong></p>\n<p>readbufferpoller-&gt;bufpollerfdreadbufferread</p>\n<p>pollerIO</p>\n<p>__poller_handle_read__poller_handle_readpoller-&gt;buf__poller_append_messagemsg-&gt;append<strong></strong>poller-&gt;bufreadpoller-&gt;buf</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>write__poller_handle_write</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __poller_handle_write(<span class=\"keyword\">struct</span> __poller_node *node,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t  <span class=\"type\">poller_t</span> *poller)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> *iov = node-&gt;data.write_iov;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> nleft;</span><br><span class=\"line\">\t<span class=\"type\">int</span> iovcnt;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (node-&gt;data.iovcnt &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tiovcnt = node-&gt;data.iovcnt;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (iovcnt &gt; IOV_MAX)</span><br><span class=\"line\">\t\t\tiovcnt = IOV_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnleft = <span class=\"built_in\">writev</span>(node-&gt;data.fd, iov, iovcnt);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nleft &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tret = errno == EAGAIN ? <span class=\"number\">0</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcount += nleft;</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;\t\t\t\t\t\t\t<span class=\"comment\">// iov</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (nleft &gt;= iov-&gt;iov_len) &#123;</span><br><span class=\"line\">\t\t\t\tnleft -= iov-&gt;iov_len;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_base = (<span class=\"type\">char</span> *)iov-&gt;iov_base + iov-&gt;iov_len;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_len = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\tiov++;</span><br><span class=\"line\">\t\t\t\tnode-&gt;data.iovcnt--;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_base = (<span class=\"type\">char</span> *)iov-&gt;iov_base + nleft;</span><br><span class=\"line\">\t\t\t\tiov-&gt;iov_len -= nleft;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> (node-&gt;data.iovcnt &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode-&gt;data.write_iov = iov;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node-&gt;data.iovcnt &gt; <span class=\"number\">0</span> &amp;&amp; ret &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node-&gt;data.<span class=\"built_in\">partial_written</span>(count, node-&gt;data.context) &gt;= <span class=\"number\">0</span>)\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__poller_remove_node(node, poller))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (node-&gt;data.iovcnt == <span class=\"number\">0</span>) &#123;\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\tnode-&gt;error = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_FINISHED;\t</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;\t\t\t\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\tnode-&gt;error = errno;</span><br><span class=\"line\">\t\tnode-&gt;state = PR_ST_ERROR;\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpoller-&gt;<span class=\"built_in\">callback</span>((<span class=\"keyword\">struct</span> poller_result *)node, poller-&gt;context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>writepollersocketfdwritevwritevbufferwritevstruct iovecwritevwhiledo whiletcpdo whilebufferiovwhile</p>\n<p>EAGAINwhilenode-&gt;data.partial_writtenpoller_nodeepollpoller-&gt;callback</p>\n<hr>\n<p><strong></strong></p>"},{"title":"WorkFlowCommunicatorTCPServer","date":"2024-11-07T04:00:00.000Z","_content":"\n## \n\n\n\n[WorkFlowGO-Task ](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\nTCPServerWorkFlowpollerCommunicatorpollerCommunicatorTCPServer\n\nworkflowGithub[https://github.com/sogou/workflow](https://github.com/sogou/workflow)\n\nGO-TaskSubTaskCommSessionGO-TaskTCPServerTCPServerGO-TaskBUGLeetCodewa\n\n<!-- more -->\n\nworkflowTCPServerCommSchedGroupCommSchedTargetCommSchedObjectCommSchedGroupCommRequest\n\n## \n\n[WorkFlow GO-Task ](https://blog.csdn.net/m0_52566365/article/details/142903964)workflowhttp_echo_server\n\n### \n\ngo-task\n\n```cpp\n#include <stdio.h>\n#include <utility>\n#include \"workflow/HttpMessage.h\"\n#include \"workflow/HttpUtil.h\"\n#include \"workflow/WFServer.h\"\n#include \"workflow/WFHttpServer.h\"\n#include \"workflow/WFFacilities.h\"\n\nvoid process(WFHttpTask *server_task) {\n\tprotocol::HttpRequest *req = server_task->get_req();\n\tprotocol::HttpResponse *resp = server_task->get_resp();\n\n    /* http */\n    /* ... */\n}\n\nint main(int argc, char *argv[]) {\n\tunsigned short port;\n\n\tif (argc != 2) {\n\t\tfprintf(stderr, \"USAGE: %s <port>\\n\", argv[0]);\n\t\texit(1);\n\t}\n\n\tsignal(SIGINT, sig_handler);\n\n\tWFHttpServer server(process);\n\tport = atoi(argv[1]);\n\tif (server.start(port) == 0) {\n\t\twait_group.wait();\n\t\tserver.stop();\n\t} else {\n\t\tperror(\"Cannot start server\");\n\t\texit(1);\n\t}\n\n\treturn 0;\n}\n```\n\nworkflowhttpserverdemo\n\n1. httpserver\n\n2. startserver\n\n3. wait_group.wait()\n\n\n\n1. process****reqrespserver_tasktcpCommunicator::create_requestininsession**sessionCommService**Communicator::replysessiontcpserversessionoutoutserver_taskreqrespsessioninout\n\n2. server.startsocketsocketsokcetCommunicatorCommunicator::bindCommunicator::bindCommServiceCommServicenew_sessionCommServiceCommService\n\n12CommService\n\n### WFHttpServer\n\nWFHttpServer\n\n```\n{ WFHttpServer == WFServer<protocol::HttpRequest, protocol::HttpResponse> } -> WFServerBase -> CommService\n```\n\nWFHttpServer**WFServer******WFServerWFServerBase\n\nWFServer\n\n```cpp\ntemplate<class REQ, class RESP>\nclass WFServer : public WFServerBase {\npublic:\n\tWFServer(const struct WFServerParams *params,\n\t\t\t std::function<void (WFNetworkTask<REQ, RESP> *)> proc) :\n\t\tWFServerBase(params),\n\t\tprocess(std::move(proc)) {  }\n\n\tWFServer(std::function<void (WFNetworkTask<REQ, RESP> *)> proc) :\n\t\tWFServerBase(&SERVER_PARAMS_DEFAULT),\n\t\tprocess(std::move(proc)) {  }\n\nprotected:\n\tvirtual CommSession *new_session(long long seq, CommConnection *conn);\n\nprotected:\n\tstd::function<void (WFNetworkTask<REQ, RESP> *)> process;\n};\n\ntemplate<class REQ, class RESP>\nCommSession *WFServer<REQ, RESP>::new_session(long long seq, CommConnection *conn) {\n\tusing factory = WFNetworkTaskFactory<REQ, RESP>;\n\tWFNetworkTask<REQ, RESP> *task;\n\n\ttask = factory::create_server_task(this, this->process);\n\ttask->set_keep_alive(this->params.keep_alive_timeout);\n\ttask->set_receive_timeout(this->params.receive_timeout);\n\ttask->get_req()->set_size_limit(this->params.request_size_limit);\n\n\treturn task;\n}\n```\n\nPS\n\nWFServerWFServerBasenew_sessionnew_sessionCommServiceWFHttpServer**new_session**WFServernew_session\n\nWFServerserverprocess**new_sessionTask**WFServerBase\n\nWFServerBaseCommServiceWFServerBase\n\n```cpp\nclass WFServerBase : protected CommService {\npublic:\n\tWFServerBase(const struct WFServerParams *params) :\n\t\tconn_count(0) {\n\t\tthis->params = *params;\n\t\tthis->unbind_finish = false;\n\t\tthis->listen_fd = -1;\n\t}\n\npublic:\n\t/* To start a TCP server */\n\t/* ... */\n\t/* Start with binding address. The only necessary start function. */\n\tint start(const struct sockaddr *bind_addr, socklen_t addrlen);\n\n\t/* stop() is a blocking operation. */\n\tvoid stop() {\n\t\tthis->shutdown();\n\t\tthis->wait_finish();\n\t}\n\n\t/* Nonblocking terminating the server. For stopping multiple servers.\n\t * Typically, call shutdown() and then wait_finish().\n\t * But indeed wait_finish() can be called before shutdown(), even before\n\t * start() in another thread. */\n\tvoid shutdown();\n\tvoid wait_finish();\n\npublic:\n\tsize_t get_conn_count() const { return this->conn_count; }\n\nprotected:\n\tWFServerParams params;\n\nprotected:\n\tvirtual int create_listen_fd();\n\tvirtual WFConnection *new_connection(int accept_fd);\n\tvoid delete_connection(WFConnection *conn);\n\nprivate:\n\tint init(const struct sockaddr *bind_addr, socklen_t addrlen);\n\tvirtual void handle_unbound();\n\nprotected:\n\tstd::atomic<size_t> conn_count;\n\nprivate:\n\tint listen_fd;\n\tbool unbind_finish;\n\n\tstd::mutex mutex;\n\tstd::condition_variable cond;\n\n\tclass CommScheduler *scheduler;\n};\n```\n\nWFServerBaseCommSchedulerschedulerCommSchedulerCommunicatorschedulerWFServerBaseCommunicatorserverCommunicator::bindlisten socketstart\n\n```cpp\nint WFServerBase::start(const struct sockaddr *bind_addr, socklen_t addrlen) {\n\tif (this->init(bind_addr, addrlen) >= 0) {\n\t\tif (this->scheduler->bind(this) >= 0)\n\t\t\treturn 0;\n\n\t\tthis->deinit();\n\t}\n\n\tthis->listen_fd = -1;\n\treturn -1;\n}\n```\n\ninit\n\n```cpp\nint WFServerBase::init(const struct sockaddr *bind_addr, socklen_t addrlen) {\n\t/* ... */\n\tif (this->CommService::init(bind_addr, addrlen, -1, timeout) < 0)\t// CommServicelisten fd\n\t\treturn -1;\n\n\tthis->scheduler = WFGlobal::get_scheduler();\t\t\t\t\t\t// CommScheduler\n\treturn 0;\n}\n```\n\ninit__CommManagerCommScheduler\n\n****__CommManager**CommScheduler**CommScheduler::init**workflow**[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\nWFServerBase::startinitCommScheduler::bindCommunicator::bindTCPServer\n\nWFServerBasenew_connection  \n\n- new_connectionWFServerBase::conn_countnew_connectionWFServerBase::conn_countCommConnectionWFServerBase::conn_countCommunicator__release_connCommConnectionWFServerBase::conn_countCommConnectionPSworkflow\n\n- WFServerBasestopshutdownwait_finishshutdownCommunicator::unbindlisten fdmpollershutdown****\n\n```\nWFServerBase::shutdown -> \n\nCommScheduler::unbind -> \n\nCommunicator::unbind -> \n\nmpoller_del(listen_fd) - - -> \n\nCommunicator::handle_listen_result -> \n\nCommunicator::shutdown_service -> \n\nwhile (CommServiceref0) { CommService::decref() } -> \n\nWFServerBase::handle_unbound\n```\n\nCommunicator::shutdown_service\n\n```cpp\nvoid Communicator::shutdown_service(CommService *service) {\n\tclose(service->listen_fd);\n\tservice->listen_fd = -1;\n\tservice->drain(-1);\n\tservice->decref();\n}\n```\n\nservice->drain(-1)servermpollerCommServiceTarget::decrefserver0WFServerBase::handle_unbound\n\n```cpp\ninline void CommService::decref() {\n\tif (__sync_sub_and_fetch(&this->ref, 1) == 0)\n\t\tthis->handle_unbound();\t\t\t\t\t\t// WFServerBase::handle_unbound\n}\n```\n\nWFServerBase::stopwait_finishWFServerBase\n\n```cpp\nvoid WFServerBase::handle_unbound() {\n\tthis->mutex.lock();\n\tthis->unbind_finish = true;\n\tthis->cond.notify_one();\n\tthis->mutex.unlock();\n}\n\nvoid WFServerBase::wait_finish() {\n\tstd::unique_lock<std::mutex> lock(this->mutex);\n\n\twhile (!this->unbind_finish)\n\t\tthis->cond.wait(lock);\n\n\tthis->deinit();\n\tthis->unbind_finish = false;\n\tlock.unlock();\n}\n```\n\n### WFHttpServerTask\n\ntcpserverWFHttpServer::new_sessionCommSession\n\n```cpp\ntemplate<> inline\nCommSession *WFHttpServer::new_session(long long seq, CommConnection *conn) {\n\tWFHttpTask *task;\n\n\ttask = WFServerTaskFactory::create_http_task(this, this->process);\n\ttask->set_keep_alive(this->params.keep_alive_timeout);\n\ttask->set_receive_timeout(this->params.receive_timeout);\n\ttask->get_req()->set_size_limit(this->params.request_size_limit);\n\n\treturn task;\n}\n```\n\nWFHttpTaskWFHttpTaskfinal\n\nWFHttpTask\n\n```cpp\nusing WFHttpTask = WFNetworkTask<protocol::HttpRequest,\n\t\t\t\t\t\t\t\t protocol::HttpResponse>;\n```\n\nWFNetworkTaskWFServerTaskFactory::create_http_taskfinalWFHttpServerTask\n\n```cpp\nclass WFHttpServerTask : public WFServerTask<protocol::HttpRequest,\n\t\t\t\t\t\t\t\t\t\t\t protocol::HttpResponse> {\nprivate:\n\tusing TASK = WFNetworkTask<protocol::HttpRequest, protocol::HttpResponse>;\n\npublic:\n\tWFHttpServerTask(CommService *service, std::function<void (TASK *)>& proc) :\n\t\tWFServerTask(service, WFGlobal::get_scheduler(), proc),\n\t\treq_is_alive_(false),\n\t\treq_has_keep_alive_header_(false) {  }\n\nprotected:\n\tvirtual void handle(int state, int error);\n\tvirtual CommMessageOut *message_out();\n\nprotected:\n\tbool req_is_alive_;\n\tbool req_has_keep_alive_header_;\n\tstd::string req_keep_alive_;\n};\n```\n\nCommSchedulerhanldemessage_outhandle\n\n```cpp\nvoid WFHttpServerTask::handle(int state, int error) {\n\tif (state == WFT_STATE_TOREPLY) {\n\t\t/* fianl... */\n\t}\n\n\tthis->WFServerTask::handle(state, error);\n}\n\n```\n\nCommunicator::handle_incoming_requestWFT_STATE_TOREPLYfinalhandleWFServerTask\n\n**tcpserverWFServerTask**WFNetworkTasktcpserverWFNetworkTaskCommRequest\n\nWFHttpServerTask\n\n```\n\tSubTask\t\tCommSession\n\t\t\t\\/\n\t\tCommRequest\n\t\t\t|\n\t\t\tV\n\tWFNetworkTask<REQ, RESP>\t# tcpserver\n\t\t\t|\n\t\t\tV\n\tWFServerTask<REQ, RESP>\n\t\t\t|\n\t\t\tV\n\tWFHttpServerTask\n```\n\nWFServerTask****\n\nSubTask::subtask_done\n\n```cpp\nvoid SubTask::subtask_done() {\n\tSubTask *cur = this;\n\n\tcur = cur->done();\n\tif (cur) {\n\t\tcur->dispatch();\t\t// dispatch\n\t}\n\treturn;\n}\n```\n\ndonedispatch**done`series_of(this)->pop()`SeriesWorknullptrSeriesWorkdelete thisSeriesWork**\n\nWFServerTask\n\n```cpp\nclass Processor : public SubTask {\npublic:\n\tProcessor(WFServerTask<REQ, RESP> *task,\n\t\t\t\tstd::function<void (WFNetworkTask<REQ, RESP> *)>& proc) :\n\t\tprocess(proc) {\n\t\tthis->task = task;\n\t}\n\n\tvirtual void dispatch() {\n\t\tthis->process(this->task);\t\t// \n\t\tthis->task = NULL;\t/* As a flag. get_conneciton() disabled. */\n\t\tthis->subtask_done();\n\t}\n\n\tvirtual SubTask *done() {\n\t\treturn series_of(this)->pop();\t// \n\t}\n\n\tstd::function<void (WFNetworkTask<REQ, RESP> *)>& process;\n\tWFServerTask<REQ, RESP> *task;\n} processor;\n\nclass Series : public SeriesWork {\npublic:\n\tSeries(WFServerTask<REQ, RESP> *task) :\n\t\tSeriesWork(&task->processor, nullptr) {\n\t\tthis->set_last_task(task);\n\t\tthis->task = task;\n\t}\n\n\tvirtual ~Series() {\n\t\tdelete this->task;\n\t}\n\n\tWFServerTask<REQ, RESP> *task;\n};\n```\n\n- Processor::dispatchprocesssubtask_donedispatch\n\n- Series **deletedelete****SubTask::pointer**\n\nWFServerTask<REQ, RESP>::handle\n\n```cpp\ntemplate<class REQ, class RESP>\nvoid WFServerTask<REQ, RESP>::handle(int state, int error) {\n\tif (state == WFT_STATE_TOREPLY) {\n\t\tthis->state = WFT_STATE_TOREPLY;\n\t\tthis->target = this->get_target();\n\t\tnew Series(this);\n\t\tthis->processor.dispatch();\n\t}\n\telse if (this->state == WFT_STATE_TOREPLY) {\n\t\tthis->state = state;\n\t\tthis->error = error;\n\t\tif (error == ETIMEDOUT)\n\t\t\tthis->timeout_reason = TOR_TRANSMIT_TIMEOUT;\n\n\t\tthis->subtask_done();\n\t}\n\telse\n\t\tdelete this;\n}\n```\n\nWFServerTaskSubTask + **CommSession**CommSessionCommSessionhandleCommunicator::handle_incoming_requestCommunicator::handle_reply_resultsession->handlestate**session->handlestateCS_STATE_TOREPLYsession->handlestateCS_STATE_SUCCESS**\n\n- handleifWFServerTask::stateWFT_STATE_TOREPLYhandleif`new Series(this);`workflow**new**SeriesnewSeriesWFServerTask::processorWFServerTaskif`this->processor.dispatch();`Processor::dispatchprocessserverprocessprocess`this->subtask_done();`****WFServerTaskSeriesWorkWFServerTask<REQ, RESP>::handleProcessorsubtask_donedispatch`WFServerTask::dispatch`WFServerTask::stateWFT_STATE_TOREPLYif`this->scheduler->reply`\n\n\t\n\n\t```\n\tWFServerTask<REQ, RESP>::handle ->\n\tProcessor::dispatch -> \n\tProcessor::subtask_done -> \n\tWFServerTask::dispatch\n\t```\n\n\t\n\t\n\t```\n\tWFServerTaskdispatch  -> \n\tProcessorsubtask_done -> \n\tProcessordispatch -> \n\tWFServerTask<REQ, RESP>::handle\n\t```\n\n\t**WFServerTask<REQ, RESP>::handleifdispatch******\n\n- WFServerTask<REQ, RESP>::handleif******ifnewWFServerTask::subtask_doneifnewSeriesWFServerTask**\n\nWFServerTask\n\n```cpp\ntemplate<class REQ, class RESP>\nclass WFServerTask : public WFNetworkTask<REQ, RESP> {\nprotected:\n\tvirtual CommMessageOut *message_out() { return &this->resp; }\n\tvirtual CommMessageIn *message_in() { return &this->req; }\n\tvirtual void handle(int state, int error);\n\nprotected:\n\tvirtual void dispatch() {\n\t\tif (this->state == WFT_STATE_TOREPLY) {\n\t\t\t/* Enable get_connection() again if the reply() call is success. */\n\t\t\tthis->processor.task = this;\n\t\t\tif (this->scheduler->reply(this) >= 0)\t// \n\t\t\t\treturn;\n\n\t\t\tthis->state = WFT_STATE_SYS_ERROR;\n\t\t\tthis->error = errno;\n\t\t\tthis->processor.task = NULL;\n\t\t}\n\t\telse\n\t\t\tthis->scheduler->shutdown(this);\n\n\t\tthis->subtask_done();\n\t}\n\n\tvirtual SubTask *done() {\n\t\tSeriesWork *series = series_of(this);\n\n\t\tif (this->callback)\n\t\t\tthis->callback(this);\n\n\t\t/* Defer deleting the task. */\n\t\treturn series->pop();\n\t}\n\npublic:\n\tWFServerTask(CommService *service, CommScheduler *scheduler,\n\t\t\t\t std::function<void (WFNetworkTask<REQ, RESP> *)>& proc) :\n\t\tWFNetworkTask<REQ, RESP>(NULL, scheduler, nullptr),\n\t\tprocessor(this, proc)\n\t{ }\n};\n```\n\nHTTPServer\n\n```\n# Workflow\n\nserver:\n\n    entry: \n        accept_conn: CONN_STATE_CONNECTED -> \n            create_request: CONN_STATE_RECEIVING ->                             // tag1\n                append_message: httpCONN_STATE_SUCCESS ->\n                    handle_incoming_request: \n                        ==>     CONN_STATE_IDLE && entrytarget->idle_list;\n                        ==>    session->passive = 2;\n                        ==>    state = CS_STATE_TOREPLY\n\n    |   |   |\n    V   V   V\n    WFHttpServerTask::handle ->\n        WFServerTask<REQ, RESP>::handle ->\n            ```cpp\n                template<class REQ, class RESP>\n                void WFServerTask<REQ, RESP>::handle(int state, int error)\n                {\n                    if (state == WFT_STATE_TOREPLY)         // \n                    {\n                        this->state = WFT_STATE_TOREPLY;\n                        this->target = this->get_target();\n                        new Series(this);\n                        this->processor.dispatch();\n                    }\n                    else if (this->state == WFT_STATE_TOREPLY)\n                    {\n                        this->state = state;\n                        this->error = error;\n                        if (error == ETIMEDOUT)\n                            this->timeout_reason = TOR_TRANSMIT_TIMEOUT;\n\n                        this->subtask_done();\n                    }\n                    else\n                        delete this;\n                }\n            ```\n\n        WFServerTask<REQ, RESP>::dispatch ->\n            this->scheduler->reply(this) -> entryepoll\n                session->passive = 3;\n\n    |   |   |       \n    V   V   V\n    handle_reply_result ->\n        ===> entry->state = CONN_STATE_KEEPALIVE && entry service->alive_list && entryepoll\n        ===> state = CS_STATE_SUCCESS\n\n    |   |   |\n    V   V   V\n    WFHttpServerTask::handle ->\n        WFServerTask<REQ, RESP>::handle ->\n            ```cpp\n                template<class REQ, class RESP>\n                void WFServerTask<REQ, RESP>::handle(int state, int error)\n                {\n                    if (state == WFT_STATE_TOREPLY)\n                    {\n                        this->state = WFT_STATE_TOREPLY;\n                        this->target = this->get_target();\n                        new Series(this);\n                        this->processor.dispatch();\n                    }\n                    else if (this->state == WFT_STATE_TOREPLY)  // \n                    {\n                        this->state = state;\n                        this->error = error;\n                        if (error == ETIMEDOUT)\n                            this->timeout_reason = TOR_TRANSMIT_TIMEOUT;\n\n                        this->subtask_done();       // will delete Series for first 'if' branch malloc\n                    }\n                    else\n                        delete this;\n                }\n            ```\n\n    |   |   |\n    V   V   V\n    go to tag1.\n```\n\n---\n\n****","source":"_posts/workflow/TCPServer_3.md","raw":"---\ntitle: WorkFlowCommunicatorTCPServer\ndate: 2024-11-07 12:00:00\ntags:\n  - \n---\n\n## \n\n\n\n[WorkFlowGO-Task ](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\nTCPServerWorkFlowpollerCommunicatorpollerCommunicatorTCPServer\n\nworkflowGithub[https://github.com/sogou/workflow](https://github.com/sogou/workflow)\n\nGO-TaskSubTaskCommSessionGO-TaskTCPServerTCPServerGO-TaskBUGLeetCodewa\n\n<!-- more -->\n\nworkflowTCPServerCommSchedGroupCommSchedTargetCommSchedObjectCommSchedGroupCommRequest\n\n## \n\n[WorkFlow GO-Task ](https://blog.csdn.net/m0_52566365/article/details/142903964)workflowhttp_echo_server\n\n### \n\ngo-task\n\n```cpp\n#include <stdio.h>\n#include <utility>\n#include \"workflow/HttpMessage.h\"\n#include \"workflow/HttpUtil.h\"\n#include \"workflow/WFServer.h\"\n#include \"workflow/WFHttpServer.h\"\n#include \"workflow/WFFacilities.h\"\n\nvoid process(WFHttpTask *server_task) {\n\tprotocol::HttpRequest *req = server_task->get_req();\n\tprotocol::HttpResponse *resp = server_task->get_resp();\n\n    /* http */\n    /* ... */\n}\n\nint main(int argc, char *argv[]) {\n\tunsigned short port;\n\n\tif (argc != 2) {\n\t\tfprintf(stderr, \"USAGE: %s <port>\\n\", argv[0]);\n\t\texit(1);\n\t}\n\n\tsignal(SIGINT, sig_handler);\n\n\tWFHttpServer server(process);\n\tport = atoi(argv[1]);\n\tif (server.start(port) == 0) {\n\t\twait_group.wait();\n\t\tserver.stop();\n\t} else {\n\t\tperror(\"Cannot start server\");\n\t\texit(1);\n\t}\n\n\treturn 0;\n}\n```\n\nworkflowhttpserverdemo\n\n1. httpserver\n\n2. startserver\n\n3. wait_group.wait()\n\n\n\n1. process****reqrespserver_tasktcpCommunicator::create_requestininsession**sessionCommService**Communicator::replysessiontcpserversessionoutoutserver_taskreqrespsessioninout\n\n2. server.startsocketsocketsokcetCommunicatorCommunicator::bindCommunicator::bindCommServiceCommServicenew_sessionCommServiceCommService\n\n12CommService\n\n### WFHttpServer\n\nWFHttpServer\n\n```\n{ WFHttpServer == WFServer<protocol::HttpRequest, protocol::HttpResponse> } -> WFServerBase -> CommService\n```\n\nWFHttpServer**WFServer******WFServerWFServerBase\n\nWFServer\n\n```cpp\ntemplate<class REQ, class RESP>\nclass WFServer : public WFServerBase {\npublic:\n\tWFServer(const struct WFServerParams *params,\n\t\t\t std::function<void (WFNetworkTask<REQ, RESP> *)> proc) :\n\t\tWFServerBase(params),\n\t\tprocess(std::move(proc)) {  }\n\n\tWFServer(std::function<void (WFNetworkTask<REQ, RESP> *)> proc) :\n\t\tWFServerBase(&SERVER_PARAMS_DEFAULT),\n\t\tprocess(std::move(proc)) {  }\n\nprotected:\n\tvirtual CommSession *new_session(long long seq, CommConnection *conn);\n\nprotected:\n\tstd::function<void (WFNetworkTask<REQ, RESP> *)> process;\n};\n\ntemplate<class REQ, class RESP>\nCommSession *WFServer<REQ, RESP>::new_session(long long seq, CommConnection *conn) {\n\tusing factory = WFNetworkTaskFactory<REQ, RESP>;\n\tWFNetworkTask<REQ, RESP> *task;\n\n\ttask = factory::create_server_task(this, this->process);\n\ttask->set_keep_alive(this->params.keep_alive_timeout);\n\ttask->set_receive_timeout(this->params.receive_timeout);\n\ttask->get_req()->set_size_limit(this->params.request_size_limit);\n\n\treturn task;\n}\n```\n\nPS\n\nWFServerWFServerBasenew_sessionnew_sessionCommServiceWFHttpServer**new_session**WFServernew_session\n\nWFServerserverprocess**new_sessionTask**WFServerBase\n\nWFServerBaseCommServiceWFServerBase\n\n```cpp\nclass WFServerBase : protected CommService {\npublic:\n\tWFServerBase(const struct WFServerParams *params) :\n\t\tconn_count(0) {\n\t\tthis->params = *params;\n\t\tthis->unbind_finish = false;\n\t\tthis->listen_fd = -1;\n\t}\n\npublic:\n\t/* To start a TCP server */\n\t/* ... */\n\t/* Start with binding address. The only necessary start function. */\n\tint start(const struct sockaddr *bind_addr, socklen_t addrlen);\n\n\t/* stop() is a blocking operation. */\n\tvoid stop() {\n\t\tthis->shutdown();\n\t\tthis->wait_finish();\n\t}\n\n\t/* Nonblocking terminating the server. For stopping multiple servers.\n\t * Typically, call shutdown() and then wait_finish().\n\t * But indeed wait_finish() can be called before shutdown(), even before\n\t * start() in another thread. */\n\tvoid shutdown();\n\tvoid wait_finish();\n\npublic:\n\tsize_t get_conn_count() const { return this->conn_count; }\n\nprotected:\n\tWFServerParams params;\n\nprotected:\n\tvirtual int create_listen_fd();\n\tvirtual WFConnection *new_connection(int accept_fd);\n\tvoid delete_connection(WFConnection *conn);\n\nprivate:\n\tint init(const struct sockaddr *bind_addr, socklen_t addrlen);\n\tvirtual void handle_unbound();\n\nprotected:\n\tstd::atomic<size_t> conn_count;\n\nprivate:\n\tint listen_fd;\n\tbool unbind_finish;\n\n\tstd::mutex mutex;\n\tstd::condition_variable cond;\n\n\tclass CommScheduler *scheduler;\n};\n```\n\nWFServerBaseCommSchedulerschedulerCommSchedulerCommunicatorschedulerWFServerBaseCommunicatorserverCommunicator::bindlisten socketstart\n\n```cpp\nint WFServerBase::start(const struct sockaddr *bind_addr, socklen_t addrlen) {\n\tif (this->init(bind_addr, addrlen) >= 0) {\n\t\tif (this->scheduler->bind(this) >= 0)\n\t\t\treturn 0;\n\n\t\tthis->deinit();\n\t}\n\n\tthis->listen_fd = -1;\n\treturn -1;\n}\n```\n\ninit\n\n```cpp\nint WFServerBase::init(const struct sockaddr *bind_addr, socklen_t addrlen) {\n\t/* ... */\n\tif (this->CommService::init(bind_addr, addrlen, -1, timeout) < 0)\t// CommServicelisten fd\n\t\treturn -1;\n\n\tthis->scheduler = WFGlobal::get_scheduler();\t\t\t\t\t\t// CommScheduler\n\treturn 0;\n}\n```\n\ninit__CommManagerCommScheduler\n\n****__CommManager**CommScheduler**CommScheduler::init**workflow**[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\nWFServerBase::startinitCommScheduler::bindCommunicator::bindTCPServer\n\nWFServerBasenew_connection  \n\n- new_connectionWFServerBase::conn_countnew_connectionWFServerBase::conn_countCommConnectionWFServerBase::conn_countCommunicator__release_connCommConnectionWFServerBase::conn_countCommConnectionPSworkflow\n\n- WFServerBasestopshutdownwait_finishshutdownCommunicator::unbindlisten fdmpollershutdown****\n\n```\nWFServerBase::shutdown -> \n\nCommScheduler::unbind -> \n\nCommunicator::unbind -> \n\nmpoller_del(listen_fd) - - -> \n\nCommunicator::handle_listen_result -> \n\nCommunicator::shutdown_service -> \n\nwhile (CommServiceref0) { CommService::decref() } -> \n\nWFServerBase::handle_unbound\n```\n\nCommunicator::shutdown_service\n\n```cpp\nvoid Communicator::shutdown_service(CommService *service) {\n\tclose(service->listen_fd);\n\tservice->listen_fd = -1;\n\tservice->drain(-1);\n\tservice->decref();\n}\n```\n\nservice->drain(-1)servermpollerCommServiceTarget::decrefserver0WFServerBase::handle_unbound\n\n```cpp\ninline void CommService::decref() {\n\tif (__sync_sub_and_fetch(&this->ref, 1) == 0)\n\t\tthis->handle_unbound();\t\t\t\t\t\t// WFServerBase::handle_unbound\n}\n```\n\nWFServerBase::stopwait_finishWFServerBase\n\n```cpp\nvoid WFServerBase::handle_unbound() {\n\tthis->mutex.lock();\n\tthis->unbind_finish = true;\n\tthis->cond.notify_one();\n\tthis->mutex.unlock();\n}\n\nvoid WFServerBase::wait_finish() {\n\tstd::unique_lock<std::mutex> lock(this->mutex);\n\n\twhile (!this->unbind_finish)\n\t\tthis->cond.wait(lock);\n\n\tthis->deinit();\n\tthis->unbind_finish = false;\n\tlock.unlock();\n}\n```\n\n### WFHttpServerTask\n\ntcpserverWFHttpServer::new_sessionCommSession\n\n```cpp\ntemplate<> inline\nCommSession *WFHttpServer::new_session(long long seq, CommConnection *conn) {\n\tWFHttpTask *task;\n\n\ttask = WFServerTaskFactory::create_http_task(this, this->process);\n\ttask->set_keep_alive(this->params.keep_alive_timeout);\n\ttask->set_receive_timeout(this->params.receive_timeout);\n\ttask->get_req()->set_size_limit(this->params.request_size_limit);\n\n\treturn task;\n}\n```\n\nWFHttpTaskWFHttpTaskfinal\n\nWFHttpTask\n\n```cpp\nusing WFHttpTask = WFNetworkTask<protocol::HttpRequest,\n\t\t\t\t\t\t\t\t protocol::HttpResponse>;\n```\n\nWFNetworkTaskWFServerTaskFactory::create_http_taskfinalWFHttpServerTask\n\n```cpp\nclass WFHttpServerTask : public WFServerTask<protocol::HttpRequest,\n\t\t\t\t\t\t\t\t\t\t\t protocol::HttpResponse> {\nprivate:\n\tusing TASK = WFNetworkTask<protocol::HttpRequest, protocol::HttpResponse>;\n\npublic:\n\tWFHttpServerTask(CommService *service, std::function<void (TASK *)>& proc) :\n\t\tWFServerTask(service, WFGlobal::get_scheduler(), proc),\n\t\treq_is_alive_(false),\n\t\treq_has_keep_alive_header_(false) {  }\n\nprotected:\n\tvirtual void handle(int state, int error);\n\tvirtual CommMessageOut *message_out();\n\nprotected:\n\tbool req_is_alive_;\n\tbool req_has_keep_alive_header_;\n\tstd::string req_keep_alive_;\n};\n```\n\nCommSchedulerhanldemessage_outhandle\n\n```cpp\nvoid WFHttpServerTask::handle(int state, int error) {\n\tif (state == WFT_STATE_TOREPLY) {\n\t\t/* fianl... */\n\t}\n\n\tthis->WFServerTask::handle(state, error);\n}\n\n```\n\nCommunicator::handle_incoming_requestWFT_STATE_TOREPLYfinalhandleWFServerTask\n\n**tcpserverWFServerTask**WFNetworkTasktcpserverWFNetworkTaskCommRequest\n\nWFHttpServerTask\n\n```\n\tSubTask\t\tCommSession\n\t\t\t\\/\n\t\tCommRequest\n\t\t\t|\n\t\t\tV\n\tWFNetworkTask<REQ, RESP>\t# tcpserver\n\t\t\t|\n\t\t\tV\n\tWFServerTask<REQ, RESP>\n\t\t\t|\n\t\t\tV\n\tWFHttpServerTask\n```\n\nWFServerTask****\n\nSubTask::subtask_done\n\n```cpp\nvoid SubTask::subtask_done() {\n\tSubTask *cur = this;\n\n\tcur = cur->done();\n\tif (cur) {\n\t\tcur->dispatch();\t\t// dispatch\n\t}\n\treturn;\n}\n```\n\ndonedispatch**done`series_of(this)->pop()`SeriesWorknullptrSeriesWorkdelete thisSeriesWork**\n\nWFServerTask\n\n```cpp\nclass Processor : public SubTask {\npublic:\n\tProcessor(WFServerTask<REQ, RESP> *task,\n\t\t\t\tstd::function<void (WFNetworkTask<REQ, RESP> *)>& proc) :\n\t\tprocess(proc) {\n\t\tthis->task = task;\n\t}\n\n\tvirtual void dispatch() {\n\t\tthis->process(this->task);\t\t// \n\t\tthis->task = NULL;\t/* As a flag. get_conneciton() disabled. */\n\t\tthis->subtask_done();\n\t}\n\n\tvirtual SubTask *done() {\n\t\treturn series_of(this)->pop();\t// \n\t}\n\n\tstd::function<void (WFNetworkTask<REQ, RESP> *)>& process;\n\tWFServerTask<REQ, RESP> *task;\n} processor;\n\nclass Series : public SeriesWork {\npublic:\n\tSeries(WFServerTask<REQ, RESP> *task) :\n\t\tSeriesWork(&task->processor, nullptr) {\n\t\tthis->set_last_task(task);\n\t\tthis->task = task;\n\t}\n\n\tvirtual ~Series() {\n\t\tdelete this->task;\n\t}\n\n\tWFServerTask<REQ, RESP> *task;\n};\n```\n\n- Processor::dispatchprocesssubtask_donedispatch\n\n- Series **deletedelete****SubTask::pointer**\n\nWFServerTask<REQ, RESP>::handle\n\n```cpp\ntemplate<class REQ, class RESP>\nvoid WFServerTask<REQ, RESP>::handle(int state, int error) {\n\tif (state == WFT_STATE_TOREPLY) {\n\t\tthis->state = WFT_STATE_TOREPLY;\n\t\tthis->target = this->get_target();\n\t\tnew Series(this);\n\t\tthis->processor.dispatch();\n\t}\n\telse if (this->state == WFT_STATE_TOREPLY) {\n\t\tthis->state = state;\n\t\tthis->error = error;\n\t\tif (error == ETIMEDOUT)\n\t\t\tthis->timeout_reason = TOR_TRANSMIT_TIMEOUT;\n\n\t\tthis->subtask_done();\n\t}\n\telse\n\t\tdelete this;\n}\n```\n\nWFServerTaskSubTask + **CommSession**CommSessionCommSessionhandleCommunicator::handle_incoming_requestCommunicator::handle_reply_resultsession->handlestate**session->handlestateCS_STATE_TOREPLYsession->handlestateCS_STATE_SUCCESS**\n\n- handleifWFServerTask::stateWFT_STATE_TOREPLYhandleif`new Series(this);`workflow**new**SeriesnewSeriesWFServerTask::processorWFServerTaskif`this->processor.dispatch();`Processor::dispatchprocessserverprocessprocess`this->subtask_done();`****WFServerTaskSeriesWorkWFServerTask<REQ, RESP>::handleProcessorsubtask_donedispatch`WFServerTask::dispatch`WFServerTask::stateWFT_STATE_TOREPLYif`this->scheduler->reply`\n\n\t\n\n\t```\n\tWFServerTask<REQ, RESP>::handle ->\n\tProcessor::dispatch -> \n\tProcessor::subtask_done -> \n\tWFServerTask::dispatch\n\t```\n\n\t\n\t\n\t```\n\tWFServerTaskdispatch  -> \n\tProcessorsubtask_done -> \n\tProcessordispatch -> \n\tWFServerTask<REQ, RESP>::handle\n\t```\n\n\t**WFServerTask<REQ, RESP>::handleifdispatch******\n\n- WFServerTask<REQ, RESP>::handleif******ifnewWFServerTask::subtask_doneifnewSeriesWFServerTask**\n\nWFServerTask\n\n```cpp\ntemplate<class REQ, class RESP>\nclass WFServerTask : public WFNetworkTask<REQ, RESP> {\nprotected:\n\tvirtual CommMessageOut *message_out() { return &this->resp; }\n\tvirtual CommMessageIn *message_in() { return &this->req; }\n\tvirtual void handle(int state, int error);\n\nprotected:\n\tvirtual void dispatch() {\n\t\tif (this->state == WFT_STATE_TOREPLY) {\n\t\t\t/* Enable get_connection() again if the reply() call is success. */\n\t\t\tthis->processor.task = this;\n\t\t\tif (this->scheduler->reply(this) >= 0)\t// \n\t\t\t\treturn;\n\n\t\t\tthis->state = WFT_STATE_SYS_ERROR;\n\t\t\tthis->error = errno;\n\t\t\tthis->processor.task = NULL;\n\t\t}\n\t\telse\n\t\t\tthis->scheduler->shutdown(this);\n\n\t\tthis->subtask_done();\n\t}\n\n\tvirtual SubTask *done() {\n\t\tSeriesWork *series = series_of(this);\n\n\t\tif (this->callback)\n\t\t\tthis->callback(this);\n\n\t\t/* Defer deleting the task. */\n\t\treturn series->pop();\n\t}\n\npublic:\n\tWFServerTask(CommService *service, CommScheduler *scheduler,\n\t\t\t\t std::function<void (WFNetworkTask<REQ, RESP> *)>& proc) :\n\t\tWFNetworkTask<REQ, RESP>(NULL, scheduler, nullptr),\n\t\tprocessor(this, proc)\n\t{ }\n};\n```\n\nHTTPServer\n\n```\n# Workflow\n\nserver:\n\n    entry: \n        accept_conn: CONN_STATE_CONNECTED -> \n            create_request: CONN_STATE_RECEIVING ->                             // tag1\n                append_message: httpCONN_STATE_SUCCESS ->\n                    handle_incoming_request: \n                        ==>     CONN_STATE_IDLE && entrytarget->idle_list;\n                        ==>    session->passive = 2;\n                        ==>    state = CS_STATE_TOREPLY\n\n    |   |   |\n    V   V   V\n    WFHttpServerTask::handle ->\n        WFServerTask<REQ, RESP>::handle ->\n            ```cpp\n                template<class REQ, class RESP>\n                void WFServerTask<REQ, RESP>::handle(int state, int error)\n                {\n                    if (state == WFT_STATE_TOREPLY)         // \n                    {\n                        this->state = WFT_STATE_TOREPLY;\n                        this->target = this->get_target();\n                        new Series(this);\n                        this->processor.dispatch();\n                    }\n                    else if (this->state == WFT_STATE_TOREPLY)\n                    {\n                        this->state = state;\n                        this->error = error;\n                        if (error == ETIMEDOUT)\n                            this->timeout_reason = TOR_TRANSMIT_TIMEOUT;\n\n                        this->subtask_done();\n                    }\n                    else\n                        delete this;\n                }\n            ```\n\n        WFServerTask<REQ, RESP>::dispatch ->\n            this->scheduler->reply(this) -> entryepoll\n                session->passive = 3;\n\n    |   |   |       \n    V   V   V\n    handle_reply_result ->\n        ===> entry->state = CONN_STATE_KEEPALIVE && entry service->alive_list && entryepoll\n        ===> state = CS_STATE_SUCCESS\n\n    |   |   |\n    V   V   V\n    WFHttpServerTask::handle ->\n        WFServerTask<REQ, RESP>::handle ->\n            ```cpp\n                template<class REQ, class RESP>\n                void WFServerTask<REQ, RESP>::handle(int state, int error)\n                {\n                    if (state == WFT_STATE_TOREPLY)\n                    {\n                        this->state = WFT_STATE_TOREPLY;\n                        this->target = this->get_target();\n                        new Series(this);\n                        this->processor.dispatch();\n                    }\n                    else if (this->state == WFT_STATE_TOREPLY)  // \n                    {\n                        this->state = state;\n                        this->error = error;\n                        if (error == ETIMEDOUT)\n                            this->timeout_reason = TOR_TRANSMIT_TIMEOUT;\n\n                        this->subtask_done();       // will delete Series for first 'if' branch malloc\n                    }\n                    else\n                        delete this;\n                }\n            ```\n\n    |   |   |\n    V   V   V\n    go to tag1.\n```\n\n---\n\n****","slug":"workflow/TCPServer_3","published":1,"updated":"2025-09-28T14:34:33.264Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9t000wq8ws64du4jnn","content":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlowGO-Task </a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlowCommunicatorTCPServer</a></p>\n<p>TCPServerWorkFlowpollerCommunicatorpollerCommunicatorTCPServer</p>\n<p>workflowGithub<a href=\"https://github.com/sogou/workflow\">https://github.com/sogou/workflow</a></p>\n<p>GO-TaskSubTaskCommSessionGO-TaskTCPServerTCPServerGO-TaskBUGLeetCodewa</p>\n<span id=\"more\"></span>\n\n<p>workflowTCPServerCommSchedGroupCommSchedTargetCommSchedObjectCommSchedGroupCommRequest</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlow GO-Task </a>workflowhttp_echo_server</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>go-task</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/HttpMessage.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/HttpUtil.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFServer.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFHttpServer.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFFacilities.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process</span><span class=\"params\">(WFHttpTask *server_task)</span> </span>&#123;</span><br><span class=\"line\">\tprotocol::HttpRequest *req = server_task-&gt;<span class=\"built_in\">get_req</span>();</span><br><span class=\"line\">\tprotocol::HttpResponse *resp = server_task-&gt;<span class=\"built_in\">get_resp</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* http */</span></span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">short</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;USAGE: %s &lt;port&gt;\\n&quot;</span>, argv[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">signal</span>(SIGINT, sig_handler);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">WFHttpServer <span class=\"title\">server</span><span class=\"params\">(process)</span></span>;</span><br><span class=\"line\">\tport = <span class=\"built_in\">atoi</span>(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (server.<span class=\"built_in\">start</span>(port) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\twait_group.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">\t\tserver.<span class=\"built_in\">stop</span>();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">perror</span>(<span class=\"string\">&quot;Cannot start server&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>workflowhttpserverdemo</p>\n<ol>\n<li><p>httpserver</p>\n</li>\n<li><p>startserver</p>\n</li>\n<li><p>wait_group.wait()</p>\n</li>\n</ol>\n<p></p>\n<ol>\n<li><p>process<strong></strong>reqrespserver_tasktcpCommunicator::create_requestininsession<strong>sessionCommService</strong>Communicator::replysessiontcpserversessionoutoutserver_taskreqrespsessioninout</p>\n</li>\n<li><p>server.startsocketsocketsokcetCommunicatorCommunicator::bindCommunicator::bindCommServiceCommServicenew_sessionCommServiceCommService</p>\n</li>\n</ol>\n<p>12CommService</p>\n<h3 id=\"WFHttpServer\"><a href=\"#WFHttpServer\" class=\"headerlink\" title=\"WFHttpServer\"></a>WFHttpServer</h3><p>WFHttpServer</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; WFHttpServer == WFServer&lt;protocol::HttpRequest, protocol::HttpResponse&gt; &#125; -&gt; WFServerBase -&gt; CommService</span><br></pre></td></tr></table></figure>\n\n<p>WFHttpServer<strong>WFServer</strong><strong></strong>WFServerWFServerBase</p>\n<p>WFServer</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFServer</span> : <span class=\"keyword\">public</span> WFServerBase &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFServer</span>(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> WFServerParams *params,</span><br><span class=\"line\">\t\t\t std::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFServerBase</span>(params),</span><br><span class=\"line\">\t\t<span class=\"built_in\">process</span>(std::<span class=\"built_in\">move</span>(proc)) &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">WFServer</span>(std::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFServerBase</span>(&amp;SERVER_PARAMS_DEFAULT),</span><br><span class=\"line\">\t\t<span class=\"built_in\">process</span>(std::<span class=\"built_in\">move</span>(proc)) &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommSession *<span class=\"title\">new_session</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> seq, CommConnection *conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt; process;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\">CommSession *WFServer&lt;REQ, RESP&gt;::<span class=\"built_in\">new_session</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> seq, CommConnection *conn) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">using</span> factory = WFNetworkTaskFactory&lt;REQ, RESP&gt;;</span><br><span class=\"line\">\tWFNetworkTask&lt;REQ, RESP&gt; *task;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttask = factory::<span class=\"built_in\">create_server_task</span>(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>-&gt;process);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_keep_alive</span>(<span class=\"keyword\">this</span>-&gt;params.keep_alive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_receive_timeout</span>(<span class=\"keyword\">this</span>-&gt;params.receive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">get_req</span>()-&gt;<span class=\"built_in\">set_size_limit</span>(<span class=\"keyword\">this</span>-&gt;params.request_size_limit);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS</p>\n<p>WFServerWFServerBasenew_sessionnew_sessionCommServiceWFHttpServer<strong>new_session</strong>WFServernew_session</p>\n<p>WFServerserverprocess<strong>new_sessionTask</strong>WFServerBase</p>\n<p>WFServerBaseCommServiceWFServerBase</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFServerBase</span> : <span class=\"keyword\">protected</span> CommService &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFServerBase</span>(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> WFServerParams *params) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">conn_count</span>(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;params = *params;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;unbind_finish = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;listen_fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">/* To start a TCP server */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* Start with binding address. The only necessary start function. */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* stop() is a blocking operation. */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">shutdown</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">wait_finish</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Nonblocking terminating the server. For stopping multiple servers.</span></span><br><span class=\"line\"><span class=\"comment\">\t * Typically, call shutdown() and then wait_finish().</span></span><br><span class=\"line\"><span class=\"comment\">\t * But indeed wait_finish() can be called before shutdown(), even before</span></span><br><span class=\"line\"><span class=\"comment\">\t * start() in another thread. */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wait_finish</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">get_conn_count</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;conn_count; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tWFServerParams params;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">create_listen_fd</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> WFConnection *<span class=\"title\">new_connection</span><span class=\"params\">(<span class=\"type\">int</span> accept_fd)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_connection</span><span class=\"params\">(WFConnection *conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle_unbound</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::atomic&lt;<span class=\"type\">size_t</span>&gt; conn_count;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> listen_fd;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> unbind_finish;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::mutex mutex;</span><br><span class=\"line\">\tstd::condition_variable cond;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">CommScheduler</span> *scheduler;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>WFServerBaseCommSchedulerschedulerCommSchedulerCommunicatorschedulerWFServerBaseCommunicatorserverCommunicator::bindlisten socketstart</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">WFServerBase::start</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">init</span>(bind_addr, addrlen) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;scheduler-&gt;<span class=\"built_in\">bind</span>(<span class=\"keyword\">this</span>) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">deinit</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;listen_fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>init</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">WFServerBase::init</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;CommService::<span class=\"built_in\">init</span>(bind_addr, addrlen, <span class=\"number\">-1</span>, timeout) &lt; <span class=\"number\">0</span>)\t<span class=\"comment\">// CommServicelisten fd</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;scheduler = WFGlobal::<span class=\"built_in\">get_scheduler</span>();\t\t\t\t\t\t<span class=\"comment\">// CommScheduler</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>init__CommManagerCommScheduler</p>\n<p><strong></strong>__CommManager<strong>CommScheduler</strong>CommScheduler::init<strong>workflow</strong><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlowCommunicatorTCPServer</a></p>\n<p>WFServerBase::startinitCommScheduler::bindCommunicator::bindTCPServer</p>\n<p>WFServerBasenew_connection  </p>\n<ul>\n<li><p>new_connectionWFServerBase::conn_countnew_connectionWFServerBase::conn_countCommConnectionWFServerBase::conn_countCommunicator__release_connCommConnectionWFServerBase::conn_countCommConnectionPSworkflow</p>\n</li>\n<li><p>WFServerBasestopshutdownwait_finishshutdownCommunicator::unbindlisten fdmpollershutdown<strong></strong></p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WFServerBase::shutdown -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">CommScheduler::unbind -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">Communicator::unbind -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">mpoller_del(listen_fd) - - -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">Communicator::handle_listen_result -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">Communicator::shutdown_service -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">while (CommServiceref0) &#123; CommService::decref() &#125; -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">WFServerBase::handle_unbound</span><br></pre></td></tr></table></figure>\n\n<p>Communicator::shutdown_service</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::shutdown_service</span><span class=\"params\">(CommService *service)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(service-&gt;listen_fd);</span><br><span class=\"line\">\tservice-&gt;listen_fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tservice-&gt;<span class=\"built_in\">drain</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tservice-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>service-&gt;drain(-1)servermpollerCommServiceTarget::decrefserver0WFServerBase::handle_unbound</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">CommService::decref</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__sync_sub_and_fetch(&amp;<span class=\"keyword\">this</span>-&gt;ref, <span class=\"number\">1</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">handle_unbound</span>();\t\t\t\t\t\t<span class=\"comment\">// WFServerBase::handle_unbound</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>WFServerBase::stopwait_finishWFServerBase</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WFServerBase::handle_unbound</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;mutex.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;unbind_finish = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;cond.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;mutex.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WFServerBase::wait_finish</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(<span class=\"keyword\">this</span>-&gt;mutex)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>-&gt;unbind_finish)</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;cond.<span class=\"built_in\">wait</span>(lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">deinit</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;unbind_finish = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tlock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WFHttpServerTask\"><a href=\"#WFHttpServerTask\" class=\"headerlink\" title=\"WFHttpServerTask\"></a>WFHttpServerTask</h3><p>tcpserverWFHttpServer::new_sessionCommSession</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt; <span class=\"function\"><span class=\"keyword\">inline</span></span></span><br><span class=\"line\"><span class=\"function\">CommSession *<span class=\"title\">WFHttpServer::new_session</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> seq, CommConnection *conn)</span> </span>&#123;</span><br><span class=\"line\">\tWFHttpTask *task;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttask = WFServerTaskFactory::<span class=\"built_in\">create_http_task</span>(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>-&gt;process);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_keep_alive</span>(<span class=\"keyword\">this</span>-&gt;params.keep_alive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_receive_timeout</span>(<span class=\"keyword\">this</span>-&gt;params.receive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">get_req</span>()-&gt;<span class=\"built_in\">set_size_limit</span>(<span class=\"keyword\">this</span>-&gt;params.request_size_limit);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>WFHttpTaskWFHttpTaskfinal</p>\n<p>WFHttpTask</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> WFHttpTask = WFNetworkTask&lt;protocol::HttpRequest,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t protocol::HttpResponse&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>WFNetworkTaskWFServerTaskFactory::create_http_taskfinalWFHttpServerTask</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFHttpServerTask</span> : <span class=\"keyword\">public</span> WFServerTask&lt;protocol::HttpRequest,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t protocol::HttpResponse&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">using</span> TASK = WFNetworkTask&lt;protocol::HttpRequest, protocol::HttpResponse&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFHttpServerTask</span>(CommService *service, std::function&lt;<span class=\"built_in\">void</span> (TASK *)&gt;&amp; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFServerTask</span>(service, WFGlobal::<span class=\"built_in\">get_scheduler</span>(), proc),</span><br><span class=\"line\">\t\t<span class=\"built_in\">req_is_alive_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">\t\t<span class=\"built_in\">req_has_keep_alive_header_</span>(<span class=\"literal\">false</span>) &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommMessageOut *<span class=\"title\">message_out</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">bool</span> req_is_alive_;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> req_has_keep_alive_header_;</span><br><span class=\"line\">\tstd::string req_keep_alive_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>CommSchedulerhanldemessage_outhandle</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WFHttpServerTask::handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* fianl... */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;WFServerTask::<span class=\"built_in\">handle</span>(state, error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Communicator::handle_incoming_requestWFT_STATE_TOREPLYfinalhandleWFServerTask</p>\n<p><strong>tcpserverWFServerTask</strong>WFNetworkTasktcpserverWFNetworkTaskCommRequest</p>\n<p>WFHttpServerTask</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SubTask\t\tCommSession</span><br><span class=\"line\">\t\t\\/</span><br><span class=\"line\">\tCommRequest</span><br><span class=\"line\">\t\t|</span><br><span class=\"line\">\t\tV</span><br><span class=\"line\">WFNetworkTask&lt;REQ, RESP&gt;\t# tcpserver</span><br><span class=\"line\">\t\t|</span><br><span class=\"line\">\t\tV</span><br><span class=\"line\">WFServerTask&lt;REQ, RESP&gt;</span><br><span class=\"line\">\t\t|</span><br><span class=\"line\">\t\tV</span><br><span class=\"line\">WFHttpServerTask</span><br></pre></td></tr></table></figure>\n\n<p>WFServerTask<strong></strong></p>\n<p>SubTask::subtask_done</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SubTask::subtask_done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tSubTask *cur = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcur = cur-&gt;<span class=\"built_in\">done</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cur) &#123;</span><br><span class=\"line\">\t\tcur-&gt;<span class=\"built_in\">dispatch</span>();\t\t<span class=\"comment\">// dispatch</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>donedispatch<strong>done<code>series_of(this)-&gt;pop()</code>SeriesWorknullptrSeriesWorkdelete thisSeriesWork</strong></p>\n<p>WFServerTask</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Processor</span> : <span class=\"keyword\">public</span> SubTask &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Processor</span>(WFServerTask&lt;REQ, RESP&gt; *task,</span><br><span class=\"line\">\t\t\t\tstd::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt;&amp; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">process</span>(proc) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;task = task;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">process</span>(<span class=\"keyword\">this</span>-&gt;task);\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;task = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">/* As a flag. get_conneciton() disabled. */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> SubTask *<span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>)-&gt;<span class=\"built_in\">pop</span>();\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt;&amp; process;</span><br><span class=\"line\">\tWFServerTask&lt;REQ, RESP&gt; *task;</span><br><span class=\"line\">&#125; processor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Series</span> : <span class=\"keyword\">public</span> SeriesWork &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Series</span>(WFServerTask&lt;REQ, RESP&gt; *task) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">SeriesWork</span>(&amp;task-&gt;processor, <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">set_last_task</span>(task);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;task = task;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Series</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>-&gt;task;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tWFServerTask&lt;REQ, RESP&gt; *task;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Processor::dispatchprocesssubtask_donedispatch</p>\n</li>\n<li><p>Series <strong>deletedelete</strong><strong>SubTask::pointer</strong></p>\n</li>\n</ul>\n<p>WFServerTask&lt;REQ, RESP&gt;::handle</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> WFServerTask&lt;REQ, RESP&gt;::<span class=\"built_in\">handle</span>(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;state = WFT_STATE_TOREPLY;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;target = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">get_target</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> <span class=\"built_in\">Series</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;processor.<span class=\"built_in\">dispatch</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;state = state;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;error = error;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (error == ETIMEDOUT)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;timeout_reason = TOR_TRANSMIT_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>WFServerTaskSubTask + <strong>CommSession</strong>CommSessionCommSessionhandleCommunicator::handle_incoming_requestCommunicator::handle_reply_resultsession-&gt;handlestate<strong>session-&gt;handlestateCS_STATE_TOREPLYsession-&gt;handlestateCS_STATE_SUCCESS</strong></p>\n<ul>\n<li><p>handleifWFServerTask::stateWFT_STATE_TOREPLYhandleif<code>new Series(this);</code>workflow<strong>new</strong>SeriesnewSeriesWFServerTask::processorWFServerTaskif<code>this-&gt;processor.dispatch();</code>Processor::dispatchprocessserverprocessprocess<code>this-&gt;subtask_done();</code><strong></strong>WFServerTaskSeriesWorkWFServerTask&lt;REQ, RESP&gt;::handleProcessorsubtask_donedispatch<code>WFServerTask::dispatch</code>WFServerTask::stateWFT_STATE_TOREPLYif<code>this-&gt;scheduler-&gt;reply</code></p>\n<p>  </p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WFServerTask&lt;REQ, RESP&gt;::handle -&gt;</span><br><span class=\"line\">Processor::dispatch -&gt; </span><br><span class=\"line\">Processor::subtask_done -&gt; </span><br><span class=\"line\">WFServerTask::dispatch</span><br></pre></td></tr></table></figure>\n\n<p>  </p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WFServerTaskdispatch  -&gt; </span><br><span class=\"line\">Processorsubtask_done -&gt; </span><br><span class=\"line\">Processordispatch -&gt; </span><br><span class=\"line\">WFServerTask&lt;REQ, RESP&gt;::handle</span><br></pre></td></tr></table></figure>\n\n<p>  <strong>WFServerTask&lt;REQ, RESP&gt;::handleifdispatch</strong><strong></strong></p>\n</li>\n<li><p>WFServerTask&lt;REQ, RESP&gt;::handleif<strong></strong><strong>ifnewWFServerTask::subtask_doneifnewSeriesWFServerTask</strong></p>\n</li>\n</ul>\n<p>WFServerTask</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFServerTask</span> : <span class=\"keyword\">public</span> WFNetworkTask&lt;REQ, RESP&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommMessageOut *<span class=\"title\">message_out</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> &amp;<span class=\"keyword\">this</span>-&gt;resp; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommMessageIn *<span class=\"title\">message_in</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> &amp;<span class=\"keyword\">this</span>-&gt;req; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* Enable get_connection() again if the reply() call is success. */</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;processor.task = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;scheduler-&gt;<span class=\"built_in\">reply</span>(<span class=\"keyword\">this</span>) &gt;= <span class=\"number\">0</span>)\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;state = WFT_STATE_SYS_ERROR;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;error = errno;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;processor.task = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;scheduler-&gt;<span class=\"built_in\">shutdown</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> SubTask *<span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSeriesWork *series = <span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;callback)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">callback</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* Defer deleting the task. */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> series-&gt;<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFServerTask</span>(CommService *service, CommScheduler *scheduler,</span><br><span class=\"line\">\t\t\t\t std::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt;&amp; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFNetworkTask</span>&lt;REQ, RESP&gt;(<span class=\"literal\">NULL</span>, scheduler, <span class=\"literal\">nullptr</span>),</span><br><span class=\"line\">\t\t<span class=\"built_in\">processor</span>(<span class=\"keyword\">this</span>, proc)</span><br><span class=\"line\">\t&#123; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>HTTPServer</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Workflow</span><br><span class=\"line\"></span><br><span class=\"line\">server:</span><br><span class=\"line\"></span><br><span class=\"line\">    entry: </span><br><span class=\"line\">        accept_conn: CONN_STATE_CONNECTED -&gt; </span><br><span class=\"line\">            create_request: CONN_STATE_RECEIVING -&gt;                             // tag1</span><br><span class=\"line\">                append_message: httpCONN_STATE_SUCCESS -&gt;</span><br><span class=\"line\">                    handle_incoming_request: </span><br><span class=\"line\">                        ==&gt;     CONN_STATE_IDLE &amp;&amp; entrytarget-&gt;idle_list;</span><br><span class=\"line\">                        ==&gt;    session-&gt;passive = 2;</span><br><span class=\"line\">                        ==&gt;    state = CS_STATE_TOREPLY</span><br><span class=\"line\"></span><br><span class=\"line\">    |   |   |</span><br><span class=\"line\">    V   V   V</span><br><span class=\"line\">    WFHttpServerTask::handle -&gt;</span><br><span class=\"line\">        WFServerTask&lt;REQ, RESP&gt;::handle -&gt;</span><br><span class=\"line\">            ```cpp</span><br><span class=\"line\">                template&lt;class REQ, class RESP&gt;</span><br><span class=\"line\">                void WFServerTask&lt;REQ, RESP&gt;::handle(int state, int error)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    if (state == WFT_STATE_TOREPLY)         // </span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        this-&gt;state = WFT_STATE_TOREPLY;</span><br><span class=\"line\">                        this-&gt;target = this-&gt;get_target();</span><br><span class=\"line\">                        new Series(this);</span><br><span class=\"line\">                        this-&gt;processor.dispatch();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else if (this-&gt;state == WFT_STATE_TOREPLY)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        this-&gt;state = state;</span><br><span class=\"line\">                        this-&gt;error = error;</span><br><span class=\"line\">                        if (error == ETIMEDOUT)</span><br><span class=\"line\">                            this-&gt;timeout_reason = TOR_TRANSMIT_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">                        this-&gt;subtask_done();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else</span><br><span class=\"line\">                        delete this;</span><br><span class=\"line\">                &#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    WFServerTask&lt;REQ, RESP&gt;::dispatch -&gt;\n        this-&gt;scheduler-&gt;reply(this) -&gt; entryepoll\n            session-&gt;passive = 3;\n\n|   |   |       \nV   V   V\nhandle_reply_result -&gt;\n    ===&gt; entry-&gt;state = CONN_STATE_KEEPALIVE &amp;&amp; entry service-&gt;alive_list &amp;&amp; entryepoll\n    ===&gt; state = CS_STATE_SUCCESS\n\n|   |   |\nV   V   V\nWFHttpServerTask::handle -&gt;\n    WFServerTask&lt;REQ, RESP&gt;::handle -&gt;\n        <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> WFServerTask&lt;REQ, RESP&gt;::<span class=\"built_in\">handle</span>(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state == WFT_STATE_TOREPLY)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;state = WFT_STATE_TOREPLY;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;target = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">get_target</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"built_in\">Series</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;processor.<span class=\"built_in\">dispatch</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;state == WFT_STATE_TOREPLY)  <span class=\"comment\">// </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;state = state;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;error = error;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error == ETIMEDOUT)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;timeout_reason = TOR_TRANSMIT_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();       <span class=\"comment\">// will delete Series for first &#x27;if&#x27; branch malloc</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n|   |   |\nV   V   V\ngo to tag1.\n</code></pre>\n<pre><code>\n---\n\n****\n</code></pre>\n","excerpt":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlowGO-Task </a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlowCommunicatorTCPServer</a></p>\n<p>TCPServerWorkFlowpollerCommunicatorpollerCommunicatorTCPServer</p>\n<p>workflowGithub<a href=\"https://github.com/sogou/workflow\">https://github.com/sogou/workflow</a></p>\n<p>GO-TaskSubTaskCommSessionGO-TaskTCPServerTCPServerGO-TaskBUGLeetCodewa</p>","more":"<p>workflowTCPServerCommSchedGroupCommSchedTargetCommSchedObjectCommSchedGroupCommRequest</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlow GO-Task </a>workflowhttp_echo_server</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>go-task</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/HttpMessage.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/HttpUtil.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFServer.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFHttpServer.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFFacilities.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process</span><span class=\"params\">(WFHttpTask *server_task)</span> </span>&#123;</span><br><span class=\"line\">\tprotocol::HttpRequest *req = server_task-&gt;<span class=\"built_in\">get_req</span>();</span><br><span class=\"line\">\tprotocol::HttpResponse *resp = server_task-&gt;<span class=\"built_in\">get_resp</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* http */</span></span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">short</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;USAGE: %s &lt;port&gt;\\n&quot;</span>, argv[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">signal</span>(SIGINT, sig_handler);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">WFHttpServer <span class=\"title\">server</span><span class=\"params\">(process)</span></span>;</span><br><span class=\"line\">\tport = <span class=\"built_in\">atoi</span>(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (server.<span class=\"built_in\">start</span>(port) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\twait_group.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">\t\tserver.<span class=\"built_in\">stop</span>();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">perror</span>(<span class=\"string\">&quot;Cannot start server&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>workflowhttpserverdemo</p>\n<ol>\n<li><p>httpserver</p>\n</li>\n<li><p>startserver</p>\n</li>\n<li><p>wait_group.wait()</p>\n</li>\n</ol>\n<p></p>\n<ol>\n<li><p>process<strong></strong>reqrespserver_tasktcpCommunicator::create_requestininsession<strong>sessionCommService</strong>Communicator::replysessiontcpserversessionoutoutserver_taskreqrespsessioninout</p>\n</li>\n<li><p>server.startsocketsocketsokcetCommunicatorCommunicator::bindCommunicator::bindCommServiceCommServicenew_sessionCommServiceCommService</p>\n</li>\n</ol>\n<p>12CommService</p>\n<h3 id=\"WFHttpServer\"><a href=\"#WFHttpServer\" class=\"headerlink\" title=\"WFHttpServer\"></a>WFHttpServer</h3><p>WFHttpServer</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; WFHttpServer == WFServer&lt;protocol::HttpRequest, protocol::HttpResponse&gt; &#125; -&gt; WFServerBase -&gt; CommService</span><br></pre></td></tr></table></figure>\n\n<p>WFHttpServer<strong>WFServer</strong><strong></strong>WFServerWFServerBase</p>\n<p>WFServer</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFServer</span> : <span class=\"keyword\">public</span> WFServerBase &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFServer</span>(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> WFServerParams *params,</span><br><span class=\"line\">\t\t\t std::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFServerBase</span>(params),</span><br><span class=\"line\">\t\t<span class=\"built_in\">process</span>(std::<span class=\"built_in\">move</span>(proc)) &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">WFServer</span>(std::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFServerBase</span>(&amp;SERVER_PARAMS_DEFAULT),</span><br><span class=\"line\">\t\t<span class=\"built_in\">process</span>(std::<span class=\"built_in\">move</span>(proc)) &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommSession *<span class=\"title\">new_session</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> seq, CommConnection *conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt; process;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\">CommSession *WFServer&lt;REQ, RESP&gt;::<span class=\"built_in\">new_session</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> seq, CommConnection *conn) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">using</span> factory = WFNetworkTaskFactory&lt;REQ, RESP&gt;;</span><br><span class=\"line\">\tWFNetworkTask&lt;REQ, RESP&gt; *task;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttask = factory::<span class=\"built_in\">create_server_task</span>(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>-&gt;process);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_keep_alive</span>(<span class=\"keyword\">this</span>-&gt;params.keep_alive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_receive_timeout</span>(<span class=\"keyword\">this</span>-&gt;params.receive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">get_req</span>()-&gt;<span class=\"built_in\">set_size_limit</span>(<span class=\"keyword\">this</span>-&gt;params.request_size_limit);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS</p>\n<p>WFServerWFServerBasenew_sessionnew_sessionCommServiceWFHttpServer<strong>new_session</strong>WFServernew_session</p>\n<p>WFServerserverprocess<strong>new_sessionTask</strong>WFServerBase</p>\n<p>WFServerBaseCommServiceWFServerBase</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFServerBase</span> : <span class=\"keyword\">protected</span> CommService &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFServerBase</span>(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> WFServerParams *params) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">conn_count</span>(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;params = *params;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;unbind_finish = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;listen_fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">/* To start a TCP server */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* Start with binding address. The only necessary start function. */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* stop() is a blocking operation. */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">shutdown</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">wait_finish</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Nonblocking terminating the server. For stopping multiple servers.</span></span><br><span class=\"line\"><span class=\"comment\">\t * Typically, call shutdown() and then wait_finish().</span></span><br><span class=\"line\"><span class=\"comment\">\t * But indeed wait_finish() can be called before shutdown(), even before</span></span><br><span class=\"line\"><span class=\"comment\">\t * start() in another thread. */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wait_finish</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">get_conn_count</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;conn_count; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tWFServerParams params;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">create_listen_fd</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> WFConnection *<span class=\"title\">new_connection</span><span class=\"params\">(<span class=\"type\">int</span> accept_fd)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_connection</span><span class=\"params\">(WFConnection *conn)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle_unbound</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::atomic&lt;<span class=\"type\">size_t</span>&gt; conn_count;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> listen_fd;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> unbind_finish;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::mutex mutex;</span><br><span class=\"line\">\tstd::condition_variable cond;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">CommScheduler</span> *scheduler;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>WFServerBaseCommSchedulerschedulerCommSchedulerCommunicatorschedulerWFServerBaseCommunicatorserverCommunicator::bindlisten socketstart</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">WFServerBase::start</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">init</span>(bind_addr, addrlen) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;scheduler-&gt;<span class=\"built_in\">bind</span>(<span class=\"keyword\">this</span>) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">deinit</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;listen_fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>init</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">WFServerBase::init</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *bind_addr, <span class=\"type\">socklen_t</span> addrlen)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;CommService::<span class=\"built_in\">init</span>(bind_addr, addrlen, <span class=\"number\">-1</span>, timeout) &lt; <span class=\"number\">0</span>)\t<span class=\"comment\">// CommServicelisten fd</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;scheduler = WFGlobal::<span class=\"built_in\">get_scheduler</span>();\t\t\t\t\t\t<span class=\"comment\">// CommScheduler</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>init__CommManagerCommScheduler</p>\n<p><strong></strong>__CommManager<strong>CommScheduler</strong>CommScheduler::init<strong>workflow</strong><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlowCommunicatorTCPServer</a></p>\n<p>WFServerBase::startinitCommScheduler::bindCommunicator::bindTCPServer</p>\n<p>WFServerBasenew_connection  </p>\n<ul>\n<li><p>new_connectionWFServerBase::conn_countnew_connectionWFServerBase::conn_countCommConnectionWFServerBase::conn_countCommunicator__release_connCommConnectionWFServerBase::conn_countCommConnectionPSworkflow</p>\n</li>\n<li><p>WFServerBasestopshutdownwait_finishshutdownCommunicator::unbindlisten fdmpollershutdown<strong></strong></p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WFServerBase::shutdown -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">CommScheduler::unbind -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">Communicator::unbind -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">mpoller_del(listen_fd) - - -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">Communicator::handle_listen_result -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">Communicator::shutdown_service -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">while (CommServiceref0) &#123; CommService::decref() &#125; -&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">WFServerBase::handle_unbound</span><br></pre></td></tr></table></figure>\n\n<p>Communicator::shutdown_service</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::shutdown_service</span><span class=\"params\">(CommService *service)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(service-&gt;listen_fd);</span><br><span class=\"line\">\tservice-&gt;listen_fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tservice-&gt;<span class=\"built_in\">drain</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tservice-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>service-&gt;drain(-1)servermpollerCommServiceTarget::decrefserver0WFServerBase::handle_unbound</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">CommService::decref</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__sync_sub_and_fetch(&amp;<span class=\"keyword\">this</span>-&gt;ref, <span class=\"number\">1</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">handle_unbound</span>();\t\t\t\t\t\t<span class=\"comment\">// WFServerBase::handle_unbound</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>WFServerBase::stopwait_finishWFServerBase</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WFServerBase::handle_unbound</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;mutex.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;unbind_finish = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;cond.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;mutex.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WFServerBase::wait_finish</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(<span class=\"keyword\">this</span>-&gt;mutex)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>-&gt;unbind_finish)</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;cond.<span class=\"built_in\">wait</span>(lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">deinit</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;unbind_finish = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tlock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WFHttpServerTask\"><a href=\"#WFHttpServerTask\" class=\"headerlink\" title=\"WFHttpServerTask\"></a>WFHttpServerTask</h3><p>tcpserverWFHttpServer::new_sessionCommSession</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt; <span class=\"function\"><span class=\"keyword\">inline</span></span></span><br><span class=\"line\"><span class=\"function\">CommSession *<span class=\"title\">WFHttpServer::new_session</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> seq, CommConnection *conn)</span> </span>&#123;</span><br><span class=\"line\">\tWFHttpTask *task;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttask = WFServerTaskFactory::<span class=\"built_in\">create_http_task</span>(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>-&gt;process);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_keep_alive</span>(<span class=\"keyword\">this</span>-&gt;params.keep_alive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">set_receive_timeout</span>(<span class=\"keyword\">this</span>-&gt;params.receive_timeout);</span><br><span class=\"line\">\ttask-&gt;<span class=\"built_in\">get_req</span>()-&gt;<span class=\"built_in\">set_size_limit</span>(<span class=\"keyword\">this</span>-&gt;params.request_size_limit);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>WFHttpTaskWFHttpTaskfinal</p>\n<p>WFHttpTask</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> WFHttpTask = WFNetworkTask&lt;protocol::HttpRequest,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t protocol::HttpResponse&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>WFNetworkTaskWFServerTaskFactory::create_http_taskfinalWFHttpServerTask</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFHttpServerTask</span> : <span class=\"keyword\">public</span> WFServerTask&lt;protocol::HttpRequest,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t protocol::HttpResponse&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">using</span> TASK = WFNetworkTask&lt;protocol::HttpRequest, protocol::HttpResponse&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFHttpServerTask</span>(CommService *service, std::function&lt;<span class=\"built_in\">void</span> (TASK *)&gt;&amp; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFServerTask</span>(service, WFGlobal::<span class=\"built_in\">get_scheduler</span>(), proc),</span><br><span class=\"line\">\t\t<span class=\"built_in\">req_is_alive_</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">\t\t<span class=\"built_in\">req_has_keep_alive_header_</span>(<span class=\"literal\">false</span>) &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommMessageOut *<span class=\"title\">message_out</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">bool</span> req_is_alive_;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> req_has_keep_alive_header_;</span><br><span class=\"line\">\tstd::string req_keep_alive_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>CommSchedulerhanldemessage_outhandle</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WFHttpServerTask::handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* fianl... */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;WFServerTask::<span class=\"built_in\">handle</span>(state, error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Communicator::handle_incoming_requestWFT_STATE_TOREPLYfinalhandleWFServerTask</p>\n<p><strong>tcpserverWFServerTask</strong>WFNetworkTasktcpserverWFNetworkTaskCommRequest</p>\n<p>WFHttpServerTask</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SubTask\t\tCommSession</span><br><span class=\"line\">\t\t\\/</span><br><span class=\"line\">\tCommRequest</span><br><span class=\"line\">\t\t|</span><br><span class=\"line\">\t\tV</span><br><span class=\"line\">WFNetworkTask&lt;REQ, RESP&gt;\t# tcpserver</span><br><span class=\"line\">\t\t|</span><br><span class=\"line\">\t\tV</span><br><span class=\"line\">WFServerTask&lt;REQ, RESP&gt;</span><br><span class=\"line\">\t\t|</span><br><span class=\"line\">\t\tV</span><br><span class=\"line\">WFHttpServerTask</span><br></pre></td></tr></table></figure>\n\n<p>WFServerTask<strong></strong></p>\n<p>SubTask::subtask_done</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SubTask::subtask_done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tSubTask *cur = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcur = cur-&gt;<span class=\"built_in\">done</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cur) &#123;</span><br><span class=\"line\">\t\tcur-&gt;<span class=\"built_in\">dispatch</span>();\t\t<span class=\"comment\">// dispatch</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>donedispatch<strong>done<code>series_of(this)-&gt;pop()</code>SeriesWorknullptrSeriesWorkdelete thisSeriesWork</strong></p>\n<p>WFServerTask</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Processor</span> : <span class=\"keyword\">public</span> SubTask &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Processor</span>(WFServerTask&lt;REQ, RESP&gt; *task,</span><br><span class=\"line\">\t\t\t\tstd::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt;&amp; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">process</span>(proc) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;task = task;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">process</span>(<span class=\"keyword\">this</span>-&gt;task);\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;task = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">/* As a flag. get_conneciton() disabled. */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> SubTask *<span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>)-&gt;<span class=\"built_in\">pop</span>();\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt;&amp; process;</span><br><span class=\"line\">\tWFServerTask&lt;REQ, RESP&gt; *task;</span><br><span class=\"line\">&#125; processor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Series</span> : <span class=\"keyword\">public</span> SeriesWork &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Series</span>(WFServerTask&lt;REQ, RESP&gt; *task) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">SeriesWork</span>(&amp;task-&gt;processor, <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">set_last_task</span>(task);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;task = task;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Series</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>-&gt;task;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tWFServerTask&lt;REQ, RESP&gt; *task;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Processor::dispatchprocesssubtask_donedispatch</p>\n</li>\n<li><p>Series <strong>deletedelete</strong><strong>SubTask::pointer</strong></p>\n</li>\n</ul>\n<p>WFServerTask&lt;REQ, RESP&gt;::handle</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> WFServerTask&lt;REQ, RESP&gt;::<span class=\"built_in\">handle</span>(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;state = WFT_STATE_TOREPLY;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;target = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">get_target</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> <span class=\"built_in\">Series</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;processor.<span class=\"built_in\">dispatch</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;state = state;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;error = error;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (error == ETIMEDOUT)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;timeout_reason = TOR_TRANSMIT_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>WFServerTaskSubTask + <strong>CommSession</strong>CommSessionCommSessionhandleCommunicator::handle_incoming_requestCommunicator::handle_reply_resultsession-&gt;handlestate<strong>session-&gt;handlestateCS_STATE_TOREPLYsession-&gt;handlestateCS_STATE_SUCCESS</strong></p>\n<ul>\n<li><p>handleifWFServerTask::stateWFT_STATE_TOREPLYhandleif<code>new Series(this);</code>workflow<strong>new</strong>SeriesnewSeriesWFServerTask::processorWFServerTaskif<code>this-&gt;processor.dispatch();</code>Processor::dispatchprocessserverprocessprocess<code>this-&gt;subtask_done();</code><strong></strong>WFServerTaskSeriesWorkWFServerTask&lt;REQ, RESP&gt;::handleProcessorsubtask_donedispatch<code>WFServerTask::dispatch</code>WFServerTask::stateWFT_STATE_TOREPLYif<code>this-&gt;scheduler-&gt;reply</code></p>\n<p>  </p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WFServerTask&lt;REQ, RESP&gt;::handle -&gt;</span><br><span class=\"line\">Processor::dispatch -&gt; </span><br><span class=\"line\">Processor::subtask_done -&gt; </span><br><span class=\"line\">WFServerTask::dispatch</span><br></pre></td></tr></table></figure>\n\n<p>  </p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WFServerTaskdispatch  -&gt; </span><br><span class=\"line\">Processorsubtask_done -&gt; </span><br><span class=\"line\">Processordispatch -&gt; </span><br><span class=\"line\">WFServerTask&lt;REQ, RESP&gt;::handle</span><br></pre></td></tr></table></figure>\n\n<p>  <strong>WFServerTask&lt;REQ, RESP&gt;::handleifdispatch</strong><strong></strong></p>\n</li>\n<li><p>WFServerTask&lt;REQ, RESP&gt;::handleif<strong></strong><strong>ifnewWFServerTask::subtask_doneifnewSeriesWFServerTask</strong></p>\n</li>\n</ul>\n<p>WFServerTask</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFServerTask</span> : <span class=\"keyword\">public</span> WFNetworkTask&lt;REQ, RESP&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommMessageOut *<span class=\"title\">message_out</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> &amp;<span class=\"keyword\">this</span>-&gt;resp; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CommMessageIn *<span class=\"title\">message_in</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> &amp;<span class=\"keyword\">this</span>-&gt;req; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;state == WFT_STATE_TOREPLY) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* Enable get_connection() again if the reply() call is success. */</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;processor.task = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;scheduler-&gt;<span class=\"built_in\">reply</span>(<span class=\"keyword\">this</span>) &gt;= <span class=\"number\">0</span>)\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;state = WFT_STATE_SYS_ERROR;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;error = errno;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;processor.task = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;scheduler-&gt;<span class=\"built_in\">shutdown</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> SubTask *<span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSeriesWork *series = <span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;callback)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">callback</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* Defer deleting the task. */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> series-&gt;<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFServerTask</span>(CommService *service, CommScheduler *scheduler,</span><br><span class=\"line\">\t\t\t\t std::function&lt;<span class=\"built_in\">void</span> (WFNetworkTask&lt;REQ, RESP&gt; *)&gt;&amp; proc) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFNetworkTask</span>&lt;REQ, RESP&gt;(<span class=\"literal\">NULL</span>, scheduler, <span class=\"literal\">nullptr</span>),</span><br><span class=\"line\">\t\t<span class=\"built_in\">processor</span>(<span class=\"keyword\">this</span>, proc)</span><br><span class=\"line\">\t&#123; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>HTTPServer</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Workflow</span><br><span class=\"line\"></span><br><span class=\"line\">server:</span><br><span class=\"line\"></span><br><span class=\"line\">    entry: </span><br><span class=\"line\">        accept_conn: CONN_STATE_CONNECTED -&gt; </span><br><span class=\"line\">            create_request: CONN_STATE_RECEIVING -&gt;                             // tag1</span><br><span class=\"line\">                append_message: httpCONN_STATE_SUCCESS -&gt;</span><br><span class=\"line\">                    handle_incoming_request: </span><br><span class=\"line\">                        ==&gt;     CONN_STATE_IDLE &amp;&amp; entrytarget-&gt;idle_list;</span><br><span class=\"line\">                        ==&gt;    session-&gt;passive = 2;</span><br><span class=\"line\">                        ==&gt;    state = CS_STATE_TOREPLY</span><br><span class=\"line\"></span><br><span class=\"line\">    |   |   |</span><br><span class=\"line\">    V   V   V</span><br><span class=\"line\">    WFHttpServerTask::handle -&gt;</span><br><span class=\"line\">        WFServerTask&lt;REQ, RESP&gt;::handle -&gt;</span><br><span class=\"line\">            ```cpp</span><br><span class=\"line\">                template&lt;class REQ, class RESP&gt;</span><br><span class=\"line\">                void WFServerTask&lt;REQ, RESP&gt;::handle(int state, int error)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    if (state == WFT_STATE_TOREPLY)         // </span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        this-&gt;state = WFT_STATE_TOREPLY;</span><br><span class=\"line\">                        this-&gt;target = this-&gt;get_target();</span><br><span class=\"line\">                        new Series(this);</span><br><span class=\"line\">                        this-&gt;processor.dispatch();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else if (this-&gt;state == WFT_STATE_TOREPLY)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        this-&gt;state = state;</span><br><span class=\"line\">                        this-&gt;error = error;</span><br><span class=\"line\">                        if (error == ETIMEDOUT)</span><br><span class=\"line\">                            this-&gt;timeout_reason = TOR_TRANSMIT_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">                        this-&gt;subtask_done();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else</span><br><span class=\"line\">                        delete this;</span><br><span class=\"line\">                &#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    WFServerTask&lt;REQ, RESP&gt;::dispatch -&gt;\n        this-&gt;scheduler-&gt;reply(this) -&gt; entryepoll\n            session-&gt;passive = 3;\n\n|   |   |       \nV   V   V\nhandle_reply_result -&gt;\n    ===&gt; entry-&gt;state = CONN_STATE_KEEPALIVE &amp;&amp; entry service-&gt;alive_list &amp;&amp; entryepoll\n    ===&gt; state = CS_STATE_SUCCESS\n\n|   |   |\nV   V   V\nWFHttpServerTask::handle -&gt;\n    WFServerTask&lt;REQ, RESP&gt;::handle -&gt;\n        <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">REQ</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">RESP</span>&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> WFServerTask&lt;REQ, RESP&gt;::<span class=\"built_in\">handle</span>(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state == WFT_STATE_TOREPLY)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;state = WFT_STATE_TOREPLY;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;target = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">get_target</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"built_in\">Series</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;processor.<span class=\"built_in\">dispatch</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;state == WFT_STATE_TOREPLY)  <span class=\"comment\">// </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;state = state;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;error = error;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error == ETIMEDOUT)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;timeout_reason = TOR_TRANSMIT_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();       <span class=\"comment\">// will delete Series for first &#x27;if&#x27; branch malloc</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n|   |   |\nV   V   V\ngo to tag1.\n</code></pre>\n<pre><code>\n---\n\n****\n</code></pre>"},{"title":"WorkFlow GO-Task ","date":"2024-10-13T04:00:00.000Z","_content":"\n[WorkFlow GO-Task ](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\n## \n\nsylarmuduoone loop per threadworkflowPS\n\n********\n\n<!-- more -->\n\nepolliotcpservertcpclient\n\nworkflowkernelc++kernelc\n\nworkflowgo-task\n\nExecQueue -> ExecSession -> Executor-> ExecRequest -> SubTask -> __ExecManager -> __WFGoTask -> WFGoTask -> SeriesWork\n\n## \n\nworkflowgotask\n\n### \n\ngo-task\n\n```cpp\n#include <stdio.h>\n#include <utility>\n#include \"workflow/WFTaskFactory.h\"\n#include \"workflow/WFFacilities.h\"\n\nvoid add(int a, int b, int& res) {\n    res = a + b;\n}\n\nint main(void) {\n    WFFacilities::WaitGroup wait_group(1);\n    int a = 1;\n    int b = 1;\n    int res;\n\n    WFGoTask *task = WFTaskFactory::create_go_task(\"test\", add, a, b, std::ref(res));   // cb1\n    task->set_callback([&](WFGoTask *task) {    // cb2\n        printf(\"%d + %d = %d\\n\", a, b, res);\n        wait_group.done();\n    });\n \n    task->start();\n    wait_group.wait();\n    return 0;\n}\n```\n\ndaemo\n\nWaitGroupwait_groupwait_groupaddcb1cb1--WFGoTaskWFGoTask::set_callbackcb2cb2\n\n\n\n1. WaitGroup/\n\n2. WFGoTaskcb1add****cb2\n\n### \n\ncreate_go_taskkernelExecQueueExecQueue\n\ncreate_go_task__ExecManagerExecutorExecutor__WFGoTaskWFGoTask__WFGoTask\n\n__ExecManager__ExecManagerExecutor\n\nExecQueueExecutor__WFGoTask\n\nExecQueuekernellinuxExecSessionEntry\n\n```cpp\nstruct ExecSessionEntry {\n\tstruct list_head list;\n\tExecSession *session;\n\tthrdpool_t *thrdpool;\n};\n```\n\nExecQueueExecSessionExecSessionEntryExecutor\n\n```cpp\nvoid Executor::executor_thread_routine(void *context) {\n\tExecQueue *queue = (ExecQueue *)context;\n\tstruct ExecSessionEntry *entry;\n\tExecSession *session;\n\tint empty;\n\n\tentry = list_entry(queue->session_list.next, struct ExecSessionEntry, list);\n\tpthread_mutex_lock(&queue->mutex);\n\tlist_del(&entry->list);\n\tempty = list_empty(&queue->session_list);\n\tpthread_mutex_unlock(&queue->mutex);\n\n\tsession = entry->session;\n\tif (!empty) {\n\t\tstruct thrdpool_task task = {\n\t\t\t.routine\t=\tExecutor::executor_thread_routine,\n\t\t\t.context\t=\tqueue\n\t\t};\n\t\t__thrdpool_schedule(&task, entry, entry->thrdpool);\n\t}\n\telse\n\t\tfree(entry);\n\n\tsession->execute();\n\tsession->handle(ES_STATE_FINISHED, 0);\n}\n```\n\n\n\n1. ExecSessionEntry\n\n2. ExecSessionEntrysessionthrdpool_taskExecSessionEntry__thrdpool_task_entryPS__thrdpool_task_entryfree\n\n3. freeExecSessionEntry\n\n4. ExecSessionexecutehandle\n\nexecutecb1handlecb2\n\n\n\n```cpp\nentry = list_entry(queue->session_list.next, struct ExecSessionEntry, list);\n```\n\n21list_delentry\n\nExecutor::executor_thread_routineExecutor::executor_thread_routineExecutor::executor_thread_routine****\n\n```cpp\nstruct thrdpool_task task = {\n    .routine\t=\tExecutor::executor_thread_routine,\n    .context\t=\tqueue\n};\n__thrdpool_schedule(&task, entry, entry->thrdpool);\n```\n\nExecQueuestart\n\n```cpp\nint Executor::request(ExecSession *session, ExecQueue *queue) {\n\tstruct ExecSessionEntry *entry;\n\n\tsession->queue = queue;\n\tentry = (struct ExecSessionEntry *)malloc(sizeof (struct ExecSessionEntry));\n\tif (entry) {\n\t\tentry->session = session;\n\t\tentry->thrdpool = this->thrdpool;\n\t\tpthread_mutex_lock(&queue->mutex);\n\t\tlist_add_tail(&entry->list, &queue->session_list);\n\t\tif (queue->session_list.next == &entry->list) {\n\t\t\tstruct thrdpool_task task = {\n\t\t\t\t.routine\t=\tExecutor::executor_thread_routine,\n\t\t\t\t.context\t=\tqueue\n\t\t\t};\n\t\t\tif (thrdpool_schedule(&task, this->thrdpool) < 0) {\n\t\t\t\tlist_del(&entry->list);\n\t\t\t\tfree(entry);\n\t\t\t\tentry = NULL;\n\t\t\t}\n\t\t}\n\n\t\tpthread_mutex_unlock(&queue->mutex);\n\t}\n\n\treturn -!entry;\n}\n```\n\nmallocsessionExecSessionEntryExecQueueExecutor::executor_thread_routine****\n\nmallocExecSessionEntry\n\n1. **mallocExecSessionEntry__thrdpool_task_entryfree**\n\n2. **Executor::executor_thread_routineExecQueuefree**\n\nworkflowmallocfree\n\nExecSessionExecQueueExecutor__WFGoTask\n\nExecQueueExecutor__WFGoTask__WFGoTask\n\n```cpp\nclass __WFGoTask : public WFGoTask {\n    // ...\nprotected:\n\tvirtual void execute() {\n\t\tthis->go();\n\t}\n\nprotected:\n\tstd::function<void ()> go;\n\npublic:\n\t__WFGoTask(ExecQueue *queue, Executor *executor,\n\t\t\t   std::function<void ()>&& func) :\n\t\tWFGoTask(queue, executor),\n\t\tgo(std::move(func)) { /* ... */ }\n};\n```\n\n**virtualexecute**gocb1\n\n\n\n```cpp\nclass WFGoTask : public ExecRequest {\npublic:\n\tvoid start() {\n\t\tassert(!series_of(this));\n\t\tWorkflow::start_series_work(this, nullptr);\n\t}\n\npublic:\n\tvoid *user_data;\n\npublic:\n\tvoid set_callback(std::function<void (WFGoTask *)> cb) {\n\t\tthis->callback = std::move(cb);\n\t}\n\nprotected:\n\tvirtual SubTask *done() {\n\t\tSeriesWork *series = series_of(this);\n\n\t\tif (this->callback)\n\t\t\tthis->callback(this);\n\n\t\tdelete this;\n\t\treturn series->pop();\n\t}\n\nprotected:\n\tstd::function<void (WFGoTask *)> callback;\n\npublic:\n\tWFGoTask(ExecQueue *queue, Executor *executor) :\n\t\tExecRequest(queue, executor) { /* ... */ }\n};\n```\n\nWFGoTask::start()startset_callbackcb2start_series_workSeriesWorkSeriesWorkWFGoTaskSubTaskuser_dataSeriesWork\n\nExecRequest\n\n```cpp\nclass ExecRequest : public SubTask, public ExecSession {\npublic:\n\tExecRequest(ExecQueue *queue, Executor *executor) { /* ... */ }\n\npublic:\n\tvirtual void dispatch() {\n\t\tif (this->executor->request(this, this->queue) < 0)\n\t\t\tthis->handle(ES_STATE_ERROR, errno);\n\t}\n\nprotected:\n\tExecQueue *queue;\n\tExecutor *executor;\n\nprotected:\n\tvirtual void handle(int state, int error) {\n\t\tthis->state = state;\n\t\tthis->error = error;\n\t\tthis->subtask_done();\n\t}\n};\n```\n\nSubTaskExecSession\n\nSubTask\n\ndispatchdone\n\nsubtask_done\n\n\n\nSubTask::dispatch ExecRequest::dispatch\n\nSubTask::done WFGoTask::done\n\nsubtask_done\n\n```cpp\nvoid SubTask::subtask_done() {\n\tSubTask *cur = this;\n\n\twhile (1) {\n\t\tcur = cur->done();\n\t\tif (cur) {\n\t\t\tcur->dispatch();\n\t\t}\n        /* ... */\n\n\t\tbreak;\n\t}\n}\n```\n\ndoneWFGoTask::donetasktasksubtask_doneExecRequest::dispatchtaskExecQueue\n\nExecSessionexecutehandle__WFGoTask::executeExecRequest::handle\n\nExecutor::executor_thread_routineexecutehandle__WFGoTask::executeExecRequest::handle()\n\ngo-task\n\n1. go-task && start\n\n2. startnewfirstgo-tasklastnullptrSeriesWork && firstdispatchExecRequest::dispatch\n\n3. executorrequestgo-taskExecQueueExecQueueExecutor::executor_thread_routine\n\n4. Executor::executor_thread_routine****ExecQueue\n\n5. __WFGoTask::execute\n\n6. ExecRequest::handle\n\n7. SubTask::subtask_done && SeriesWorktaskdispatchPSExecRequest::dispatch\n\n8. WFGoTask::donetask\n\n**Executor::executor_thread_routineExecQueueexecute** Executor::executor_thread_routineExecutor::requestExecutor::executor_thread_routineExecutor::executor_thread_routine\n\n---\n\n****","source":"_posts/workflow/go_task.md","raw":"---\ntitle: WorkFlow GO-Task \ndate: 2024-10-13 12:00:00\ntags:\n  - \n---\n\n[WorkFlow GO-Task ](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\n## \n\nsylarmuduoone loop per threadworkflowPS\n\n********\n\n<!-- more -->\n\nepolliotcpservertcpclient\n\nworkflowkernelc++kernelc\n\nworkflowgo-task\n\nExecQueue -> ExecSession -> Executor-> ExecRequest -> SubTask -> __ExecManager -> __WFGoTask -> WFGoTask -> SeriesWork\n\n## \n\nworkflowgotask\n\n### \n\ngo-task\n\n```cpp\n#include <stdio.h>\n#include <utility>\n#include \"workflow/WFTaskFactory.h\"\n#include \"workflow/WFFacilities.h\"\n\nvoid add(int a, int b, int& res) {\n    res = a + b;\n}\n\nint main(void) {\n    WFFacilities::WaitGroup wait_group(1);\n    int a = 1;\n    int b = 1;\n    int res;\n\n    WFGoTask *task = WFTaskFactory::create_go_task(\"test\", add, a, b, std::ref(res));   // cb1\n    task->set_callback([&](WFGoTask *task) {    // cb2\n        printf(\"%d + %d = %d\\n\", a, b, res);\n        wait_group.done();\n    });\n \n    task->start();\n    wait_group.wait();\n    return 0;\n}\n```\n\ndaemo\n\nWaitGroupwait_groupwait_groupaddcb1cb1--WFGoTaskWFGoTask::set_callbackcb2cb2\n\n\n\n1. WaitGroup/\n\n2. WFGoTaskcb1add****cb2\n\n### \n\ncreate_go_taskkernelExecQueueExecQueue\n\ncreate_go_task__ExecManagerExecutorExecutor__WFGoTaskWFGoTask__WFGoTask\n\n__ExecManager__ExecManagerExecutor\n\nExecQueueExecutor__WFGoTask\n\nExecQueuekernellinuxExecSessionEntry\n\n```cpp\nstruct ExecSessionEntry {\n\tstruct list_head list;\n\tExecSession *session;\n\tthrdpool_t *thrdpool;\n};\n```\n\nExecQueueExecSessionExecSessionEntryExecutor\n\n```cpp\nvoid Executor::executor_thread_routine(void *context) {\n\tExecQueue *queue = (ExecQueue *)context;\n\tstruct ExecSessionEntry *entry;\n\tExecSession *session;\n\tint empty;\n\n\tentry = list_entry(queue->session_list.next, struct ExecSessionEntry, list);\n\tpthread_mutex_lock(&queue->mutex);\n\tlist_del(&entry->list);\n\tempty = list_empty(&queue->session_list);\n\tpthread_mutex_unlock(&queue->mutex);\n\n\tsession = entry->session;\n\tif (!empty) {\n\t\tstruct thrdpool_task task = {\n\t\t\t.routine\t=\tExecutor::executor_thread_routine,\n\t\t\t.context\t=\tqueue\n\t\t};\n\t\t__thrdpool_schedule(&task, entry, entry->thrdpool);\n\t}\n\telse\n\t\tfree(entry);\n\n\tsession->execute();\n\tsession->handle(ES_STATE_FINISHED, 0);\n}\n```\n\n\n\n1. ExecSessionEntry\n\n2. ExecSessionEntrysessionthrdpool_taskExecSessionEntry__thrdpool_task_entryPS__thrdpool_task_entryfree\n\n3. freeExecSessionEntry\n\n4. ExecSessionexecutehandle\n\nexecutecb1handlecb2\n\n\n\n```cpp\nentry = list_entry(queue->session_list.next, struct ExecSessionEntry, list);\n```\n\n21list_delentry\n\nExecutor::executor_thread_routineExecutor::executor_thread_routineExecutor::executor_thread_routine****\n\n```cpp\nstruct thrdpool_task task = {\n    .routine\t=\tExecutor::executor_thread_routine,\n    .context\t=\tqueue\n};\n__thrdpool_schedule(&task, entry, entry->thrdpool);\n```\n\nExecQueuestart\n\n```cpp\nint Executor::request(ExecSession *session, ExecQueue *queue) {\n\tstruct ExecSessionEntry *entry;\n\n\tsession->queue = queue;\n\tentry = (struct ExecSessionEntry *)malloc(sizeof (struct ExecSessionEntry));\n\tif (entry) {\n\t\tentry->session = session;\n\t\tentry->thrdpool = this->thrdpool;\n\t\tpthread_mutex_lock(&queue->mutex);\n\t\tlist_add_tail(&entry->list, &queue->session_list);\n\t\tif (queue->session_list.next == &entry->list) {\n\t\t\tstruct thrdpool_task task = {\n\t\t\t\t.routine\t=\tExecutor::executor_thread_routine,\n\t\t\t\t.context\t=\tqueue\n\t\t\t};\n\t\t\tif (thrdpool_schedule(&task, this->thrdpool) < 0) {\n\t\t\t\tlist_del(&entry->list);\n\t\t\t\tfree(entry);\n\t\t\t\tentry = NULL;\n\t\t\t}\n\t\t}\n\n\t\tpthread_mutex_unlock(&queue->mutex);\n\t}\n\n\treturn -!entry;\n}\n```\n\nmallocsessionExecSessionEntryExecQueueExecutor::executor_thread_routine****\n\nmallocExecSessionEntry\n\n1. **mallocExecSessionEntry__thrdpool_task_entryfree**\n\n2. **Executor::executor_thread_routineExecQueuefree**\n\nworkflowmallocfree\n\nExecSessionExecQueueExecutor__WFGoTask\n\nExecQueueExecutor__WFGoTask__WFGoTask\n\n```cpp\nclass __WFGoTask : public WFGoTask {\n    // ...\nprotected:\n\tvirtual void execute() {\n\t\tthis->go();\n\t}\n\nprotected:\n\tstd::function<void ()> go;\n\npublic:\n\t__WFGoTask(ExecQueue *queue, Executor *executor,\n\t\t\t   std::function<void ()>&& func) :\n\t\tWFGoTask(queue, executor),\n\t\tgo(std::move(func)) { /* ... */ }\n};\n```\n\n**virtualexecute**gocb1\n\n\n\n```cpp\nclass WFGoTask : public ExecRequest {\npublic:\n\tvoid start() {\n\t\tassert(!series_of(this));\n\t\tWorkflow::start_series_work(this, nullptr);\n\t}\n\npublic:\n\tvoid *user_data;\n\npublic:\n\tvoid set_callback(std::function<void (WFGoTask *)> cb) {\n\t\tthis->callback = std::move(cb);\n\t}\n\nprotected:\n\tvirtual SubTask *done() {\n\t\tSeriesWork *series = series_of(this);\n\n\t\tif (this->callback)\n\t\t\tthis->callback(this);\n\n\t\tdelete this;\n\t\treturn series->pop();\n\t}\n\nprotected:\n\tstd::function<void (WFGoTask *)> callback;\n\npublic:\n\tWFGoTask(ExecQueue *queue, Executor *executor) :\n\t\tExecRequest(queue, executor) { /* ... */ }\n};\n```\n\nWFGoTask::start()startset_callbackcb2start_series_workSeriesWorkSeriesWorkWFGoTaskSubTaskuser_dataSeriesWork\n\nExecRequest\n\n```cpp\nclass ExecRequest : public SubTask, public ExecSession {\npublic:\n\tExecRequest(ExecQueue *queue, Executor *executor) { /* ... */ }\n\npublic:\n\tvirtual void dispatch() {\n\t\tif (this->executor->request(this, this->queue) < 0)\n\t\t\tthis->handle(ES_STATE_ERROR, errno);\n\t}\n\nprotected:\n\tExecQueue *queue;\n\tExecutor *executor;\n\nprotected:\n\tvirtual void handle(int state, int error) {\n\t\tthis->state = state;\n\t\tthis->error = error;\n\t\tthis->subtask_done();\n\t}\n};\n```\n\nSubTaskExecSession\n\nSubTask\n\ndispatchdone\n\nsubtask_done\n\n\n\nSubTask::dispatch ExecRequest::dispatch\n\nSubTask::done WFGoTask::done\n\nsubtask_done\n\n```cpp\nvoid SubTask::subtask_done() {\n\tSubTask *cur = this;\n\n\twhile (1) {\n\t\tcur = cur->done();\n\t\tif (cur) {\n\t\t\tcur->dispatch();\n\t\t}\n        /* ... */\n\n\t\tbreak;\n\t}\n}\n```\n\ndoneWFGoTask::donetasktasksubtask_doneExecRequest::dispatchtaskExecQueue\n\nExecSessionexecutehandle__WFGoTask::executeExecRequest::handle\n\nExecutor::executor_thread_routineexecutehandle__WFGoTask::executeExecRequest::handle()\n\ngo-task\n\n1. go-task && start\n\n2. startnewfirstgo-tasklastnullptrSeriesWork && firstdispatchExecRequest::dispatch\n\n3. executorrequestgo-taskExecQueueExecQueueExecutor::executor_thread_routine\n\n4. Executor::executor_thread_routine****ExecQueue\n\n5. __WFGoTask::execute\n\n6. ExecRequest::handle\n\n7. SubTask::subtask_done && SeriesWorktaskdispatchPSExecRequest::dispatch\n\n8. WFGoTask::donetask\n\n**Executor::executor_thread_routineExecQueueexecute** Executor::executor_thread_routineExecutor::requestExecutor::executor_thread_routineExecutor::executor_thread_routine\n\n---\n\n****","slug":"workflow/go_task","published":1,"updated":"2025-09-28T14:32:17.118Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9t000yq8ws5v75f0jg","content":"<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlow GO-Task </a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlowCommunicatorTCPServer</a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>sylarmuduoone loop per threadworkflowPS</p>\n<p><strong></strong><strong></strong></p>\n<span id=\"more\"></span>\n\n<p>epolliotcpservertcpclient</p>\n<p>workflowkernelc++kernelc</p>\n<p>workflowgo-task</p>\n<p>ExecQueue -&gt; ExecSession -&gt; Executor-&gt; ExecRequest -&gt; SubTask -&gt; __ExecManager -&gt; __WFGoTask -&gt; WFGoTask -&gt; SeriesWork</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>workflowgotask</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>go-task</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFTaskFactory.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFFacilities.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span>&amp; res)</span> </span>&#123;</span><br><span class=\"line\">    res = a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">WFFacilities::WaitGroup <span class=\"title\">wait_group</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    WFGoTask *task = WFTaskFactory::<span class=\"built_in\">create_go_task</span>(<span class=\"string\">&quot;test&quot;</span>, add, a, b, std::<span class=\"built_in\">ref</span>(res));   <span class=\"comment\">// cb1</span></span><br><span class=\"line\">    task-&gt;<span class=\"built_in\">set_callback</span>([&amp;](WFGoTask *task) &#123;    <span class=\"comment\">// cb2</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d + %d = %d\\n&quot;</span>, a, b, res);</span><br><span class=\"line\">        wait_group.<span class=\"built_in\">done</span>();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">    task-&gt;<span class=\"built_in\">start</span>();</span><br><span class=\"line\">    wait_group.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>daemo</p>\n<p>WaitGroupwait_groupwait_groupaddcb1cb1WFGoTaskWFGoTask::set_callbackcb2cb2</p>\n<p></p>\n<ol>\n<li><p>WaitGroup&#x2F;</p>\n</li>\n<li><p>WFGoTaskcb1add<strong></strong>cb2</p>\n</li>\n</ol>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>create_go_taskkernelExecQueueExecQueue</p>\n<p>create_go_task__ExecManagerExecutorExecutor__WFGoTaskWFGoTask__WFGoTask</p>\n<p>__ExecManager__ExecManagerExecutor</p>\n<p>ExecQueueExecutor__WFGoTask</p>\n<p>ExecQueuekernellinuxExecSessionEntry</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ExecSessionEntry</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> list;</span><br><span class=\"line\">\tExecSession *session;</span><br><span class=\"line\">\t<span class=\"type\">thrdpool_t</span> *thrdpool;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>ExecQueueExecSessionExecSessionEntryExecutor</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Executor::executor_thread_routine</span><span class=\"params\">(<span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">\tExecQueue *queue = (ExecQueue *)context;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">ExecSessionEntry</span> *entry;</span><br><span class=\"line\">\tExecSession *session;</span><br><span class=\"line\">\t<span class=\"type\">int</span> empty;</span><br><span class=\"line\"></span><br><span class=\"line\">\tentry = <span class=\"built_in\">list_entry</span>(queue-&gt;session_list.next, <span class=\"keyword\">struct</span> ExecSessionEntry, list);</span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"built_in\">list_del</span>(&amp;entry-&gt;list);</span><br><span class=\"line\">\tempty = <span class=\"built_in\">list_empty</span>(&amp;queue-&gt;session_list);</span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">\tsession = entry-&gt;session;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!empty) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">thrdpool_task</span> task = &#123;</span><br><span class=\"line\">\t\t\t.routine\t=\tExecutor::executor_thread_routine,</span><br><span class=\"line\">\t\t\t.context\t=\tqueue</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t__thrdpool_schedule(&amp;task, entry, entry-&gt;thrdpool);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(entry);</span><br><span class=\"line\"></span><br><span class=\"line\">\tsession-&gt;<span class=\"built_in\">execute</span>();</span><br><span class=\"line\">\tsession-&gt;<span class=\"built_in\">handle</span>(ES_STATE_FINISHED, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<ol>\n<li><p>ExecSessionEntry</p>\n</li>\n<li><p>ExecSessionEntrysessionthrdpool_taskExecSessionEntry__thrdpool_task_entryPS__thrdpool_task_entryfree</p>\n</li>\n<li><p>freeExecSessionEntry</p>\n</li>\n<li><p>ExecSessionexecutehandle</p>\n</li>\n</ol>\n<p>executecb1handlecb2</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry = <span class=\"built_in\">list_entry</span>(queue-&gt;session_list.next, <span class=\"keyword\">struct</span> ExecSessionEntry, list);</span><br></pre></td></tr></table></figure>\n\n<p>21list_delentry</p>\n<p>Executor::executor_thread_routineExecutor::executor_thread_routineExecutor::executor_thread_routine<strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">thrdpool_task</span> task = &#123;</span><br><span class=\"line\">    .routine\t=\tExecutor::executor_thread_routine,</span><br><span class=\"line\">    .context\t=\tqueue</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">__thrdpool_schedule(&amp;task, entry, entry-&gt;thrdpool);</span><br></pre></td></tr></table></figure>\n\n<p>ExecQueuestart</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Executor::request</span><span class=\"params\">(ExecSession *session, ExecQueue *queue)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">ExecSessionEntry</span> *entry;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsession-&gt;queue = queue;</span><br><span class=\"line\">\tentry = (<span class=\"keyword\">struct</span> ExecSessionEntry *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> ExecSessionEntry));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (entry) &#123;</span><br><span class=\"line\">\t\tentry-&gt;session = session;</span><br><span class=\"line\">\t\tentry-&gt;thrdpool = <span class=\"keyword\">this</span>-&gt;thrdpool;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_add_tail</span>(&amp;entry-&gt;list, &amp;queue-&gt;session_list);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (queue-&gt;session_list.next == &amp;entry-&gt;list) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">thrdpool_task</span> task = &#123;</span><br><span class=\"line\">\t\t\t\t.routine\t=\tExecutor::executor_thread_routine,</span><br><span class=\"line\">\t\t\t\t.context\t=\tqueue</span><br><span class=\"line\">\t\t\t&#125;;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">thrdpool_schedule</span>(&amp;task, <span class=\"keyword\">this</span>-&gt;thrdpool) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">list_del</span>(&amp;entry-&gt;list);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">free</span>(entry);</span><br><span class=\"line\">\t\t\t\tentry = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -!entry;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mallocsessionExecSessionEntryExecQueueExecutor::executor_thread_routine<strong></strong></p>\n<p>mallocExecSessionEntry</p>\n<ol>\n<li><p><strong>mallocExecSessionEntry__thrdpool_task_entryfree</strong></p>\n</li>\n<li><p><strong>Executor::executor_thread_routineExecQueuefree</strong></p>\n</li>\n</ol>\n<p>workflowmallocfree</p>\n<p>ExecSessionExecQueueExecutor__WFGoTask</p>\n<p>ExecQueueExecutor__WFGoTask__WFGoTask</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">__WFGoTask</span> : <span class=\"keyword\">public</span> WFGoTask &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">go</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> ()&gt; go;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t__WFGoTask(ExecQueue *queue, Executor *executor,</span><br><span class=\"line\">\t\t\t   std::function&lt;<span class=\"built_in\">void</span> ()&gt;&amp;&amp; func) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFGoTask</span>(queue, executor),</span><br><span class=\"line\">\t\t<span class=\"built_in\">go</span>(std::<span class=\"built_in\">move</span>(func)) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>virtualexecute</strong>gocb1</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFGoTask</span> : <span class=\"keyword\">public</span> ExecRequest &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">assert</span>(!<span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">\t\tWorkflow::<span class=\"built_in\">start_series_work</span>(<span class=\"keyword\">this</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">void</span> *user_data;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_callback</span><span class=\"params\">(std::function&lt;<span class=\"type\">void</span> (WFGoTask *)&gt; cb)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;callback = std::<span class=\"built_in\">move</span>(cb);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> SubTask *<span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSeriesWork *series = <span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;callback)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">callback</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> series-&gt;<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> (WFGoTask *)&gt; callback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFGoTask</span>(ExecQueue *queue, Executor *executor) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">ExecRequest</span>(queue, executor) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>WFGoTask::start()startset_callbackcb2start_series_workSeriesWorkSeriesWorkWFGoTaskSubTaskuser_dataSeriesWork</p>\n<p>ExecRequest</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExecRequest</span> : <span class=\"keyword\">public</span> SubTask, <span class=\"keyword\">public</span> ExecSession &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">ExecRequest</span>(ExecQueue *queue, Executor *executor) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;executor-&gt;<span class=\"built_in\">request</span>(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>-&gt;queue) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">handle</span>(ES_STATE_ERROR, errno);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tExecQueue *queue;</span><br><span class=\"line\">\tExecutor *executor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;state = state;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;error = error;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>SubTaskExecSession</p>\n<p>SubTask</p>\n<p>dispatchdone</p>\n<p>subtask_done</p>\n<p></p>\n<p>SubTask::dispatch ExecRequest::dispatch</p>\n<p>SubTask::done WFGoTask::done</p>\n<p>subtask_done</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SubTask::subtask_done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tSubTask *cur = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tcur = cur-&gt;<span class=\"built_in\">done</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur) &#123;</span><br><span class=\"line\">\t\t\tcur-&gt;<span class=\"built_in\">dispatch</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">/* ... */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>doneWFGoTask::donetasktasksubtask_doneExecRequest::dispatchtaskExecQueue</p>\n<p>ExecSessionexecutehandle__WFGoTask::executeExecRequest::handle</p>\n<p>Executor::executor_thread_routineexecutehandle__WFGoTask::executeExecRequest::handle()</p>\n<p>go-task</p>\n<ol>\n<li><p>go-task &amp;&amp; start</p>\n</li>\n<li><p>startnewfirstgo-tasklastnullptrSeriesWork &amp;&amp; firstdispatchExecRequest::dispatch</p>\n</li>\n<li><p>executorrequestgo-taskExecQueueExecQueueExecutor::executor_thread_routine</p>\n</li>\n<li><p>Executor::executor_thread_routine<strong></strong>ExecQueue</p>\n</li>\n<li><p>__WFGoTask::execute</p>\n</li>\n<li><p>ExecRequest::handle</p>\n</li>\n<li><p>SubTask::subtask_done &amp;&amp; SeriesWorktaskdispatchPSExecRequest::dispatch</p>\n</li>\n<li><p>WFGoTask::donetask</p>\n</li>\n</ol>\n<p><strong>Executor::executor_thread_routineExecQueueexecute</strong> Executor::executor_thread_routineExecutor::requestExecutor::executor_thread_routineExecutor::executor_thread_routine</p>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlow GO-Task </a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlowCommunicatorTCPServer</a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>sylarmuduoone loop per threadworkflowPS</p>\n<p><strong></strong><strong></strong></p>","more":"<p>epolliotcpservertcpclient</p>\n<p>workflowkernelc++kernelc</p>\n<p>workflowgo-task</p>\n<p>ExecQueue -&gt; ExecSession -&gt; Executor-&gt; ExecRequest -&gt; SubTask -&gt; __ExecManager -&gt; __WFGoTask -&gt; WFGoTask -&gt; SeriesWork</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>workflowgotask</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>go-task</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFTaskFactory.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;workflow/WFFacilities.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span>&amp; res)</span> </span>&#123;</span><br><span class=\"line\">    res = a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">WFFacilities::WaitGroup <span class=\"title\">wait_group</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    WFGoTask *task = WFTaskFactory::<span class=\"built_in\">create_go_task</span>(<span class=\"string\">&quot;test&quot;</span>, add, a, b, std::<span class=\"built_in\">ref</span>(res));   <span class=\"comment\">// cb1</span></span><br><span class=\"line\">    task-&gt;<span class=\"built_in\">set_callback</span>([&amp;](WFGoTask *task) &#123;    <span class=\"comment\">// cb2</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d + %d = %d\\n&quot;</span>, a, b, res);</span><br><span class=\"line\">        wait_group.<span class=\"built_in\">done</span>();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">    task-&gt;<span class=\"built_in\">start</span>();</span><br><span class=\"line\">    wait_group.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>daemo</p>\n<p>WaitGroupwait_groupwait_groupaddcb1cb1WFGoTaskWFGoTask::set_callbackcb2cb2</p>\n<p></p>\n<ol>\n<li><p>WaitGroup&#x2F;</p>\n</li>\n<li><p>WFGoTaskcb1add<strong></strong>cb2</p>\n</li>\n</ol>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>create_go_taskkernelExecQueueExecQueue</p>\n<p>create_go_task__ExecManagerExecutorExecutor__WFGoTaskWFGoTask__WFGoTask</p>\n<p>__ExecManager__ExecManagerExecutor</p>\n<p>ExecQueueExecutor__WFGoTask</p>\n<p>ExecQueuekernellinuxExecSessionEntry</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ExecSessionEntry</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> list;</span><br><span class=\"line\">\tExecSession *session;</span><br><span class=\"line\">\t<span class=\"type\">thrdpool_t</span> *thrdpool;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>ExecQueueExecSessionExecSessionEntryExecutor</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Executor::executor_thread_routine</span><span class=\"params\">(<span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">\tExecQueue *queue = (ExecQueue *)context;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">ExecSessionEntry</span> *entry;</span><br><span class=\"line\">\tExecSession *session;</span><br><span class=\"line\">\t<span class=\"type\">int</span> empty;</span><br><span class=\"line\"></span><br><span class=\"line\">\tentry = <span class=\"built_in\">list_entry</span>(queue-&gt;session_list.next, <span class=\"keyword\">struct</span> ExecSessionEntry, list);</span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"built_in\">list_del</span>(&amp;entry-&gt;list);</span><br><span class=\"line\">\tempty = <span class=\"built_in\">list_empty</span>(&amp;queue-&gt;session_list);</span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">\tsession = entry-&gt;session;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!empty) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">thrdpool_task</span> task = &#123;</span><br><span class=\"line\">\t\t\t.routine\t=\tExecutor::executor_thread_routine,</span><br><span class=\"line\">\t\t\t.context\t=\tqueue</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t__thrdpool_schedule(&amp;task, entry, entry-&gt;thrdpool);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(entry);</span><br><span class=\"line\"></span><br><span class=\"line\">\tsession-&gt;<span class=\"built_in\">execute</span>();</span><br><span class=\"line\">\tsession-&gt;<span class=\"built_in\">handle</span>(ES_STATE_FINISHED, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<ol>\n<li><p>ExecSessionEntry</p>\n</li>\n<li><p>ExecSessionEntrysessionthrdpool_taskExecSessionEntry__thrdpool_task_entryPS__thrdpool_task_entryfree</p>\n</li>\n<li><p>freeExecSessionEntry</p>\n</li>\n<li><p>ExecSessionexecutehandle</p>\n</li>\n</ol>\n<p>executecb1handlecb2</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry = <span class=\"built_in\">list_entry</span>(queue-&gt;session_list.next, <span class=\"keyword\">struct</span> ExecSessionEntry, list);</span><br></pre></td></tr></table></figure>\n\n<p>21list_delentry</p>\n<p>Executor::executor_thread_routineExecutor::executor_thread_routineExecutor::executor_thread_routine<strong></strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">thrdpool_task</span> task = &#123;</span><br><span class=\"line\">    .routine\t=\tExecutor::executor_thread_routine,</span><br><span class=\"line\">    .context\t=\tqueue</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">__thrdpool_schedule(&amp;task, entry, entry-&gt;thrdpool);</span><br></pre></td></tr></table></figure>\n\n<p>ExecQueuestart</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Executor::request</span><span class=\"params\">(ExecSession *session, ExecQueue *queue)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">ExecSessionEntry</span> *entry;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsession-&gt;queue = queue;</span><br><span class=\"line\">\tentry = (<span class=\"keyword\">struct</span> ExecSessionEntry *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> ExecSessionEntry));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (entry) &#123;</span><br><span class=\"line\">\t\tentry-&gt;session = session;</span><br><span class=\"line\">\t\tentry-&gt;thrdpool = <span class=\"keyword\">this</span>-&gt;thrdpool;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_add_tail</span>(&amp;entry-&gt;list, &amp;queue-&gt;session_list);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (queue-&gt;session_list.next == &amp;entry-&gt;list) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">thrdpool_task</span> task = &#123;</span><br><span class=\"line\">\t\t\t\t.routine\t=\tExecutor::executor_thread_routine,</span><br><span class=\"line\">\t\t\t\t.context\t=\tqueue</span><br><span class=\"line\">\t\t\t&#125;;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">thrdpool_schedule</span>(&amp;task, <span class=\"keyword\">this</span>-&gt;thrdpool) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">list_del</span>(&amp;entry-&gt;list);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">free</span>(entry);</span><br><span class=\"line\">\t\t\t\tentry = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;queue-&gt;mutex);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -!entry;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mallocsessionExecSessionEntryExecQueueExecutor::executor_thread_routine<strong></strong></p>\n<p>mallocExecSessionEntry</p>\n<ol>\n<li><p><strong>mallocExecSessionEntry__thrdpool_task_entryfree</strong></p>\n</li>\n<li><p><strong>Executor::executor_thread_routineExecQueuefree</strong></p>\n</li>\n</ol>\n<p>workflowmallocfree</p>\n<p>ExecSessionExecQueueExecutor__WFGoTask</p>\n<p>ExecQueueExecutor__WFGoTask__WFGoTask</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">__WFGoTask</span> : <span class=\"keyword\">public</span> WFGoTask &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">go</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> ()&gt; go;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t__WFGoTask(ExecQueue *queue, Executor *executor,</span><br><span class=\"line\">\t\t\t   std::function&lt;<span class=\"built_in\">void</span> ()&gt;&amp;&amp; func) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">WFGoTask</span>(queue, executor),</span><br><span class=\"line\">\t\t<span class=\"built_in\">go</span>(std::<span class=\"built_in\">move</span>(func)) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>virtualexecute</strong>gocb1</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WFGoTask</span> : <span class=\"keyword\">public</span> ExecRequest &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">assert</span>(!<span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">\t\tWorkflow::<span class=\"built_in\">start_series_work</span>(<span class=\"keyword\">this</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">void</span> *user_data;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_callback</span><span class=\"params\">(std::function&lt;<span class=\"type\">void</span> (WFGoTask *)&gt; cb)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;callback = std::<span class=\"built_in\">move</span>(cb);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> SubTask *<span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSeriesWork *series = <span class=\"built_in\">series_of</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;callback)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">callback</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> series-&gt;<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span> (WFGoTask *)&gt; callback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">WFGoTask</span>(ExecQueue *queue, Executor *executor) :</span><br><span class=\"line\">\t\t<span class=\"built_in\">ExecRequest</span>(queue, executor) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>WFGoTask::start()startset_callbackcb2start_series_workSeriesWorkSeriesWorkWFGoTaskSubTaskuser_dataSeriesWork</p>\n<p>ExecRequest</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExecRequest</span> : <span class=\"keyword\">public</span> SubTask, <span class=\"keyword\">public</span> ExecSession &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">ExecRequest</span>(ExecQueue *queue, Executor *executor) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;executor-&gt;<span class=\"built_in\">request</span>(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>-&gt;queue) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">handle</span>(ES_STATE_ERROR, errno);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tExecQueue *queue;</span><br><span class=\"line\">\tExecutor *executor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> state, <span class=\"type\">int</span> error)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;state = state;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;error = error;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">subtask_done</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>SubTaskExecSession</p>\n<p>SubTask</p>\n<p>dispatchdone</p>\n<p>subtask_done</p>\n<p></p>\n<p>SubTask::dispatch ExecRequest::dispatch</p>\n<p>SubTask::done WFGoTask::done</p>\n<p>subtask_done</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SubTask::subtask_done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tSubTask *cur = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tcur = cur-&gt;<span class=\"built_in\">done</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur) &#123;</span><br><span class=\"line\">\t\t\tcur-&gt;<span class=\"built_in\">dispatch</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">/* ... */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>doneWFGoTask::donetasktasksubtask_doneExecRequest::dispatchtaskExecQueue</p>\n<p>ExecSessionexecutehandle__WFGoTask::executeExecRequest::handle</p>\n<p>Executor::executor_thread_routineexecutehandle__WFGoTask::executeExecRequest::handle()</p>\n<p>go-task</p>\n<ol>\n<li><p>go-task &amp;&amp; start</p>\n</li>\n<li><p>startnewfirstgo-tasklastnullptrSeriesWork &amp;&amp; firstdispatchExecRequest::dispatch</p>\n</li>\n<li><p>executorrequestgo-taskExecQueueExecQueueExecutor::executor_thread_routine</p>\n</li>\n<li><p>Executor::executor_thread_routine<strong></strong>ExecQueue</p>\n</li>\n<li><p>__WFGoTask::execute</p>\n</li>\n<li><p>ExecRequest::handle</p>\n</li>\n<li><p>SubTask::subtask_done &amp;&amp; SeriesWorktaskdispatchPSExecRequest::dispatch</p>\n</li>\n<li><p>WFGoTask::donetask</p>\n</li>\n</ol>\n<p><strong>Executor::executor_thread_routineExecQueueexecute</strong> Executor::executor_thread_routineExecutor::requestExecutor::executor_thread_routineExecutor::executor_thread_routine</p>\n<hr>\n<p><strong></strong></p>"},{"title":"WorkFlowCommunicatorTCPServer","date":"2024-11-04T04:00:00.000Z","_content":"\n[WorkFlowGO-Task ](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\n## \n\nworkflowpollerCommunicatorpollerPSCommunicatorpollerCommunicatormpollerpollermpollermpollerpollermanagerpollerpoller_nodepoller\n\npollerpoller->callback()node->data.accept()node->data.partial_written()node->data.create_message()IOpoller->callback()pollerpoller_nodemallocfreefreepoller_node\n\n<!-- more -->\n\n\n\nTCPServerSSLUDPTCP\n\n## \n\n### \n\nCommunicatorCommConnEntry\n\n```cpp\nstruct CommConnEntry\n{\n\tstruct list_head list;          // \n\tCommConnection *conn;           // TCPServer\n\tlong long seq;                  // seq - seq\n\tint sockfd;                     // \n#define CONN_STATE_CONNECTING\t0\n#define CONN_STATE_CONNECTED\t1\n#define CONN_STATE_RECEIVING\t2\n#define CONN_STATE_SUCCESS\t\t3\n#define CONN_STATE_IDLE\t\t\t4\n#define CONN_STATE_KEEPALIVE\t5\n#define CONN_STATE_CLOSING\t\t6\n#define CONN_STATE_ERROR\t\t7\n\tint state;                      // \n\tint error;\n\tint ref;                        // \n\tstruct iovec *write_iov;        // \n\tCommSession *session;           // go-taskhanle\n\tCommTarget *target;             // \n\tCommService *service;           // \n\tmpoller_t *mpoller;\n\t/* Connection entry's mutex is for client session only. */\n\tpthread_mutex_t mutex;\n};\n```\n\nworkflowtcpudpssl\n\nserviceseq\n\nCommConnEntry::list\n\n- CommService::alive_listhttp\n\n- CommTarget::idle_listipaddr:porthttp\n\nCommServiceTarget::idle_listhttpidle_list\n\n\n\n1. tcpstate\n\n2. refCommConnEntryfree\n\n\n\n### \n\nIOIOsession->handlesessiongo-taskworkflowTCPServercommunicator\n\n\n\n======================================================\n\nCommunicator::init\n\n\n\n```cpp\nint Communicator::init(size_t poller_threads, size_t handler_threads) {\n    /* ... */\n\n\tif (this->create_poller(poller_threads) >= 0)\n\t{\n\t\tif (this->create_handler_threads(handler_threads) >= 0)\n\t\t{\n\t\t\tthis->stop_flag = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmpoller_stop(this->mpoller);\n\t\tmpoller_destroy(this->mpoller);\n\t\tmsgqueue_destroy(this->msgqueue);\n\t}\n\n\treturn -1;\n}\n```\n\n\n\n1. Communicator::initmpollerpoller->callbackpoller->contextpollerstruct poller_paramsCommunicator::create_poller\n\n    ```cpp\n    void Communicator::callback(struct poller_result *res, void *context) {\n        msgqueue_t *msgqueue = (msgqueue_t *)context;\n        msgqueue_put(res, msgqueue);\n    }\n\n    int Communicator::create_poller(size_t poller_threads) {\n        struct poller_params params = {\n            .max_open_files\t\t=\t(size_t)sysconf(_SC_OPEN_MAX),\n            .callback\t\t\t=\tCommunicator::callback,\n        };\n\n        this->msgqueue = msgqueue_create(16 * 1024, sizeof (struct poller_result));\n        if (this->msgqueue) {\n            params.context = this->msgqueue;\n            /* ... */\n        }\n\n        return -1;\n    }\n    ```\n\n    poller->callbackpoller_resultCommunicator\n\n2. Communicator::initworkflow****routineCommunicator::handler_thread_routineCommunicator::handler_thread_routine****Communicator::handler_thread_routine1\n\nCommunicator::handler_thread_routine\n\n```cpp\nvoid Communicator::handler_thread_routine(void *context) {\n\tCommunicator *comm = (Communicator *)context;\n\tstruct poller_result *res;\n\n\twhile (1) {\n\t\tres = (struct poller_result *)msgqueue_get(comm->msgqueue);\n\t\tif (!res)\n\t\t\tbreak;\n\n\t\tswitch (res->data.operation) {\n\t\tcase PD_OP_TIMER:\n\t\t\tcomm->handle_sleep_result(res);\n\t\t\tbreak;\n\t\tcase PD_OP_READ:\n\t\t\tcomm->handle_read_result(res);\n\t\t\tbreak;\n\t\tcase PD_OP_WRITE:\n\t\t\tcomm->handle_write_result(res);\n\t\t\tbreak;\n\t\tcase PD_OP_LISTEN:\n\t\t\tcomm->handle_listen_result(res);\n\t\t\tbreak;\n        /* ... */\n\t\t}\n\n\t\tfree(res);\n\t}\n\n\tif (!comm->thrdpool) {\n\t\tmpoller_destroy(comm->mpoller);\n\t\tmsgqueue_destroy(comm->msgqueue);\n\t}\n}\n```\n\nfreepollerpoller_nodemallocfreefreepoller_node\n\n**poller_node**\n\npoller_node\n\n```\n__poller_new_node { malloc } -> write(addr) -> pipe -> __poller_handle_pipe { addr = read() } -> poller->callback(addr) -> handler_thread_routine { free }\n```\n\n\npollerCommunicator\n\n![](./TCPServer_2/photo/StateTranslateThreadPool.drawio.png)\n\n### IO\n\ntcp\n\n```\n\t+-----------+\n\t|\tsocket\t|\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tbind\t|\tCommunicator\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tlisten\t|\n\t+-----------+\n\t\t|\t\t\t______________________________________________\n\t\tV\n\t+-----------+\n\t|\taccept\t|\tpoller\n\t+-----------+\n\t|\t|\t|\t|\n\tV\tV\tV\tV\n\tfd\tfd\tfd\t...\n\t\t/\\\n\tread  write\n```\n\nCommunicatormpollerapisockfdIOIOlisten fdcommunicator\n\n======================================================\n\nCommunicator::bind\n\n\n\n```cpp\nint Communicator::bind(CommService *service) {\n\tstruct poller_data data;\n\tint errno_bak = errno;\n\tint sockfd;\n\n\tsockfd = this->nonblock_listen(service);\n\tif (sockfd >= 0) {\n\t\tdata.fd = sockfd;\n\t\tdata.context = service;\n\t\t/* ... */\n\t\tdata.operation = PD_OP_LISTEN;\n\t\tdata.accept = Communicator::accept;\n\t\t// \n\t\tif (mpoller_add(&data, service->listen_timeout, this->mpoller) >= 0) {\n\t\t\terrno = errno_bak;\n\t\t\treturn 0;\n\t\t}\n\n\t\tclose(sockfd);\n\t}\n\n\treturn -1;\n}\n```\n\nlistenCommunicator::acceptpollerlistenIO socketacceptCommunicator::acceptIO socketCommServiceTarget\n\nnonblock_listen\n\n```cpp\nint Communicator::nonblock_listen(CommService *service) {\n\tint sockfd = service->create_listen_fd();\t\t\t\t// scoket()\n\tint ret;\n\n\tif (sockfd >= 0) {\n\t\tif (__set_fd_nonblock(sockfd) >= 0)\t{\t\t\t\t// \n\t\t\tif (__bind_sockaddr(sockfd, service->bind_addr,\n\t\t\t\t\t\t\t\tservice->addrlen) >= 0)\t{ \t// socketaddr\n\t\t\t\tret = listen(sockfd, SOMAXCONN);\t\t\t// \n\t\t\t\tif (ret >= 0 || errno == EOPNOTSUPP) {\n\t\t\t\t\tservice->reliable = (ret >= 0);\n\t\t\t\t\treturn sockfd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tclose(sockfd);\n\t}\n\n\treturn -1;\n}\n```\n\nCommunicator::bindtcpserver\n\n1. \n\n2. mpoller\n\n======================================================\n\nCommunicator::handle_listen_result\n\nbindpollerpolleracceptCommunicator::acceptpoller->callbackIOsocketresresCommunicatorresres->data.operationCommunicator::handle_listen_result\n\n```cpp\nvoid Communicator::handle_listen_result(struct poller_result *res) {\n\tCommService *service = (CommService *)res->data.context;\n\tstruct CommConnEntry *entry;\n\tCommServiceTarget *target;\n\tint timeout;\n\n\tswitch (res->state) {\n\tcase PR_ST_SUCCESS:\n\t\ttarget = (CommServiceTarget *)res->data.result;\t\t// Communicator::accept\n\t\tentry = Communicator::accept_conn(target, service);\n\t\tif (entry) {\n\t\t\tentry->mpoller = this->mpoller;\n\t\t\tres->data.operation = PD_OP_READ;\n\t\t\tres->data.fd = entry->sockfd;\n\t\t\tres->data.create_message = Communicator::create_request;\n\t\t\tres->data.context = entry;\n\t\t\tres->data.message = NULL;\n\t\t\ttimeout = target->response_timeout;\n\t\t\tif (mpoller_add(&res->data, timeout, this->mpoller) >= 0) {\n\t\t\t\tif (this->stop_flag)\n\t\t\t\t\tmpoller_del(res->data.fd, this->mpoller);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t__release_conn(entry);\n\t\t}\n\t\telse\n\t\t\tclose(target->sockfd);\n\n\t\ttarget->decref();\n\t\tbreak;\n\t}\n}\n```\n\nCommunicator::accept_connresIOsocketCommConnEntrystateCONN_STATE_CONNECTEDmpollerIOsocket\n\n======================================================\n\nCommunicator::create_request + Communicator::append_message\n\nCommunicator::handle_read_result\n\n\n\n### \n\n  \n\n======================================================\n\n\n\n![](./TCPServer_2/photo/ReadStatusTranslate.drawio.png)\n\npoller__poller_handle_listen\n\n1. CommServiceTarget\n\n2. IO socketfdpoller->callbackCommunicator\n\nCommunicatorCommunicator::handle_listen_result\n\n1. resoperationPD_OP_LISTENresCommunicator::handle_listen_resultres\n\n2. Communicator::handle_listen_resultentryCONN_STATE_CONNECTED\n\n3. operationREADpoller_nodedatacreate_messageCommunicator::create_request\n\n4. poller_nodempoller\n\npoller__poller_handle_read\n\n1. \n\n2. __poller_append_messagepoller_message_tmsgpoller_message_tmsg->append0msgres**poller->callback**create_messageappendCommunicator::create_requestCommunicator::append_messageentrycreate_messageentry->stateCONN_STATE_RECEIVINGCommunicator::append_messagein->append0ifentry->stateCONN_STATE_SUCCESS\n\nCommunicator::handle_read_resultCommunicator::handle_incoming_request\n\n1. resoperationPD_OP_READresCommunicator::handle_read_resultresCommunicator::handle_read_resultCommunicator::handle_incoming_request\n\n2. sessionstateCS_STATE_TOREPLY\n\n3. entry->state == CONN_STATE_SUCCESSentrytargetidleentry->ref++entry->stateCONN_STATE_IDLEsession->passive  2\n\n4. session->handleentry->ref--entry->ref0__release_connfreeentry\n\nentry\n\n```\n[CONN_STATE_CONNECTED] -> [CONN_STATE_RECEIVING] -> [CONN_STATE_SUCCESS] -> [CONN_STATE_IDLE]\n```\n\n======================================================\n\n\n\nCommunicator::reply\n\n```cpp\nint Communicator::reply(CommSession *session) {\n\tstruct CommConnEntry *entry;\n\tCommServiceTarget *target;\n\tint errno_bak;\n\tint ret;\n\n\tif (session->passive != 2) {\t// \n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\terrno_bak = errno;\n\tsession->passive = 3;\t\t\t// \n\ttarget = (CommServiceTarget *)session->target;\n\tret = this->reply_reliable(session, target);\n\n\n\tif (ret == 0) {\t\t\t\t\t// \n\t\tentry = session->in->entry;\n\t\tsession->handle(CS_STATE_SUCCESS, 0);\t// sessionhandle\n\t\tif (__sync_sub_and_fetch(&entry->ref, 1) == 0) {\n\t\t\t__release_conn(entry);\n\t\t\ttarget->decref();\n\t\t}\n\t} else if (ret < 0)\n\t\treturn -1;\n\n\terrno = errno_bak;\n\treturn 0;\n}\n\nint Communicator::reply_reliable(CommSession *session, CommTarget *target) {\n\tstruct CommConnEntry *entry;\n\tstruct list_head *pos;\n\tint ret = -1;\n\n\tpthread_mutex_lock(&target->mutex);\n\tif (!list_empty(&target->idle_list)) {\t// CONN_STATE_IDLE\n\t\tpos = target->idle_list.next;\n\t\tentry = list_entry(pos, struct CommConnEntry, list);\n\t\tlist_del(pos);\n\n\t\tsession->out = session->message_out();\n\t\tif (session->out)\n\t\t\tret = this->send_message(entry);\n\n\n\t} else\n\t\terrno = ENOENT;\n\n\tpthread_mutex_unlock(&target->mutex);\n\treturn ret;\n}\n\nint Communicator::send_message(struct CommConnEntry *entry) {\n\t/* ... */\n\tend = vectors + cnt;\n\tcnt = this->send_message_sync(vectors, cnt, entry);\t\t// \n\tif (cnt <= 0)\n\t\treturn cnt;\n\n\treturn this->send_message_async(end - cnt, cnt, entry);\t// \n}\n```\n\nMuduo[muduo10TcpConnection](https://blog.csdn.net/m0_52566365/article/details/135720278)\n\npoller__poller_handle_writetcppoller_node__poller_handle_writenode->data.partial_writtenCommunicator::send_message_asyncWRITEpoller_nodepartial_writtenCommunicator::partial_written\n\n```cpp\nint Communicator::partial_written(size_t n, void *context) {\n\tstruct CommConnEntry *entry = (struct CommConnEntry *)context;\n\tCommSession *session = entry->session;\n\tint timeout;\n\n\ttimeout = Communicator::next_timeout(session);\n\tmpoller_set_timeout(entry->sockfd, timeout, entry->mpoller);\n\treturn 0;\n}\n```\n\npartial_written\n\n__poller_handle_read**__poller_handle_writepoller_nodeepoll**poller->callbackPSpoller[WorkFlowCommunicatorTCPServer](./TcpServer_1.md)\n\nCommunicatorCommunicator::handle_write_resultCommunicator::handle_reply_result\n\n```cpp\nvoid Communicator::handle_reply_result(struct poller_result *res) {\n\tstruct CommConnEntry *entry = (struct CommConnEntry *)res->data.context;\n\tCommService *service = entry->service;\n\tCommSession *session = entry->session;\n\tCommTarget *target = entry->target;\n\tint timeout;\n\tint state;\n\n\tswitch (res->state) {\n\tcase PR_ST_FINISHED:\n\t\ttimeout = session->keep_alive_timeout();\n\t\tif (timeout != 0) {\n\t\t\t__sync_add_and_fetch(&entry->ref, 1);\t\t\t\t\t\t\t// \n\t\t\tres->data.operation = PD_OP_READ;\n\t\t\tres->data.create_message = Communicator::create_request;\n\t\t\tres->data.message = NULL;\n\t\t\tpthread_mutex_lock(&target->mutex);\n\t\t\tif (mpoller_add(&res->data, timeout, this->mpoller) >= 0) {\t\t// mpoller\n\t\t\t\tpthread_mutex_lock(&service->mutex);\n\t\t\t\tif (!this->stop_flag && service->listen_fd >= 0) {\n\t\t\t\t\tentry->state = CONN_STATE_KEEPALIVE;\t\t\t\t\t// entry->stateCONN_STATE_KEEPALIVE\n\t\t\t\t\tlist_add_tail(&entry->list, &service->alive_list);\t\t// \n\t\t\t\t} else {\n\t\t\t\t\tmpoller_del(res->data.fd, this->mpoller);\n\t\t\t\t\tentry->state = CONN_STATE_CLOSING;\n\t\t\t\t}\n\n\t\t\t\tpthread_mutex_unlock(&service->mutex);\n\t\t\t}\n\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// \n\t\t\t\t__sync_sub_and_fetch(&entry->ref, 1);\t\t\n\n\t\t\tpthread_mutex_unlock(&target->mutex);\n\t\t}\n\n\t\tif (1)\n\t\t\tstate = CS_STATE_SUCCESS;\n\n\t\tsession->handle(state, res->error);\t\t\t\t\t\t\t\t\t// session->handle\n\t\tif (__sync_sub_and_fetch(&entry->ref, 1) == 0) {\n\t\t\t__release_conn(entry);\n\t\t\t((CommServiceTarget *)target)->decref();\n\t\t}\n\n\t\tbreak;\n\t}\n}\n```\n\n\n\n1. entry->ref && poller_nodempoller && entry->stateCONN_STATE_KEEPALIVECommService\n\n2. sessionstateCS_STATE_SUCCESSsession->handle\n\n3. entry->ref\n\nCommunicator::handle_reply_resultentry->stateCONN_STATE_KEEPALIVE\n\n\n\n1. **session->passivecreate_requestmsgsession->passive1Communicator::handle_incoming_requestsession->passive2Communicator::replysession->passive3**\n\n2. Communicator::send_message_asyncpoller_nodeWRITEmpollermpoller_mod\n\n3. CommunicatorTCPServersessionHTTPServerSessionCommunicatorsessionworkflowgo-taskHTTPServerSessionHTTPCommunicator**-** - ****CommunicatorsessionCommunicator::create_requestservice->new_sessionCommunicatorgo-taskCommunicatorsessionsession delete\n\n\n\ntcpsocketfd\n\nworkflow****\n\n---\n\n****","source":"_posts/workflow/TCPServer_2.md","raw":"---\ntitle: WorkFlowCommunicatorTCPServer\ndate: 2024-11-04 12:00:00\ntags:\n  - \n---\n\n[WorkFlowGO-Task ](https://blog.csdn.net/m0_52566365/article/details/142903964)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143452443)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143493066)\n\n[WorkFlowCommunicatorTCPServer](https://blog.csdn.net/m0_52566365/article/details/143605123)\n\n## \n\nworkflowpollerCommunicatorpollerPSCommunicatorpollerCommunicatormpollerpollermpollermpollerpollermanagerpollerpoller_nodepoller\n\npollerpoller->callback()node->data.accept()node->data.partial_written()node->data.create_message()IOpoller->callback()pollerpoller_nodemallocfreefreepoller_node\n\n<!-- more -->\n\n\n\nTCPServerSSLUDPTCP\n\n## \n\n### \n\nCommunicatorCommConnEntry\n\n```cpp\nstruct CommConnEntry\n{\n\tstruct list_head list;          // \n\tCommConnection *conn;           // TCPServer\n\tlong long seq;                  // seq - seq\n\tint sockfd;                     // \n#define CONN_STATE_CONNECTING\t0\n#define CONN_STATE_CONNECTED\t1\n#define CONN_STATE_RECEIVING\t2\n#define CONN_STATE_SUCCESS\t\t3\n#define CONN_STATE_IDLE\t\t\t4\n#define CONN_STATE_KEEPALIVE\t5\n#define CONN_STATE_CLOSING\t\t6\n#define CONN_STATE_ERROR\t\t7\n\tint state;                      // \n\tint error;\n\tint ref;                        // \n\tstruct iovec *write_iov;        // \n\tCommSession *session;           // go-taskhanle\n\tCommTarget *target;             // \n\tCommService *service;           // \n\tmpoller_t *mpoller;\n\t/* Connection entry's mutex is for client session only. */\n\tpthread_mutex_t mutex;\n};\n```\n\nworkflowtcpudpssl\n\nserviceseq\n\nCommConnEntry::list\n\n- CommService::alive_listhttp\n\n- CommTarget::idle_listipaddr:porthttp\n\nCommServiceTarget::idle_listhttpidle_list\n\n\n\n1. tcpstate\n\n2. refCommConnEntryfree\n\n\n\n### \n\nIOIOsession->handlesessiongo-taskworkflowTCPServercommunicator\n\n\n\n======================================================\n\nCommunicator::init\n\n\n\n```cpp\nint Communicator::init(size_t poller_threads, size_t handler_threads) {\n    /* ... */\n\n\tif (this->create_poller(poller_threads) >= 0)\n\t{\n\t\tif (this->create_handler_threads(handler_threads) >= 0)\n\t\t{\n\t\t\tthis->stop_flag = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmpoller_stop(this->mpoller);\n\t\tmpoller_destroy(this->mpoller);\n\t\tmsgqueue_destroy(this->msgqueue);\n\t}\n\n\treturn -1;\n}\n```\n\n\n\n1. Communicator::initmpollerpoller->callbackpoller->contextpollerstruct poller_paramsCommunicator::create_poller\n\n    ```cpp\n    void Communicator::callback(struct poller_result *res, void *context) {\n        msgqueue_t *msgqueue = (msgqueue_t *)context;\n        msgqueue_put(res, msgqueue);\n    }\n\n    int Communicator::create_poller(size_t poller_threads) {\n        struct poller_params params = {\n            .max_open_files\t\t=\t(size_t)sysconf(_SC_OPEN_MAX),\n            .callback\t\t\t=\tCommunicator::callback,\n        };\n\n        this->msgqueue = msgqueue_create(16 * 1024, sizeof (struct poller_result));\n        if (this->msgqueue) {\n            params.context = this->msgqueue;\n            /* ... */\n        }\n\n        return -1;\n    }\n    ```\n\n    poller->callbackpoller_resultCommunicator\n\n2. Communicator::initworkflow****routineCommunicator::handler_thread_routineCommunicator::handler_thread_routine****Communicator::handler_thread_routine1\n\nCommunicator::handler_thread_routine\n\n```cpp\nvoid Communicator::handler_thread_routine(void *context) {\n\tCommunicator *comm = (Communicator *)context;\n\tstruct poller_result *res;\n\n\twhile (1) {\n\t\tres = (struct poller_result *)msgqueue_get(comm->msgqueue);\n\t\tif (!res)\n\t\t\tbreak;\n\n\t\tswitch (res->data.operation) {\n\t\tcase PD_OP_TIMER:\n\t\t\tcomm->handle_sleep_result(res);\n\t\t\tbreak;\n\t\tcase PD_OP_READ:\n\t\t\tcomm->handle_read_result(res);\n\t\t\tbreak;\n\t\tcase PD_OP_WRITE:\n\t\t\tcomm->handle_write_result(res);\n\t\t\tbreak;\n\t\tcase PD_OP_LISTEN:\n\t\t\tcomm->handle_listen_result(res);\n\t\t\tbreak;\n        /* ... */\n\t\t}\n\n\t\tfree(res);\n\t}\n\n\tif (!comm->thrdpool) {\n\t\tmpoller_destroy(comm->mpoller);\n\t\tmsgqueue_destroy(comm->msgqueue);\n\t}\n}\n```\n\nfreepollerpoller_nodemallocfreefreepoller_node\n\n**poller_node**\n\npoller_node\n\n```\n__poller_new_node { malloc } -> write(addr) -> pipe -> __poller_handle_pipe { addr = read() } -> poller->callback(addr) -> handler_thread_routine { free }\n```\n\n\npollerCommunicator\n\n![](./TCPServer_2/photo/StateTranslateThreadPool.drawio.png)\n\n### IO\n\ntcp\n\n```\n\t+-----------+\n\t|\tsocket\t|\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tbind\t|\tCommunicator\n\t+-----------+\n\t\t|\n\t\tV\n\t+-----------+\n\t|\tlisten\t|\n\t+-----------+\n\t\t|\t\t\t______________________________________________\n\t\tV\n\t+-----------+\n\t|\taccept\t|\tpoller\n\t+-----------+\n\t|\t|\t|\t|\n\tV\tV\tV\tV\n\tfd\tfd\tfd\t...\n\t\t/\\\n\tread  write\n```\n\nCommunicatormpollerapisockfdIOIOlisten fdcommunicator\n\n======================================================\n\nCommunicator::bind\n\n\n\n```cpp\nint Communicator::bind(CommService *service) {\n\tstruct poller_data data;\n\tint errno_bak = errno;\n\tint sockfd;\n\n\tsockfd = this->nonblock_listen(service);\n\tif (sockfd >= 0) {\n\t\tdata.fd = sockfd;\n\t\tdata.context = service;\n\t\t/* ... */\n\t\tdata.operation = PD_OP_LISTEN;\n\t\tdata.accept = Communicator::accept;\n\t\t// \n\t\tif (mpoller_add(&data, service->listen_timeout, this->mpoller) >= 0) {\n\t\t\terrno = errno_bak;\n\t\t\treturn 0;\n\t\t}\n\n\t\tclose(sockfd);\n\t}\n\n\treturn -1;\n}\n```\n\nlistenCommunicator::acceptpollerlistenIO socketacceptCommunicator::acceptIO socketCommServiceTarget\n\nnonblock_listen\n\n```cpp\nint Communicator::nonblock_listen(CommService *service) {\n\tint sockfd = service->create_listen_fd();\t\t\t\t// scoket()\n\tint ret;\n\n\tif (sockfd >= 0) {\n\t\tif (__set_fd_nonblock(sockfd) >= 0)\t{\t\t\t\t// \n\t\t\tif (__bind_sockaddr(sockfd, service->bind_addr,\n\t\t\t\t\t\t\t\tservice->addrlen) >= 0)\t{ \t// socketaddr\n\t\t\t\tret = listen(sockfd, SOMAXCONN);\t\t\t// \n\t\t\t\tif (ret >= 0 || errno == EOPNOTSUPP) {\n\t\t\t\t\tservice->reliable = (ret >= 0);\n\t\t\t\t\treturn sockfd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tclose(sockfd);\n\t}\n\n\treturn -1;\n}\n```\n\nCommunicator::bindtcpserver\n\n1. \n\n2. mpoller\n\n======================================================\n\nCommunicator::handle_listen_result\n\nbindpollerpolleracceptCommunicator::acceptpoller->callbackIOsocketresresCommunicatorresres->data.operationCommunicator::handle_listen_result\n\n```cpp\nvoid Communicator::handle_listen_result(struct poller_result *res) {\n\tCommService *service = (CommService *)res->data.context;\n\tstruct CommConnEntry *entry;\n\tCommServiceTarget *target;\n\tint timeout;\n\n\tswitch (res->state) {\n\tcase PR_ST_SUCCESS:\n\t\ttarget = (CommServiceTarget *)res->data.result;\t\t// Communicator::accept\n\t\tentry = Communicator::accept_conn(target, service);\n\t\tif (entry) {\n\t\t\tentry->mpoller = this->mpoller;\n\t\t\tres->data.operation = PD_OP_READ;\n\t\t\tres->data.fd = entry->sockfd;\n\t\t\tres->data.create_message = Communicator::create_request;\n\t\t\tres->data.context = entry;\n\t\t\tres->data.message = NULL;\n\t\t\ttimeout = target->response_timeout;\n\t\t\tif (mpoller_add(&res->data, timeout, this->mpoller) >= 0) {\n\t\t\t\tif (this->stop_flag)\n\t\t\t\t\tmpoller_del(res->data.fd, this->mpoller);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t__release_conn(entry);\n\t\t}\n\t\telse\n\t\t\tclose(target->sockfd);\n\n\t\ttarget->decref();\n\t\tbreak;\n\t}\n}\n```\n\nCommunicator::accept_connresIOsocketCommConnEntrystateCONN_STATE_CONNECTEDmpollerIOsocket\n\n======================================================\n\nCommunicator::create_request + Communicator::append_message\n\nCommunicator::handle_read_result\n\n\n\n### \n\n  \n\n======================================================\n\n\n\n![](./TCPServer_2/photo/ReadStatusTranslate.drawio.png)\n\npoller__poller_handle_listen\n\n1. CommServiceTarget\n\n2. IO socketfdpoller->callbackCommunicator\n\nCommunicatorCommunicator::handle_listen_result\n\n1. resoperationPD_OP_LISTENresCommunicator::handle_listen_resultres\n\n2. Communicator::handle_listen_resultentryCONN_STATE_CONNECTED\n\n3. operationREADpoller_nodedatacreate_messageCommunicator::create_request\n\n4. poller_nodempoller\n\npoller__poller_handle_read\n\n1. \n\n2. __poller_append_messagepoller_message_tmsgpoller_message_tmsg->append0msgres**poller->callback**create_messageappendCommunicator::create_requestCommunicator::append_messageentrycreate_messageentry->stateCONN_STATE_RECEIVINGCommunicator::append_messagein->append0ifentry->stateCONN_STATE_SUCCESS\n\nCommunicator::handle_read_resultCommunicator::handle_incoming_request\n\n1. resoperationPD_OP_READresCommunicator::handle_read_resultresCommunicator::handle_read_resultCommunicator::handle_incoming_request\n\n2. sessionstateCS_STATE_TOREPLY\n\n3. entry->state == CONN_STATE_SUCCESSentrytargetidleentry->ref++entry->stateCONN_STATE_IDLEsession->passive  2\n\n4. session->handleentry->ref--entry->ref0__release_connfreeentry\n\nentry\n\n```\n[CONN_STATE_CONNECTED] -> [CONN_STATE_RECEIVING] -> [CONN_STATE_SUCCESS] -> [CONN_STATE_IDLE]\n```\n\n======================================================\n\n\n\nCommunicator::reply\n\n```cpp\nint Communicator::reply(CommSession *session) {\n\tstruct CommConnEntry *entry;\n\tCommServiceTarget *target;\n\tint errno_bak;\n\tint ret;\n\n\tif (session->passive != 2) {\t// \n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\terrno_bak = errno;\n\tsession->passive = 3;\t\t\t// \n\ttarget = (CommServiceTarget *)session->target;\n\tret = this->reply_reliable(session, target);\n\n\n\tif (ret == 0) {\t\t\t\t\t// \n\t\tentry = session->in->entry;\n\t\tsession->handle(CS_STATE_SUCCESS, 0);\t// sessionhandle\n\t\tif (__sync_sub_and_fetch(&entry->ref, 1) == 0) {\n\t\t\t__release_conn(entry);\n\t\t\ttarget->decref();\n\t\t}\n\t} else if (ret < 0)\n\t\treturn -1;\n\n\terrno = errno_bak;\n\treturn 0;\n}\n\nint Communicator::reply_reliable(CommSession *session, CommTarget *target) {\n\tstruct CommConnEntry *entry;\n\tstruct list_head *pos;\n\tint ret = -1;\n\n\tpthread_mutex_lock(&target->mutex);\n\tif (!list_empty(&target->idle_list)) {\t// CONN_STATE_IDLE\n\t\tpos = target->idle_list.next;\n\t\tentry = list_entry(pos, struct CommConnEntry, list);\n\t\tlist_del(pos);\n\n\t\tsession->out = session->message_out();\n\t\tif (session->out)\n\t\t\tret = this->send_message(entry);\n\n\n\t} else\n\t\terrno = ENOENT;\n\n\tpthread_mutex_unlock(&target->mutex);\n\treturn ret;\n}\n\nint Communicator::send_message(struct CommConnEntry *entry) {\n\t/* ... */\n\tend = vectors + cnt;\n\tcnt = this->send_message_sync(vectors, cnt, entry);\t\t// \n\tif (cnt <= 0)\n\t\treturn cnt;\n\n\treturn this->send_message_async(end - cnt, cnt, entry);\t// \n}\n```\n\nMuduo[muduo10TcpConnection](https://blog.csdn.net/m0_52566365/article/details/135720278)\n\npoller__poller_handle_writetcppoller_node__poller_handle_writenode->data.partial_writtenCommunicator::send_message_asyncWRITEpoller_nodepartial_writtenCommunicator::partial_written\n\n```cpp\nint Communicator::partial_written(size_t n, void *context) {\n\tstruct CommConnEntry *entry = (struct CommConnEntry *)context;\n\tCommSession *session = entry->session;\n\tint timeout;\n\n\ttimeout = Communicator::next_timeout(session);\n\tmpoller_set_timeout(entry->sockfd, timeout, entry->mpoller);\n\treturn 0;\n}\n```\n\npartial_written\n\n__poller_handle_read**__poller_handle_writepoller_nodeepoll**poller->callbackPSpoller[WorkFlowCommunicatorTCPServer](./TcpServer_1.md)\n\nCommunicatorCommunicator::handle_write_resultCommunicator::handle_reply_result\n\n```cpp\nvoid Communicator::handle_reply_result(struct poller_result *res) {\n\tstruct CommConnEntry *entry = (struct CommConnEntry *)res->data.context;\n\tCommService *service = entry->service;\n\tCommSession *session = entry->session;\n\tCommTarget *target = entry->target;\n\tint timeout;\n\tint state;\n\n\tswitch (res->state) {\n\tcase PR_ST_FINISHED:\n\t\ttimeout = session->keep_alive_timeout();\n\t\tif (timeout != 0) {\n\t\t\t__sync_add_and_fetch(&entry->ref, 1);\t\t\t\t\t\t\t// \n\t\t\tres->data.operation = PD_OP_READ;\n\t\t\tres->data.create_message = Communicator::create_request;\n\t\t\tres->data.message = NULL;\n\t\t\tpthread_mutex_lock(&target->mutex);\n\t\t\tif (mpoller_add(&res->data, timeout, this->mpoller) >= 0) {\t\t// mpoller\n\t\t\t\tpthread_mutex_lock(&service->mutex);\n\t\t\t\tif (!this->stop_flag && service->listen_fd >= 0) {\n\t\t\t\t\tentry->state = CONN_STATE_KEEPALIVE;\t\t\t\t\t// entry->stateCONN_STATE_KEEPALIVE\n\t\t\t\t\tlist_add_tail(&entry->list, &service->alive_list);\t\t// \n\t\t\t\t} else {\n\t\t\t\t\tmpoller_del(res->data.fd, this->mpoller);\n\t\t\t\t\tentry->state = CONN_STATE_CLOSING;\n\t\t\t\t}\n\n\t\t\t\tpthread_mutex_unlock(&service->mutex);\n\t\t\t}\n\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// \n\t\t\t\t__sync_sub_and_fetch(&entry->ref, 1);\t\t\n\n\t\t\tpthread_mutex_unlock(&target->mutex);\n\t\t}\n\n\t\tif (1)\n\t\t\tstate = CS_STATE_SUCCESS;\n\n\t\tsession->handle(state, res->error);\t\t\t\t\t\t\t\t\t// session->handle\n\t\tif (__sync_sub_and_fetch(&entry->ref, 1) == 0) {\n\t\t\t__release_conn(entry);\n\t\t\t((CommServiceTarget *)target)->decref();\n\t\t}\n\n\t\tbreak;\n\t}\n}\n```\n\n\n\n1. entry->ref && poller_nodempoller && entry->stateCONN_STATE_KEEPALIVECommService\n\n2. sessionstateCS_STATE_SUCCESSsession->handle\n\n3. entry->ref\n\nCommunicator::handle_reply_resultentry->stateCONN_STATE_KEEPALIVE\n\n\n\n1. **session->passivecreate_requestmsgsession->passive1Communicator::handle_incoming_requestsession->passive2Communicator::replysession->passive3**\n\n2. Communicator::send_message_asyncpoller_nodeWRITEmpollermpoller_mod\n\n3. CommunicatorTCPServersessionHTTPServerSessionCommunicatorsessionworkflowgo-taskHTTPServerSessionHTTPCommunicator**-** - ****CommunicatorsessionCommunicator::create_requestservice->new_sessionCommunicatorgo-taskCommunicatorsessionsession delete\n\n\n\ntcpsocketfd\n\nworkflow****\n\n---\n\n****","slug":"workflow/TCPServer_2","published":1,"updated":"2025-09-28T14:38:07.199Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9t0010q8ws2bl6bydm","content":"<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlowGO-Task </a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlowCommunicatorTCPServer</a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>workflowpollerCommunicatorpollerPSCommunicatorpollerCommunicatormpollerpollermpollermpollerpollermanagerpollerpoller_nodepoller</p>\n<p>pollerpoller-&gt;callback()node-&gt;data.accept()node-&gt;data.partial_written()node-&gt;data.create_message()IOpoller-&gt;callback()pollerpoller_nodemallocfreefreepoller_node</p>\n<span id=\"more\"></span>\n\n<p></p>\n<p>TCPServerSSLUDPTCP</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>CommunicatorCommConnEntry</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> list;          <span class=\"comment\">// </span></span><br><span class=\"line\">\tCommConnection *conn;           <span class=\"comment\">// TCPServer</span></span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> seq;                  <span class=\"comment\">// seq - seq</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> sockfd;                     <span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_CONNECTING\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_CONNECTED\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_RECEIVING\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_SUCCESS\t\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_IDLE\t\t\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_KEEPALIVE\t5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_CLOSING\t\t6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_ERROR\t\t7</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> state;                      <span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"type\">int</span> error;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ref;                        <span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> *write_iov;        <span class=\"comment\">// </span></span><br><span class=\"line\">\tCommSession *session;           <span class=\"comment\">// go-taskhanle</span></span><br><span class=\"line\">\tCommTarget *target;             <span class=\"comment\">// </span></span><br><span class=\"line\">\tCommService *service;           <span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"type\">mpoller_t</span> *mpoller;</span><br><span class=\"line\">\t<span class=\"comment\">/* Connection entry&#x27;s mutex is for client session only. */</span></span><br><span class=\"line\">\t<span class=\"type\">pthread_mutex_t</span> mutex;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>workflowtcpudpssl</p>\n<p>serviceseq</p>\n<p>CommConnEntry::list</p>\n<ul>\n<li><p>CommService::alive_listhttp</p>\n</li>\n<li><p>CommTarget::idle_listipaddr:porthttp</p>\n</li>\n</ul>\n<p>CommServiceTarget::idle_listhttpidle_list</p>\n<p></p>\n<ol>\n<li><p>tcpstate</p>\n</li>\n<li><p>refCommConnEntryfree</p>\n</li>\n</ol>\n<p></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>IOIOsession-&gt;handlesessiongo-taskworkflowTCPServercommunicator</p>\n<p></p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>Communicator::init</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::init</span><span class=\"params\">(<span class=\"type\">size_t</span> poller_threads, <span class=\"type\">size_t</span> handler_threads)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">create_poller</span>(poller_threads) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">create_handler_threads</span>(handler_threads) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;stop_flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">mpoller_stop</span>(<span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t<span class=\"built_in\">mpoller_destroy</span>(<span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t<span class=\"built_in\">msgqueue_destroy</span>(<span class=\"keyword\">this</span>-&gt;msgqueue);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<ol>\n<li><p>Communicator::initmpollerpoller-&gt;callbackpoller-&gt;contextpollerstruct poller_paramsCommunicator::create_poller</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::callback</span><span class=\"params\">(<span class=\"keyword\">struct</span> poller_result *res, <span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">msgqueue_t</span> *msgqueue = (<span class=\"type\">msgqueue_t</span> *)context;</span><br><span class=\"line\">    <span class=\"built_in\">msgqueue_put</span>(res, msgqueue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::create_poller</span><span class=\"params\">(<span class=\"type\">size_t</span> poller_threads)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">poller_params</span> params = &#123;</span><br><span class=\"line\">        .max_open_files\t\t=\t(<span class=\"type\">size_t</span>)<span class=\"built_in\">sysconf</span>(_SC_OPEN_MAX),</span><br><span class=\"line\">        .callback\t\t\t=\tCommunicator::callback,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;msgqueue = <span class=\"built_in\">msgqueue_create</span>(<span class=\"number\">16</span> * <span class=\"number\">1024</span>, <span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> poller_result));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;msgqueue) &#123;</span><br><span class=\"line\">        params.context = <span class=\"keyword\">this</span>-&gt;msgqueue;</span><br><span class=\"line\">        <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> poller-&gt;callbackpoller_resultCommunicator</p>\n</li>\n<li><p>Communicator::initworkflow<strong></strong>routineCommunicator::handler_thread_routineCommunicator::handler_thread_routine<strong></strong>Communicator::handler_thread_routine1</p>\n</li>\n</ol>\n<p>Communicator::handler_thread_routine</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::handler_thread_routine</span><span class=\"params\">(<span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">\tCommunicator *comm = (Communicator *)context;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_result</span> *res;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tres = (<span class=\"keyword\">struct</span> poller_result *)<span class=\"built_in\">msgqueue_get</span>(comm-&gt;msgqueue);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!res)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (res-&gt;data.operation) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_TIMER:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_sleep_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_READ:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_read_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_WRITE:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_write_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_LISTEN:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_listen_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(res);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!comm-&gt;thrdpool) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">mpoller_destroy</span>(comm-&gt;mpoller);</span><br><span class=\"line\">\t\t<span class=\"built_in\">msgqueue_destroy</span>(comm-&gt;msgqueue);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>freepollerpoller_nodemallocfreefreepoller_node</p>\n<p><strong>poller_node</strong></p>\n<p>poller_node</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__poller_new_node &#123; malloc &#125; -&gt; write(addr) -&gt; pipe -&gt; __poller_handle_pipe &#123; addr = read() &#125; -&gt; poller-&gt;callback(addr) -&gt; handler_thread_routine &#123; free &#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>pollerCommunicator</p>\n<p><img src=\"/2024/11/04/workflow/TCPServer_2/photo/StateTranslateThreadPool.drawio.png\"></p>\n<h3 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h3><p>tcp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tsocket\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tbind\t|\tCommunicator</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tlisten\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|\t\t\t______________________________________________</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\taccept\t|\tpoller</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\t|\t|\t|</span><br><span class=\"line\">V\tV\tV\tV</span><br><span class=\"line\">fd\tfd\tfd\t...</span><br><span class=\"line\">\t/\\</span><br><span class=\"line\">read  write</span><br></pre></td></tr></table></figure>\n\n<p>CommunicatormpollerapisockfdIOIOlisten fdcommunicator</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>Communicator::bind</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::bind</span><span class=\"params\">(CommService *service)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span> data;</span><br><span class=\"line\">\t<span class=\"type\">int</span> errno_bak = errno;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sockfd;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsockfd = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">nonblock_listen</span>(service);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sockfd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tdata.fd = sockfd;</span><br><span class=\"line\">\t\tdata.context = service;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t\tdata.operation = PD_OP_LISTEN;</span><br><span class=\"line\">\t\tdata.accept = Communicator::accept;</span><br><span class=\"line\">\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">mpoller_add</span>(&amp;data, service-&gt;listen_timeout, <span class=\"keyword\">this</span>-&gt;mpoller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\terrno = errno_bak;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>listenCommunicator::acceptpollerlistenIO socketacceptCommunicator::acceptIO socketCommServiceTarget</p>\n<p>nonblock_listen</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::nonblock_listen</span><span class=\"params\">(CommService *service)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sockfd = service-&gt;<span class=\"built_in\">create_listen_fd</span>();\t\t\t\t<span class=\"comment\">// scoket()</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sockfd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (__set_fd_nonblock(sockfd) &gt;= <span class=\"number\">0</span>)\t&#123;\t\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (__bind_sockaddr(sockfd, service-&gt;bind_addr,</span><br><span class=\"line\">\t\t\t\t\t\t\t\tservice-&gt;addrlen) &gt;= <span class=\"number\">0</span>)\t&#123; \t<span class=\"comment\">// socketaddr</span></span><br><span class=\"line\">\t\t\t\tret = <span class=\"built_in\">listen</span>(sockfd, SOMAXCONN);\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (ret &gt;= <span class=\"number\">0</span> || errno == EOPNOTSUPP) &#123;</span><br><span class=\"line\">\t\t\t\t\tservice-&gt;reliable = (ret &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> sockfd;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Communicator::bindtcpserver</p>\n<ol>\n<li><p></p>\n</li>\n<li><p>mpoller</p>\n</li>\n</ol>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>Communicator::handle_listen_result</p>\n<p>bindpollerpolleracceptCommunicator::acceptpoller-&gt;callbackIOsocketresresCommunicatorresres-&gt;data.operationCommunicator::handle_listen_result</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::handle_listen_result</span><span class=\"params\">(<span class=\"keyword\">struct</span> poller_result *res)</span> </span>&#123;</span><br><span class=\"line\">\tCommService *service = (CommService *)res-&gt;data.context;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry;</span><br><span class=\"line\">\tCommServiceTarget *target;</span><br><span class=\"line\">\t<span class=\"type\">int</span> timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (res-&gt;state) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> PR_ST_SUCCESS:</span><br><span class=\"line\">\t\ttarget = (CommServiceTarget *)res-&gt;data.result;\t\t<span class=\"comment\">// Communicator::accept</span></span><br><span class=\"line\">\t\tentry = Communicator::<span class=\"built_in\">accept_conn</span>(target, service);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (entry) &#123;</span><br><span class=\"line\">\t\t\tentry-&gt;mpoller = <span class=\"keyword\">this</span>-&gt;mpoller;</span><br><span class=\"line\">\t\t\tres-&gt;data.operation = PD_OP_READ;</span><br><span class=\"line\">\t\t\tres-&gt;data.fd = entry-&gt;sockfd;</span><br><span class=\"line\">\t\t\tres-&gt;data.create_message = Communicator::create_request;</span><br><span class=\"line\">\t\t\tres-&gt;data.context = entry;</span><br><span class=\"line\">\t\t\tres-&gt;data.message = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\ttimeout = target-&gt;response_timeout;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">mpoller_add</span>(&amp;res-&gt;data, timeout, <span class=\"keyword\">this</span>-&gt;mpoller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;stop_flag)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">mpoller_del</span>(res-&gt;data.fd, <span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t__release_conn(entry);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(target-&gt;sockfd);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttarget-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Communicator::accept_connresIOsocketCommConnEntrystateCONN_STATE_CONNECTEDmpollerIOsocket</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>Communicator::create_request + Communicator::append_message</p>\n<p>Communicator::handle_read_result</p>\n<p></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>  </p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p></p>\n<p><img src=\"/2024/11/04/workflow/TCPServer_2/photo/ReadStatusTranslate.drawio.png\"></p>\n<p>poller__poller_handle_listen</p>\n<ol>\n<li><p>CommServiceTarget</p>\n</li>\n<li><p>IO socketfdpoller-&gt;callbackCommunicator</p>\n</li>\n</ol>\n<p>CommunicatorCommunicator::handle_listen_result</p>\n<ol>\n<li><p>resoperationPD_OP_LISTENresCommunicator::handle_listen_resultres</p>\n</li>\n<li><p>Communicator::handle_listen_resultentryCONN_STATE_CONNECTED</p>\n</li>\n<li><p>operationREADpoller_nodedatacreate_messageCommunicator::create_request</p>\n</li>\n<li><p>poller_nodempoller</p>\n</li>\n</ol>\n<p>poller__poller_handle_read</p>\n<ol>\n<li><p></p>\n</li>\n<li><p>__poller_append_messagepoller_message_tmsgpoller_message_tmsg-&gt;append0msgres<strong>poller-&gt;callback</strong>create_messageappendCommunicator::create_requestCommunicator::append_messageentrycreate_messageentry-&gt;stateCONN_STATE_RECEIVINGCommunicator::append_messagein-&gt;append0ifentry-&gt;stateCONN_STATE_SUCCESS</p>\n</li>\n</ol>\n<p>Communicator::handle_read_resultCommunicator::handle_incoming_request</p>\n<ol>\n<li><p>resoperationPD_OP_READresCommunicator::handle_read_resultresCommunicator::handle_read_resultCommunicator::handle_incoming_request</p>\n</li>\n<li><p>sessionstateCS_STATE_TOREPLY</p>\n</li>\n<li><p>entry-&gt;state &#x3D;&#x3D; CONN_STATE_SUCCESSentrytargetidleentry-&gt;ref++entry-&gt;stateCONN_STATE_IDLEsession-&gt;passive  2</p>\n</li>\n<li><p>session-&gt;handleentry-&gt;refentry-&gt;ref0__release_connfreeentry</p>\n</li>\n</ol>\n<p>entry</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[CONN_STATE_CONNECTED] -&gt; [CONN_STATE_RECEIVING] -&gt; [CONN_STATE_SUCCESS] -&gt; [CONN_STATE_IDLE]</span><br></pre></td></tr></table></figure>\n\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p></p>\n<p>Communicator::reply</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::reply</span><span class=\"params\">(CommSession *session)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry;</span><br><span class=\"line\">\tCommServiceTarget *target;</span><br><span class=\"line\">\t<span class=\"type\">int</span> errno_bak;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (session-&gt;passive != <span class=\"number\">2</span>) &#123;\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\terrno = EINVAL;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\terrno_bak = errno;</span><br><span class=\"line\">\tsession-&gt;passive = <span class=\"number\">3</span>;\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\ttarget = (CommServiceTarget *)session-&gt;target;</span><br><span class=\"line\">\tret = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">reply_reliable</span>(session, target);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>) &#123;\t\t\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\tentry = session-&gt;in-&gt;entry;</span><br><span class=\"line\">\t\tsession-&gt;<span class=\"built_in\">handle</span>(CS_STATE_SUCCESS, <span class=\"number\">0</span>);\t<span class=\"comment\">// sessionhandle</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (__sync_sub_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t__release_conn(entry);</span><br><span class=\"line\">\t\t\ttarget-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\terrno = errno_bak;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::reply_reliable</span><span class=\"params\">(CommSession *session, CommTarget *target)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> *pos;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!<span class=\"built_in\">list_empty</span>(&amp;target-&gt;idle_list)) &#123;\t<span class=\"comment\">// CONN_STATE_IDLE</span></span><br><span class=\"line\">\t\tpos = target-&gt;idle_list.next;</span><br><span class=\"line\">\t\tentry = <span class=\"built_in\">list_entry</span>(pos, <span class=\"keyword\">struct</span> CommConnEntry, list);</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_del</span>(pos);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsession-&gt;out = session-&gt;<span class=\"built_in\">message_out</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (session-&gt;out)</span><br><span class=\"line\">\t\t\tret = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">send_message</span>(entry);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\terrno = ENOENT;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::send_message</span><span class=\"params\">(<span class=\"keyword\">struct</span> CommConnEntry *entry)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\tend = vectors + cnt;</span><br><span class=\"line\">\tcnt = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">send_message_sync</span>(vectors, cnt, entry);\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">send_message_async</span>(end - cnt, cnt, entry);\t<span class=\"comment\">// </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Muduo<a href=\"https://blog.csdn.net/m0_52566365/article/details/135720278\">muduo10TcpConnection</a></p>\n<p>poller__poller_handle_writetcppoller_node__poller_handle_writenode-&gt;data.partial_writtenCommunicator::send_message_asyncWRITEpoller_nodepartial_writtenCommunicator::partial_written</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::partial_written</span><span class=\"params\">(<span class=\"type\">size_t</span> n, <span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry = (<span class=\"keyword\">struct</span> CommConnEntry *)context;</span><br><span class=\"line\">\tCommSession *session = entry-&gt;session;</span><br><span class=\"line\">\t<span class=\"type\">int</span> timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttimeout = Communicator::<span class=\"built_in\">next_timeout</span>(session);</span><br><span class=\"line\">\t<span class=\"built_in\">mpoller_set_timeout</span>(entry-&gt;sockfd, timeout, entry-&gt;mpoller);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>partial_written</p>\n<p>__poller_handle_read**__poller_handle_writepoller_nodeepoll**poller-&gt;callbackPSpoller<a href=\"./TcpServer_1.md\">WorkFlowCommunicatorTCPServer</a></p>\n<p>CommunicatorCommunicator::handle_write_resultCommunicator::handle_reply_result</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::handle_reply_result</span><span class=\"params\">(<span class=\"keyword\">struct</span> poller_result *res)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry = (<span class=\"keyword\">struct</span> CommConnEntry *)res-&gt;data.context;</span><br><span class=\"line\">\tCommService *service = entry-&gt;service;</span><br><span class=\"line\">\tCommSession *session = entry-&gt;session;</span><br><span class=\"line\">\tCommTarget *target = entry-&gt;target;</span><br><span class=\"line\">\t<span class=\"type\">int</span> timeout;</span><br><span class=\"line\">\t<span class=\"type\">int</span> state;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (res-&gt;state) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> PR_ST_FINISHED:</span><br><span class=\"line\">\t\ttimeout = session-&gt;<span class=\"built_in\">keep_alive_timeout</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (timeout != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t__sync_add_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>);\t\t\t\t\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\tres-&gt;data.operation = PD_OP_READ;</span><br><span class=\"line\">\t\t\tres-&gt;data.create_message = Communicator::create_request;</span><br><span class=\"line\">\t\t\tres-&gt;data.message = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">mpoller_add</span>(&amp;res-&gt;data, timeout, <span class=\"keyword\">this</span>-&gt;mpoller) &gt;= <span class=\"number\">0</span>) &#123;\t\t<span class=\"comment\">// mpoller</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;service-&gt;mutex);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>-&gt;stop_flag &amp;&amp; service-&gt;listen_fd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tentry-&gt;state = CONN_STATE_KEEPALIVE;\t\t\t\t\t<span class=\"comment\">// entry-&gt;stateCONN_STATE_KEEPALIVE</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">list_add_tail</span>(&amp;entry-&gt;list, &amp;service-&gt;alive_list);\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">mpoller_del</span>(res-&gt;data.fd, <span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t\t\t\tentry-&gt;state = CONN_STATE_CLOSING;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;service-&gt;mutex);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\t\t__sync_sub_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>);\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tstate = CS_STATE_SUCCESS;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsession-&gt;<span class=\"built_in\">handle</span>(state, res-&gt;error);\t\t\t\t\t\t\t\t\t<span class=\"comment\">// session-&gt;handle</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (__sync_sub_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t__release_conn(entry);</span><br><span class=\"line\">\t\t\t((CommServiceTarget *)target)-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<ol>\n<li><p>entry-&gt;ref &amp;&amp; poller_nodempoller &amp;&amp; entry-&gt;stateCONN_STATE_KEEPALIVECommService</p>\n</li>\n<li><p>sessionstateCS_STATE_SUCCESSsession-&gt;handle</p>\n</li>\n<li><p>entry-&gt;ref</p>\n</li>\n</ol>\n<p>Communicator::handle_reply_resultentry-&gt;stateCONN_STATE_KEEPALIVE</p>\n<p></p>\n<ol>\n<li><p><strong>session-&gt;passivecreate_requestmsgsession-&gt;passive1Communicator::handle_incoming_requestsession-&gt;passive2Communicator::replysession-&gt;passive3</strong></p>\n</li>\n<li><p>Communicator::send_message_asyncpoller_nodeWRITEmpollermpoller_mod</p>\n</li>\n<li><p>CommunicatorTCPServersessionHTTPServerSessionCommunicatorsessionworkflowgo-taskHTTPServerSessionHTTPCommunicator<strong>-</strong> - <strong></strong>CommunicatorsessionCommunicator::create_requestservice-&gt;new_sessionCommunicatorgo-taskCommunicatorsessionsession delete</p>\n</li>\n</ol>\n<p></p>\n<p>tcpsocketfd</p>\n<p>workflow<strong></strong></p>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/142903964\">WorkFlowGO-Task </a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143452443\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143493066\">WorkFlowCommunicatorTCPServer</a></p>\n<p><a href=\"https://blog.csdn.net/m0_52566365/article/details/143605123\">WorkFlowCommunicatorTCPServer</a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>workflowpollerCommunicatorpollerPSCommunicatorpollerCommunicatormpollerpollermpollermpollerpollermanagerpollerpoller_nodepoller</p>\n<p>pollerpoller-&gt;callback()node-&gt;data.accept()node-&gt;data.partial_written()node-&gt;data.create_message()IOpoller-&gt;callback()pollerpoller_nodemallocfreefreepoller_node</p>","more":"<p></p>\n<p>TCPServerSSLUDPTCP</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>CommunicatorCommConnEntry</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> list;          <span class=\"comment\">// </span></span><br><span class=\"line\">\tCommConnection *conn;           <span class=\"comment\">// TCPServer</span></span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> seq;                  <span class=\"comment\">// seq - seq</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> sockfd;                     <span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_CONNECTING\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_CONNECTED\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_RECEIVING\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_SUCCESS\t\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_IDLE\t\t\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_KEEPALIVE\t5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_CLOSING\t\t6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONN_STATE_ERROR\t\t7</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> state;                      <span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"type\">int</span> error;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ref;                        <span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">iovec</span> *write_iov;        <span class=\"comment\">// </span></span><br><span class=\"line\">\tCommSession *session;           <span class=\"comment\">// go-taskhanle</span></span><br><span class=\"line\">\tCommTarget *target;             <span class=\"comment\">// </span></span><br><span class=\"line\">\tCommService *service;           <span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"type\">mpoller_t</span> *mpoller;</span><br><span class=\"line\">\t<span class=\"comment\">/* Connection entry&#x27;s mutex is for client session only. */</span></span><br><span class=\"line\">\t<span class=\"type\">pthread_mutex_t</span> mutex;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>workflowtcpudpssl</p>\n<p>serviceseq</p>\n<p>CommConnEntry::list</p>\n<ul>\n<li><p>CommService::alive_listhttp</p>\n</li>\n<li><p>CommTarget::idle_listipaddr:porthttp</p>\n</li>\n</ul>\n<p>CommServiceTarget::idle_listhttpidle_list</p>\n<p></p>\n<ol>\n<li><p>tcpstate</p>\n</li>\n<li><p>refCommConnEntryfree</p>\n</li>\n</ol>\n<p></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>IOIOsession-&gt;handlesessiongo-taskworkflowTCPServercommunicator</p>\n<p></p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>Communicator::init</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::init</span><span class=\"params\">(<span class=\"type\">size_t</span> poller_threads, <span class=\"type\">size_t</span> handler_threads)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">create_poller</span>(poller_threads) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">create_handler_threads</span>(handler_threads) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;stop_flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">mpoller_stop</span>(<span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t<span class=\"built_in\">mpoller_destroy</span>(<span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t<span class=\"built_in\">msgqueue_destroy</span>(<span class=\"keyword\">this</span>-&gt;msgqueue);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<ol>\n<li><p>Communicator::initmpollerpoller-&gt;callbackpoller-&gt;contextpollerstruct poller_paramsCommunicator::create_poller</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::callback</span><span class=\"params\">(<span class=\"keyword\">struct</span> poller_result *res, <span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">msgqueue_t</span> *msgqueue = (<span class=\"type\">msgqueue_t</span> *)context;</span><br><span class=\"line\">    <span class=\"built_in\">msgqueue_put</span>(res, msgqueue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::create_poller</span><span class=\"params\">(<span class=\"type\">size_t</span> poller_threads)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">poller_params</span> params = &#123;</span><br><span class=\"line\">        .max_open_files\t\t=\t(<span class=\"type\">size_t</span>)<span class=\"built_in\">sysconf</span>(_SC_OPEN_MAX),</span><br><span class=\"line\">        .callback\t\t\t=\tCommunicator::callback,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;msgqueue = <span class=\"built_in\">msgqueue_create</span>(<span class=\"number\">16</span> * <span class=\"number\">1024</span>, <span class=\"built_in\">sizeof</span> (<span class=\"keyword\">struct</span> poller_result));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;msgqueue) &#123;</span><br><span class=\"line\">        params.context = <span class=\"keyword\">this</span>-&gt;msgqueue;</span><br><span class=\"line\">        <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> poller-&gt;callbackpoller_resultCommunicator</p>\n</li>\n<li><p>Communicator::initworkflow<strong></strong>routineCommunicator::handler_thread_routineCommunicator::handler_thread_routine<strong></strong>Communicator::handler_thread_routine1</p>\n</li>\n</ol>\n<p>Communicator::handler_thread_routine</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::handler_thread_routine</span><span class=\"params\">(<span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">\tCommunicator *comm = (Communicator *)context;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_result</span> *res;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tres = (<span class=\"keyword\">struct</span> poller_result *)<span class=\"built_in\">msgqueue_get</span>(comm-&gt;msgqueue);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!res)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (res-&gt;data.operation) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_TIMER:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_sleep_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_READ:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_read_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_WRITE:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_write_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> PD_OP_LISTEN:</span><br><span class=\"line\">\t\t\tcomm-&gt;<span class=\"built_in\">handle_listen_result</span>(res);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(res);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!comm-&gt;thrdpool) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">mpoller_destroy</span>(comm-&gt;mpoller);</span><br><span class=\"line\">\t\t<span class=\"built_in\">msgqueue_destroy</span>(comm-&gt;msgqueue);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>freepollerpoller_nodemallocfreefreepoller_node</p>\n<p><strong>poller_node</strong></p>\n<p>poller_node</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__poller_new_node &#123; malloc &#125; -&gt; write(addr) -&gt; pipe -&gt; __poller_handle_pipe &#123; addr = read() &#125; -&gt; poller-&gt;callback(addr) -&gt; handler_thread_routine &#123; free &#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>pollerCommunicator</p>\n<p><img src=\"/2024/11/04/workflow/TCPServer_2/photo/StateTranslateThreadPool.drawio.png\"></p>\n<h3 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h3><p>tcp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tsocket\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tbind\t|\tCommunicator</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\tlisten\t|</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">\t|\t\t\t______________________________________________</span><br><span class=\"line\">\tV</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\taccept\t|\tpoller</span><br><span class=\"line\">+-----------+</span><br><span class=\"line\">|\t|\t|\t|</span><br><span class=\"line\">V\tV\tV\tV</span><br><span class=\"line\">fd\tfd\tfd\t...</span><br><span class=\"line\">\t/\\</span><br><span class=\"line\">read  write</span><br></pre></td></tr></table></figure>\n\n<p>CommunicatormpollerapisockfdIOIOlisten fdcommunicator</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>Communicator::bind</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::bind</span><span class=\"params\">(CommService *service)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">poller_data</span> data;</span><br><span class=\"line\">\t<span class=\"type\">int</span> errno_bak = errno;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sockfd;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsockfd = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">nonblock_listen</span>(service);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sockfd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tdata.fd = sockfd;</span><br><span class=\"line\">\t\tdata.context = service;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t\tdata.operation = PD_OP_LISTEN;</span><br><span class=\"line\">\t\tdata.accept = Communicator::accept;</span><br><span class=\"line\">\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">mpoller_add</span>(&amp;data, service-&gt;listen_timeout, <span class=\"keyword\">this</span>-&gt;mpoller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\terrno = errno_bak;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>listenCommunicator::acceptpollerlistenIO socketacceptCommunicator::acceptIO socketCommServiceTarget</p>\n<p>nonblock_listen</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::nonblock_listen</span><span class=\"params\">(CommService *service)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sockfd = service-&gt;<span class=\"built_in\">create_listen_fd</span>();\t\t\t\t<span class=\"comment\">// scoket()</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sockfd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (__set_fd_nonblock(sockfd) &gt;= <span class=\"number\">0</span>)\t&#123;\t\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (__bind_sockaddr(sockfd, service-&gt;bind_addr,</span><br><span class=\"line\">\t\t\t\t\t\t\t\tservice-&gt;addrlen) &gt;= <span class=\"number\">0</span>)\t&#123; \t<span class=\"comment\">// socketaddr</span></span><br><span class=\"line\">\t\t\t\tret = <span class=\"built_in\">listen</span>(sockfd, SOMAXCONN);\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (ret &gt;= <span class=\"number\">0</span> || errno == EOPNOTSUPP) &#123;</span><br><span class=\"line\">\t\t\t\t\tservice-&gt;reliable = (ret &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> sockfd;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Communicator::bindtcpserver</p>\n<ol>\n<li><p></p>\n</li>\n<li><p>mpoller</p>\n</li>\n</ol>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>Communicator::handle_listen_result</p>\n<p>bindpollerpolleracceptCommunicator::acceptpoller-&gt;callbackIOsocketresresCommunicatorresres-&gt;data.operationCommunicator::handle_listen_result</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::handle_listen_result</span><span class=\"params\">(<span class=\"keyword\">struct</span> poller_result *res)</span> </span>&#123;</span><br><span class=\"line\">\tCommService *service = (CommService *)res-&gt;data.context;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry;</span><br><span class=\"line\">\tCommServiceTarget *target;</span><br><span class=\"line\">\t<span class=\"type\">int</span> timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (res-&gt;state) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> PR_ST_SUCCESS:</span><br><span class=\"line\">\t\ttarget = (CommServiceTarget *)res-&gt;data.result;\t\t<span class=\"comment\">// Communicator::accept</span></span><br><span class=\"line\">\t\tentry = Communicator::<span class=\"built_in\">accept_conn</span>(target, service);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (entry) &#123;</span><br><span class=\"line\">\t\t\tentry-&gt;mpoller = <span class=\"keyword\">this</span>-&gt;mpoller;</span><br><span class=\"line\">\t\t\tres-&gt;data.operation = PD_OP_READ;</span><br><span class=\"line\">\t\t\tres-&gt;data.fd = entry-&gt;sockfd;</span><br><span class=\"line\">\t\t\tres-&gt;data.create_message = Communicator::create_request;</span><br><span class=\"line\">\t\t\tres-&gt;data.context = entry;</span><br><span class=\"line\">\t\t\tres-&gt;data.message = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\ttimeout = target-&gt;response_timeout;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">mpoller_add</span>(&amp;res-&gt;data, timeout, <span class=\"keyword\">this</span>-&gt;mpoller) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;stop_flag)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">mpoller_del</span>(res-&gt;data.fd, <span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t__release_conn(entry);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(target-&gt;sockfd);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttarget-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Communicator::accept_connresIOsocketCommConnEntrystateCONN_STATE_CONNECTEDmpollerIOsocket</p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>Communicator::create_request + Communicator::append_message</p>\n<p>Communicator::handle_read_result</p>\n<p></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>  </p>\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p></p>\n<p><img src=\"/2024/11/04/workflow/TCPServer_2/photo/ReadStatusTranslate.drawio.png\"></p>\n<p>poller__poller_handle_listen</p>\n<ol>\n<li><p>CommServiceTarget</p>\n</li>\n<li><p>IO socketfdpoller-&gt;callbackCommunicator</p>\n</li>\n</ol>\n<p>CommunicatorCommunicator::handle_listen_result</p>\n<ol>\n<li><p>resoperationPD_OP_LISTENresCommunicator::handle_listen_resultres</p>\n</li>\n<li><p>Communicator::handle_listen_resultentryCONN_STATE_CONNECTED</p>\n</li>\n<li><p>operationREADpoller_nodedatacreate_messageCommunicator::create_request</p>\n</li>\n<li><p>poller_nodempoller</p>\n</li>\n</ol>\n<p>poller__poller_handle_read</p>\n<ol>\n<li><p></p>\n</li>\n<li><p>__poller_append_messagepoller_message_tmsgpoller_message_tmsg-&gt;append0msgres<strong>poller-&gt;callback</strong>create_messageappendCommunicator::create_requestCommunicator::append_messageentrycreate_messageentry-&gt;stateCONN_STATE_RECEIVINGCommunicator::append_messagein-&gt;append0ifentry-&gt;stateCONN_STATE_SUCCESS</p>\n</li>\n</ol>\n<p>Communicator::handle_read_resultCommunicator::handle_incoming_request</p>\n<ol>\n<li><p>resoperationPD_OP_READresCommunicator::handle_read_resultresCommunicator::handle_read_resultCommunicator::handle_incoming_request</p>\n</li>\n<li><p>sessionstateCS_STATE_TOREPLY</p>\n</li>\n<li><p>entry-&gt;state &#x3D;&#x3D; CONN_STATE_SUCCESSentrytargetidleentry-&gt;ref++entry-&gt;stateCONN_STATE_IDLEsession-&gt;passive  2</p>\n</li>\n<li><p>session-&gt;handleentry-&gt;refentry-&gt;ref0__release_connfreeentry</p>\n</li>\n</ol>\n<p>entry</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[CONN_STATE_CONNECTED] -&gt; [CONN_STATE_RECEIVING] -&gt; [CONN_STATE_SUCCESS] -&gt; [CONN_STATE_IDLE]</span><br></pre></td></tr></table></figure>\n\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p></p>\n<p>Communicator::reply</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::reply</span><span class=\"params\">(CommSession *session)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry;</span><br><span class=\"line\">\tCommServiceTarget *target;</span><br><span class=\"line\">\t<span class=\"type\">int</span> errno_bak;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (session-&gt;passive != <span class=\"number\">2</span>) &#123;\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\terrno = EINVAL;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\terrno_bak = errno;</span><br><span class=\"line\">\tsession-&gt;passive = <span class=\"number\">3</span>;\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\ttarget = (CommServiceTarget *)session-&gt;target;</span><br><span class=\"line\">\tret = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">reply_reliable</span>(session, target);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>) &#123;\t\t\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\tentry = session-&gt;in-&gt;entry;</span><br><span class=\"line\">\t\tsession-&gt;<span class=\"built_in\">handle</span>(CS_STATE_SUCCESS, <span class=\"number\">0</span>);\t<span class=\"comment\">// sessionhandle</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (__sync_sub_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t__release_conn(entry);</span><br><span class=\"line\">\t\t\ttarget-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\terrno = errno_bak;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::reply_reliable</span><span class=\"params\">(CommSession *session, CommTarget *target)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">list_head</span> *pos;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!<span class=\"built_in\">list_empty</span>(&amp;target-&gt;idle_list)) &#123;\t<span class=\"comment\">// CONN_STATE_IDLE</span></span><br><span class=\"line\">\t\tpos = target-&gt;idle_list.next;</span><br><span class=\"line\">\t\tentry = <span class=\"built_in\">list_entry</span>(pos, <span class=\"keyword\">struct</span> CommConnEntry, list);</span><br><span class=\"line\">\t\t<span class=\"built_in\">list_del</span>(pos);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsession-&gt;out = session-&gt;<span class=\"built_in\">message_out</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (session-&gt;out)</span><br><span class=\"line\">\t\t\tret = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">send_message</span>(entry);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\terrno = ENOENT;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::send_message</span><span class=\"params\">(<span class=\"keyword\">struct</span> CommConnEntry *entry)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\tend = vectors + cnt;</span><br><span class=\"line\">\tcnt = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">send_message_sync</span>(vectors, cnt, entry);\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">send_message_async</span>(end - cnt, cnt, entry);\t<span class=\"comment\">// </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Muduo<a href=\"https://blog.csdn.net/m0_52566365/article/details/135720278\">muduo10TcpConnection</a></p>\n<p>poller__poller_handle_writetcppoller_node__poller_handle_writenode-&gt;data.partial_writtenCommunicator::send_message_asyncWRITEpoller_nodepartial_writtenCommunicator::partial_written</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Communicator::partial_written</span><span class=\"params\">(<span class=\"type\">size_t</span> n, <span class=\"type\">void</span> *context)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry = (<span class=\"keyword\">struct</span> CommConnEntry *)context;</span><br><span class=\"line\">\tCommSession *session = entry-&gt;session;</span><br><span class=\"line\">\t<span class=\"type\">int</span> timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttimeout = Communicator::<span class=\"built_in\">next_timeout</span>(session);</span><br><span class=\"line\">\t<span class=\"built_in\">mpoller_set_timeout</span>(entry-&gt;sockfd, timeout, entry-&gt;mpoller);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>partial_written</p>\n<p>__poller_handle_read**__poller_handle_writepoller_nodeepoll**poller-&gt;callbackPSpoller<a href=\"./TcpServer_1.md\">WorkFlowCommunicatorTCPServer</a></p>\n<p>CommunicatorCommunicator::handle_write_resultCommunicator::handle_reply_result</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Communicator::handle_reply_result</span><span class=\"params\">(<span class=\"keyword\">struct</span> poller_result *res)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">CommConnEntry</span> *entry = (<span class=\"keyword\">struct</span> CommConnEntry *)res-&gt;data.context;</span><br><span class=\"line\">\tCommService *service = entry-&gt;service;</span><br><span class=\"line\">\tCommSession *session = entry-&gt;session;</span><br><span class=\"line\">\tCommTarget *target = entry-&gt;target;</span><br><span class=\"line\">\t<span class=\"type\">int</span> timeout;</span><br><span class=\"line\">\t<span class=\"type\">int</span> state;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (res-&gt;state) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> PR_ST_FINISHED:</span><br><span class=\"line\">\t\ttimeout = session-&gt;<span class=\"built_in\">keep_alive_timeout</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (timeout != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t__sync_add_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>);\t\t\t\t\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\tres-&gt;data.operation = PD_OP_READ;</span><br><span class=\"line\">\t\t\tres-&gt;data.create_message = Communicator::create_request;</span><br><span class=\"line\">\t\t\tres-&gt;data.message = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">mpoller_add</span>(&amp;res-&gt;data, timeout, <span class=\"keyword\">this</span>-&gt;mpoller) &gt;= <span class=\"number\">0</span>) &#123;\t\t<span class=\"comment\">// mpoller</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">pthread_mutex_lock</span>(&amp;service-&gt;mutex);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>-&gt;stop_flag &amp;&amp; service-&gt;listen_fd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tentry-&gt;state = CONN_STATE_KEEPALIVE;\t\t\t\t\t<span class=\"comment\">// entry-&gt;stateCONN_STATE_KEEPALIVE</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">list_add_tail</span>(&amp;entry-&gt;list, &amp;service-&gt;alive_list);\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">mpoller_del</span>(res-&gt;data.fd, <span class=\"keyword\">this</span>-&gt;mpoller);</span><br><span class=\"line\">\t\t\t\t\tentry-&gt;state = CONN_STATE_CLOSING;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;service-&gt;mutex);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t\t\t\t__sync_sub_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>);\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">pthread_mutex_unlock</span>(&amp;target-&gt;mutex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tstate = CS_STATE_SUCCESS;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsession-&gt;<span class=\"built_in\">handle</span>(state, res-&gt;error);\t\t\t\t\t\t\t\t\t<span class=\"comment\">// session-&gt;handle</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (__sync_sub_and_fetch(&amp;entry-&gt;ref, <span class=\"number\">1</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t__release_conn(entry);</span><br><span class=\"line\">\t\t\t((CommServiceTarget *)target)-&gt;<span class=\"built_in\">decref</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<ol>\n<li><p>entry-&gt;ref &amp;&amp; poller_nodempoller &amp;&amp; entry-&gt;stateCONN_STATE_KEEPALIVECommService</p>\n</li>\n<li><p>sessionstateCS_STATE_SUCCESSsession-&gt;handle</p>\n</li>\n<li><p>entry-&gt;ref</p>\n</li>\n</ol>\n<p>Communicator::handle_reply_resultentry-&gt;stateCONN_STATE_KEEPALIVE</p>\n<p></p>\n<ol>\n<li><p><strong>session-&gt;passivecreate_requestmsgsession-&gt;passive1Communicator::handle_incoming_requestsession-&gt;passive2Communicator::replysession-&gt;passive3</strong></p>\n</li>\n<li><p>Communicator::send_message_asyncpoller_nodeWRITEmpollermpoller_mod</p>\n</li>\n<li><p>CommunicatorTCPServersessionHTTPServerSessionCommunicatorsessionworkflowgo-taskHTTPServerSessionHTTPCommunicator<strong>-</strong> - <strong></strong>CommunicatorsessionCommunicator::create_requestservice-&gt;new_sessionCommunicatorgo-taskCommunicatorsessionsession delete</p>\n</li>\n</ol>\n<p></p>\n<p>tcpsocketfd</p>\n<p>workflow<strong></strong></p>\n<hr>\n<p><strong></strong></p>"},{"title":" Onix & XV6 2Unix","date":"2024-06-07T04:00:00.000Z","_content":"\n## \n\nXV6Unix\n\nXV6OnixXV6\n\nOnix\n\n- [github](https://github.com/StevenBaby/onix)\n\n- [B](https://www.bilibili.com/video/BV1qM4y127om/)\n\nXV6-x86github\n\n- [](https://github.com/mit-pdos/xv6-public)\n\n<!-- more -->\n\n## \n\nunix-like\n\nx86cr0cr3cr0cr3cr0cpu3\n\n![](./MemoryManager/photo/memmanager/vaddr.png)\n\n10****4Byte10****4Byte12****1Byte4096Page124096sizeof() == sizeof() == sizeof() == 4096\n\n4Byte1024entry\n\n4Byte4Byte\n\n![](./MemoryManager/photo/memmanager/entry.png)\n\nentry204G40961M200\n\nentry120entry1entry3unix-like1****\n\nCPUMMUvaddr\n\n0. cr3dir_paddr\n\n1. vaddr1010dir_entrydir_entrydir_entrytab_paddr\ns\n2. vaddr1010tab_entrytab_entrytab_entryfrm_paddr\n\n3. vaddr1212frm_addrfrm_paddr + offset\n\nxv6\n\n![](./MemoryManager/photo/memmanager/vaddr2paddr.png)\n\n## \n\nmaincpu &  &  & BSP4K & 4M big page\n\nXV6main\n\n```cpp\nint\nmain(void)\n{\n  kinit1(end, P2V(4*1024*1024)); // phys page allocator\n  kvmalloc();      // kernel page table\n  seginit();       // segment descriptors // &\n  // ...\n  startothers();   // start other processors  // \n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()\n  // ...\n}\n```\n\ncpuP2V4M\n\n```cpp\n#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts\n#define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts\n```\n\n### kinit11\n\nxv6kallocxv6kalloc4Kkalloc****Onixunix-likeget_page + alloc_kpage + kmalloc\n\n```cpp\n// Onix\n\n// src/kernel/memory.c\n\n// 2561Byteentry\n// 1Bytecopy on write\n// xv6Onixforkcopy on write\n// \n\n// \nstatic u32 get_page() { /* ... */ }\n// \nstatic void put_page(u32 addr) {/* ... */}\n\n// \n// get_page()xv6\n// xv61page\n\n// src/kernel/memory.c\n\n//  count \nu32 alloc_kpage(u32 count) { /* ... */ }\n//  count \nvoid free_kpage(u32 vaddr, u32 count) { /* ... */ }\n\n// src/kernel/area.c\n// 4K\n\n// \nvoid *kmalloc(size_t size) { /* ... */ }\nvoid kfree(void *ptr) { /* ... */ }\n```\n\n1byte1M1M * pagesieze4096== 4G140961M 1024 * 1024 / 4 * 1024 = 256\n\nkinit1kinit14Mpage\n\n![](./MemoryManager/photo/memmanager/kalloc.drawio.png)\n\n### kvmallockpgdir\n\ncpuentrypgdir4M big pagekvmallockpgdir4Kentrypgdirkpgdirkpgdirkpgdirentrypgdirkmappgdir4MPHYSTOP224M****XV6PHYSTOP224MPHYSTOPXV6PHYSTOPKERNBASEPHYSTOP4GKERNBASE + PHYSTOP\n\n```cpp\nstatic struct kmap {\n  void *virt;\n  uint phys_start;\n  uint phys_end;\n  int perm;\n} kmap[] = {\n { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space\n { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata\n { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory\n { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices\n};\n```\n\n\n\nMMUvaalloc1\n\n```cpp\n// va\nstatic pte_t *\nwalkpgdir(pde_t *pgdir, const void *va, int alloc)\n{\n  pde_t *pde;   // vaddr \n  pte_t *pgtab; // vaddr \n\n  pde = &pgdir[PDX(va)];                          // va\n  if(*pde & PTE_P){\n    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));          // \n  } else {\n    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0) // \n      return 0;\n    // Make sure all those PTE_P bits are zero.\n    memset(pgtab, 0, PGSIZE);                     // \n    // The permissions here are overly generous, but they can\n    // be further restricted by the permissions in the page table\n    // entries, if necessary.\n    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;    // \n  }\n  return &pgtab[PTX(va)];\n}\n```\n\nmappageswalkpgdirwalkpgdir\n\n```cpp\n// Create PTEs for virtual addresses starting at va that refer to\n// physical addresses starting at pa. va and size might not\n// be page-aligned.\nstatic int\nmappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)\n{\n  char *a, *last;\n  pte_t *pte;\n\n  a = (char*)PGROUNDDOWN((uint)va);                 // 4k\n  last = (char*)PGROUNDDOWN(((uint)va) + size - 1); // \n  for(;;){\n    if((pte = walkpgdir(pgdir, a, 1)) == 0)         // a\n      return -1;\n    if(*pte & PTE_P)\n      panic(\"remap\");\n    *pte = pa | perm | PTE_P;                       // \n    if(a == last)\n      break;\n    a += PGSIZE;\n    pa += PGSIZE;\n  }\n  return 0;\n}\n\n```\n\nsetupkvmmappageskmapkpgdir\n\n```cpp\n\n// Set up kernel part of a page table.\npde_t*\nsetupkvm(void)\n{\n  pde_t *pgdir;\n  struct kmap *k;\n\n  if((pgdir = (pde_t*)kalloc()) == 0)   // \n    return 0;\n  memset(pgdir, 0, PGSIZE);             // \n  if (P2V(PHYSTOP) > (void*)DEVSPACE)   // PHYSTOPio\n    panic(\"PHYSTOP too high\");\n  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)    // 4M big page\n    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,\n                (uint)k->phys_start, k->perm) < 0) {\n      freevm(pgdir);\n      return 0;\n    }\n  return pgdir;\n}\n\n// Allocate one page table for the machine for the kernel address\n// space for scheduler processes.\nvoid\nkvmalloc(void)\n{\n  kpgdir = setupkvm();\n  switchkvm();\n}\n```\n\nV2PP2V\n\n\n\n![](./MemoryManager/photo/memmanager/main_page_table.drawio.png)\n\n### kinit22\n\nAPstartothersBSPAPschedulerkfreeXV6schedulerKERNBASE + 4MKERNBASE + 4Mkmem\n\nkinit1kinit2KERNBASE + 4MKERNBASE + PHYSTOPkmemfreelist**kalloc**\n\ncpu &  & && & BSP4K & kmap4K\n\nXV6\n\n## Onix\n\nXV6kalloc\n\nOnixOnixOnixget_page + alloc_kpage + kmallocget_pagepage4G256byte4Gpagealloc_kpagepageOnixOnixbyte1alloc_kpagekmallocpageC++OnixOnix\n\nOnixOnix\n\n![](./MemoryManager/photo/memmanager/onix_memory_map.drawio.png)\n\nOnixOnixalloc_kpageget_page\n\nOnixXV6Onix\n\n**entry**Onix\n\n![](./MemoryManager/photo/memmanager/memory_paging_02.drawio.png)\n\nentry0x100712\n\n\n\n1. \n\n2. **0xfffff000**\n\nMMU0xfffff000\n\nOnix\n\n- **0xFFC00000 | 10**\n\nMMU\n\nOnix\n\n```cpp\n// vd\nstatic page_entry_t *get_pde()\n{\n    return (page_entry_t *)(0xfffff000);\n}\n\n//  vaddr vd\nstatic page_entry_t *get_pte(u32 vaddr, bool create)\n{\n    page_entry_t *pde = get_pde();\n    u32 idx = DIDX(vaddr);\n    page_entry_t *entry = &pde[idx];\n\n    assert(create || (!create && entry->present));\n\n    page_entry_t *table = (page_entry_t *)(PDE_MASK | (idx << 12));\n\n    if (!entry->present)\n    {\n        LOGK(\"Get and create page table entry for 0x%p\\n\", vaddr);\n        u32 page = get_page();\n\n        //!!!\n        entry_init(entry, IDX(page));\n        memset(table, 0, PAGE_SIZE);\n    }\n\n    return table;\n}\n\npage_entry_t *get_entry(u32 vaddr, bool create)\n{\n    page_entry_t *pte = get_pte(vaddr, create);\n    return &pte[TIDX(vaddr)];\n}\n```\n\nUnix-likeOnix\n\n\n\nXV6https://th0ar.gitbooks.io/xv6-chinese/content/\n\nOnixhttps://github.com/StevenBaby/onix/blob/dev/docs/05%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/041%20%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86.md\n\nCR0https://blog.csdn.net/qq_30528603/article/details/131143850\n\n---\n\n****\n","source":"_posts/xv6/MemoryManager.md","raw":"---\ntitle:  Onix & XV6 2Unix\ndate: 2024-06-07 12:00:00\ntags:\n  - Unix\n---\n\n## \n\nXV6Unix\n\nXV6OnixXV6\n\nOnix\n\n- [github](https://github.com/StevenBaby/onix)\n\n- [B](https://www.bilibili.com/video/BV1qM4y127om/)\n\nXV6-x86github\n\n- [](https://github.com/mit-pdos/xv6-public)\n\n<!-- more -->\n\n## \n\nunix-like\n\nx86cr0cr3cr0cr3cr0cpu3\n\n![](./MemoryManager/photo/memmanager/vaddr.png)\n\n10****4Byte10****4Byte12****1Byte4096Page124096sizeof() == sizeof() == sizeof() == 4096\n\n4Byte1024entry\n\n4Byte4Byte\n\n![](./MemoryManager/photo/memmanager/entry.png)\n\nentry204G40961M200\n\nentry120entry1entry3unix-like1****\n\nCPUMMUvaddr\n\n0. cr3dir_paddr\n\n1. vaddr1010dir_entrydir_entrydir_entrytab_paddr\ns\n2. vaddr1010tab_entrytab_entrytab_entryfrm_paddr\n\n3. vaddr1212frm_addrfrm_paddr + offset\n\nxv6\n\n![](./MemoryManager/photo/memmanager/vaddr2paddr.png)\n\n## \n\nmaincpu &  &  & BSP4K & 4M big page\n\nXV6main\n\n```cpp\nint\nmain(void)\n{\n  kinit1(end, P2V(4*1024*1024)); // phys page allocator\n  kvmalloc();      // kernel page table\n  seginit();       // segment descriptors // &\n  // ...\n  startothers();   // start other processors  // \n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()\n  // ...\n}\n```\n\ncpuP2V4M\n\n```cpp\n#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts\n#define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts\n```\n\n### kinit11\n\nxv6kallocxv6kalloc4Kkalloc****Onixunix-likeget_page + alloc_kpage + kmalloc\n\n```cpp\n// Onix\n\n// src/kernel/memory.c\n\n// 2561Byteentry\n// 1Bytecopy on write\n// xv6Onixforkcopy on write\n// \n\n// \nstatic u32 get_page() { /* ... */ }\n// \nstatic void put_page(u32 addr) {/* ... */}\n\n// \n// get_page()xv6\n// xv61page\n\n// src/kernel/memory.c\n\n//  count \nu32 alloc_kpage(u32 count) { /* ... */ }\n//  count \nvoid free_kpage(u32 vaddr, u32 count) { /* ... */ }\n\n// src/kernel/area.c\n// 4K\n\n// \nvoid *kmalloc(size_t size) { /* ... */ }\nvoid kfree(void *ptr) { /* ... */ }\n```\n\n1byte1M1M * pagesieze4096== 4G140961M 1024 * 1024 / 4 * 1024 = 256\n\nkinit1kinit14Mpage\n\n![](./MemoryManager/photo/memmanager/kalloc.drawio.png)\n\n### kvmallockpgdir\n\ncpuentrypgdir4M big pagekvmallockpgdir4Kentrypgdirkpgdirkpgdirkpgdirentrypgdirkmappgdir4MPHYSTOP224M****XV6PHYSTOP224MPHYSTOPXV6PHYSTOPKERNBASEPHYSTOP4GKERNBASE + PHYSTOP\n\n```cpp\nstatic struct kmap {\n  void *virt;\n  uint phys_start;\n  uint phys_end;\n  int perm;\n} kmap[] = {\n { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space\n { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata\n { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory\n { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices\n};\n```\n\n\n\nMMUvaalloc1\n\n```cpp\n// va\nstatic pte_t *\nwalkpgdir(pde_t *pgdir, const void *va, int alloc)\n{\n  pde_t *pde;   // vaddr \n  pte_t *pgtab; // vaddr \n\n  pde = &pgdir[PDX(va)];                          // va\n  if(*pde & PTE_P){\n    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));          // \n  } else {\n    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0) // \n      return 0;\n    // Make sure all those PTE_P bits are zero.\n    memset(pgtab, 0, PGSIZE);                     // \n    // The permissions here are overly generous, but they can\n    // be further restricted by the permissions in the page table\n    // entries, if necessary.\n    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;    // \n  }\n  return &pgtab[PTX(va)];\n}\n```\n\nmappageswalkpgdirwalkpgdir\n\n```cpp\n// Create PTEs for virtual addresses starting at va that refer to\n// physical addresses starting at pa. va and size might not\n// be page-aligned.\nstatic int\nmappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)\n{\n  char *a, *last;\n  pte_t *pte;\n\n  a = (char*)PGROUNDDOWN((uint)va);                 // 4k\n  last = (char*)PGROUNDDOWN(((uint)va) + size - 1); // \n  for(;;){\n    if((pte = walkpgdir(pgdir, a, 1)) == 0)         // a\n      return -1;\n    if(*pte & PTE_P)\n      panic(\"remap\");\n    *pte = pa | perm | PTE_P;                       // \n    if(a == last)\n      break;\n    a += PGSIZE;\n    pa += PGSIZE;\n  }\n  return 0;\n}\n\n```\n\nsetupkvmmappageskmapkpgdir\n\n```cpp\n\n// Set up kernel part of a page table.\npde_t*\nsetupkvm(void)\n{\n  pde_t *pgdir;\n  struct kmap *k;\n\n  if((pgdir = (pde_t*)kalloc()) == 0)   // \n    return 0;\n  memset(pgdir, 0, PGSIZE);             // \n  if (P2V(PHYSTOP) > (void*)DEVSPACE)   // PHYSTOPio\n    panic(\"PHYSTOP too high\");\n  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)    // 4M big page\n    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,\n                (uint)k->phys_start, k->perm) < 0) {\n      freevm(pgdir);\n      return 0;\n    }\n  return pgdir;\n}\n\n// Allocate one page table for the machine for the kernel address\n// space for scheduler processes.\nvoid\nkvmalloc(void)\n{\n  kpgdir = setupkvm();\n  switchkvm();\n}\n```\n\nV2PP2V\n\n\n\n![](./MemoryManager/photo/memmanager/main_page_table.drawio.png)\n\n### kinit22\n\nAPstartothersBSPAPschedulerkfreeXV6schedulerKERNBASE + 4MKERNBASE + 4Mkmem\n\nkinit1kinit2KERNBASE + 4MKERNBASE + PHYSTOPkmemfreelist**kalloc**\n\ncpu &  & && & BSP4K & kmap4K\n\nXV6\n\n## Onix\n\nXV6kalloc\n\nOnixOnixOnixget_page + alloc_kpage + kmallocget_pagepage4G256byte4Gpagealloc_kpagepageOnixOnixbyte1alloc_kpagekmallocpageC++OnixOnix\n\nOnixOnix\n\n![](./MemoryManager/photo/memmanager/onix_memory_map.drawio.png)\n\nOnixOnixalloc_kpageget_page\n\nOnixXV6Onix\n\n**entry**Onix\n\n![](./MemoryManager/photo/memmanager/memory_paging_02.drawio.png)\n\nentry0x100712\n\n\n\n1. \n\n2. **0xfffff000**\n\nMMU0xfffff000\n\nOnix\n\n- **0xFFC00000 | 10**\n\nMMU\n\nOnix\n\n```cpp\n// vd\nstatic page_entry_t *get_pde()\n{\n    return (page_entry_t *)(0xfffff000);\n}\n\n//  vaddr vd\nstatic page_entry_t *get_pte(u32 vaddr, bool create)\n{\n    page_entry_t *pde = get_pde();\n    u32 idx = DIDX(vaddr);\n    page_entry_t *entry = &pde[idx];\n\n    assert(create || (!create && entry->present));\n\n    page_entry_t *table = (page_entry_t *)(PDE_MASK | (idx << 12));\n\n    if (!entry->present)\n    {\n        LOGK(\"Get and create page table entry for 0x%p\\n\", vaddr);\n        u32 page = get_page();\n\n        //!!!\n        entry_init(entry, IDX(page));\n        memset(table, 0, PAGE_SIZE);\n    }\n\n    return table;\n}\n\npage_entry_t *get_entry(u32 vaddr, bool create)\n{\n    page_entry_t *pte = get_pte(vaddr, create);\n    return &pte[TIDX(vaddr)];\n}\n```\n\nUnix-likeOnix\n\n\n\nXV6https://th0ar.gitbooks.io/xv6-chinese/content/\n\nOnixhttps://github.com/StevenBaby/onix/blob/dev/docs/05%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/041%20%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86.md\n\nCR0https://blog.csdn.net/qq_30528603/article/details/131143850\n\n---\n\n****\n","slug":"xv6/MemoryManager","published":1,"updated":"2025-09-28T09:40:58.181Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9u0012q8wsfwecb723","content":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>XV6Unix</p>\n<p>XV6OnixXV6</p>\n<p>Onix</p>\n<ul>\n<li><p><a href=\"https://github.com/StevenBaby/onix\">github</a></p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/BV1qM4y127om/\">B</a></p>\n</li>\n</ul>\n<p>XV6-x86github</p>\n<ul>\n<li><a href=\"https://github.com/mit-pdos/xv6-public\"></a></li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>unix-like</p>\n<p>x86cr0cr3cr0cr3cr0cpu3</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/vaddr.png\"></p>\n<p>10<strong></strong>4Byte10<strong></strong>4Byte12<strong></strong>1Byte4096Page124096sizeof() &#x3D;&#x3D; sizeof() &#x3D;&#x3D; sizeof() &#x3D;&#x3D; 4096</p>\n<p>4Byte1024entry</p>\n<p>4Byte4Byte</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/entry.png\"></p>\n<p>entry204G40961M200</p>\n<p>entry120entry1entry3unix-like1<strong></strong></p>\n<p>CPUMMUvaddr</p>\n<ol start=\"0\">\n<li><p>cr3dir_paddr</p>\n</li>\n<li><p>vaddr1010dir_entrydir_entrydir_entrytab_paddr<br>s</p>\n</li>\n<li><p>vaddr1010tab_entrytab_entrytab_entryfrm_paddr</p>\n</li>\n<li><p>vaddr1212frm_addrfrm_paddr + offset</p>\n</li>\n</ol>\n<p>xv6</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/vaddr2paddr.png\"></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>maincpu &amp;  &amp;  &amp; BSP4K &amp; 4M big page</p>\n<p>XV6main</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">kinit1</span>(end, <span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>)); <span class=\"comment\">// phys page allocator</span></span><br><span class=\"line\">  <span class=\"built_in\">kvmalloc</span>();      <span class=\"comment\">// kernel page table</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();       <span class=\"comment\">// segment descriptors // &amp;</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">startothers</span>();   <span class=\"comment\">// start other processors  // </span></span><br><span class=\"line\">  <span class=\"built_in\">kinit2</span>(<span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>), <span class=\"built_in\">P2V</span>(PHYSTOP)); <span class=\"comment\">// must come after startothers()</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>cpuP2V4M</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> V2P_WO(x) ((x) - KERNBASE)    <span class=\"comment\">// same as V2P, but without casts</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> P2V_WO(x) ((x) + KERNBASE)    <span class=\"comment\">// same as P2V, but without casts</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"kinit11\"><a href=\"#kinit11\" class=\"headerlink\" title=\"kinit11\"></a>kinit11</h3><p>xv6kallocxv6kalloc4Kkalloc<strong></strong>Onixunix-likeget_page + alloc_kpage + kmalloc</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Onix</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/kernel/memory.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2561Byteentry</span></span><br><span class=\"line\"><span class=\"comment\">// 1Bytecopy on write</span></span><br><span class=\"line\"><span class=\"comment\">// xv6Onixforkcopy on write</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> u32 <span class=\"title\">get_page</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">put_page</span><span class=\"params\">(u32 addr)</span> </span>&#123;<span class=\"comment\">/* ... */</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// get_page()xv6</span></span><br><span class=\"line\"><span class=\"comment\">// xv61page</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/kernel/memory.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  count </span></span><br><span class=\"line\"><span class=\"function\">u32 <span class=\"title\">alloc_kpage</span><span class=\"params\">(u32 count)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">//  count </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">free_kpage</span><span class=\"params\">(u32 vaddr, u32 count)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/kernel/area.c</span></span><br><span class=\"line\"><span class=\"comment\">// 4K</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">kmalloc</span><span class=\"params\">(<span class=\"type\">size_t</span> size)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">kfree</span><span class=\"params\">(<span class=\"type\">void</span> *ptr)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>1byte1M1M * pagesieze4096&#x3D;&#x3D; 4G140961M 1024 * 1024 &#x2F; 4 * 1024 &#x3D; 256</p>\n<p>kinit1kinit14Mpage</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/kalloc.drawio.png\"></p>\n<h3 id=\"kvmallockpgdir\"><a href=\"#kvmallockpgdir\" class=\"headerlink\" title=\"kvmallockpgdir\"></a>kvmallockpgdir</h3><p>cpuentrypgdir4M big pagekvmallockpgdir4Kentrypgdirkpgdirkpgdirkpgdirentrypgdirkmappgdir4MPHYSTOP224M<strong></strong>XV6PHYSTOP224MPHYSTOPXV6PHYSTOPKERNBASEPHYSTOP4GKERNBASE + PHYSTOP</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">kmap</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">void</span> *virt;</span><br><span class=\"line\">  uint phys_start;</span><br><span class=\"line\">  uint phys_end;</span><br><span class=\"line\">  <span class=\"type\">int</span> perm;</span><br><span class=\"line\">&#125; kmap[] = &#123;</span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)KERNBASE, <span class=\"number\">0</span>,             EXTMEM,    PTE_W&#125;, <span class=\"comment\">// I/O space</span></span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)KERNLINK, <span class=\"built_in\">V2P</span>(KERNLINK), <span class=\"built_in\">V2P</span>(data), <span class=\"number\">0</span>&#125;,     <span class=\"comment\">// kern text+rodata</span></span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)data,     <span class=\"built_in\">V2P</span>(data),     PHYSTOP,   PTE_W&#125;, <span class=\"comment\">// kern data+memory</span></span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)DEVSPACE, DEVSPACE,      <span class=\"number\">0</span>,         PTE_W&#125;, <span class=\"comment\">// more devices</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p>MMUvaalloc1</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// va</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">pte_t</span> *</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">walkpgdir</span><span class=\"params\">(<span class=\"type\">pde_t</span> *pgdir, <span class=\"type\">const</span> <span class=\"type\">void</span> *va, <span class=\"type\">int</span> alloc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">pde_t</span> *pde;   <span class=\"comment\">// vaddr </span></span><br><span class=\"line\">  <span class=\"type\">pte_t</span> *pgtab; <span class=\"comment\">// vaddr </span></span><br><span class=\"line\"></span><br><span class=\"line\">  pde = &amp;pgdir[<span class=\"built_in\">PDX</span>(va)];                          <span class=\"comment\">// va</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(*pde &amp; PTE_P)&#123;</span><br><span class=\"line\">    pgtab = (<span class=\"type\">pte_t</span>*)<span class=\"built_in\">P2V</span>(<span class=\"built_in\">PTE_ADDR</span>(*pde));          <span class=\"comment\">// </span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!alloc || (pgtab = (<span class=\"type\">pte_t</span>*)<span class=\"built_in\">kalloc</span>()) == <span class=\"number\">0</span>) <span class=\"comment\">// </span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Make sure all those PTE_P bits are zero.</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(pgtab, <span class=\"number\">0</span>, PGSIZE);                     <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// The permissions here are overly generous, but they can</span></span><br><span class=\"line\">    <span class=\"comment\">// be further restricted by the permissions in the page table</span></span><br><span class=\"line\">    <span class=\"comment\">// entries, if necessary.</span></span><br><span class=\"line\">    *pde = <span class=\"built_in\">V2P</span>(pgtab) | PTE_P | PTE_W | PTE_U;    <span class=\"comment\">// </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;pgtab[<span class=\"built_in\">PTX</span>(va)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mappageswalkpgdirwalkpgdir</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class=\"line\"><span class=\"comment\">// physical addresses starting at pa. va and size might not</span></span><br><span class=\"line\"><span class=\"comment\">// be page-aligned.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mappages</span><span class=\"params\">(<span class=\"type\">pde_t</span> *pgdir, <span class=\"type\">void</span> *va, uint size, uint pa, <span class=\"type\">int</span> perm)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> *a, *last;</span><br><span class=\"line\">  <span class=\"type\">pte_t</span> *pte;</span><br><span class=\"line\"></span><br><span class=\"line\">  a = (<span class=\"type\">char</span>*)<span class=\"built_in\">PGROUNDDOWN</span>((uint)va);                 <span class=\"comment\">// 4k</span></span><br><span class=\"line\">  last = (<span class=\"type\">char</span>*)<span class=\"built_in\">PGROUNDDOWN</span>(((uint)va) + size - <span class=\"number\">1</span>); <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((pte = <span class=\"built_in\">walkpgdir</span>(pgdir, a, <span class=\"number\">1</span>)) == <span class=\"number\">0</span>)         <span class=\"comment\">// a</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(*pte &amp; PTE_P)</span><br><span class=\"line\">      <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;remap&quot;</span>);</span><br><span class=\"line\">    *pte = pa | perm | PTE_P;                       <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a == last)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    a += PGSIZE;</span><br><span class=\"line\">    pa += PGSIZE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>setupkvmmappageskmapkpgdir</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set up kernel part of a page table.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">pde_t</span>*</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">setupkvm</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">pde_t</span> *pgdir;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">kmap</span> *k;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((pgdir = (<span class=\"type\">pde_t</span>*)<span class=\"built_in\">kalloc</span>()) == <span class=\"number\">0</span>)   <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(pgdir, <span class=\"number\">0</span>, PGSIZE);             <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">P2V</span>(PHYSTOP) &gt; (<span class=\"type\">void</span>*)DEVSPACE)   <span class=\"comment\">// PHYSTOPio</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;PHYSTOP too high&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(k = kmap; k &lt; &amp;kmap[<span class=\"built_in\">NELEM</span>(kmap)]; k++)    <span class=\"comment\">// 4M big page</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">mappages</span>(pgdir, k-&gt;virt, k-&gt;phys_end - k-&gt;phys_start,</span><br><span class=\"line\">                (uint)k-&gt;phys_start, k-&gt;perm) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">freevm</span>(pgdir);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pgdir;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Allocate one page table for the machine for the kernel address</span></span><br><span class=\"line\"><span class=\"comment\">// space for scheduler processes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kvmalloc</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  kpgdir = <span class=\"built_in\">setupkvm</span>();</span><br><span class=\"line\">  switchkvm();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>V2PP2V</p>\n<p></p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/main_page_table.drawio.png\"></p>\n<h3 id=\"kinit22\"><a href=\"#kinit22\" class=\"headerlink\" title=\"kinit22\"></a>kinit22</h3><p>APstartothersBSPAPschedulerkfreeXV6schedulerKERNBASE + 4MKERNBASE + 4Mkmem</p>\n<p>kinit1kinit2KERNBASE + 4MKERNBASE + PHYSTOPkmemfreelist<strong>kalloc</strong></p>\n<p>cpu &amp;  &amp; &amp;&amp; &amp; BSP4K &amp; kmap4K</p>\n<p>XV6</p>\n<h2 id=\"Onix\"><a href=\"#Onix\" class=\"headerlink\" title=\"Onix\"></a>Onix</h2><p>XV6kalloc</p>\n<p>OnixOnixOnixget_page + alloc_kpage + kmallocget_pagepage4G256byte4Gpagealloc_kpagepageOnixOnixbyte1alloc_kpagekmallocpageC++OnixOnix</p>\n<p>OnixOnix</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/onix_memory_map.drawio.png\"></p>\n<p>OnixOnixalloc_kpageget_page</p>\n<p>OnixXV6Onix</p>\n<p><strong>entry</strong>Onix</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/memory_paging_02.drawio.png\"></p>\n<p>entry0x100712</p>\n<p></p>\n<ol>\n<li><p></p>\n</li>\n<li><p><strong>0xfffff000</strong></p>\n</li>\n</ol>\n<p>MMU0xfffff000</p>\n<p>Onix</p>\n<ul>\n<li><strong>0xFFC00000 | 10</strong></li>\n</ul>\n<p>MMU</p>\n<p>Onix</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">page_entry_t</span> *<span class=\"title\">get_pde</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">page_entry_t</span> *)(<span class=\"number\">0xfffff000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  vaddr vd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">page_entry_t</span> *<span class=\"title\">get_pte</span><span class=\"params\">(u32 vaddr, <span class=\"type\">bool</span> create)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *pde = <span class=\"built_in\">get_pde</span>();</span><br><span class=\"line\">    u32 idx = <span class=\"built_in\">DIDX</span>(vaddr);</span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *entry = &amp;pde[idx];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(create || (!create &amp;&amp; entry-&gt;present));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *table = (<span class=\"type\">page_entry_t</span> *)(PDE_MASK | (idx &lt;&lt; <span class=\"number\">12</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!entry-&gt;present)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">LOGK</span>(<span class=\"string\">&quot;Get and create page table entry for 0x%p\\n&quot;</span>, vaddr);</span><br><span class=\"line\">        u32 page = <span class=\"built_in\">get_page</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//!!!</span></span><br><span class=\"line\">        <span class=\"built_in\">entry_init</span>(entry, <span class=\"built_in\">IDX</span>(page));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(table, <span class=\"number\">0</span>, PAGE_SIZE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">page_entry_t</span> *<span class=\"title\">get_entry</span><span class=\"params\">(u32 vaddr, <span class=\"type\">bool</span> create)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *pte = <span class=\"built_in\">get_pte</span>(vaddr, create);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;pte[<span class=\"built_in\">TIDX</span>(vaddr)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Unix-likeOnix</p>\n<p></p>\n<p>XV6<a href=\"https://th0ar.gitbooks.io/xv6-chinese/content/\">https://th0ar.gitbooks.io/xv6-chinese/content/</a></p>\n<p>Onix<a href=\"https://github.com/StevenBaby/onix/blob/dev/docs/05%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/041%20%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86.md\">https://github.com/StevenBaby/onix/blob/dev/docs/05%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/041%20%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86.md</a></p>\n<p>CR0<a href=\"https://blog.csdn.net/qq_30528603/article/details/131143850\">https://blog.csdn.net/qq_30528603/article/details/131143850</a></p>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>XV6Unix</p>\n<p>XV6OnixXV6</p>\n<p>Onix</p>\n<ul>\n<li><p><a href=\"https://github.com/StevenBaby/onix\">github</a></p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/BV1qM4y127om/\">B</a></p>\n</li>\n</ul>\n<p>XV6-x86github</p>\n<ul>\n<li><a href=\"https://github.com/mit-pdos/xv6-public\"></a></li>\n</ul>","more":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>unix-like</p>\n<p>x86cr0cr3cr0cr3cr0cpu3</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/vaddr.png\"></p>\n<p>10<strong></strong>4Byte10<strong></strong>4Byte12<strong></strong>1Byte4096Page124096sizeof() &#x3D;&#x3D; sizeof() &#x3D;&#x3D; sizeof() &#x3D;&#x3D; 4096</p>\n<p>4Byte1024entry</p>\n<p>4Byte4Byte</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/entry.png\"></p>\n<p>entry204G40961M200</p>\n<p>entry120entry1entry3unix-like1<strong></strong></p>\n<p>CPUMMUvaddr</p>\n<ol start=\"0\">\n<li><p>cr3dir_paddr</p>\n</li>\n<li><p>vaddr1010dir_entrydir_entrydir_entrytab_paddr<br>s</p>\n</li>\n<li><p>vaddr1010tab_entrytab_entrytab_entryfrm_paddr</p>\n</li>\n<li><p>vaddr1212frm_addrfrm_paddr + offset</p>\n</li>\n</ol>\n<p>xv6</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/vaddr2paddr.png\"></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>maincpu &amp;  &amp;  &amp; BSP4K &amp; 4M big page</p>\n<p>XV6main</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">kinit1</span>(end, <span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>)); <span class=\"comment\">// phys page allocator</span></span><br><span class=\"line\">  <span class=\"built_in\">kvmalloc</span>();      <span class=\"comment\">// kernel page table</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();       <span class=\"comment\">// segment descriptors // &amp;</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">startothers</span>();   <span class=\"comment\">// start other processors  // </span></span><br><span class=\"line\">  <span class=\"built_in\">kinit2</span>(<span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>), <span class=\"built_in\">P2V</span>(PHYSTOP)); <span class=\"comment\">// must come after startothers()</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>cpuP2V4M</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> V2P_WO(x) ((x) - KERNBASE)    <span class=\"comment\">// same as V2P, but without casts</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> P2V_WO(x) ((x) + KERNBASE)    <span class=\"comment\">// same as P2V, but without casts</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"kinit11\"><a href=\"#kinit11\" class=\"headerlink\" title=\"kinit11\"></a>kinit11</h3><p>xv6kallocxv6kalloc4Kkalloc<strong></strong>Onixunix-likeget_page + alloc_kpage + kmalloc</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Onix</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/kernel/memory.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2561Byteentry</span></span><br><span class=\"line\"><span class=\"comment\">// 1Bytecopy on write</span></span><br><span class=\"line\"><span class=\"comment\">// xv6Onixforkcopy on write</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> u32 <span class=\"title\">get_page</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">put_page</span><span class=\"params\">(u32 addr)</span> </span>&#123;<span class=\"comment\">/* ... */</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// get_page()xv6</span></span><br><span class=\"line\"><span class=\"comment\">// xv61page</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/kernel/memory.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  count </span></span><br><span class=\"line\"><span class=\"function\">u32 <span class=\"title\">alloc_kpage</span><span class=\"params\">(u32 count)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">//  count </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">free_kpage</span><span class=\"params\">(u32 vaddr, u32 count)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/kernel/area.c</span></span><br><span class=\"line\"><span class=\"comment\">// 4K</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">kmalloc</span><span class=\"params\">(<span class=\"type\">size_t</span> size)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">kfree</span><span class=\"params\">(<span class=\"type\">void</span> *ptr)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>1byte1M1M * pagesieze4096&#x3D;&#x3D; 4G140961M 1024 * 1024 &#x2F; 4 * 1024 &#x3D; 256</p>\n<p>kinit1kinit14Mpage</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/kalloc.drawio.png\"></p>\n<h3 id=\"kvmallockpgdir\"><a href=\"#kvmallockpgdir\" class=\"headerlink\" title=\"kvmallockpgdir\"></a>kvmallockpgdir</h3><p>cpuentrypgdir4M big pagekvmallockpgdir4Kentrypgdirkpgdirkpgdirkpgdirentrypgdirkmappgdir4MPHYSTOP224M<strong></strong>XV6PHYSTOP224MPHYSTOPXV6PHYSTOPKERNBASEPHYSTOP4GKERNBASE + PHYSTOP</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">kmap</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">void</span> *virt;</span><br><span class=\"line\">  uint phys_start;</span><br><span class=\"line\">  uint phys_end;</span><br><span class=\"line\">  <span class=\"type\">int</span> perm;</span><br><span class=\"line\">&#125; kmap[] = &#123;</span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)KERNBASE, <span class=\"number\">0</span>,             EXTMEM,    PTE_W&#125;, <span class=\"comment\">// I/O space</span></span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)KERNLINK, <span class=\"built_in\">V2P</span>(KERNLINK), <span class=\"built_in\">V2P</span>(data), <span class=\"number\">0</span>&#125;,     <span class=\"comment\">// kern text+rodata</span></span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)data,     <span class=\"built_in\">V2P</span>(data),     PHYSTOP,   PTE_W&#125;, <span class=\"comment\">// kern data+memory</span></span><br><span class=\"line\"> &#123; (<span class=\"type\">void</span>*)DEVSPACE, DEVSPACE,      <span class=\"number\">0</span>,         PTE_W&#125;, <span class=\"comment\">// more devices</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p>MMUvaalloc1</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// va</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">pte_t</span> *</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">walkpgdir</span><span class=\"params\">(<span class=\"type\">pde_t</span> *pgdir, <span class=\"type\">const</span> <span class=\"type\">void</span> *va, <span class=\"type\">int</span> alloc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">pde_t</span> *pde;   <span class=\"comment\">// vaddr </span></span><br><span class=\"line\">  <span class=\"type\">pte_t</span> *pgtab; <span class=\"comment\">// vaddr </span></span><br><span class=\"line\"></span><br><span class=\"line\">  pde = &amp;pgdir[<span class=\"built_in\">PDX</span>(va)];                          <span class=\"comment\">// va</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(*pde &amp; PTE_P)&#123;</span><br><span class=\"line\">    pgtab = (<span class=\"type\">pte_t</span>*)<span class=\"built_in\">P2V</span>(<span class=\"built_in\">PTE_ADDR</span>(*pde));          <span class=\"comment\">// </span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!alloc || (pgtab = (<span class=\"type\">pte_t</span>*)<span class=\"built_in\">kalloc</span>()) == <span class=\"number\">0</span>) <span class=\"comment\">// </span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Make sure all those PTE_P bits are zero.</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(pgtab, <span class=\"number\">0</span>, PGSIZE);                     <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// The permissions here are overly generous, but they can</span></span><br><span class=\"line\">    <span class=\"comment\">// be further restricted by the permissions in the page table</span></span><br><span class=\"line\">    <span class=\"comment\">// entries, if necessary.</span></span><br><span class=\"line\">    *pde = <span class=\"built_in\">V2P</span>(pgtab) | PTE_P | PTE_W | PTE_U;    <span class=\"comment\">// </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;pgtab[<span class=\"built_in\">PTX</span>(va)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mappageswalkpgdirwalkpgdir</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class=\"line\"><span class=\"comment\">// physical addresses starting at pa. va and size might not</span></span><br><span class=\"line\"><span class=\"comment\">// be page-aligned.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mappages</span><span class=\"params\">(<span class=\"type\">pde_t</span> *pgdir, <span class=\"type\">void</span> *va, uint size, uint pa, <span class=\"type\">int</span> perm)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> *a, *last;</span><br><span class=\"line\">  <span class=\"type\">pte_t</span> *pte;</span><br><span class=\"line\"></span><br><span class=\"line\">  a = (<span class=\"type\">char</span>*)<span class=\"built_in\">PGROUNDDOWN</span>((uint)va);                 <span class=\"comment\">// 4k</span></span><br><span class=\"line\">  last = (<span class=\"type\">char</span>*)<span class=\"built_in\">PGROUNDDOWN</span>(((uint)va) + size - <span class=\"number\">1</span>); <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((pte = <span class=\"built_in\">walkpgdir</span>(pgdir, a, <span class=\"number\">1</span>)) == <span class=\"number\">0</span>)         <span class=\"comment\">// a</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(*pte &amp; PTE_P)</span><br><span class=\"line\">      <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;remap&quot;</span>);</span><br><span class=\"line\">    *pte = pa | perm | PTE_P;                       <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a == last)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    a += PGSIZE;</span><br><span class=\"line\">    pa += PGSIZE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>setupkvmmappageskmapkpgdir</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set up kernel part of a page table.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">pde_t</span>*</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">setupkvm</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">pde_t</span> *pgdir;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">kmap</span> *k;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((pgdir = (<span class=\"type\">pde_t</span>*)<span class=\"built_in\">kalloc</span>()) == <span class=\"number\">0</span>)   <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(pgdir, <span class=\"number\">0</span>, PGSIZE);             <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">P2V</span>(PHYSTOP) &gt; (<span class=\"type\">void</span>*)DEVSPACE)   <span class=\"comment\">// PHYSTOPio</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;PHYSTOP too high&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(k = kmap; k &lt; &amp;kmap[<span class=\"built_in\">NELEM</span>(kmap)]; k++)    <span class=\"comment\">// 4M big page</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">mappages</span>(pgdir, k-&gt;virt, k-&gt;phys_end - k-&gt;phys_start,</span><br><span class=\"line\">                (uint)k-&gt;phys_start, k-&gt;perm) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">freevm</span>(pgdir);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pgdir;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Allocate one page table for the machine for the kernel address</span></span><br><span class=\"line\"><span class=\"comment\">// space for scheduler processes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kvmalloc</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  kpgdir = <span class=\"built_in\">setupkvm</span>();</span><br><span class=\"line\">  switchkvm();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>V2PP2V</p>\n<p></p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/main_page_table.drawio.png\"></p>\n<h3 id=\"kinit22\"><a href=\"#kinit22\" class=\"headerlink\" title=\"kinit22\"></a>kinit22</h3><p>APstartothersBSPAPschedulerkfreeXV6schedulerKERNBASE + 4MKERNBASE + 4Mkmem</p>\n<p>kinit1kinit2KERNBASE + 4MKERNBASE + PHYSTOPkmemfreelist<strong>kalloc</strong></p>\n<p>cpu &amp;  &amp; &amp;&amp; &amp; BSP4K &amp; kmap4K</p>\n<p>XV6</p>\n<h2 id=\"Onix\"><a href=\"#Onix\" class=\"headerlink\" title=\"Onix\"></a>Onix</h2><p>XV6kalloc</p>\n<p>OnixOnixOnixget_page + alloc_kpage + kmallocget_pagepage4G256byte4Gpagealloc_kpagepageOnixOnixbyte1alloc_kpagekmallocpageC++OnixOnix</p>\n<p>OnixOnix</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/onix_memory_map.drawio.png\"></p>\n<p>OnixOnixalloc_kpageget_page</p>\n<p>OnixXV6Onix</p>\n<p><strong>entry</strong>Onix</p>\n<p><img src=\"/2024/06/07/xv6/MemoryManager/photo/memmanager/memory_paging_02.drawio.png\"></p>\n<p>entry0x100712</p>\n<p></p>\n<ol>\n<li><p></p>\n</li>\n<li><p><strong>0xfffff000</strong></p>\n</li>\n</ol>\n<p>MMU0xfffff000</p>\n<p>Onix</p>\n<ul>\n<li><strong>0xFFC00000 | 10</strong></li>\n</ul>\n<p>MMU</p>\n<p>Onix</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">page_entry_t</span> *<span class=\"title\">get_pde</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">page_entry_t</span> *)(<span class=\"number\">0xfffff000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  vaddr vd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">page_entry_t</span> *<span class=\"title\">get_pte</span><span class=\"params\">(u32 vaddr, <span class=\"type\">bool</span> create)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *pde = <span class=\"built_in\">get_pde</span>();</span><br><span class=\"line\">    u32 idx = <span class=\"built_in\">DIDX</span>(vaddr);</span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *entry = &amp;pde[idx];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(create || (!create &amp;&amp; entry-&gt;present));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *table = (<span class=\"type\">page_entry_t</span> *)(PDE_MASK | (idx &lt;&lt; <span class=\"number\">12</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!entry-&gt;present)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">LOGK</span>(<span class=\"string\">&quot;Get and create page table entry for 0x%p\\n&quot;</span>, vaddr);</span><br><span class=\"line\">        u32 page = <span class=\"built_in\">get_page</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//!!!</span></span><br><span class=\"line\">        <span class=\"built_in\">entry_init</span>(entry, <span class=\"built_in\">IDX</span>(page));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(table, <span class=\"number\">0</span>, PAGE_SIZE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">page_entry_t</span> *<span class=\"title\">get_entry</span><span class=\"params\">(u32 vaddr, <span class=\"type\">bool</span> create)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">page_entry_t</span> *pte = <span class=\"built_in\">get_pte</span>(vaddr, create);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;pte[<span class=\"built_in\">TIDX</span>(vaddr)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Unix-likeOnix</p>\n<p></p>\n<p>XV6<a href=\"https://th0ar.gitbooks.io/xv6-chinese/content/\">https://th0ar.gitbooks.io/xv6-chinese/content/</a></p>\n<p>Onix<a href=\"https://github.com/StevenBaby/onix/blob/dev/docs/05%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/041%20%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86.md\">https://github.com/StevenBaby/onix/blob/dev/docs/05%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/041%20%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86.md</a></p>\n<p>CR0<a href=\"https://blog.csdn.net/qq_30528603/article/details/131143850\">https://blog.csdn.net/qq_30528603/article/details/131143850</a></p>\n<hr>\n<p><strong></strong></p>"},{"title":" Onix & XV6 4","date":"2025-09-28T04:00:00.000Z","_content":"\n## \n\nunix\n\n2025-9-16ing ing ing\n\nOnixXV6OnixXV6XV6Onix\n\nlinuxIOIOpipelinux\n\n<!-- more -->\n\nXV6\n\n![](./FileSystem/photo/filesystem/xv6_fs_structure.drawio.png)\n\nOnix\n\n![](./FileSystem/photo/filesystem/onix_fs_structure.drawio.png)\n\nXV6OnixXV6 \n\nOnix IO `struct device_t` io `fs_op_t` Linux\n\n**Onix**\n\n## IO & \n\n- IO: IO\n\n- : IOOnixXV6Onix \n\n### XV6\n\nXV6IOIO  IOide.cIO**IOIOIOIOIO** LevelDBLevelDBWrite[LevelDB1](https://blog.csdn.net/m0_52566365/article/details/137910783)\n\n\n\n![](./FileSystem/photo/filesystem/xv6_ide.drawio.png)\n\n\n\niderw\n\n**iderw**\n\n> 1.  `iderw(struct buf *b)`\n> 2. pushIO\n> 3. IO `idestart`\n> 4. ** IO **\n\n**ideintr**\n\n> 1. IO\n> 2. \n> 3. IO** IO IO `idestart`**\n\n(FCFS)\n\n### Onix\n\nOnixIO IDEIntegrated Drive ElectronicsIDEATAAdvanced Technology AttachmentXV6idestartOnixIOkernel/ide.cOnixIOOnix\n\nOnix\n\n```c\ntypedef struct device_t\n{\n    char name[NAMELEN];  // \n    int type;            // \n    int subtype;         // \n    dev_t dev;           // \n    dev_t parent;        // \n    void *ptr;           // \n    list_t request_list; // \n    bool direct;         // \n\n    // \n    int (*ioctl)(void *dev, int cmd, void *args, int flags);\n    // \n    int (*read)(void *dev, void *buf, size_t count, idx_t idx, int flags);\n    // \n    int (*write)(void *dev, void *buf, size_t count, idx_t idx, int flags);\n} device_t;\n```\n\nIOioctlreadwriteIOIOminixonixIO\n\nOnixIO1024\n\n```c\n// \nenum device_type_t\n{\n    DEV_NULL,  // \n    DEV_CHAR,  // \n    DEV_BLOCK, // \n};\n```\n\n `enum device_subtype_t` \n\nOnixIOXV6IO\n\n```c\n// \nerr_t device_request(dev_t dev, void *buf, u8 count, idx_t idx, int flags, u32 type) {\n    device_t *device = device_get(dev);\n    request_t *req = kmalloc(sizeof(request_t));\n\n    // ...\n\n    // \n    bool empty = list_empty(&device->request_list);\n\n    // \n    list_insert_sort(&device->request_list, &req->node, element_node_offset(request_t, node, idx));\n\n    // \n    if (!empty)\n    {\n        req->task = running_task();\n        assert(task_block(req->task, NULL, TASK_BLOCKED, TIMELESS) == EOK);\n    }\n\n    // do io\n    err_t ret = do_request(req);\n\n    // reqIO\n    request_t *nextreq = request_nextreq(device, req);\n\n    list_remove(&req->node);\n    kfree(req);\n\n    // \n    if (nextreq)\n    {\n        assert(nextreq->task->magic == ONIX_MAGIC);\n        task_unblock(nextreq->task, EOK);\n    }\n\n    return ret;\n}\n```\n\nOnix IO\n\n![](./FileSystem/photo/filesystem/onix_ide.drawio.png)\n\n\n\n> 1. IO `device_request`\n> 2. IOreq\n> 3. req\n> 4. IO\n> 5. IO\n> 6. reqIOreqnext\n> 7. req\n> 8. reqnextreqnext\n\nOnixXV6FCFS\n\n****\n\nOnixrequest_nextreq\n\n```c\n// \nstatic request_t *request_nextreq(device_t *device, request_t *req) {\n    list_t *list = &device->request_list;\n\n    if (device->direct == DIRECT_UP && req->node.next == &list->tail) {\n        device->direct = DIRECT_DOWN;\n    } else if (device->direct == DIRECT_DOWN && req->node.prev == &list->head) {\n        device->direct = DIRECT_UP;\n    }\n\n    void *next = NULL;\n    if (device->direct == DIRECT_UP) {\n        next = req->node.next;\n    } else {\n        next = req->node.prev;\n    }\n\n    if (next == &list->head || next == &list->tail) {\n        return NULL;\n    }\n\n    return element_entry(request_t, node, next);\n}\n```\n\n## \n\nOSXV6512Onix1024IOOnixonix-dev/src/kernel/buffer.c\n\n****LRUCMU154451LRULRU-KLevelDB.sstLRUOnixLRU\n\nOnixLRU\n\nLRU\n\n![](./FileSystem/photo/filesystem/onix_cache.drawio.png)\n\nLRU\n\n-  `idle_list`:  OS0OSLRULRULRU\n- : \n\n\n-  `block1`\n    1.  ` ( ^ ) % ` block1block10\n    2. buffer1\n    3. buffer1\n    4. idle_listbuffer1\n\n    \n    ![](./FileSystem/photo/filesystem/onix_caceh1.drawio.png)\n\n-  `block4`\n    1. idle_listLRUidle_listidle_list buffer3\n    2. buffer3buffer3\n    3. block4buffer3\n    4. block4block41block4\n\n    \n    ![](./FileSystem/photo/filesystem/onix_cache2.drawio.png)\n\n\n1. buffer4\n2. 0idle_listidle_list\n\n    \n    ![](./FileSystem/photo/filesystem/onix_cache3.drawio.png)\n\n## \n\n### \n\nXV6OnixXV6XV6**** \n\nlinuxmysqloracleleveldblinux\n\n i  i \n\nxv6 \n\n\n\n### \n\nXV6\n\n![](./FileSystem/photo/filesystem/xv6_fsstructureondisk.png)\n\n\n\nxv6log.cinitlog\n\n```c\nstruct logheader {\n  int n;\n  int block[LOGSIZE];\n};\n\nstruct log {\n  struct spinlock lock;\n  int start;\n  int size;\n  int outstanding; // how many FS sys calls are executing.\n  int committing;  // in commit(), please wait.\n  int dev;\n  struct logheader lh;\n};\nstruct log log;\n\nvoid\ninitlog(int dev)\n{\n  struct superblock sb;\n  initlock(&log.lock, \"log\");\n  readsb(dev, &sb);\n  log.start = sb.logstart;\n  log.size = sb.nlog;\n  log.dev = dev;\n  recover_from_log();\n}\n```\n\n1.  `sb.logstart`   `sb.nlog`\n\n2. recover_from_logrecover_from_log\n\n    1. read_head\n        ```c\n        struct logheader {\n            int n;\n            int block[LOGSIZE];\n        };\n        ```\n        nblockblock  install_trans\n    2. install_trans\n        ```c\n        // Copy committed blocks from log to their home location\n        static void\n        install_trans(void)\n        {\n        int tail;\n\n        for (tail = 0; tail < log.lh.n; tail++) {\n            struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block\n            struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst\n            memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst\n            bwrite(dbuf);  // write dst to disk\n            brelse(lbuf);\n            brelse(dbuf);\n        }\n        }\n        ```\n        ****\n    3. logheader::n0\n\n\n\n![](./FileSystem/photo/filesystem/xv6_log_structure.drawio.png)\n\n### \n\nlog_writexv6log_writelog_writebegin_opend_oplog_write\n\n1. logheader.block\n2. \n\ncommit\n\n\n\n```c\n// called at the start of each FS system call.\nvoid\nbegin_op(void)\n{\n  acquire(&log.lock);\n  while(1){\n    if(log.committing){\n      sleep(&log, &log.lock);\n    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){\n      // this op might exhaust log space; wait for commit.\n      sleep(&log, &log.lock);\n    } else {\n      log.outstanding += 1;\n      release(&log.lock);\n      break;\n    }\n  }\n}\n\n// called at the end of each FS system call.\n// commits if this was the last outstanding operation.\nvoid\nend_op(void)\n{\n  int do_commit = 0;\n\n  acquire(&log.lock);\n  log.outstanding -= 1;\n  if(log.committing)\n    panic(\"log.committing\");\n  if(log.outstanding == 0){\n    do_commit = 1;\n    log.committing = 1;\n  } else {\n    // begin_op() may be waiting for log space,\n    // and decrementing log.outstanding has decreased\n    // the amount of reserved space.\n    wakeup(&log);\n  }\n  release(&log.lock);\n\n  if(do_commit){\n    // call commit w/o holding locks, since not allowed\n    // to sleep with locks.\n    commit();\n    acquire(&log.lock);\n    log.committing = 0;\n    wakeup(&log);\n    release(&log.lock);\n  }\n}\n```\n\nbegin_opend_op**xv6begin_opend_opbegin_op**ABCABCbegin_op `log.outstanding` 3ABend_op`log.outstanding`0C`log.outstanding` 0begin_opxv6\n\nxv6  X  i  Y  i  i Y  X  i  X  X  xv6 \n\ncommit\n\n```c\nstatic void\ncommit()\n{\n  if (log.lh.n > 0) {\n    write_log();     // Write modified blocks from cache to log\n    write_head();    // Write header to disk -- the real commit\n    install_trans(); // Now install writes to home locations\n    log.lh.n = 0;\n    write_head();    // Erase the transaction from the log\n  }\n}\n```\n\n4\n\n> 1. ****\n> 2. logheader\n> 3. \n> 4. \n\nxv6 \n\n## \n\nOnix Minixlinux\n\n- intfd\n- fd\n- 256Glinux0\n- IOfd\n\n### i\n\ni\n\ni  i i\n\niiii\n\ni\n\n```c\ntypedef struct super_t\n{\n    void *desc;           // \n    struct buffer_t *buf; //  buffer\n    dev_t dev;            // \n    u32 count;            // \n    int type;             // \n    size_t sector_size;   // \n    size_t block_size;    // \n    list_t inode_list;    //  inode \n    inode_t *iroot;       //  inode\n    inode_t *imount;      //  inode\n} super_t;\n\ntypedef struct inode_t\n{\n    list_node_t node; // \n\n    void *desc; // inode  i\n\n    union\n    {\n        struct buffer_t *buf; // inode  buffer\n        void *addr;           // pipe \n    };\n\n    dev_t dev;  // \n    dev_t rdev; // \n\n    idx_t nr;     // i \n    size_t count; // \n\n    time_t atime; // \n    time_t mtime; // \n    time_t ctime; // \n\n    dev_t mount; // \n\n    mode_t mode; // \n    size_t size; // \n    int type;    // \n\n    int uid; //  id\n    int gid; //  id\n\n    struct super_t *super;   // \n    struct fs_op_t *op;      // \n    struct task_t *rxwaiter; // \n    struct task_t *txwaiter; // \n} inode_t;\n```\n\ninode_t::typeonix\n\n```c\nenum\n{\n    FS_TYPE_NONE = 0,\n    FS_TYPE_PIPE,\n    FS_TYPE_SOCKET,\n    FS_TYPE_MINIX,\n    FS_TYPE_NUM,\n};\n```\n\nIOiinode_t `inode_t::desc` iFS_TYPE_MINIXinode_t::desc `minix_inode_t` iiFS_TYPE_SOCKETinode_t::desc `socket_t`iFS_TYPE_PIPEinode_t::desc `fifo_t`\n\nFS_TYPE_MINIXiminix `fs_ops` minix\n\n```c\nstatic fs_op_t minix_op = {\n    minix_mkfs,\n    minix_super,\n\n    minix_open,\n    minix_close,\n\n    minix_read,\n    minix_write,\n    minix_truncate,\n\n    minix_stat,\n    minix_permission,\n\n    minix_namei,\n    minix_mkdir,\n    minix_rmdir,\n    minix_link,\n    minix_unlink,\n    minix_mknod,\n    minix_readdir,\n};\n\nvoid minix_init()\n{\n    fs_register_op(FS_TYPE_MINIX, &minix_op);\n}\n```\n\nminixminixiinode_t::opminix_op\n\nminix\n\n![](./FileSystem/photo/filesystem/onix_fsstructureondisk.drawio.png)\n\n\n\n>|  |  |  |\n>| :-: | :-: | :-: |\n>|  | 1 | i |\n>| i | 2 | i |\n>|  | 2 + super->imap_blocks |  |\n>| i | 2 + super->imap_blocks + super->zmap_blocks | i |\n>|  | minix_super_t::firstdatazone |  |\n\n### i\n\niiiii\n\nii/ i  i  i  i  i n i  i \n\n i  `minix_inode_t` `mode` nlink  i  i size `zone`  **//**  `zone` 0\n\ni\n\n```c\ntypedef struct minix_inode_t\n{\n    u16 mode;    // (rwx )\n    u16 uid;     // id\n    u32 size;    // \n    u32 mtime;   //   UTC \n    u8 gid;      // id()\n    u8 nlinks;   // i \n    u16 zone[9]; //  (0-6)(7) (8) \n} minix_inode_t;\n\ntypedef struct minix_super_t\n{\n    u16 inodes;        // \n    u16 zones;         // \n    u16 imap_blocks;   // i \n    u16 zmap_blocks;   // \n    u16 firstdatazone; // \n    u16 log_zone_size; // log2()\n    u32 max_size;      // \n    u16 magic;         // \n} minix_super_t;\n```\n\ni/ `minix_ialloc`  `minix_ifree`iiitrueminix_ialloci`minix_ifree`  `minix_ialloc` ifalse\n\n```c\n//  inode\nidx_t minix_ialloc(super_t *super)\n{\n    buffer_t *buf = NULL;\n    idx_t bit = EOF;\n    bitmap_t map;\n\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    idx_t bidx = 2;\n    for (size_t i = 0; i < desc->imap_blocks; i++)\n    {\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        bitmap_make(&map, buf->data, BLOCK_BITS, i * BLOCK_BITS);\n        bit = bitmap_scan(&map, 1);\n        if (bit != EOF)\n        {\n            assert(bit < desc->inodes);\n            buf->dirty = true;\n            break;\n        }\n    }\n    brelse(buf); // todo \n    return bit;\n}\n\n//  inode\nvoid minix_ifree(super_t *super, idx_t idx)\n{\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    assert(idx < desc->inodes);\n\n    buffer_t *buf;\n    bitmap_t map;\n\n    idx_t bidx = 2;\n    for (size_t i = 0; i < desc->imap_blocks; i++)\n    {\n        if (idx > BLOCK_BITS * (i + 1))\n        {\n            continue;\n        }\n\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        bitmap_make(&map, buf->data, BLOCK_BITS, i * BLOCK_BITS);\n        assert(bitmap_test(&map, idx));\n        bitmap_set(&map, idx, 0);\n        buf->dirty = true;\n        break;\n    }\n    brelse(buf); // todo \n}\n```\n\ni `iget` **ii**iii `get_free_inode` iiiiiii\n\ni\n\n>- inode_t::desc i\n>- inode::buf iinode::buf i  i inode_t::desci lru\n>- iIOinode_t::rdevminix_inode_t::zone[0]minix_inode_t::zone[0]IO\n>- inode_t::super\n>- inode_t::typeFS_TYPE_MINIX\n>- inode_t::opFS_TYPE_MINIX\n\n\n\n```c\n#define BLOCK_INODES (BLOCK_SIZE / sizeof(minix_inode_t))    // 1 inode\n\n//  inode nr \nstatic inline idx_t inode_block(minix_super_t *desc, idx_t nr) {\n    // inode   1 \n    return 2 + desc->imap_blocks + desc->zmap_blocks + (nr - 1) / BLOCK_INODES;\n}\n\n// ii\nstatic inode_t *iget(dev_t dev, idx_t nr) {\n    inode_t *inode = find_inode(dev, nr);\n    if (inode)\n    {\n        inode->count++;\n        inode->atime = time();\n        return fit_inode(inode);\n    }\n\n    super_t *super = get_super(dev);\n    assert(super);\n\n    minix_super_t *desc = (minix_super_t *)super->desc;\n\n    assert(nr <= desc->inodes);\n\n    inode = get_free_inode();\n    inode->dev = dev;\n    inode->nr = nr;\n    inode->count++;\n\n    //  inode \n    list_push(&super->inode_list, &inode->node);\n\n    idx_t block = inode_block(desc, inode->nr);\n    buffer_t *buf = bread(inode->dev, block);\n\n    inode->buf = buf;\n\n    //  inode \n    inode->desc = &((minix_inode_t *)buf->data)[(inode->nr - 1) % BLOCK_INODES];\n    minix_inode_t *minode = (minix_inode_t *)inode->desc;\n\n    inode->rdev = minode->zone[0];\n\n    inode->mode = minode->mode;\n    inode->size = minode->size;\n    inode->super = super;\n\n    inode->type = FS_TYPE_MINIX;\n    inode->op = fs_get_op(FS_TYPE_MINIX);\n\n    return fit_inode(inode);\n}\n```\n\nigetiputonix-dev/src/fs/inode.ciputiiput minix_close inode_t::countinode::bufii\n\n### \n\noniximinix_inode_t::zone `minix_balloc`  `minix_bfree` \n\n/ i/`minix_ialloc`  `minix_ifree`trueminix_ialloc`minix_bfree`  `minix_balloc` false\n\n\n\n```c\n// \nidx_t minix_balloc(super_t *super)\n{\n    buffer_t *buf = NULL;\n    idx_t bit = EOF;\n    bitmap_t map;\n\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    idx_t bidx = 2 + desc->imap_blocks;\n\n    for (size_t i = 0; i < desc->zmap_blocks; i++)\n    {\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        // \n        bitmap_make(&map, buf->data, BLOCK_SIZE, i * BLOCK_BITS + desc->firstdatazone - 1);\n\n        // \n        bit = bitmap_scan(&map, 1);\n        if (bit != EOF)\n        {\n            //  \n            assert(bit < desc->zones);\n            buf->dirty = true;\n            break;\n        }\n    }\n    brelse(buf); // todo \n    return bit;\n}\n\n// \nvoid minix_bfree(super_t *super, idx_t idx)\n{\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    assert(idx < desc->zones);\n\n    buffer_t *buf;\n    bitmap_t map;\n\n    idx_t bidx = 2 + desc->imap_blocks;\n\n    for (size_t i = 0; i < desc->zmap_blocks; i++)\n    {\n        // \n        if (idx > BLOCK_BITS * (i + 1))\n        {\n            continue;\n        }\n\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        // \n        bitmap_make(&map, buf->data, BLOCK_SIZE, BLOCK_BITS * i + desc->firstdatazone - 1);\n\n        //  idx  0\n        assert(bitmap_test(&map, idx));\n        bitmap_set(&map, idx, 0);\n\n        // \n        buf->dirty = true;\n        break;\n    }\n    brelse(buf); // todo \n}\n```\n\n### \n\nonix `open` iionix\n\nsuper_init\n\n- super_initinodemount_root\n- mount_rootdevread_superdev**i**i\n    ```c\n    // \n    static void mount_root() {\n        LOGK(\"Mount root file system...\\n\");\n        // \n        device_t *device = device_find(DEV_IDE_PART, 0);\n        assert(device);\n\n        // \n        root = read_super(device->dev);\n\n        // i\n        root->imount = root->iroot;\n        root->imount->count++;\n\n        root->iroot->mount = device->dev;\n    }\n    ```\n- read_superdevread_superminix_super\n    ```c\n    //  dev \n    super_t *read_super(dev_t dev) {\n        super_t *super = get_super(dev);\n        if (super) {\n            super->count++;\n            return super;\n        }\n\n        LOGK(\"Reading super block of device %d\\n\", dev);\n\n        // \n        super = get_free_super();\n        super->count++;\n\n        for (size_t i = 1; i < FS_TYPE_NUM; i++) {\n            fs_op_t *op = fs_get_op(i);\n            if (!op)\n                continue;\n            // minix_super\n            if (op->super(dev, super) == EOK) {\n                return super;\n            }\n        }\n\n        put_super(super);\n        return NULL;\n    }\n    ```\n- minix_super 1 1  super_t::descsuper_t::buf iget ii1\n    ```c\n    static int minix_super(dev_t dev, super_t *super) {\n        // \n        buffer_t *buf = bread(dev, 1);\n        if (!buf)\n            return -EFSUNK;\n\n        assert(buf);\n        minix_super_t *desc = (minix_super_t *)buf->data;\n\n        if (desc->magic != MINIX1_MAGIC) {\n            brelse(buf);\n            return -EFSUNK;\n        }\n\n        super->buf = buf;\n        super->desc = desc;\n        super->dev = dev;\n        super->type = FS_TYPE_MINIX;\n        super->block_size = BLOCK_SIZE;\n        super->sector_size = SECTOR_SIZE;\n        super->iroot = iget(dev, 1);\n\n        return EOK;\n    }\n    ```\n\n `super->iroot`  iget  iget \n\n```c\nstatic inode_t *iget(dev_t dev, idx_t nr) {\n    inode_t *inode = find_inode(dev, nr);\n    if (inode) {\n        inode->count++;\n        inode->atime = time();\n        return fit_inode(inode);\n    }\n\n    super_t *super = get_super(dev);\n    assert(super);\n\n    // ...\n    return fit_inode(inode);\n}\n```\n\n iget  minix_superigetiget `super->iroot` \n\n### /\n\nonixopen `O_CREAT | O_TRUNC` openopen `sys_open` \n\n```c\nfd_t sys_open(char *filename, int flags, int mode) {\n    char *next;\n    inode_t *dir = NULL;\n\n    // filenameinext\n    dir = named(filename, &next);\n\n    // /a/b/minixopen\n    if (!*next) {\n        inode = dir;\n        dir->count++;\n        goto makeup;\n    }\n    // minixopen/\n    int ret = dir->op->open(dir, next, flags, mode, &inode);\n\n    // file_t\n    file_t *file;\n    fd_t fd = fd_get(&file);\n\n    file->inode = inode;\n    file->flags = flags;\n    file->count = 1;\n    file->offset = 0;\n    // file\n    if (flags & O_APPEND) {\n        file->offset = file->inode->size;\n    }\n\n    return fd;\n}\n```\n\n> 1. namedfilenameinext\n> 2. /a/b/minixopen4\n> 3. minixopen/i\n> 4. file_t\n> 5. flags `O_APPEND` file\n\nnamedinextnamed\n\n```c\n//  pathname  inode\ninode_t *named(char *pathname, char **next) {\n\n    // ...\n    while (true) {\n        // \n        if (match_name(name, \"..\", next) && dir == dir->super->iroot) {\n            super_t *super = dir->super;\n            inode = super->imount;\n            inode->count++;\n            iput(dir);\n            dir = inode;\n        }\n    }\n    // ...\n}\n```\n\n `name`pathname  `..` iflinux `..`  \"\" \n\nif `sys_mknod`  `sys_mount` onixonix-dev/src/fs/dev.c sys_mknod  sys_mount \n\nonix\n\n\n\n![](./FileSystem/photo/filesystem/onix_mount.drawio.png)\n\nsys_mknodminix_mknodizoneiiirdevminode->zone[0]minix_mknod\n\n```c\nint minix_mknod(inode_t *dir, char *name, int mode, int dev) {\n    // ...\n    // \n    // ...\n    if (ISBLK(mode) || ISCHR(mode))\n        minode->zone[0] = dev;\n\n    // ...\n}\n```\n\nsys_mountsd/dev/sdb1sd `mount /dev/sdb1 /mnt` **sd  iLinuxSDii** onix sys_mount\n\n```c\nint sys_mount(char *devname, char *dirname, int flags) {\n    // i\n    devinode = namei(devname);\n\n    // i\n    dirinode = namei(dirname);\n\n    // \n    super = read_super(devinode->rdev);\n\n    // \n    super->imount = dirinode;\n\n    // \n    dirinode->mount = devinode->rdev;\n    iput(devinode);\n    return EOK;\n}\n```\n\n\n\n> 1. i\n> 2. i\n> 3. \n> 4. \n> 5. \n\nsys_openminix_open\n\n```c\nstatic int minix_open(inode_t *dir, char *name, int flags, int mode, inode_t **result) {\n    minix_dentry_t *entry = NULL;\n\n    // dirnameentry\n    buf = find_entry(dir, name, &next, &entry);\n    if (buf) {\n        //  iiiget\n        inode = iget(dir->dev, entry->nr);\n        assert(inode);\n        goto makeup;\n    } // \n\n    // \n    if (!(flags & O_CREAT)) {\n        ret = -EEXIST;\n        return res;\n    }\n\n    // nameentry\n    buf = add_entry(dir, name, &entry);\n\n    // i\n    entry->nr = minix_ialloc(dir->super);\n\n    // ii\n    inode = new_inode(dir->dev, entry->nr);\n\nmakeup:\n    // \n    *result = inode;\n    return EOK;\n}\n```\n\nsys_openminix_opennamedirnamei\n\n> 1. find_entrydirnameentry ii `makeup` iget\n> 2.  `O_CREAT` \n> 3. add_entrynameentry\n> 4. i\n> 5. ii\n\n `find_entry`  `add_entry`  **** \n\n\n\n![](./FileSystem/photo/filesystem/onix_vfs_structure.drawio.png)\n\n### /\n\ni\n\n **i** iii\n\n![](./FileSystem/photo/filesystem/onix_minix_inode.drawio.png)\n\ni\n\n| i |  |\n| :-: | :-: |\n| minix_inode_t::mode | onix |\n| minix_inode_t::uid | id |\n| minix_inode_t::size | Byte |\n| minix_inode_t::mtime |  |\n| minix_inode_t::gid | id |\n| minix_inode_t::nlinks | i |\n| minix_inode_t::zone | 9uint16_t789 |\n\ni** `minix_inode_t::zone` 0**onix/xv6i  --\n\ni -- 0\n\ni `sys_read`  `sys_write` \n\n `sys_read` \n\n```c\nint sys_read(fd_t fd, char *buf, int count) {\n    // ...\n    if ((ret = fd_check(fd, &file)) < EOK)\n        return ret;\n\n    inode_t *inode = file->inode;\n\n    int len = inode->op->read(inode, buf, count, file->offset);\n\n    if (len > 0)\n        file->offset += len;\n\n    return len;\n}\n```\n\n> 1. fd `file_t` \n> 2. i\n> 3.  minix read \n\nminix read minix_readlenoffset\n\n```c\n//  inode  offset  len  buf\nstatic int minix_read(inode_t *inode, char *data, int len, off_t offset) {\n    minix_inode_t *minode = (minix_inode_t *)inode->desc;\n    if (ISCHR(minode->mode)) {\n        assert(minode->zone[0]);\n        return device_read(minode->zone[0], data, len, 0, 0);\n    } else if (ISBLK(minode->mode)) {\n        assert(minode->zone[0]);\n        device_t *device = device_get(minode->zone[0]);\n        assert(len % BLOCK_SIZE == 0);\n        assert(device_read(minode->zone[0], data, len / BLOCK_SIZE, offset / BLOCK_SIZE, 0) == EOK);\n        return len;\n    }\n\n    assert(ISFILE(minode->mode) || ISDIR(minode->mode));\n\n    //  EOF\n    if (offset >= minode->size) {\n        return EOF;\n    }\n\n    // \n    u32 begin = offset;\n\n    // \n    u32 left = MIN(len, minode->size - offset);\n    while (left) {\n        // \n        idx_t nr = minix_bmap(inode, offset / BLOCK_SIZE, false);\n        assert(nr);\n\n        // \n        buffer_t *buf = bread(inode->dev, nr);\n\n        // \n        u32 start = offset % BLOCK_SIZE;\n\n        // \n        u32 chars = MIN(BLOCK_SIZE - start, left);\n\n        //    \n        offset += chars;\n        left -= chars;\n\n        // \n        char *ptr = buf->data + start;\n\n        // \n        memcpy(data, ptr, chars);\n\n        // \n        data += chars;\n\n        // \n        brelse(buf);\n    }\n\n    // \n    inode->atime = time();\n\n    // \n    return offset - begin;\n}\n```\n\n\n\n> 1. minode->zone[0]/\n> 2. whileminix_bmapizoneoffset\n> 3. \n> 4.  `MIN(BLOCK_SIZE - start, left)` \n> 5. len2~4\n\nminix_bmaponixminix_bmap [ Onix & XV6 2Unix](https://blog.csdn.net/m0_52566365/article/details/139525258)  i offset\n\n> -  offset zone\n> -  offset \n>   - offset\n>   - offset `(offset & 0x7FC00) >> 10` 9uint16_toffset10 `offset & 0x3FF` \n> -  offset \n>   - offset + \n>   - offset `(offset & 0xFF80000) >> 10` 9uint16_t `(offset & 0x7FC00) >> 10` uint16_toffset10 `offset & 0x3FF` \n\n **onixzoneuint16_tonix2^16 - 1 onix 64MB** \n\nonix\n\n### \n\n`find_entry`  `add_entry`  onix\n\n```c\n// \ntypedef struct minix_dentry_t\n{\n    u16 nr;              // i \n    char name[NAME_LEN]; // \n} minix_dentry_t;\n```\n\n\n\n![](./FileSystem/photo/filesystem/onix_dentry.drawio.png)\n\nonixfind_entryfor\n\nadd_entry `nr` 0onixnr0nr0onixminix_rmdir\n\n---\n\n****","source":"_posts/xv6/FileSystem.md","raw":"---\ntitle:  Onix & XV6 4\ndate: 2025-09-28 12:00:00\ntags:\n  - Unix\n---\n\n## \n\nunix\n\n2025-9-16ing ing ing\n\nOnixXV6OnixXV6XV6Onix\n\nlinuxIOIOpipelinux\n\n<!-- more -->\n\nXV6\n\n![](./FileSystem/photo/filesystem/xv6_fs_structure.drawio.png)\n\nOnix\n\n![](./FileSystem/photo/filesystem/onix_fs_structure.drawio.png)\n\nXV6OnixXV6 \n\nOnix IO `struct device_t` io `fs_op_t` Linux\n\n**Onix**\n\n## IO & \n\n- IO: IO\n\n- : IOOnixXV6Onix \n\n### XV6\n\nXV6IOIO  IOide.cIO**IOIOIOIOIO** LevelDBLevelDBWrite[LevelDB1](https://blog.csdn.net/m0_52566365/article/details/137910783)\n\n\n\n![](./FileSystem/photo/filesystem/xv6_ide.drawio.png)\n\n\n\niderw\n\n**iderw**\n\n> 1.  `iderw(struct buf *b)`\n> 2. pushIO\n> 3. IO `idestart`\n> 4. ** IO **\n\n**ideintr**\n\n> 1. IO\n> 2. \n> 3. IO** IO IO `idestart`**\n\n(FCFS)\n\n### Onix\n\nOnixIO IDEIntegrated Drive ElectronicsIDEATAAdvanced Technology AttachmentXV6idestartOnixIOkernel/ide.cOnixIOOnix\n\nOnix\n\n```c\ntypedef struct device_t\n{\n    char name[NAMELEN];  // \n    int type;            // \n    int subtype;         // \n    dev_t dev;           // \n    dev_t parent;        // \n    void *ptr;           // \n    list_t request_list; // \n    bool direct;         // \n\n    // \n    int (*ioctl)(void *dev, int cmd, void *args, int flags);\n    // \n    int (*read)(void *dev, void *buf, size_t count, idx_t idx, int flags);\n    // \n    int (*write)(void *dev, void *buf, size_t count, idx_t idx, int flags);\n} device_t;\n```\n\nIOioctlreadwriteIOIOminixonixIO\n\nOnixIO1024\n\n```c\n// \nenum device_type_t\n{\n    DEV_NULL,  // \n    DEV_CHAR,  // \n    DEV_BLOCK, // \n};\n```\n\n `enum device_subtype_t` \n\nOnixIOXV6IO\n\n```c\n// \nerr_t device_request(dev_t dev, void *buf, u8 count, idx_t idx, int flags, u32 type) {\n    device_t *device = device_get(dev);\n    request_t *req = kmalloc(sizeof(request_t));\n\n    // ...\n\n    // \n    bool empty = list_empty(&device->request_list);\n\n    // \n    list_insert_sort(&device->request_list, &req->node, element_node_offset(request_t, node, idx));\n\n    // \n    if (!empty)\n    {\n        req->task = running_task();\n        assert(task_block(req->task, NULL, TASK_BLOCKED, TIMELESS) == EOK);\n    }\n\n    // do io\n    err_t ret = do_request(req);\n\n    // reqIO\n    request_t *nextreq = request_nextreq(device, req);\n\n    list_remove(&req->node);\n    kfree(req);\n\n    // \n    if (nextreq)\n    {\n        assert(nextreq->task->magic == ONIX_MAGIC);\n        task_unblock(nextreq->task, EOK);\n    }\n\n    return ret;\n}\n```\n\nOnix IO\n\n![](./FileSystem/photo/filesystem/onix_ide.drawio.png)\n\n\n\n> 1. IO `device_request`\n> 2. IOreq\n> 3. req\n> 4. IO\n> 5. IO\n> 6. reqIOreqnext\n> 7. req\n> 8. reqnextreqnext\n\nOnixXV6FCFS\n\n****\n\nOnixrequest_nextreq\n\n```c\n// \nstatic request_t *request_nextreq(device_t *device, request_t *req) {\n    list_t *list = &device->request_list;\n\n    if (device->direct == DIRECT_UP && req->node.next == &list->tail) {\n        device->direct = DIRECT_DOWN;\n    } else if (device->direct == DIRECT_DOWN && req->node.prev == &list->head) {\n        device->direct = DIRECT_UP;\n    }\n\n    void *next = NULL;\n    if (device->direct == DIRECT_UP) {\n        next = req->node.next;\n    } else {\n        next = req->node.prev;\n    }\n\n    if (next == &list->head || next == &list->tail) {\n        return NULL;\n    }\n\n    return element_entry(request_t, node, next);\n}\n```\n\n## \n\nOSXV6512Onix1024IOOnixonix-dev/src/kernel/buffer.c\n\n****LRUCMU154451LRULRU-KLevelDB.sstLRUOnixLRU\n\nOnixLRU\n\nLRU\n\n![](./FileSystem/photo/filesystem/onix_cache.drawio.png)\n\nLRU\n\n-  `idle_list`:  OS0OSLRULRULRU\n- : \n\n\n-  `block1`\n    1.  ` ( ^ ) % ` block1block10\n    2. buffer1\n    3. buffer1\n    4. idle_listbuffer1\n\n    \n    ![](./FileSystem/photo/filesystem/onix_caceh1.drawio.png)\n\n-  `block4`\n    1. idle_listLRUidle_listidle_list buffer3\n    2. buffer3buffer3\n    3. block4buffer3\n    4. block4block41block4\n\n    \n    ![](./FileSystem/photo/filesystem/onix_cache2.drawio.png)\n\n\n1. buffer4\n2. 0idle_listidle_list\n\n    \n    ![](./FileSystem/photo/filesystem/onix_cache3.drawio.png)\n\n## \n\n### \n\nXV6OnixXV6XV6**** \n\nlinuxmysqloracleleveldblinux\n\n i  i \n\nxv6 \n\n\n\n### \n\nXV6\n\n![](./FileSystem/photo/filesystem/xv6_fsstructureondisk.png)\n\n\n\nxv6log.cinitlog\n\n```c\nstruct logheader {\n  int n;\n  int block[LOGSIZE];\n};\n\nstruct log {\n  struct spinlock lock;\n  int start;\n  int size;\n  int outstanding; // how many FS sys calls are executing.\n  int committing;  // in commit(), please wait.\n  int dev;\n  struct logheader lh;\n};\nstruct log log;\n\nvoid\ninitlog(int dev)\n{\n  struct superblock sb;\n  initlock(&log.lock, \"log\");\n  readsb(dev, &sb);\n  log.start = sb.logstart;\n  log.size = sb.nlog;\n  log.dev = dev;\n  recover_from_log();\n}\n```\n\n1.  `sb.logstart`   `sb.nlog`\n\n2. recover_from_logrecover_from_log\n\n    1. read_head\n        ```c\n        struct logheader {\n            int n;\n            int block[LOGSIZE];\n        };\n        ```\n        nblockblock  install_trans\n    2. install_trans\n        ```c\n        // Copy committed blocks from log to their home location\n        static void\n        install_trans(void)\n        {\n        int tail;\n\n        for (tail = 0; tail < log.lh.n; tail++) {\n            struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block\n            struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst\n            memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst\n            bwrite(dbuf);  // write dst to disk\n            brelse(lbuf);\n            brelse(dbuf);\n        }\n        }\n        ```\n        ****\n    3. logheader::n0\n\n\n\n![](./FileSystem/photo/filesystem/xv6_log_structure.drawio.png)\n\n### \n\nlog_writexv6log_writelog_writebegin_opend_oplog_write\n\n1. logheader.block\n2. \n\ncommit\n\n\n\n```c\n// called at the start of each FS system call.\nvoid\nbegin_op(void)\n{\n  acquire(&log.lock);\n  while(1){\n    if(log.committing){\n      sleep(&log, &log.lock);\n    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){\n      // this op might exhaust log space; wait for commit.\n      sleep(&log, &log.lock);\n    } else {\n      log.outstanding += 1;\n      release(&log.lock);\n      break;\n    }\n  }\n}\n\n// called at the end of each FS system call.\n// commits if this was the last outstanding operation.\nvoid\nend_op(void)\n{\n  int do_commit = 0;\n\n  acquire(&log.lock);\n  log.outstanding -= 1;\n  if(log.committing)\n    panic(\"log.committing\");\n  if(log.outstanding == 0){\n    do_commit = 1;\n    log.committing = 1;\n  } else {\n    // begin_op() may be waiting for log space,\n    // and decrementing log.outstanding has decreased\n    // the amount of reserved space.\n    wakeup(&log);\n  }\n  release(&log.lock);\n\n  if(do_commit){\n    // call commit w/o holding locks, since not allowed\n    // to sleep with locks.\n    commit();\n    acquire(&log.lock);\n    log.committing = 0;\n    wakeup(&log);\n    release(&log.lock);\n  }\n}\n```\n\nbegin_opend_op**xv6begin_opend_opbegin_op**ABCABCbegin_op `log.outstanding` 3ABend_op`log.outstanding`0C`log.outstanding` 0begin_opxv6\n\nxv6  X  i  Y  i  i Y  X  i  X  X  xv6 \n\ncommit\n\n```c\nstatic void\ncommit()\n{\n  if (log.lh.n > 0) {\n    write_log();     // Write modified blocks from cache to log\n    write_head();    // Write header to disk -- the real commit\n    install_trans(); // Now install writes to home locations\n    log.lh.n = 0;\n    write_head();    // Erase the transaction from the log\n  }\n}\n```\n\n4\n\n> 1. ****\n> 2. logheader\n> 3. \n> 4. \n\nxv6 \n\n## \n\nOnix Minixlinux\n\n- intfd\n- fd\n- 256Glinux0\n- IOfd\n\n### i\n\ni\n\ni  i i\n\niiii\n\ni\n\n```c\ntypedef struct super_t\n{\n    void *desc;           // \n    struct buffer_t *buf; //  buffer\n    dev_t dev;            // \n    u32 count;            // \n    int type;             // \n    size_t sector_size;   // \n    size_t block_size;    // \n    list_t inode_list;    //  inode \n    inode_t *iroot;       //  inode\n    inode_t *imount;      //  inode\n} super_t;\n\ntypedef struct inode_t\n{\n    list_node_t node; // \n\n    void *desc; // inode  i\n\n    union\n    {\n        struct buffer_t *buf; // inode  buffer\n        void *addr;           // pipe \n    };\n\n    dev_t dev;  // \n    dev_t rdev; // \n\n    idx_t nr;     // i \n    size_t count; // \n\n    time_t atime; // \n    time_t mtime; // \n    time_t ctime; // \n\n    dev_t mount; // \n\n    mode_t mode; // \n    size_t size; // \n    int type;    // \n\n    int uid; //  id\n    int gid; //  id\n\n    struct super_t *super;   // \n    struct fs_op_t *op;      // \n    struct task_t *rxwaiter; // \n    struct task_t *txwaiter; // \n} inode_t;\n```\n\ninode_t::typeonix\n\n```c\nenum\n{\n    FS_TYPE_NONE = 0,\n    FS_TYPE_PIPE,\n    FS_TYPE_SOCKET,\n    FS_TYPE_MINIX,\n    FS_TYPE_NUM,\n};\n```\n\nIOiinode_t `inode_t::desc` iFS_TYPE_MINIXinode_t::desc `minix_inode_t` iiFS_TYPE_SOCKETinode_t::desc `socket_t`iFS_TYPE_PIPEinode_t::desc `fifo_t`\n\nFS_TYPE_MINIXiminix `fs_ops` minix\n\n```c\nstatic fs_op_t minix_op = {\n    minix_mkfs,\n    minix_super,\n\n    minix_open,\n    minix_close,\n\n    minix_read,\n    minix_write,\n    minix_truncate,\n\n    minix_stat,\n    minix_permission,\n\n    minix_namei,\n    minix_mkdir,\n    minix_rmdir,\n    minix_link,\n    minix_unlink,\n    minix_mknod,\n    minix_readdir,\n};\n\nvoid minix_init()\n{\n    fs_register_op(FS_TYPE_MINIX, &minix_op);\n}\n```\n\nminixminixiinode_t::opminix_op\n\nminix\n\n![](./FileSystem/photo/filesystem/onix_fsstructureondisk.drawio.png)\n\n\n\n>|  |  |  |\n>| :-: | :-: | :-: |\n>|  | 1 | i |\n>| i | 2 | i |\n>|  | 2 + super->imap_blocks |  |\n>| i | 2 + super->imap_blocks + super->zmap_blocks | i |\n>|  | minix_super_t::firstdatazone |  |\n\n### i\n\niiiii\n\nii/ i  i  i  i  i n i  i \n\n i  `minix_inode_t` `mode` nlink  i  i size `zone`  **//**  `zone` 0\n\ni\n\n```c\ntypedef struct minix_inode_t\n{\n    u16 mode;    // (rwx )\n    u16 uid;     // id\n    u32 size;    // \n    u32 mtime;   //   UTC \n    u8 gid;      // id()\n    u8 nlinks;   // i \n    u16 zone[9]; //  (0-6)(7) (8) \n} minix_inode_t;\n\ntypedef struct minix_super_t\n{\n    u16 inodes;        // \n    u16 zones;         // \n    u16 imap_blocks;   // i \n    u16 zmap_blocks;   // \n    u16 firstdatazone; // \n    u16 log_zone_size; // log2()\n    u32 max_size;      // \n    u16 magic;         // \n} minix_super_t;\n```\n\ni/ `minix_ialloc`  `minix_ifree`iiitrueminix_ialloci`minix_ifree`  `minix_ialloc` ifalse\n\n```c\n//  inode\nidx_t minix_ialloc(super_t *super)\n{\n    buffer_t *buf = NULL;\n    idx_t bit = EOF;\n    bitmap_t map;\n\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    idx_t bidx = 2;\n    for (size_t i = 0; i < desc->imap_blocks; i++)\n    {\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        bitmap_make(&map, buf->data, BLOCK_BITS, i * BLOCK_BITS);\n        bit = bitmap_scan(&map, 1);\n        if (bit != EOF)\n        {\n            assert(bit < desc->inodes);\n            buf->dirty = true;\n            break;\n        }\n    }\n    brelse(buf); // todo \n    return bit;\n}\n\n//  inode\nvoid minix_ifree(super_t *super, idx_t idx)\n{\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    assert(idx < desc->inodes);\n\n    buffer_t *buf;\n    bitmap_t map;\n\n    idx_t bidx = 2;\n    for (size_t i = 0; i < desc->imap_blocks; i++)\n    {\n        if (idx > BLOCK_BITS * (i + 1))\n        {\n            continue;\n        }\n\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        bitmap_make(&map, buf->data, BLOCK_BITS, i * BLOCK_BITS);\n        assert(bitmap_test(&map, idx));\n        bitmap_set(&map, idx, 0);\n        buf->dirty = true;\n        break;\n    }\n    brelse(buf); // todo \n}\n```\n\ni `iget` **ii**iii `get_free_inode` iiiiiii\n\ni\n\n>- inode_t::desc i\n>- inode::buf iinode::buf i  i inode_t::desci lru\n>- iIOinode_t::rdevminix_inode_t::zone[0]minix_inode_t::zone[0]IO\n>- inode_t::super\n>- inode_t::typeFS_TYPE_MINIX\n>- inode_t::opFS_TYPE_MINIX\n\n\n\n```c\n#define BLOCK_INODES (BLOCK_SIZE / sizeof(minix_inode_t))    // 1 inode\n\n//  inode nr \nstatic inline idx_t inode_block(minix_super_t *desc, idx_t nr) {\n    // inode   1 \n    return 2 + desc->imap_blocks + desc->zmap_blocks + (nr - 1) / BLOCK_INODES;\n}\n\n// ii\nstatic inode_t *iget(dev_t dev, idx_t nr) {\n    inode_t *inode = find_inode(dev, nr);\n    if (inode)\n    {\n        inode->count++;\n        inode->atime = time();\n        return fit_inode(inode);\n    }\n\n    super_t *super = get_super(dev);\n    assert(super);\n\n    minix_super_t *desc = (minix_super_t *)super->desc;\n\n    assert(nr <= desc->inodes);\n\n    inode = get_free_inode();\n    inode->dev = dev;\n    inode->nr = nr;\n    inode->count++;\n\n    //  inode \n    list_push(&super->inode_list, &inode->node);\n\n    idx_t block = inode_block(desc, inode->nr);\n    buffer_t *buf = bread(inode->dev, block);\n\n    inode->buf = buf;\n\n    //  inode \n    inode->desc = &((minix_inode_t *)buf->data)[(inode->nr - 1) % BLOCK_INODES];\n    minix_inode_t *minode = (minix_inode_t *)inode->desc;\n\n    inode->rdev = minode->zone[0];\n\n    inode->mode = minode->mode;\n    inode->size = minode->size;\n    inode->super = super;\n\n    inode->type = FS_TYPE_MINIX;\n    inode->op = fs_get_op(FS_TYPE_MINIX);\n\n    return fit_inode(inode);\n}\n```\n\nigetiputonix-dev/src/fs/inode.ciputiiput minix_close inode_t::countinode::bufii\n\n### \n\noniximinix_inode_t::zone `minix_balloc`  `minix_bfree` \n\n/ i/`minix_ialloc`  `minix_ifree`trueminix_ialloc`minix_bfree`  `minix_balloc` false\n\n\n\n```c\n// \nidx_t minix_balloc(super_t *super)\n{\n    buffer_t *buf = NULL;\n    idx_t bit = EOF;\n    bitmap_t map;\n\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    idx_t bidx = 2 + desc->imap_blocks;\n\n    for (size_t i = 0; i < desc->zmap_blocks; i++)\n    {\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        // \n        bitmap_make(&map, buf->data, BLOCK_SIZE, i * BLOCK_BITS + desc->firstdatazone - 1);\n\n        // \n        bit = bitmap_scan(&map, 1);\n        if (bit != EOF)\n        {\n            //  \n            assert(bit < desc->zones);\n            buf->dirty = true;\n            break;\n        }\n    }\n    brelse(buf); // todo \n    return bit;\n}\n\n// \nvoid minix_bfree(super_t *super, idx_t idx)\n{\n    minix_super_t *desc = (minix_super_t *)super->desc;\n    assert(idx < desc->zones);\n\n    buffer_t *buf;\n    bitmap_t map;\n\n    idx_t bidx = 2 + desc->imap_blocks;\n\n    for (size_t i = 0; i < desc->zmap_blocks; i++)\n    {\n        // \n        if (idx > BLOCK_BITS * (i + 1))\n        {\n            continue;\n        }\n\n        buf = bread(super->dev, bidx + i);\n        assert(buf);\n\n        // \n        bitmap_make(&map, buf->data, BLOCK_SIZE, BLOCK_BITS * i + desc->firstdatazone - 1);\n\n        //  idx  0\n        assert(bitmap_test(&map, idx));\n        bitmap_set(&map, idx, 0);\n\n        // \n        buf->dirty = true;\n        break;\n    }\n    brelse(buf); // todo \n}\n```\n\n### \n\nonix `open` iionix\n\nsuper_init\n\n- super_initinodemount_root\n- mount_rootdevread_superdev**i**i\n    ```c\n    // \n    static void mount_root() {\n        LOGK(\"Mount root file system...\\n\");\n        // \n        device_t *device = device_find(DEV_IDE_PART, 0);\n        assert(device);\n\n        // \n        root = read_super(device->dev);\n\n        // i\n        root->imount = root->iroot;\n        root->imount->count++;\n\n        root->iroot->mount = device->dev;\n    }\n    ```\n- read_superdevread_superminix_super\n    ```c\n    //  dev \n    super_t *read_super(dev_t dev) {\n        super_t *super = get_super(dev);\n        if (super) {\n            super->count++;\n            return super;\n        }\n\n        LOGK(\"Reading super block of device %d\\n\", dev);\n\n        // \n        super = get_free_super();\n        super->count++;\n\n        for (size_t i = 1; i < FS_TYPE_NUM; i++) {\n            fs_op_t *op = fs_get_op(i);\n            if (!op)\n                continue;\n            // minix_super\n            if (op->super(dev, super) == EOK) {\n                return super;\n            }\n        }\n\n        put_super(super);\n        return NULL;\n    }\n    ```\n- minix_super 1 1  super_t::descsuper_t::buf iget ii1\n    ```c\n    static int minix_super(dev_t dev, super_t *super) {\n        // \n        buffer_t *buf = bread(dev, 1);\n        if (!buf)\n            return -EFSUNK;\n\n        assert(buf);\n        minix_super_t *desc = (minix_super_t *)buf->data;\n\n        if (desc->magic != MINIX1_MAGIC) {\n            brelse(buf);\n            return -EFSUNK;\n        }\n\n        super->buf = buf;\n        super->desc = desc;\n        super->dev = dev;\n        super->type = FS_TYPE_MINIX;\n        super->block_size = BLOCK_SIZE;\n        super->sector_size = SECTOR_SIZE;\n        super->iroot = iget(dev, 1);\n\n        return EOK;\n    }\n    ```\n\n `super->iroot`  iget  iget \n\n```c\nstatic inode_t *iget(dev_t dev, idx_t nr) {\n    inode_t *inode = find_inode(dev, nr);\n    if (inode) {\n        inode->count++;\n        inode->atime = time();\n        return fit_inode(inode);\n    }\n\n    super_t *super = get_super(dev);\n    assert(super);\n\n    // ...\n    return fit_inode(inode);\n}\n```\n\n iget  minix_superigetiget `super->iroot` \n\n### /\n\nonixopen `O_CREAT | O_TRUNC` openopen `sys_open` \n\n```c\nfd_t sys_open(char *filename, int flags, int mode) {\n    char *next;\n    inode_t *dir = NULL;\n\n    // filenameinext\n    dir = named(filename, &next);\n\n    // /a/b/minixopen\n    if (!*next) {\n        inode = dir;\n        dir->count++;\n        goto makeup;\n    }\n    // minixopen/\n    int ret = dir->op->open(dir, next, flags, mode, &inode);\n\n    // file_t\n    file_t *file;\n    fd_t fd = fd_get(&file);\n\n    file->inode = inode;\n    file->flags = flags;\n    file->count = 1;\n    file->offset = 0;\n    // file\n    if (flags & O_APPEND) {\n        file->offset = file->inode->size;\n    }\n\n    return fd;\n}\n```\n\n> 1. namedfilenameinext\n> 2. /a/b/minixopen4\n> 3. minixopen/i\n> 4. file_t\n> 5. flags `O_APPEND` file\n\nnamedinextnamed\n\n```c\n//  pathname  inode\ninode_t *named(char *pathname, char **next) {\n\n    // ...\n    while (true) {\n        // \n        if (match_name(name, \"..\", next) && dir == dir->super->iroot) {\n            super_t *super = dir->super;\n            inode = super->imount;\n            inode->count++;\n            iput(dir);\n            dir = inode;\n        }\n    }\n    // ...\n}\n```\n\n `name`pathname  `..` iflinux `..`  \"\" \n\nif `sys_mknod`  `sys_mount` onixonix-dev/src/fs/dev.c sys_mknod  sys_mount \n\nonix\n\n\n\n![](./FileSystem/photo/filesystem/onix_mount.drawio.png)\n\nsys_mknodminix_mknodizoneiiirdevminode->zone[0]minix_mknod\n\n```c\nint minix_mknod(inode_t *dir, char *name, int mode, int dev) {\n    // ...\n    // \n    // ...\n    if (ISBLK(mode) || ISCHR(mode))\n        minode->zone[0] = dev;\n\n    // ...\n}\n```\n\nsys_mountsd/dev/sdb1sd `mount /dev/sdb1 /mnt` **sd  iLinuxSDii** onix sys_mount\n\n```c\nint sys_mount(char *devname, char *dirname, int flags) {\n    // i\n    devinode = namei(devname);\n\n    // i\n    dirinode = namei(dirname);\n\n    // \n    super = read_super(devinode->rdev);\n\n    // \n    super->imount = dirinode;\n\n    // \n    dirinode->mount = devinode->rdev;\n    iput(devinode);\n    return EOK;\n}\n```\n\n\n\n> 1. i\n> 2. i\n> 3. \n> 4. \n> 5. \n\nsys_openminix_open\n\n```c\nstatic int minix_open(inode_t *dir, char *name, int flags, int mode, inode_t **result) {\n    minix_dentry_t *entry = NULL;\n\n    // dirnameentry\n    buf = find_entry(dir, name, &next, &entry);\n    if (buf) {\n        //  iiiget\n        inode = iget(dir->dev, entry->nr);\n        assert(inode);\n        goto makeup;\n    } // \n\n    // \n    if (!(flags & O_CREAT)) {\n        ret = -EEXIST;\n        return res;\n    }\n\n    // nameentry\n    buf = add_entry(dir, name, &entry);\n\n    // i\n    entry->nr = minix_ialloc(dir->super);\n\n    // ii\n    inode = new_inode(dir->dev, entry->nr);\n\nmakeup:\n    // \n    *result = inode;\n    return EOK;\n}\n```\n\nsys_openminix_opennamedirnamei\n\n> 1. find_entrydirnameentry ii `makeup` iget\n> 2.  `O_CREAT` \n> 3. add_entrynameentry\n> 4. i\n> 5. ii\n\n `find_entry`  `add_entry`  **** \n\n\n\n![](./FileSystem/photo/filesystem/onix_vfs_structure.drawio.png)\n\n### /\n\ni\n\n **i** iii\n\n![](./FileSystem/photo/filesystem/onix_minix_inode.drawio.png)\n\ni\n\n| i |  |\n| :-: | :-: |\n| minix_inode_t::mode | onix |\n| minix_inode_t::uid | id |\n| minix_inode_t::size | Byte |\n| minix_inode_t::mtime |  |\n| minix_inode_t::gid | id |\n| minix_inode_t::nlinks | i |\n| minix_inode_t::zone | 9uint16_t789 |\n\ni** `minix_inode_t::zone` 0**onix/xv6i  --\n\ni -- 0\n\ni `sys_read`  `sys_write` \n\n `sys_read` \n\n```c\nint sys_read(fd_t fd, char *buf, int count) {\n    // ...\n    if ((ret = fd_check(fd, &file)) < EOK)\n        return ret;\n\n    inode_t *inode = file->inode;\n\n    int len = inode->op->read(inode, buf, count, file->offset);\n\n    if (len > 0)\n        file->offset += len;\n\n    return len;\n}\n```\n\n> 1. fd `file_t` \n> 2. i\n> 3.  minix read \n\nminix read minix_readlenoffset\n\n```c\n//  inode  offset  len  buf\nstatic int minix_read(inode_t *inode, char *data, int len, off_t offset) {\n    minix_inode_t *minode = (minix_inode_t *)inode->desc;\n    if (ISCHR(minode->mode)) {\n        assert(minode->zone[0]);\n        return device_read(minode->zone[0], data, len, 0, 0);\n    } else if (ISBLK(minode->mode)) {\n        assert(minode->zone[0]);\n        device_t *device = device_get(minode->zone[0]);\n        assert(len % BLOCK_SIZE == 0);\n        assert(device_read(minode->zone[0], data, len / BLOCK_SIZE, offset / BLOCK_SIZE, 0) == EOK);\n        return len;\n    }\n\n    assert(ISFILE(minode->mode) || ISDIR(minode->mode));\n\n    //  EOF\n    if (offset >= minode->size) {\n        return EOF;\n    }\n\n    // \n    u32 begin = offset;\n\n    // \n    u32 left = MIN(len, minode->size - offset);\n    while (left) {\n        // \n        idx_t nr = minix_bmap(inode, offset / BLOCK_SIZE, false);\n        assert(nr);\n\n        // \n        buffer_t *buf = bread(inode->dev, nr);\n\n        // \n        u32 start = offset % BLOCK_SIZE;\n\n        // \n        u32 chars = MIN(BLOCK_SIZE - start, left);\n\n        //    \n        offset += chars;\n        left -= chars;\n\n        // \n        char *ptr = buf->data + start;\n\n        // \n        memcpy(data, ptr, chars);\n\n        // \n        data += chars;\n\n        // \n        brelse(buf);\n    }\n\n    // \n    inode->atime = time();\n\n    // \n    return offset - begin;\n}\n```\n\n\n\n> 1. minode->zone[0]/\n> 2. whileminix_bmapizoneoffset\n> 3. \n> 4.  `MIN(BLOCK_SIZE - start, left)` \n> 5. len2~4\n\nminix_bmaponixminix_bmap [ Onix & XV6 2Unix](https://blog.csdn.net/m0_52566365/article/details/139525258)  i offset\n\n> -  offset zone\n> -  offset \n>   - offset\n>   - offset `(offset & 0x7FC00) >> 10` 9uint16_toffset10 `offset & 0x3FF` \n> -  offset \n>   - offset + \n>   - offset `(offset & 0xFF80000) >> 10` 9uint16_t `(offset & 0x7FC00) >> 10` uint16_toffset10 `offset & 0x3FF` \n\n **onixzoneuint16_tonix2^16 - 1 onix 64MB** \n\nonix\n\n### \n\n`find_entry`  `add_entry`  onix\n\n```c\n// \ntypedef struct minix_dentry_t\n{\n    u16 nr;              // i \n    char name[NAME_LEN]; // \n} minix_dentry_t;\n```\n\n\n\n![](./FileSystem/photo/filesystem/onix_dentry.drawio.png)\n\nonixfind_entryfor\n\nadd_entry `nr` 0onixnr0nr0onixminix_rmdir\n\n---\n\n****","slug":"xv6/FileSystem","published":1,"updated":"2025-09-28T15:01:19.926Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9u0014q8ws9y7072z2","content":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>unix</p>\n<p>2025-9-16ing ing ing</p>\n<p>OnixXV6OnixXV6XV6Onix</p>\n<p>linuxIOIOpipelinux</p>\n<span id=\"more\"></span>\n\n<p>XV6</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio.png\"></p>\n<p>Onix</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio.png\"></p>\n<p>XV6OnixXV6 </p>\n<p>Onix IO <code>struct device_t</code> io <code>fs_op_t</code> Linux</p>\n<p><strong>Onix</strong></p>\n<h2 id=\"IO-\"><a href=\"#IO-\" class=\"headerlink\" title=\"IO &amp; \"></a>IO &amp; </h2><ul>\n<li><p>IO: IO</p>\n</li>\n<li><p>: IOOnixXV6Onix</p>\n</li>\n</ul>\n<h3 id=\"XV6\"><a href=\"#XV6\" class=\"headerlink\" title=\"XV6\"></a>XV6</h3><p>XV6IOIO  IOide.cIO<strong>IOIOIOIOIO</strong> LevelDBLevelDBWrite<a href=\"https://blog.csdn.net/m0_52566365/article/details/137910783\">LevelDB1</a></p>\n<p></p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_ide.drawio.png\"></p>\n<p></p>\n<p>iderw</p>\n<p><strong>iderw</strong></p>\n<blockquote>\n<ol>\n<li> <code>iderw(struct buf *b)</code></li>\n<li>pushIO</li>\n<li>IO <code>idestart</code></li>\n<li><strong> IO </strong></li>\n</ol>\n</blockquote>\n<p><strong>ideintr</strong></p>\n<blockquote>\n<ol>\n<li>IO</li>\n<li></li>\n<li>IO<strong> IO IO <code>idestart</code></strong></li>\n</ol>\n</blockquote>\n<p>(FCFS)</p>\n<h3 id=\"Onix\"><a href=\"#Onix\" class=\"headerlink\" title=\"Onix\"></a>Onix</h3><p>OnixIO IDEIntegrated Drive ElectronicsIDEATAAdvanced Technology AttachmentXV6idestartOnixIOkernel&#x2F;ide.cOnixIOOnix</p>\n<p>Onix</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> name[NAMELEN];  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> type;            <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> subtype;         <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> dev;           <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> parent;        <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">void</span> *ptr;           <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">list_t</span> request_list; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> direct;         <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*ioctl)(<span class=\"type\">void</span> *dev, <span class=\"type\">int</span> cmd, <span class=\"type\">void</span> *args, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*read)(<span class=\"type\">void</span> *dev, <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> count, <span class=\"type\">idx_t</span> idx, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*write)(<span class=\"type\">void</span> *dev, <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> count, <span class=\"type\">idx_t</span> idx, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">&#125; <span class=\"type\">device_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>IOioctlreadwriteIOIOminixonixIO</p>\n<p>OnixIO1024</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">device_type_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    DEV_NULL,  <span class=\"comment\">// </span></span><br><span class=\"line\">    DEV_CHAR,  <span class=\"comment\">// </span></span><br><span class=\"line\">    DEV_BLOCK, <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p> <code>enum device_subtype_t</code> </p>\n<p>OnixIOXV6IO</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"type\">err_t</span> <span class=\"title function_\">device_request</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">void</span> *buf, u8 count, <span class=\"type\">idx_t</span> idx, <span class=\"type\">int</span> flags, u32 type)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">device_t</span> *device = device_get(dev);</span><br><span class=\"line\">    <span class=\"type\">request_t</span> *req = kmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"type\">request_t</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> empty = list_empty(&amp;device-&gt;request_list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    list_insert_sort(&amp;device-&gt;request_list, &amp;req-&gt;node, element_node_offset(<span class=\"type\">request_t</span>, node, idx));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!empty)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        req-&gt;task = running_task();</span><br><span class=\"line\">        assert(task_block(req-&gt;task, <span class=\"literal\">NULL</span>, TASK_BLOCKED, TIMELESS) == EOK);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// do io</span></span><br><span class=\"line\">    <span class=\"type\">err_t</span> ret = do_request(req);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// reqIO</span></span><br><span class=\"line\">    <span class=\"type\">request_t</span> *nextreq = request_nextreq(device, req);</span><br><span class=\"line\"></span><br><span class=\"line\">    list_remove(&amp;req-&gt;node);</span><br><span class=\"line\">    kfree(req);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextreq)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        assert(nextreq-&gt;task-&gt;magic == ONIX_MAGIC);</span><br><span class=\"line\">        task_unblock(nextreq-&gt;task, EOK);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Onix IO</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_ide.drawio.png\"></p>\n<p></p>\n<blockquote>\n<ol>\n<li>IO <code>device_request</code></li>\n<li>IOreq</li>\n<li>req</li>\n<li>IO</li>\n<li>IO</li>\n<li>reqIOreqnext</li>\n<li>req</li>\n<li>reqnextreqnext</li>\n</ol>\n</blockquote>\n<p>OnixXV6FCFS</p>\n<p><strong></strong></p>\n<p>Onixrequest_nextreq</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">request_t</span> *<span class=\"title function_\">request_nextreq</span><span class=\"params\">(<span class=\"type\">device_t</span> *device, <span class=\"type\">request_t</span> *req)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">list_t</span> *<span class=\"built_in\">list</span> = &amp;device-&gt;request_list;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (device-&gt;direct == DIRECT_UP &amp;&amp; req-&gt;node.next == &amp;<span class=\"built_in\">list</span>-&gt;tail) &#123;</span><br><span class=\"line\">        device-&gt;direct = DIRECT_DOWN;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (device-&gt;direct == DIRECT_DOWN &amp;&amp; req-&gt;node.prev == &amp;<span class=\"built_in\">list</span>-&gt;head) &#123;</span><br><span class=\"line\">        device-&gt;direct = DIRECT_UP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">void</span> *next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (device-&gt;direct == DIRECT_UP) &#123;</span><br><span class=\"line\">        next = req-&gt;node.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        next = req-&gt;node.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == &amp;<span class=\"built_in\">list</span>-&gt;head || next == &amp;<span class=\"built_in\">list</span>-&gt;tail) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> element_entry(<span class=\"type\">request_t</span>, node, next);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>OSXV6512Onix1024IOOnixonix-dev&#x2F;src&#x2F;kernel&#x2F;buffer.c</p>\n<p><strong></strong>LRUCMU154451LRULRU-KLevelDB.sstLRUOnixLRU</p>\n<p>OnixLRU</p>\n<p>LRU</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache.drawio.png\"></p>\n<p>LRU</p>\n<ul>\n<li> <code>idle_list</code>:  OS0OSLRULRULRU</li>\n<li>: </li>\n</ul>\n<p></p>\n<ul>\n<li><p> <code>block1</code></p>\n<ol>\n<li> <code> ( ^ ) % </code> block1block10</li>\n<li>buffer1</li>\n<li>buffer1</li>\n<li>idle_listbuffer1</li>\n</ol>\n<p>  <br>  <img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio.png\"></p>\n</li>\n<li><p> <code>block4</code></p>\n<ol>\n<li>idle_listLRUidle_listidle_list buffer3</li>\n<li>buffer3buffer3</li>\n<li>block4buffer3</li>\n<li>block4block41block4</li>\n</ol>\n<p>  <br>  <img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache2.drawio.png\"></p>\n</li>\n</ul>\n<p></p>\n<ol>\n<li><p>buffer4</p>\n</li>\n<li><p>0idle_listidle_list</p>\n<p> <br> <img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache3.drawio.png\"></p>\n</li>\n</ol>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>XV6OnixXV6XV6<strong></strong> </p>\n<p>linuxmysqloracleleveldblinux</p>\n<p> i  i </p>\n<p>xv6 </p>\n<p></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>XV6</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_fsstructureondisk.png\"></p>\n<p></p>\n<p>xv6log.cinitlog</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">logheader</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> n;</span><br><span class=\"line\">  <span class=\"type\">int</span> block[LOGSIZE];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">log</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">spinlock</span> <span class=\"title\">lock</span>;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> start;</span><br><span class=\"line\">  <span class=\"type\">int</span> size;</span><br><span class=\"line\">  <span class=\"type\">int</span> outstanding; <span class=\"comment\">// how many FS sys calls are executing.</span></span><br><span class=\"line\">  <span class=\"type\">int</span> committing;  <span class=\"comment\">// in commit(), please wait.</span></span><br><span class=\"line\">  <span class=\"type\">int</span> dev;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">logheader</span> <span class=\"title\">lh</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">log</span> <span class=\"title\">log</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">initlog</span><span class=\"params\">(<span class=\"type\">int</span> dev)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">superblock</span> <span class=\"title\">sb</span>;</span></span><br><span class=\"line\">  initlock(&amp;<span class=\"built_in\">log</span>.lock, <span class=\"string\">&quot;log&quot;</span>);</span><br><span class=\"line\">  readsb(dev, &amp;sb);</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.start = sb.logstart;</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.size = sb.nlog;</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.dev = dev;</span><br><span class=\"line\">  recover_from_log();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p> <code>sb.logstart</code>   <code>sb.nlog</code></p>\n</li>\n<li><p>recover_from_logrecover_from_log</p>\n<ol>\n<li>read_head <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">logheader</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"type\">int</span> block[LOGSIZE];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n nblockblock  install_trans</li>\n<li>install_trans <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copy committed blocks from log to their home location</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">install_trans</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> tail;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (tail = <span class=\"number\">0</span>; tail &lt; <span class=\"built_in\">log</span>.lh.n; tail++) &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> *<span class=\"title\">lbuf</span> =</span> bread(<span class=\"built_in\">log</span>.dev, <span class=\"built_in\">log</span>.start+tail+<span class=\"number\">1</span>); <span class=\"comment\">// read log block</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> *<span class=\"title\">dbuf</span> =</span> bread(<span class=\"built_in\">log</span>.dev, <span class=\"built_in\">log</span>.lh.block[tail]); <span class=\"comment\">// read dst</span></span><br><span class=\"line\">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class=\"comment\">// copy block to dst</span></span><br><span class=\"line\">    bwrite(dbuf);  <span class=\"comment\">// write dst to disk</span></span><br><span class=\"line\">    brelse(lbuf);</span><br><span class=\"line\">    brelse(dbuf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n <strong></strong></li>\n<li>logheader::n0</li>\n</ol>\n</li>\n</ol>\n<p></p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio.png\"></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>log_writexv6log_writelog_writebegin_opend_oplog_write</p>\n<ol>\n<li>logheader.block</li>\n<li></li>\n</ol>\n<p>commit</p>\n<p></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// called at the start of each FS system call.</span></span><br><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">begin_op</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  acquire(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.committing)&#123;</span><br><span class=\"line\">      sleep(&amp;<span class=\"built_in\">log</span>, &amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.lh.n + (<span class=\"built_in\">log</span>.outstanding+<span class=\"number\">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// this op might exhaust log space; wait for commit.</span></span><br><span class=\"line\">      sleep(&amp;<span class=\"built_in\">log</span>, &amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">log</span>.outstanding += <span class=\"number\">1</span>;</span><br><span class=\"line\">      release(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// called at the end of each FS system call.</span></span><br><span class=\"line\"><span class=\"comment\">// commits if this was the last outstanding operation.</span></span><br><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">end_op</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> do_commit = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  acquire(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.outstanding -= <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.committing)</span><br><span class=\"line\">    panic(<span class=\"string\">&quot;log.committing&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.outstanding == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    do_commit = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">log</span>.committing = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// begin_op() may be waiting for log space,</span></span><br><span class=\"line\">    <span class=\"comment\">// and decrementing log.outstanding has decreased</span></span><br><span class=\"line\">    <span class=\"comment\">// the amount of reserved space.</span></span><br><span class=\"line\">    wakeup(&amp;<span class=\"built_in\">log</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  release(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(do_commit)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// call commit w/o holding locks, since not allowed</span></span><br><span class=\"line\">    <span class=\"comment\">// to sleep with locks.</span></span><br><span class=\"line\">    commit();</span><br><span class=\"line\">    acquire(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">    <span class=\"built_in\">log</span>.committing = <span class=\"number\">0</span>;</span><br><span class=\"line\">    wakeup(&amp;<span class=\"built_in\">log</span>);</span><br><span class=\"line\">    release(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>begin_opend_op<strong>xv6begin_opend_opbegin_op</strong>ABCABCbegin_op <code>log.outstanding</code> 3ABend_op<code>log.outstanding</code>0C<code>log.outstanding</code> 0begin_opxv6</p>\n<p>xv6  X  i  Y  i  i Y  X  i  X  X  xv6 </p>\n<p>commit</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">commit</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">log</span>.lh.n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    write_log();     <span class=\"comment\">// Write modified blocks from cache to log</span></span><br><span class=\"line\">    write_head();    <span class=\"comment\">// Write header to disk -- the real commit</span></span><br><span class=\"line\">    install_trans(); <span class=\"comment\">// Now install writes to home locations</span></span><br><span class=\"line\">    <span class=\"built_in\">log</span>.lh.n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    write_head();    <span class=\"comment\">// Erase the transaction from the log</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4</p>\n<blockquote>\n<ol>\n<li><strong></strong></li>\n<li>logheader</li>\n<li></li>\n<li></li>\n</ol>\n</blockquote>\n<p>xv6 </p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>Onix Minixlinux</p>\n<ul>\n<li>intfd</li>\n<li>fd</li>\n<li>256Glinux0</li>\n<li>IOfd</li>\n</ul>\n<h3 id=\"i\"><a href=\"#i\" class=\"headerlink\" title=\"i\"></a>i</h3><p>i</p>\n<p>i  i i</p>\n<p>iiii</p>\n<p>i</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">super_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *desc;           <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buffer_t</span> *<span class=\"title\">buf</span>;</span> <span class=\"comment\">//  buffer</span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> dev;            <span class=\"comment\">// </span></span><br><span class=\"line\">    u32 count;            <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> type;             <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> sector_size;   <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> block_size;    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">list_t</span> inode_list;    <span class=\"comment\">//  inode </span></span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *iroot;       <span class=\"comment\">//  inode</span></span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *imount;      <span class=\"comment\">//  inode</span></span><br><span class=\"line\">&#125; <span class=\"type\">super_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">list_node_t</span> node; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">void</span> *desc; <span class=\"comment\">// inode  i</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buffer_t</span> *<span class=\"title\">buf</span>;</span> <span class=\"comment\">// inode  buffer</span></span><br><span class=\"line\">        <span class=\"type\">void</span> *addr;           <span class=\"comment\">// pipe </span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> dev;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> rdev; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> nr;     <span class=\"comment\">// i </span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> count; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">time_t</span> atime; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">time_t</span> mtime; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">time_t</span> ctime; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> mount; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">mode_t</span> mode; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> type;    <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> uid; <span class=\"comment\">//  id</span></span><br><span class=\"line\">    <span class=\"type\">int</span> gid; <span class=\"comment\">//  id</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">super_t</span> *<span class=\"title\">super</span>;</span>   <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fs_op_t</span> *<span class=\"title\">op</span>;</span>      <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_t</span> *<span class=\"title\">rxwaiter</span>;</span> <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_t</span> *<span class=\"title\">txwaiter</span>;</span> <span class=\"comment\">// </span></span><br><span class=\"line\">&#125; <span class=\"type\">inode_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>inode_t::typeonix</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    FS_TYPE_NONE = <span class=\"number\">0</span>,</span><br><span class=\"line\">    FS_TYPE_PIPE,</span><br><span class=\"line\">    FS_TYPE_SOCKET,</span><br><span class=\"line\">    FS_TYPE_MINIX,</span><br><span class=\"line\">    FS_TYPE_NUM,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>IOiinode_t <code>inode_t::desc</code> iFS_TYPE_MINIXinode_t::desc <code>minix_inode_t</code> iiFS_TYPE_SOCKETinode_t::desc <code>socket_t</code>iFS_TYPE_PIPEinode_t::desc <code>fifo_t</code></p>\n<p>FS_TYPE_MINIXiminix <code>fs_ops</code> minix</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">fs_op_t</span> minix_op = &#123;</span><br><span class=\"line\">    minix_mkfs,</span><br><span class=\"line\">    minix_super,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_open,</span><br><span class=\"line\">    minix_close,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_read,</span><br><span class=\"line\">    minix_write,</span><br><span class=\"line\">    minix_truncate,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_stat,</span><br><span class=\"line\">    minix_permission,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_namei,</span><br><span class=\"line\">    minix_mkdir,</span><br><span class=\"line\">    minix_rmdir,</span><br><span class=\"line\">    minix_link,</span><br><span class=\"line\">    minix_unlink,</span><br><span class=\"line\">    minix_mknod,</span><br><span class=\"line\">    minix_readdir,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">minix_init</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    fs_register_op(FS_TYPE_MINIX, &amp;minix_op);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>minixminixiinode_t::opminix_op</p>\n<p>minix</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio.png\"></p>\n<p></p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\">1</td>\n<td align=\"center\">i</td>\n</tr>\n<tr>\n<td align=\"center\">i</td>\n<td align=\"center\">2</td>\n<td align=\"center\">i</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">2 + super-&gt;imap_blocks</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">i</td>\n<td align=\"center\">2 + super-&gt;imap_blocks + super-&gt;zmap_blocks</td>\n<td align=\"center\">i</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">minix_super_t::firstdatazone</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n</blockquote>\n<h3 id=\"i\"><a href=\"#i\" class=\"headerlink\" title=\"i\"></a>i</h3><p>iiiii</p>\n<p>ii&#x2F; i  i  i  i  i n i  i </p>\n<p> i  <code>minix_inode_t</code> <code>mode</code> nlink  i  i size <code>zone</code>  <strong>&#x2F;&#x2F;</strong>  <code>zone</code> 0</p>\n<p>i</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minix_inode_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    u16 mode;    <span class=\"comment\">// (rwx )</span></span><br><span class=\"line\">    u16 uid;     <span class=\"comment\">// id</span></span><br><span class=\"line\">    u32 size;    <span class=\"comment\">// </span></span><br><span class=\"line\">    u32 mtime;   <span class=\"comment\">//   UTC </span></span><br><span class=\"line\">    u8 gid;      <span class=\"comment\">// id()</span></span><br><span class=\"line\">    u8 nlinks;   <span class=\"comment\">// i </span></span><br><span class=\"line\">    u16 zone[<span class=\"number\">9</span>]; <span class=\"comment\">//  (0-6)(7) (8) </span></span><br><span class=\"line\">&#125; <span class=\"type\">minix_inode_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minix_super_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    u16 inodes;        <span class=\"comment\">// </span></span><br><span class=\"line\">    u16 zones;         <span class=\"comment\">// </span></span><br><span class=\"line\">    u16 imap_blocks;   <span class=\"comment\">// i </span></span><br><span class=\"line\">    u16 zmap_blocks;   <span class=\"comment\">// </span></span><br><span class=\"line\">    u16 firstdatazone; <span class=\"comment\">// </span></span><br><span class=\"line\">    u16 log_zone_size; <span class=\"comment\">// log2()</span></span><br><span class=\"line\">    u32 max_size;      <span class=\"comment\">// </span></span><br><span class=\"line\">    u16 magic;         <span class=\"comment\">// </span></span><br><span class=\"line\">&#125; <span class=\"type\">minix_super_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>i&#x2F; <code>minix_ialloc</code>  <code>minix_ifree</code>iiitrueminix_ialloci<code>minix_ifree</code>  <code>minix_ialloc</code> ifalse</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  inode</span></span><br><span class=\"line\"><span class=\"type\">idx_t</span> <span class=\"title function_\">minix_ialloc</span><span class=\"params\">(<span class=\"type\">super_t</span> *super)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bit = EOF;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;imap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_BITS, i * BLOCK_BITS);</span><br><span class=\"line\">        bit = bitmap_scan(&amp;<span class=\"built_in\">map</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bit != EOF)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            assert(bit &lt; desc-&gt;inodes);</span><br><span class=\"line\">            buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bit;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  inode</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">minix_ifree</span><span class=\"params\">(<span class=\"type\">super_t</span> *super, <span class=\"type\">idx_t</span> idx)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    assert(idx &lt; desc-&gt;inodes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;imap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &gt; BLOCK_BITS * (i + <span class=\"number\">1</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_BITS, i * BLOCK_BITS);</span><br><span class=\"line\">        assert(bitmap_test(&amp;<span class=\"built_in\">map</span>, idx));</span><br><span class=\"line\">        bitmap_set(&amp;<span class=\"built_in\">map</span>, idx, <span class=\"number\">0</span>);</span><br><span class=\"line\">        buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>i <code>iget</code> <strong>ii</strong>iii <code>get_free_inode</code> iiiiiii</p>\n<p>i</p>\n<blockquote>\n<ul>\n<li>inode_t::desc i</li>\n<li>inode::buf iinode::buf i  i inode_t::desci lru</li>\n<li>iIOinode_t::rdevminix_inode_t::zone[0]minix_inode_t::zone[0]IO</li>\n<li>inode_t::super</li>\n<li>inode_t::typeFS_TYPE_MINIX</li>\n<li>inode_t::opFS_TYPE_MINIX</li>\n</ul>\n</blockquote>\n<p></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BLOCK_INODES (BLOCK_SIZE / sizeof(minix_inode_t))    <span class=\"comment\">// 1 inode</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  inode nr </span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">idx_t</span> <span class=\"title function_\">inode_block</span><span class=\"params\">(<span class=\"type\">minix_super_t</span> *desc, <span class=\"type\">idx_t</span> nr)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// inode   1 </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> + desc-&gt;imap_blocks + desc-&gt;zmap_blocks + (nr - <span class=\"number\">1</span>) / BLOCK_INODES;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ii</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">inode_t</span> *<span class=\"title function_\">iget</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">idx_t</span> nr)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *inode = find_inode(dev, nr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inode)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        inode-&gt;count++;</span><br><span class=\"line\">        inode-&gt;atime = time();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">super_t</span> *super = get_super(dev);</span><br><span class=\"line\">    assert(super);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(nr &lt;= desc-&gt;inodes);</span><br><span class=\"line\"></span><br><span class=\"line\">    inode = get_free_inode();</span><br><span class=\"line\">    inode-&gt;dev = dev;</span><br><span class=\"line\">    inode-&gt;nr = nr;</span><br><span class=\"line\">    inode-&gt;count++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  inode </span></span><br><span class=\"line\">    list_push(&amp;super-&gt;inode_list, &amp;inode-&gt;node);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> block = inode_block(desc, inode-&gt;nr);</span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = bread(inode-&gt;dev, block);</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;buf = buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  inode </span></span><br><span class=\"line\">    inode-&gt;desc = &amp;((<span class=\"type\">minix_inode_t</span> *)buf-&gt;data)[(inode-&gt;nr - <span class=\"number\">1</span>) % BLOCK_INODES];</span><br><span class=\"line\">    <span class=\"type\">minix_inode_t</span> *minode = (<span class=\"type\">minix_inode_t</span> *)inode-&gt;desc;</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;rdev = minode-&gt;zone[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;mode = minode-&gt;mode;</span><br><span class=\"line\">    inode-&gt;size = minode-&gt;size;</span><br><span class=\"line\">    inode-&gt;super = super;</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;type = FS_TYPE_MINIX;</span><br><span class=\"line\">    inode-&gt;op = fs_get_op(FS_TYPE_MINIX);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>igetiputonix-dev&#x2F;src&#x2F;fs&#x2F;inode.ciputiiput minix_close inode_t::countinode::bufii</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>oniximinix_inode_t::zone <code>minix_balloc</code>  <code>minix_bfree</code> </p>\n<p>&#x2F; i&#x2F;<code>minix_ialloc</code>  <code>minix_ifree</code>trueminix_ialloc<code>minix_bfree</code>  <code>minix_balloc</code> false</p>\n<p></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"type\">idx_t</span> <span class=\"title function_\">minix_balloc</span><span class=\"params\">(<span class=\"type\">super_t</span> *super)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bit = EOF;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span> + desc-&gt;imap_blocks;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;zmap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_SIZE, i * BLOCK_BITS + desc-&gt;firstdatazone - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        bit = bitmap_scan(&amp;<span class=\"built_in\">map</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bit != EOF)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//  </span></span><br><span class=\"line\">            assert(bit &lt; desc-&gt;zones);</span><br><span class=\"line\">            buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bit;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">minix_bfree</span><span class=\"params\">(<span class=\"type\">super_t</span> *super, <span class=\"type\">idx_t</span> idx)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    assert(idx &lt; desc-&gt;zones);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span> + desc-&gt;imap_blocks;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;zmap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &gt; BLOCK_BITS * (i + <span class=\"number\">1</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_SIZE, BLOCK_BITS * i + desc-&gt;firstdatazone - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//  idx  0</span></span><br><span class=\"line\">        assert(bitmap_test(&amp;<span class=\"built_in\">map</span>, idx));</span><br><span class=\"line\">        bitmap_set(&amp;<span class=\"built_in\">map</span>, idx, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>onix <code>open</code> iionix</p>\n<p>super_init</p>\n<ul>\n<li>super_initinodemount_root</li>\n<li>mount_rootdevread_superdev<strong>i</strong>i  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">mount_root</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    LOGK(<span class=\"string\">&quot;Mount root file system...\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">device_t</span> *device = device_find(DEV_IDE_PART, <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(device);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    root = read_super(device-&gt;dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// i</span></span><br><span class=\"line\">    root-&gt;imount = root-&gt;iroot;</span><br><span class=\"line\">    root-&gt;imount-&gt;count++;</span><br><span class=\"line\"></span><br><span class=\"line\">    root-&gt;iroot-&gt;mount = device-&gt;dev;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>read_superdevread_superminix_super  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  dev </span></span><br><span class=\"line\"><span class=\"type\">super_t</span> *<span class=\"title function_\">read_super</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">super_t</span> *super = get_super(dev);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (super) &#123;</span><br><span class=\"line\">        super-&gt;count++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> super;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOGK(<span class=\"string\">&quot;Reading super block of device %d\\n&quot;</span>, dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    super = get_free_super();</span><br><span class=\"line\">    super-&gt;count++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">1</span>; i &lt; FS_TYPE_NUM; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">fs_op_t</span> *op = fs_get_op(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!op)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"comment\">// minix_super</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (op-&gt;super(dev, super) == EOK) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> super;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    put_super(super);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>minix_super 1 1  super_t::descsuper_t::buf iget ii1  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">minix_super</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">super_t</span> *super)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = bread(dev, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!buf)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EFSUNK;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(buf);</span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)buf-&gt;data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (desc-&gt;magic != MINIX1_MAGIC) &#123;</span><br><span class=\"line\">        brelse(buf);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EFSUNK;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    super-&gt;buf = buf;</span><br><span class=\"line\">    super-&gt;desc = desc;</span><br><span class=\"line\">    super-&gt;dev = dev;</span><br><span class=\"line\">    super-&gt;type = FS_TYPE_MINIX;</span><br><span class=\"line\">    super-&gt;block_size = BLOCK_SIZE;</span><br><span class=\"line\">    super-&gt;sector_size = SECTOR_SIZE;</span><br><span class=\"line\">    super-&gt;iroot = iget(dev, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p> <code>super-&gt;iroot</code>  iget  iget </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">inode_t</span> *<span class=\"title function_\">iget</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">idx_t</span> nr)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *inode = find_inode(dev, nr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inode) &#123;</span><br><span class=\"line\">        inode-&gt;count++;</span><br><span class=\"line\">        inode-&gt;atime = time();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">super_t</span> *super = get_super(dev);</span><br><span class=\"line\">    assert(super);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> iget  minix_superigetiget <code>super-&gt;iroot</code> </p>\n<h3 id=\"-\"><a href=\"#-\" class=\"headerlink\" title=\"&#x2F;\"></a>&#x2F;</h3><p>onixopen <code>O_CREAT | O_TRUNC</code> openopen <code>sys_open</code> </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">fd_t</span> <span class=\"title function_\">sys_open</span><span class=\"params\">(<span class=\"type\">char</span> *filename, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> mode)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *next;</span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *dir = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// filenameinext</span></span><br><span class=\"line\">    dir = named(filename, &amp;next);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /a/b/minixopen</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*next) &#123;</span><br><span class=\"line\">        inode = dir;</span><br><span class=\"line\">        dir-&gt;count++;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> makeup;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// minixopen/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ret = dir-&gt;op-&gt;open(dir, next, flags, mode, &amp;inode);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// file_t</span></span><br><span class=\"line\">    <span class=\"type\">file_t</span> *file;</span><br><span class=\"line\">    <span class=\"type\">fd_t</span> fd = fd_get(&amp;file);</span><br><span class=\"line\"></span><br><span class=\"line\">    file-&gt;inode = inode;</span><br><span class=\"line\">    file-&gt;flags = flags;</span><br><span class=\"line\">    file-&gt;count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    file-&gt;offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// file</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags &amp; O_APPEND) &#123;</span><br><span class=\"line\">        file-&gt;offset = file-&gt;inode-&gt;size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>namedfilenameinext</li>\n<li>&#x2F;a&#x2F;b&#x2F;minixopen4</li>\n<li>minixopen&#x2F;i</li>\n<li>file_t</li>\n<li>flags <code>O_APPEND</code> file</li>\n</ol>\n</blockquote>\n<p>namedinextnamed</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  pathname  inode</span></span><br><span class=\"line\"><span class=\"type\">inode_t</span> *<span class=\"title function_\">named</span><span class=\"params\">(<span class=\"type\">char</span> *pathname, <span class=\"type\">char</span> **next)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (match_name(name, <span class=\"string\">&quot;..&quot;</span>, next) &amp;&amp; dir == dir-&gt;super-&gt;iroot) &#123;</span><br><span class=\"line\">            <span class=\"type\">super_t</span> *super = dir-&gt;super;</span><br><span class=\"line\">            inode = super-&gt;imount;</span><br><span class=\"line\">            inode-&gt;count++;</span><br><span class=\"line\">            iput(dir);</span><br><span class=\"line\">            dir = inode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> <code>name</code>pathname  <code>..</code> iflinux <code>..</code>   </p>\n<p>if <code>sys_mknod</code>  <code>sys_mount</code> onixonix-dev&#x2F;src&#x2F;fs&#x2F;dev.c sys_mknod  sys_mount </p>\n<p>onix</p>\n<p></p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_mount.drawio.png\"></p>\n<p>sys_mknodminix_mknodizoneiiirdevminode-&gt;zone[0]minix_mknod</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">minix_mknod</span><span class=\"params\">(<span class=\"type\">inode_t</span> *dir, <span class=\"type\">char</span> *name, <span class=\"type\">int</span> mode, <span class=\"type\">int</span> dev)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ISBLK(mode) || ISCHR(mode))</span><br><span class=\"line\">        minode-&gt;zone[<span class=\"number\">0</span>] = dev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sys_mountsd&#x2F;dev&#x2F;sdb1sd <code>mount /dev/sdb1 /mnt</code> <strong>sd  iLinuxSDii</strong> onix sys_mount</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sys_mount</span><span class=\"params\">(<span class=\"type\">char</span> *devname, <span class=\"type\">char</span> *dirname, <span class=\"type\">int</span> flags)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// i</span></span><br><span class=\"line\">    devinode = namei(devname);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// i</span></span><br><span class=\"line\">    dirinode = namei(dirname);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    super = read_super(devinode-&gt;rdev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    super-&gt;imount = dirinode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    dirinode-&gt;mount = devinode-&gt;rdev;</span><br><span class=\"line\">    iput(devinode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<blockquote>\n<ol>\n<li>i</li>\n<li>i</li>\n<li></li>\n<li></li>\n<li></li>\n</ol>\n</blockquote>\n<p>sys_openminix_open</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">minix_open</span><span class=\"params\">(<span class=\"type\">inode_t</span> *dir, <span class=\"type\">char</span> *name, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> mode, <span class=\"type\">inode_t</span> **result)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">minix_dentry_t</span> *entry = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// dirnameentry</span></span><br><span class=\"line\">    buf = find_entry(dir, name, &amp;next, &amp;entry);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buf) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//  iiiget</span></span><br><span class=\"line\">        inode = iget(dir-&gt;dev, entry-&gt;nr);</span><br><span class=\"line\">        assert(inode);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> makeup;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(flags &amp; O_CREAT)) &#123;</span><br><span class=\"line\">        ret = -EEXIST;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// nameentry</span></span><br><span class=\"line\">    buf = add_entry(dir, name, &amp;entry);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// i</span></span><br><span class=\"line\">    entry-&gt;nr = minix_ialloc(dir-&gt;super);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ii</span></span><br><span class=\"line\">    inode = new_inode(dir-&gt;dev, entry-&gt;nr);</span><br><span class=\"line\"></span><br><span class=\"line\">makeup:</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    *result = inode;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sys_openminix_opennamedirnamei</p>\n<blockquote>\n<ol>\n<li>find_entrydirnameentry ii <code>makeup</code> iget</li>\n<li> <code>O_CREAT</code> </li>\n<li>add_entrynameentry</li>\n<li>i</li>\n<li>ii</li>\n</ol>\n</blockquote>\n<p> <code>find_entry</code>  <code>add_entry</code>  <strong></strong> </p>\n<p></p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio.png\"></p>\n<h3 id=\"-\"><a href=\"#-\" class=\"headerlink\" title=\"&#x2F;\"></a>&#x2F;</h3><p>i</p>\n<p> <strong>i</strong> iii</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio.png\"></p>\n<p>i</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">i</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">minix_inode_t::mode</td>\n<td align=\"center\">onix</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::uid</td>\n<td align=\"center\">id</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::size</td>\n<td align=\"center\">Byte</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::mtime</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::gid</td>\n<td align=\"center\">id</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::nlinks</td>\n<td align=\"center\">i</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::zone</td>\n<td align=\"center\">9uint16_t789</td>\n</tr>\n</tbody></table>\n<p>i<strong> <code>minix_inode_t::zone</code> 0</strong>onix&#x2F;xv6i  --</p>\n<p>i -- 0</p>\n<p>i <code>sys_read</code>  <code>sys_write</code> </p>\n<p> <code>sys_read</code> </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sys_read</span><span class=\"params\">(<span class=\"type\">fd_t</span> fd, <span class=\"type\">char</span> *buf, <span class=\"type\">int</span> count)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((ret = fd_check(fd, &amp;file)) &lt; EOK)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *inode = file-&gt;inode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> len = inode-&gt;op-&gt;read(inode, buf, count, file-&gt;offset);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        file-&gt;offset += len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>fd <code>file_t</code> </li>\n<li>i</li>\n<li> minix read </li>\n</ol>\n</blockquote>\n<p>minix read minix_readlenoffset</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  inode  offset  len  buf</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">minix_read</span><span class=\"params\">(<span class=\"type\">inode_t</span> *inode, <span class=\"type\">char</span> *data, <span class=\"type\">int</span> len, <span class=\"type\">off_t</span> offset)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">minix_inode_t</span> *minode = (<span class=\"type\">minix_inode_t</span> *)inode-&gt;desc;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ISCHR(minode-&gt;mode)) &#123;</span><br><span class=\"line\">        assert(minode-&gt;zone[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> device_read(minode-&gt;zone[<span class=\"number\">0</span>], data, len, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ISBLK(minode-&gt;mode)) &#123;</span><br><span class=\"line\">        assert(minode-&gt;zone[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"type\">device_t</span> *device = device_get(minode-&gt;zone[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        assert(len % BLOCK_SIZE == <span class=\"number\">0</span>);</span><br><span class=\"line\">        assert(device_read(minode-&gt;zone[<span class=\"number\">0</span>], data, len / BLOCK_SIZE, offset / BLOCK_SIZE, <span class=\"number\">0</span>) == EOK);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(ISFILE(minode-&gt;mode) || ISDIR(minode-&gt;mode));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  EOF</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset &gt;= minode-&gt;size) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    u32 begin = offset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    u32 left = MIN(len, minode-&gt;size - offset);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"type\">idx_t</span> nr = minix_bmap(inode, offset / BLOCK_SIZE, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        assert(nr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"type\">buffer_t</span> *buf = bread(inode-&gt;dev, nr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        u32 start = offset % BLOCK_SIZE;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        u32 chars = MIN(BLOCK_SIZE - start, left);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//    </span></span><br><span class=\"line\">        offset += chars;</span><br><span class=\"line\">        left -= chars;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"type\">char</span> *ptr = buf-&gt;data + start;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(data, ptr, chars);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        data += chars;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        brelse(buf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    inode-&gt;atime = time();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> offset - begin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<blockquote>\n<ol>\n<li>minode-&gt;zone[0]&#x2F;</li>\n<li>whileminix_bmapizoneoffset</li>\n<li></li>\n<li> <code>MIN(BLOCK_SIZE - start, left)</code> </li>\n<li>len2~4</li>\n</ol>\n</blockquote>\n<p>minix_bmaponixminix_bmap <a href=\"https://blog.csdn.net/m0_52566365/article/details/139525258\"> Onix &amp; XV6 2Unix</a>  i offset</p>\n<blockquote>\n<ul>\n<li> offset zone</li>\n<li> offset <ul>\n<li>offset</li>\n<li>offset <code>(offset &amp; 0x7FC00) &gt;&gt; 10</code> 9uint16_toffset10 <code>offset &amp; 0x3FF</code> </li>\n</ul>\n</li>\n<li> offset <ul>\n<li>offset + </li>\n<li>offset <code>(offset &amp; 0xFF80000) &gt;&gt; 10</code> 9uint16_t <code>(offset &amp; 0x7FC00) &gt;&gt; 10</code> uint16_toffset10 <code>offset &amp; 0x3FF</code> </li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p> <strong>onixzoneuint16_tonix2^16 - 1 onix 64MB</strong> </p>\n<p>onix</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p><code>find_entry</code>  <code>add_entry</code>  onix</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minix_dentry_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    u16 nr;              <span class=\"comment\">// i </span></span><br><span class=\"line\">    <span class=\"type\">char</span> name[NAME_LEN]; <span class=\"comment\">// </span></span><br><span class=\"line\">&#125; <span class=\"type\">minix_dentry_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_dentry.drawio.png\"></p>\n<p>onixfind_entryfor</p>\n<p>add_entry <code>nr</code> 0onixnr0nr0onixminix_rmdir</p>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>unix</p>\n<p>2025-9-16ing ing ing</p>\n<p>OnixXV6OnixXV6XV6Onix</p>\n<p>linuxIOIOpipelinux</p>","more":"<p>XV6</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio.png\"></p>\n<p>Onix</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio.png\"></p>\n<p>XV6OnixXV6 </p>\n<p>Onix IO <code>struct device_t</code> io <code>fs_op_t</code> Linux</p>\n<p><strong>Onix</strong></p>\n<h2 id=\"IO-\"><a href=\"#IO-\" class=\"headerlink\" title=\"IO &amp; \"></a>IO &amp; </h2><ul>\n<li><p>IO: IO</p>\n</li>\n<li><p>: IOOnixXV6Onix</p>\n</li>\n</ul>\n<h3 id=\"XV6\"><a href=\"#XV6\" class=\"headerlink\" title=\"XV6\"></a>XV6</h3><p>XV6IOIO  IOide.cIO<strong>IOIOIOIOIO</strong> LevelDBLevelDBWrite<a href=\"https://blog.csdn.net/m0_52566365/article/details/137910783\">LevelDB1</a></p>\n<p></p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_ide.drawio.png\"></p>\n<p></p>\n<p>iderw</p>\n<p><strong>iderw</strong></p>\n<blockquote>\n<ol>\n<li> <code>iderw(struct buf *b)</code></li>\n<li>pushIO</li>\n<li>IO <code>idestart</code></li>\n<li><strong> IO </strong></li>\n</ol>\n</blockquote>\n<p><strong>ideintr</strong></p>\n<blockquote>\n<ol>\n<li>IO</li>\n<li></li>\n<li>IO<strong> IO IO <code>idestart</code></strong></li>\n</ol>\n</blockquote>\n<p>(FCFS)</p>\n<h3 id=\"Onix\"><a href=\"#Onix\" class=\"headerlink\" title=\"Onix\"></a>Onix</h3><p>OnixIO IDEIntegrated Drive ElectronicsIDEATAAdvanced Technology AttachmentXV6idestartOnixIOkernel&#x2F;ide.cOnixIOOnix</p>\n<p>Onix</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> name[NAMELEN];  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> type;            <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> subtype;         <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> dev;           <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> parent;        <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">void</span> *ptr;           <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">list_t</span> request_list; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> direct;         <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*ioctl)(<span class=\"type\">void</span> *dev, <span class=\"type\">int</span> cmd, <span class=\"type\">void</span> *args, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*read)(<span class=\"type\">void</span> *dev, <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> count, <span class=\"type\">idx_t</span> idx, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*write)(<span class=\"type\">void</span> *dev, <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> count, <span class=\"type\">idx_t</span> idx, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">&#125; <span class=\"type\">device_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>IOioctlreadwriteIOIOminixonixIO</p>\n<p>OnixIO1024</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">device_type_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    DEV_NULL,  <span class=\"comment\">// </span></span><br><span class=\"line\">    DEV_CHAR,  <span class=\"comment\">// </span></span><br><span class=\"line\">    DEV_BLOCK, <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p> <code>enum device_subtype_t</code> </p>\n<p>OnixIOXV6IO</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"type\">err_t</span> <span class=\"title function_\">device_request</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">void</span> *buf, u8 count, <span class=\"type\">idx_t</span> idx, <span class=\"type\">int</span> flags, u32 type)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">device_t</span> *device = device_get(dev);</span><br><span class=\"line\">    <span class=\"type\">request_t</span> *req = kmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"type\">request_t</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> empty = list_empty(&amp;device-&gt;request_list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    list_insert_sort(&amp;device-&gt;request_list, &amp;req-&gt;node, element_node_offset(<span class=\"type\">request_t</span>, node, idx));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!empty)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        req-&gt;task = running_task();</span><br><span class=\"line\">        assert(task_block(req-&gt;task, <span class=\"literal\">NULL</span>, TASK_BLOCKED, TIMELESS) == EOK);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// do io</span></span><br><span class=\"line\">    <span class=\"type\">err_t</span> ret = do_request(req);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// reqIO</span></span><br><span class=\"line\">    <span class=\"type\">request_t</span> *nextreq = request_nextreq(device, req);</span><br><span class=\"line\"></span><br><span class=\"line\">    list_remove(&amp;req-&gt;node);</span><br><span class=\"line\">    kfree(req);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextreq)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        assert(nextreq-&gt;task-&gt;magic == ONIX_MAGIC);</span><br><span class=\"line\">        task_unblock(nextreq-&gt;task, EOK);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Onix IO</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_ide.drawio.png\"></p>\n<p></p>\n<blockquote>\n<ol>\n<li>IO <code>device_request</code></li>\n<li>IOreq</li>\n<li>req</li>\n<li>IO</li>\n<li>IO</li>\n<li>reqIOreqnext</li>\n<li>req</li>\n<li>reqnextreqnext</li>\n</ol>\n</blockquote>\n<p>OnixXV6FCFS</p>\n<p><strong></strong></p>\n<p>Onixrequest_nextreq</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">request_t</span> *<span class=\"title function_\">request_nextreq</span><span class=\"params\">(<span class=\"type\">device_t</span> *device, <span class=\"type\">request_t</span> *req)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">list_t</span> *<span class=\"built_in\">list</span> = &amp;device-&gt;request_list;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (device-&gt;direct == DIRECT_UP &amp;&amp; req-&gt;node.next == &amp;<span class=\"built_in\">list</span>-&gt;tail) &#123;</span><br><span class=\"line\">        device-&gt;direct = DIRECT_DOWN;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (device-&gt;direct == DIRECT_DOWN &amp;&amp; req-&gt;node.prev == &amp;<span class=\"built_in\">list</span>-&gt;head) &#123;</span><br><span class=\"line\">        device-&gt;direct = DIRECT_UP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">void</span> *next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (device-&gt;direct == DIRECT_UP) &#123;</span><br><span class=\"line\">        next = req-&gt;node.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        next = req-&gt;node.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == &amp;<span class=\"built_in\">list</span>-&gt;head || next == &amp;<span class=\"built_in\">list</span>-&gt;tail) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> element_entry(<span class=\"type\">request_t</span>, node, next);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>OSXV6512Onix1024IOOnixonix-dev&#x2F;src&#x2F;kernel&#x2F;buffer.c</p>\n<p><strong></strong>LRUCMU154451LRULRU-KLevelDB.sstLRUOnixLRU</p>\n<p>OnixLRU</p>\n<p>LRU</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache.drawio.png\"></p>\n<p>LRU</p>\n<ul>\n<li> <code>idle_list</code>:  OS0OSLRULRULRU</li>\n<li>: </li>\n</ul>\n<p></p>\n<ul>\n<li><p> <code>block1</code></p>\n<ol>\n<li> <code> ( ^ ) % </code> block1block10</li>\n<li>buffer1</li>\n<li>buffer1</li>\n<li>idle_listbuffer1</li>\n</ol>\n<p>  <br>  <img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio.png\"></p>\n</li>\n<li><p> <code>block4</code></p>\n<ol>\n<li>idle_listLRUidle_listidle_list buffer3</li>\n<li>buffer3buffer3</li>\n<li>block4buffer3</li>\n<li>block4block41block4</li>\n</ol>\n<p>  <br>  <img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache2.drawio.png\"></p>\n</li>\n</ul>\n<p></p>\n<ol>\n<li><p>buffer4</p>\n</li>\n<li><p>0idle_listidle_list</p>\n<p> <br> <img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_cache3.drawio.png\"></p>\n</li>\n</ol>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>XV6OnixXV6XV6<strong></strong> </p>\n<p>linuxmysqloracleleveldblinux</p>\n<p> i  i </p>\n<p>xv6 </p>\n<p></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>XV6</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_fsstructureondisk.png\"></p>\n<p></p>\n<p>xv6log.cinitlog</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">logheader</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> n;</span><br><span class=\"line\">  <span class=\"type\">int</span> block[LOGSIZE];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">log</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">spinlock</span> <span class=\"title\">lock</span>;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> start;</span><br><span class=\"line\">  <span class=\"type\">int</span> size;</span><br><span class=\"line\">  <span class=\"type\">int</span> outstanding; <span class=\"comment\">// how many FS sys calls are executing.</span></span><br><span class=\"line\">  <span class=\"type\">int</span> committing;  <span class=\"comment\">// in commit(), please wait.</span></span><br><span class=\"line\">  <span class=\"type\">int</span> dev;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">logheader</span> <span class=\"title\">lh</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">log</span> <span class=\"title\">log</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">initlog</span><span class=\"params\">(<span class=\"type\">int</span> dev)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">superblock</span> <span class=\"title\">sb</span>;</span></span><br><span class=\"line\">  initlock(&amp;<span class=\"built_in\">log</span>.lock, <span class=\"string\">&quot;log&quot;</span>);</span><br><span class=\"line\">  readsb(dev, &amp;sb);</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.start = sb.logstart;</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.size = sb.nlog;</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.dev = dev;</span><br><span class=\"line\">  recover_from_log();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p> <code>sb.logstart</code>   <code>sb.nlog</code></p>\n</li>\n<li><p>recover_from_logrecover_from_log</p>\n<ol>\n<li>read_head <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">logheader</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"type\">int</span> block[LOGSIZE];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n nblockblock  install_trans</li>\n<li>install_trans <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copy committed blocks from log to their home location</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">install_trans</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> tail;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (tail = <span class=\"number\">0</span>; tail &lt; <span class=\"built_in\">log</span>.lh.n; tail++) &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> *<span class=\"title\">lbuf</span> =</span> bread(<span class=\"built_in\">log</span>.dev, <span class=\"built_in\">log</span>.start+tail+<span class=\"number\">1</span>); <span class=\"comment\">// read log block</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> *<span class=\"title\">dbuf</span> =</span> bread(<span class=\"built_in\">log</span>.dev, <span class=\"built_in\">log</span>.lh.block[tail]); <span class=\"comment\">// read dst</span></span><br><span class=\"line\">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class=\"comment\">// copy block to dst</span></span><br><span class=\"line\">    bwrite(dbuf);  <span class=\"comment\">// write dst to disk</span></span><br><span class=\"line\">    brelse(lbuf);</span><br><span class=\"line\">    brelse(dbuf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n <strong></strong></li>\n<li>logheader::n0</li>\n</ol>\n</li>\n</ol>\n<p></p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio.png\"></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>log_writexv6log_writelog_writebegin_opend_oplog_write</p>\n<ol>\n<li>logheader.block</li>\n<li></li>\n</ol>\n<p>commit</p>\n<p></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// called at the start of each FS system call.</span></span><br><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">begin_op</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  acquire(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.committing)&#123;</span><br><span class=\"line\">      sleep(&amp;<span class=\"built_in\">log</span>, &amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.lh.n + (<span class=\"built_in\">log</span>.outstanding+<span class=\"number\">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// this op might exhaust log space; wait for commit.</span></span><br><span class=\"line\">      sleep(&amp;<span class=\"built_in\">log</span>, &amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">log</span>.outstanding += <span class=\"number\">1</span>;</span><br><span class=\"line\">      release(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// called at the end of each FS system call.</span></span><br><span class=\"line\"><span class=\"comment\">// commits if this was the last outstanding operation.</span></span><br><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">end_op</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> do_commit = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  acquire(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">  <span class=\"built_in\">log</span>.outstanding -= <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.committing)</span><br><span class=\"line\">    panic(<span class=\"string\">&quot;log.committing&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">log</span>.outstanding == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    do_commit = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">log</span>.committing = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// begin_op() may be waiting for log space,</span></span><br><span class=\"line\">    <span class=\"comment\">// and decrementing log.outstanding has decreased</span></span><br><span class=\"line\">    <span class=\"comment\">// the amount of reserved space.</span></span><br><span class=\"line\">    wakeup(&amp;<span class=\"built_in\">log</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  release(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(do_commit)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// call commit w/o holding locks, since not allowed</span></span><br><span class=\"line\">    <span class=\"comment\">// to sleep with locks.</span></span><br><span class=\"line\">    commit();</span><br><span class=\"line\">    acquire(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">    <span class=\"built_in\">log</span>.committing = <span class=\"number\">0</span>;</span><br><span class=\"line\">    wakeup(&amp;<span class=\"built_in\">log</span>);</span><br><span class=\"line\">    release(&amp;<span class=\"built_in\">log</span>.lock);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>begin_opend_op<strong>xv6begin_opend_opbegin_op</strong>ABCABCbegin_op <code>log.outstanding</code> 3ABend_op<code>log.outstanding</code>0C<code>log.outstanding</code> 0begin_opxv6</p>\n<p>xv6  X  i  Y  i  i Y  X  i  X  X  xv6 </p>\n<p>commit</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">commit</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">log</span>.lh.n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    write_log();     <span class=\"comment\">// Write modified blocks from cache to log</span></span><br><span class=\"line\">    write_head();    <span class=\"comment\">// Write header to disk -- the real commit</span></span><br><span class=\"line\">    install_trans(); <span class=\"comment\">// Now install writes to home locations</span></span><br><span class=\"line\">    <span class=\"built_in\">log</span>.lh.n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    write_head();    <span class=\"comment\">// Erase the transaction from the log</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4</p>\n<blockquote>\n<ol>\n<li><strong></strong></li>\n<li>logheader</li>\n<li></li>\n<li></li>\n</ol>\n</blockquote>\n<p>xv6 </p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>Onix Minixlinux</p>\n<ul>\n<li>intfd</li>\n<li>fd</li>\n<li>256Glinux0</li>\n<li>IOfd</li>\n</ul>\n<h3 id=\"i\"><a href=\"#i\" class=\"headerlink\" title=\"i\"></a>i</h3><p>i</p>\n<p>i  i i</p>\n<p>iiii</p>\n<p>i</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">super_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *desc;           <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buffer_t</span> *<span class=\"title\">buf</span>;</span> <span class=\"comment\">//  buffer</span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> dev;            <span class=\"comment\">// </span></span><br><span class=\"line\">    u32 count;            <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> type;             <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> sector_size;   <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> block_size;    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">list_t</span> inode_list;    <span class=\"comment\">//  inode </span></span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *iroot;       <span class=\"comment\">//  inode</span></span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *imount;      <span class=\"comment\">//  inode</span></span><br><span class=\"line\">&#125; <span class=\"type\">super_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">list_node_t</span> node; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">void</span> *desc; <span class=\"comment\">// inode  i</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buffer_t</span> *<span class=\"title\">buf</span>;</span> <span class=\"comment\">// inode  buffer</span></span><br><span class=\"line\">        <span class=\"type\">void</span> *addr;           <span class=\"comment\">// pipe </span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> dev;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> rdev; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> nr;     <span class=\"comment\">// i </span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> count; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">time_t</span> atime; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">time_t</span> mtime; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">time_t</span> ctime; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">dev_t</span> mount; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">mode_t</span> mode; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size; <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">int</span> type;    <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> uid; <span class=\"comment\">//  id</span></span><br><span class=\"line\">    <span class=\"type\">int</span> gid; <span class=\"comment\">//  id</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">super_t</span> *<span class=\"title\">super</span>;</span>   <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fs_op_t</span> *<span class=\"title\">op</span>;</span>      <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_t</span> *<span class=\"title\">rxwaiter</span>;</span> <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_t</span> *<span class=\"title\">txwaiter</span>;</span> <span class=\"comment\">// </span></span><br><span class=\"line\">&#125; <span class=\"type\">inode_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>inode_t::typeonix</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    FS_TYPE_NONE = <span class=\"number\">0</span>,</span><br><span class=\"line\">    FS_TYPE_PIPE,</span><br><span class=\"line\">    FS_TYPE_SOCKET,</span><br><span class=\"line\">    FS_TYPE_MINIX,</span><br><span class=\"line\">    FS_TYPE_NUM,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>IOiinode_t <code>inode_t::desc</code> iFS_TYPE_MINIXinode_t::desc <code>minix_inode_t</code> iiFS_TYPE_SOCKETinode_t::desc <code>socket_t</code>iFS_TYPE_PIPEinode_t::desc <code>fifo_t</code></p>\n<p>FS_TYPE_MINIXiminix <code>fs_ops</code> minix</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">fs_op_t</span> minix_op = &#123;</span><br><span class=\"line\">    minix_mkfs,</span><br><span class=\"line\">    minix_super,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_open,</span><br><span class=\"line\">    minix_close,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_read,</span><br><span class=\"line\">    minix_write,</span><br><span class=\"line\">    minix_truncate,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_stat,</span><br><span class=\"line\">    minix_permission,</span><br><span class=\"line\"></span><br><span class=\"line\">    minix_namei,</span><br><span class=\"line\">    minix_mkdir,</span><br><span class=\"line\">    minix_rmdir,</span><br><span class=\"line\">    minix_link,</span><br><span class=\"line\">    minix_unlink,</span><br><span class=\"line\">    minix_mknod,</span><br><span class=\"line\">    minix_readdir,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">minix_init</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    fs_register_op(FS_TYPE_MINIX, &amp;minix_op);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>minixminixiinode_t::opminix_op</p>\n<p>minix</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio.png\"></p>\n<p></p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\">1</td>\n<td align=\"center\">i</td>\n</tr>\n<tr>\n<td align=\"center\">i</td>\n<td align=\"center\">2</td>\n<td align=\"center\">i</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">2 + super-&gt;imap_blocks</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">i</td>\n<td align=\"center\">2 + super-&gt;imap_blocks + super-&gt;zmap_blocks</td>\n<td align=\"center\">i</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">minix_super_t::firstdatazone</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n</blockquote>\n<h3 id=\"i\"><a href=\"#i\" class=\"headerlink\" title=\"i\"></a>i</h3><p>iiiii</p>\n<p>ii&#x2F; i  i  i  i  i n i  i </p>\n<p> i  <code>minix_inode_t</code> <code>mode</code> nlink  i  i size <code>zone</code>  <strong>&#x2F;&#x2F;</strong>  <code>zone</code> 0</p>\n<p>i</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minix_inode_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    u16 mode;    <span class=\"comment\">// (rwx )</span></span><br><span class=\"line\">    u16 uid;     <span class=\"comment\">// id</span></span><br><span class=\"line\">    u32 size;    <span class=\"comment\">// </span></span><br><span class=\"line\">    u32 mtime;   <span class=\"comment\">//   UTC </span></span><br><span class=\"line\">    u8 gid;      <span class=\"comment\">// id()</span></span><br><span class=\"line\">    u8 nlinks;   <span class=\"comment\">// i </span></span><br><span class=\"line\">    u16 zone[<span class=\"number\">9</span>]; <span class=\"comment\">//  (0-6)(7) (8) </span></span><br><span class=\"line\">&#125; <span class=\"type\">minix_inode_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minix_super_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    u16 inodes;        <span class=\"comment\">// </span></span><br><span class=\"line\">    u16 zones;         <span class=\"comment\">// </span></span><br><span class=\"line\">    u16 imap_blocks;   <span class=\"comment\">// i </span></span><br><span class=\"line\">    u16 zmap_blocks;   <span class=\"comment\">// </span></span><br><span class=\"line\">    u16 firstdatazone; <span class=\"comment\">// </span></span><br><span class=\"line\">    u16 log_zone_size; <span class=\"comment\">// log2()</span></span><br><span class=\"line\">    u32 max_size;      <span class=\"comment\">// </span></span><br><span class=\"line\">    u16 magic;         <span class=\"comment\">// </span></span><br><span class=\"line\">&#125; <span class=\"type\">minix_super_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>i&#x2F; <code>minix_ialloc</code>  <code>minix_ifree</code>iiitrueminix_ialloci<code>minix_ifree</code>  <code>minix_ialloc</code> ifalse</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  inode</span></span><br><span class=\"line\"><span class=\"type\">idx_t</span> <span class=\"title function_\">minix_ialloc</span><span class=\"params\">(<span class=\"type\">super_t</span> *super)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bit = EOF;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;imap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_BITS, i * BLOCK_BITS);</span><br><span class=\"line\">        bit = bitmap_scan(&amp;<span class=\"built_in\">map</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bit != EOF)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            assert(bit &lt; desc-&gt;inodes);</span><br><span class=\"line\">            buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bit;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  inode</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">minix_ifree</span><span class=\"params\">(<span class=\"type\">super_t</span> *super, <span class=\"type\">idx_t</span> idx)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    assert(idx &lt; desc-&gt;inodes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;imap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &gt; BLOCK_BITS * (i + <span class=\"number\">1</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_BITS, i * BLOCK_BITS);</span><br><span class=\"line\">        assert(bitmap_test(&amp;<span class=\"built_in\">map</span>, idx));</span><br><span class=\"line\">        bitmap_set(&amp;<span class=\"built_in\">map</span>, idx, <span class=\"number\">0</span>);</span><br><span class=\"line\">        buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>i <code>iget</code> <strong>ii</strong>iii <code>get_free_inode</code> iiiiiii</p>\n<p>i</p>\n<blockquote>\n<ul>\n<li>inode_t::desc i</li>\n<li>inode::buf iinode::buf i  i inode_t::desci lru</li>\n<li>iIOinode_t::rdevminix_inode_t::zone[0]minix_inode_t::zone[0]IO</li>\n<li>inode_t::super</li>\n<li>inode_t::typeFS_TYPE_MINIX</li>\n<li>inode_t::opFS_TYPE_MINIX</li>\n</ul>\n</blockquote>\n<p></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BLOCK_INODES (BLOCK_SIZE / sizeof(minix_inode_t))    <span class=\"comment\">// 1 inode</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  inode nr </span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">idx_t</span> <span class=\"title function_\">inode_block</span><span class=\"params\">(<span class=\"type\">minix_super_t</span> *desc, <span class=\"type\">idx_t</span> nr)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// inode   1 </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> + desc-&gt;imap_blocks + desc-&gt;zmap_blocks + (nr - <span class=\"number\">1</span>) / BLOCK_INODES;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ii</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">inode_t</span> *<span class=\"title function_\">iget</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">idx_t</span> nr)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *inode = find_inode(dev, nr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inode)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        inode-&gt;count++;</span><br><span class=\"line\">        inode-&gt;atime = time();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">super_t</span> *super = get_super(dev);</span><br><span class=\"line\">    assert(super);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(nr &lt;= desc-&gt;inodes);</span><br><span class=\"line\"></span><br><span class=\"line\">    inode = get_free_inode();</span><br><span class=\"line\">    inode-&gt;dev = dev;</span><br><span class=\"line\">    inode-&gt;nr = nr;</span><br><span class=\"line\">    inode-&gt;count++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  inode </span></span><br><span class=\"line\">    list_push(&amp;super-&gt;inode_list, &amp;inode-&gt;node);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> block = inode_block(desc, inode-&gt;nr);</span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = bread(inode-&gt;dev, block);</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;buf = buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  inode </span></span><br><span class=\"line\">    inode-&gt;desc = &amp;((<span class=\"type\">minix_inode_t</span> *)buf-&gt;data)[(inode-&gt;nr - <span class=\"number\">1</span>) % BLOCK_INODES];</span><br><span class=\"line\">    <span class=\"type\">minix_inode_t</span> *minode = (<span class=\"type\">minix_inode_t</span> *)inode-&gt;desc;</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;rdev = minode-&gt;zone[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;mode = minode-&gt;mode;</span><br><span class=\"line\">    inode-&gt;size = minode-&gt;size;</span><br><span class=\"line\">    inode-&gt;super = super;</span><br><span class=\"line\"></span><br><span class=\"line\">    inode-&gt;type = FS_TYPE_MINIX;</span><br><span class=\"line\">    inode-&gt;op = fs_get_op(FS_TYPE_MINIX);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>igetiputonix-dev&#x2F;src&#x2F;fs&#x2F;inode.ciputiiput minix_close inode_t::countinode::bufii</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>oniximinix_inode_t::zone <code>minix_balloc</code>  <code>minix_bfree</code> </p>\n<p>&#x2F; i&#x2F;<code>minix_ialloc</code>  <code>minix_ifree</code>trueminix_ialloc<code>minix_bfree</code>  <code>minix_balloc</code> false</p>\n<p></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"type\">idx_t</span> <span class=\"title function_\">minix_balloc</span><span class=\"params\">(<span class=\"type\">super_t</span> *super)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bit = EOF;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span> + desc-&gt;imap_blocks;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;zmap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_SIZE, i * BLOCK_BITS + desc-&gt;firstdatazone - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        bit = bitmap_scan(&amp;<span class=\"built_in\">map</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bit != EOF)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//  </span></span><br><span class=\"line\">            assert(bit &lt; desc-&gt;zones);</span><br><span class=\"line\">            buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bit;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">minix_bfree</span><span class=\"params\">(<span class=\"type\">super_t</span> *super, <span class=\"type\">idx_t</span> idx)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)super-&gt;desc;</span><br><span class=\"line\">    assert(idx &lt; desc-&gt;zones);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf;</span><br><span class=\"line\">    <span class=\"type\">bitmap_t</span> <span class=\"built_in\">map</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">idx_t</span> bidx = <span class=\"number\">2</span> + desc-&gt;imap_blocks;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; desc-&gt;zmap_blocks; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &gt; BLOCK_BITS * (i + <span class=\"number\">1</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        buf = bread(super-&gt;dev, bidx + i);</span><br><span class=\"line\">        assert(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        bitmap_make(&amp;<span class=\"built_in\">map</span>, buf-&gt;data, BLOCK_SIZE, BLOCK_BITS * i + desc-&gt;firstdatazone - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//  idx  0</span></span><br><span class=\"line\">        assert(bitmap_test(&amp;<span class=\"built_in\">map</span>, idx));</span><br><span class=\"line\">        bitmap_set(&amp;<span class=\"built_in\">map</span>, idx, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        buf-&gt;dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(buf); <span class=\"comment\">// todo </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>onix <code>open</code> iionix</p>\n<p>super_init</p>\n<ul>\n<li>super_initinodemount_root</li>\n<li>mount_rootdevread_superdev<strong>i</strong>i  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">mount_root</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    LOGK(<span class=\"string\">&quot;Mount root file system...\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">device_t</span> *device = device_find(DEV_IDE_PART, <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(device);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    root = read_super(device-&gt;dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// i</span></span><br><span class=\"line\">    root-&gt;imount = root-&gt;iroot;</span><br><span class=\"line\">    root-&gt;imount-&gt;count++;</span><br><span class=\"line\"></span><br><span class=\"line\">    root-&gt;iroot-&gt;mount = device-&gt;dev;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>read_superdevread_superminix_super  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  dev </span></span><br><span class=\"line\"><span class=\"type\">super_t</span> *<span class=\"title function_\">read_super</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">super_t</span> *super = get_super(dev);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (super) &#123;</span><br><span class=\"line\">        super-&gt;count++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> super;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOGK(<span class=\"string\">&quot;Reading super block of device %d\\n&quot;</span>, dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    super = get_free_super();</span><br><span class=\"line\">    super-&gt;count++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">1</span>; i &lt; FS_TYPE_NUM; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">fs_op_t</span> *op = fs_get_op(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!op)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"comment\">// minix_super</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (op-&gt;super(dev, super) == EOK) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> super;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    put_super(super);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>minix_super 1 1  super_t::descsuper_t::buf iget ii1  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">minix_super</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">super_t</span> *super)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">buffer_t</span> *buf = bread(dev, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!buf)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EFSUNK;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(buf);</span><br><span class=\"line\">    <span class=\"type\">minix_super_t</span> *desc = (<span class=\"type\">minix_super_t</span> *)buf-&gt;data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (desc-&gt;magic != MINIX1_MAGIC) &#123;</span><br><span class=\"line\">        brelse(buf);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EFSUNK;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    super-&gt;buf = buf;</span><br><span class=\"line\">    super-&gt;desc = desc;</span><br><span class=\"line\">    super-&gt;dev = dev;</span><br><span class=\"line\">    super-&gt;type = FS_TYPE_MINIX;</span><br><span class=\"line\">    super-&gt;block_size = BLOCK_SIZE;</span><br><span class=\"line\">    super-&gt;sector_size = SECTOR_SIZE;</span><br><span class=\"line\">    super-&gt;iroot = iget(dev, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p> <code>super-&gt;iroot</code>  iget  iget </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">inode_t</span> *<span class=\"title function_\">iget</span><span class=\"params\">(<span class=\"type\">dev_t</span> dev, <span class=\"type\">idx_t</span> nr)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *inode = find_inode(dev, nr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inode) &#123;</span><br><span class=\"line\">        inode-&gt;count++;</span><br><span class=\"line\">        inode-&gt;atime = time();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">super_t</span> *super = get_super(dev);</span><br><span class=\"line\">    assert(super);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fit_inode(inode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> iget  minix_superigetiget <code>super-&gt;iroot</code> </p>\n<h3 id=\"-\"><a href=\"#-\" class=\"headerlink\" title=\"&#x2F;\"></a>&#x2F;</h3><p>onixopen <code>O_CREAT | O_TRUNC</code> openopen <code>sys_open</code> </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">fd_t</span> <span class=\"title function_\">sys_open</span><span class=\"params\">(<span class=\"type\">char</span> *filename, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> mode)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *next;</span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *dir = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// filenameinext</span></span><br><span class=\"line\">    dir = named(filename, &amp;next);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /a/b/minixopen</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*next) &#123;</span><br><span class=\"line\">        inode = dir;</span><br><span class=\"line\">        dir-&gt;count++;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> makeup;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// minixopen/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ret = dir-&gt;op-&gt;open(dir, next, flags, mode, &amp;inode);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// file_t</span></span><br><span class=\"line\">    <span class=\"type\">file_t</span> *file;</span><br><span class=\"line\">    <span class=\"type\">fd_t</span> fd = fd_get(&amp;file);</span><br><span class=\"line\"></span><br><span class=\"line\">    file-&gt;inode = inode;</span><br><span class=\"line\">    file-&gt;flags = flags;</span><br><span class=\"line\">    file-&gt;count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    file-&gt;offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// file</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags &amp; O_APPEND) &#123;</span><br><span class=\"line\">        file-&gt;offset = file-&gt;inode-&gt;size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>namedfilenameinext</li>\n<li>&#x2F;a&#x2F;b&#x2F;minixopen4</li>\n<li>minixopen&#x2F;i</li>\n<li>file_t</li>\n<li>flags <code>O_APPEND</code> file</li>\n</ol>\n</blockquote>\n<p>namedinextnamed</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  pathname  inode</span></span><br><span class=\"line\"><span class=\"type\">inode_t</span> *<span class=\"title function_\">named</span><span class=\"params\">(<span class=\"type\">char</span> *pathname, <span class=\"type\">char</span> **next)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (match_name(name, <span class=\"string\">&quot;..&quot;</span>, next) &amp;&amp; dir == dir-&gt;super-&gt;iroot) &#123;</span><br><span class=\"line\">            <span class=\"type\">super_t</span> *super = dir-&gt;super;</span><br><span class=\"line\">            inode = super-&gt;imount;</span><br><span class=\"line\">            inode-&gt;count++;</span><br><span class=\"line\">            iput(dir);</span><br><span class=\"line\">            dir = inode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> <code>name</code>pathname  <code>..</code> iflinux <code>..</code>   </p>\n<p>if <code>sys_mknod</code>  <code>sys_mount</code> onixonix-dev&#x2F;src&#x2F;fs&#x2F;dev.c sys_mknod  sys_mount </p>\n<p>onix</p>\n<p></p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_mount.drawio.png\"></p>\n<p>sys_mknodminix_mknodizoneiiirdevminode-&gt;zone[0]minix_mknod</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">minix_mknod</span><span class=\"params\">(<span class=\"type\">inode_t</span> *dir, <span class=\"type\">char</span> *name, <span class=\"type\">int</span> mode, <span class=\"type\">int</span> dev)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ISBLK(mode) || ISCHR(mode))</span><br><span class=\"line\">        minode-&gt;zone[<span class=\"number\">0</span>] = dev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sys_mountsd&#x2F;dev&#x2F;sdb1sd <code>mount /dev/sdb1 /mnt</code> <strong>sd  iLinuxSDii</strong> onix sys_mount</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sys_mount</span><span class=\"params\">(<span class=\"type\">char</span> *devname, <span class=\"type\">char</span> *dirname, <span class=\"type\">int</span> flags)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// i</span></span><br><span class=\"line\">    devinode = namei(devname);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// i</span></span><br><span class=\"line\">    dirinode = namei(dirname);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    super = read_super(devinode-&gt;rdev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    super-&gt;imount = dirinode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    dirinode-&gt;mount = devinode-&gt;rdev;</span><br><span class=\"line\">    iput(devinode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<blockquote>\n<ol>\n<li>i</li>\n<li>i</li>\n<li></li>\n<li></li>\n<li></li>\n</ol>\n</blockquote>\n<p>sys_openminix_open</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">minix_open</span><span class=\"params\">(<span class=\"type\">inode_t</span> *dir, <span class=\"type\">char</span> *name, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> mode, <span class=\"type\">inode_t</span> **result)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">minix_dentry_t</span> *entry = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// dirnameentry</span></span><br><span class=\"line\">    buf = find_entry(dir, name, &amp;next, &amp;entry);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buf) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//  iiiget</span></span><br><span class=\"line\">        inode = iget(dir-&gt;dev, entry-&gt;nr);</span><br><span class=\"line\">        assert(inode);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> makeup;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(flags &amp; O_CREAT)) &#123;</span><br><span class=\"line\">        ret = -EEXIST;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// nameentry</span></span><br><span class=\"line\">    buf = add_entry(dir, name, &amp;entry);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// i</span></span><br><span class=\"line\">    entry-&gt;nr = minix_ialloc(dir-&gt;super);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ii</span></span><br><span class=\"line\">    inode = new_inode(dir-&gt;dev, entry-&gt;nr);</span><br><span class=\"line\"></span><br><span class=\"line\">makeup:</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    *result = inode;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sys_openminix_opennamedirnamei</p>\n<blockquote>\n<ol>\n<li>find_entrydirnameentry ii <code>makeup</code> iget</li>\n<li> <code>O_CREAT</code> </li>\n<li>add_entrynameentry</li>\n<li>i</li>\n<li>ii</li>\n</ol>\n</blockquote>\n<p> <code>find_entry</code>  <code>add_entry</code>  <strong></strong> </p>\n<p></p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio.png\"></p>\n<h3 id=\"-\"><a href=\"#-\" class=\"headerlink\" title=\"&#x2F;\"></a>&#x2F;</h3><p>i</p>\n<p> <strong>i</strong> iii</p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio.png\"></p>\n<p>i</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">i</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">minix_inode_t::mode</td>\n<td align=\"center\">onix</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::uid</td>\n<td align=\"center\">id</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::size</td>\n<td align=\"center\">Byte</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::mtime</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::gid</td>\n<td align=\"center\">id</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::nlinks</td>\n<td align=\"center\">i</td>\n</tr>\n<tr>\n<td align=\"center\">minix_inode_t::zone</td>\n<td align=\"center\">9uint16_t789</td>\n</tr>\n</tbody></table>\n<p>i<strong> <code>minix_inode_t::zone</code> 0</strong>onix&#x2F;xv6i  --</p>\n<p>i -- 0</p>\n<p>i <code>sys_read</code>  <code>sys_write</code> </p>\n<p> <code>sys_read</code> </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sys_read</span><span class=\"params\">(<span class=\"type\">fd_t</span> fd, <span class=\"type\">char</span> *buf, <span class=\"type\">int</span> count)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((ret = fd_check(fd, &amp;file)) &lt; EOK)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">inode_t</span> *inode = file-&gt;inode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> len = inode-&gt;op-&gt;read(inode, buf, count, file-&gt;offset);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        file-&gt;offset += len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>fd <code>file_t</code> </li>\n<li>i</li>\n<li> minix read </li>\n</ol>\n</blockquote>\n<p>minix read minix_readlenoffset</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  inode  offset  len  buf</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">minix_read</span><span class=\"params\">(<span class=\"type\">inode_t</span> *inode, <span class=\"type\">char</span> *data, <span class=\"type\">int</span> len, <span class=\"type\">off_t</span> offset)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">minix_inode_t</span> *minode = (<span class=\"type\">minix_inode_t</span> *)inode-&gt;desc;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ISCHR(minode-&gt;mode)) &#123;</span><br><span class=\"line\">        assert(minode-&gt;zone[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> device_read(minode-&gt;zone[<span class=\"number\">0</span>], data, len, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ISBLK(minode-&gt;mode)) &#123;</span><br><span class=\"line\">        assert(minode-&gt;zone[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"type\">device_t</span> *device = device_get(minode-&gt;zone[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        assert(len % BLOCK_SIZE == <span class=\"number\">0</span>);</span><br><span class=\"line\">        assert(device_read(minode-&gt;zone[<span class=\"number\">0</span>], data, len / BLOCK_SIZE, offset / BLOCK_SIZE, <span class=\"number\">0</span>) == EOK);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(ISFILE(minode-&gt;mode) || ISDIR(minode-&gt;mode));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  EOF</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset &gt;= minode-&gt;size) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    u32 begin = offset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    u32 left = MIN(len, minode-&gt;size - offset);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"type\">idx_t</span> nr = minix_bmap(inode, offset / BLOCK_SIZE, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        assert(nr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"type\">buffer_t</span> *buf = bread(inode-&gt;dev, nr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        u32 start = offset % BLOCK_SIZE;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        u32 chars = MIN(BLOCK_SIZE - start, left);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//    </span></span><br><span class=\"line\">        offset += chars;</span><br><span class=\"line\">        left -= chars;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"type\">char</span> *ptr = buf-&gt;data + start;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(data, ptr, chars);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        data += chars;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        brelse(buf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    inode-&gt;atime = time();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> offset - begin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<blockquote>\n<ol>\n<li>minode-&gt;zone[0]&#x2F;</li>\n<li>whileminix_bmapizoneoffset</li>\n<li></li>\n<li> <code>MIN(BLOCK_SIZE - start, left)</code> </li>\n<li>len2~4</li>\n</ol>\n</blockquote>\n<p>minix_bmaponixminix_bmap <a href=\"https://blog.csdn.net/m0_52566365/article/details/139525258\"> Onix &amp; XV6 2Unix</a>  i offset</p>\n<blockquote>\n<ul>\n<li> offset zone</li>\n<li> offset <ul>\n<li>offset</li>\n<li>offset <code>(offset &amp; 0x7FC00) &gt;&gt; 10</code> 9uint16_toffset10 <code>offset &amp; 0x3FF</code> </li>\n</ul>\n</li>\n<li> offset <ul>\n<li>offset + </li>\n<li>offset <code>(offset &amp; 0xFF80000) &gt;&gt; 10</code> 9uint16_t <code>(offset &amp; 0x7FC00) &gt;&gt; 10</code> uint16_toffset10 <code>offset &amp; 0x3FF</code> </li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p> <strong>onixzoneuint16_tonix2^16 - 1 onix 64MB</strong> </p>\n<p>onix</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p><code>find_entry</code>  <code>add_entry</code>  onix</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minix_dentry_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    u16 nr;              <span class=\"comment\">// i </span></span><br><span class=\"line\">    <span class=\"type\">char</span> name[NAME_LEN]; <span class=\"comment\">// </span></span><br><span class=\"line\">&#125; <span class=\"type\">minix_dentry_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p><img src=\"/2025/09/28/xv6/FileSystem/photo/filesystem/onix_dentry.drawio.png\"></p>\n<p>onixfind_entryfor</p>\n<p>add_entry <code>nr</code> 0onixnr0nr0onixminix_rmdir</p>\n<hr>\n<p><strong></strong></p>"},{"title":" Onix & XV6 3Unix-like","date":"2024-06-08T04:00:00.000Z","_content":"\n## \n\nXV6CPU\n\nXV6cpu &  & && & BSP4K & kmap4K\n\nOnix\n\n- [github](https://github.com/StevenBaby/onix)\n\n- [B](https://www.bilibili.com/video/BV1qM4y127om/)\n\nXV6-x86github\n\n- [](https://github.com/mit-pdos/xv6-public)\n\n<!-- more -->\n\n## \n\nOS\n\n\n\n\n\n-  CPU UARTUART\n\n-  CPU \n\n- IO\n\n  CPU  \n\n### Onix\n\nPC 8259a PICprogrammable interrupt controllerPICINTCPUonix\n\n![](./Scheduler/photo/scheduler/8259a.drawio.png)\n\n8259a8259aPICINTCPU8259aINTPICIR2PIC PICPICCPU\n\nPICcpu\n\n-  (Initialization Command Words, ICW), ICW  4  ICW1 ~ ICW4\n\n-  (Operation Command Word, OCW), OCW  3  OCW1 ~ OCW3\n\nICW  ICW **** ICW1ICW2ICW3ICW4\n\nOCW  8259A 8259A  OCW OCW 3 \n\n**Onix**https://github.com/StevenBaby/onix/blob/dev/docs/04%20%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F/033%20%E5%A4%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.md\n\n8259aOnix\n\n```cpp\n#define PIC_M_CTRL 0x20 // \n#define PIC_M_DATA 0x21 // \n#define PIC_S_CTRL 0xa0 // \n#define PIC_S_DATA 0xa1 // \n#define PIC_EOI 0x20    // \n\n// \nvoid pic_init()\n{\n    // PIC\n    outb(PIC_M_CTRL, 0b00010001); // ICW1: ,  8259, ICW4.\n    outb(PIC_M_DATA, 0x20);       // ICW2:  0x20\n    outb(PIC_M_DATA, 0b00000100); // ICW3: IR2.\n    outb(PIC_M_DATA, 0b00000001); // ICW4: 8086, EOI\n\n    // PIC\n    outb(PIC_S_CTRL, 0b00010001); // ICW1: ,  8259, ICW4.\n    outb(PIC_S_DATA, 0x28);       // ICW2:  0x28\n    outb(PIC_S_DATA, 2);          // ICW3:  IR2 \n    outb(PIC_S_DATA, 0b00000001); // ICW4: 8086, EOI\n\n    outb(PIC_M_DATA, 0b11111111); // OCW1PIC\n    outb(PIC_S_DATA, 0b11111111); // OCW1PIC\n}\n```\n\nCPUPICPICOCW2 \n\n```cpp\n// \nvoid send_eoi(int vector)\n{\n    if (vector >= 0x20 && vector < 0x28)\n    {\n        outb(PIC_M_CTRL, PIC_EOI);\n    }\n    if (vector >= 0x28 && vector < 0x30)\n    {\n        outb(PIC_M_CTRL, PIC_EOI);\n        outb(PIC_S_CTRL, PIC_EOI);\n    }\n}\n```\n\nOS\n\n### XV6\n\nAPIC\n\n\n\n![](./Scheduler/photo/scheduler/APICStructure.png)\n\nhttps://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\n\n\n\nBSPbootstrap processor\n\nAPxapplication processors \n\nBSPAPxAP\n\nCPULocal APICAdvanced Programmable Interrupt Controller**lapiccpu**cpucpuAPICcpucpucpuespeipeflag\n\nlapicICCinterrupt controller communications BusIO APIC**ioapiccpu**cpu**ioapicIRQlapicIDlapic**lapicioapicioapic168259aioapic**ioapic8259a PIC**cpu\n\niopic RTE(Redirection Table Entry)RTE64entryentryioapicentrylapic\n\nlapicIDcpudevice spacelapicIDlapicIDcpulapicIDICC Buscpucpulapiclapiccpuioapiccpumaster picPIC_EOI\n\nlapicioapiclapicICR(Interrupt Command Register)ICRioapicRTEentrylapicIDlapiclapicBSPAPsINIT or STARTUP IPIinterprocessor interrupts\n\nXV6cpulapiciopicmpinitmpinitlapiciopic\"AP\"\n\nLocal APICIO APIIChttps://blog.csdn.net/weixin_46645613/article/details/119207945\n\n### \n\ncpu\n\nEntryEntry8\n\n![](./Scheduler/photo/scheduler/IDT_Entry.png)\n\n- Offset\n\n- Selector\n\n- Type **eflagFL_IFeflagFL_IF** i\n\n- S0\n\n- DPL0x00x3DPL_USER\n\n- P1.\n\nXV6XV6\n\n```cpp\n// Gate descriptors for interrupts and traps\nstruct gatedesc {\n  uint off_15_0 : 16;   // low 16 bits of offset in segment\n  uint cs : 16;         // code segment selector\n  uint args : 5;        // # args, 0 for interrupt/trap gates\n  uint rsv1 : 3;        // reserved(should be zero I guess)\n  uint type : 4;        // type(STS_{IG32,TG32})\n  uint s : 1;           // must be 0 (system)\n  uint dpl : 2;         // descriptor(meaning new) privilege level\n  uint p : 1;           // Present\n  uint off_31_16 : 16;  // high bits of offset in segment\n};\n\n// Set up a normal interrupt/trap gate descriptor.\n// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.\n//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone\n// - sel: Code segment selector for interrupt/trap handler\n// - off: Offset in code segment for interrupt/trap handler\n// - dpl: Descriptor Privilege Level -\n//        the privilege level required for software to invoke\n//        this interrupt/trap gate explicitly using an int instruction.\n#define SETGATE(gate, istrap, sel, off, d)                \\\n{                                                         \\\n  (gate).off_15_0 = (uint)(off) & 0xffff;                \\\n  (gate).cs = (sel);                                      \\\n  (gate).args = 0;                                        \\\n  (gate).rsv1 = 0;                                        \\\n  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \\\n  (gate).s = 0;                                           \\\n  (gate).dpl = (d);                                       \\\n  (gate).p = 1;                                           \\\n  (gate).off_31_16 = (uint)(off) >> 16;                  \\\n}\n```\n\n\n\n3216\n\n![](./Scheduler/photo/scheduler/IDTR.png)\n\n## AP\n\nmain\n\n```cpp\n// Bootstrap processor starts running C code here.\n// Allocate a real stack and switch to it, first\n// doing some setup required for memory allocator to work.\nint\nmain(void)\n{\n  kinit1(end, P2V(4*1024*1024)); // \n  kvmalloc();      // \n  mpinit();        // detect other processors\n  lapicinit();     // interrupt controller\n  seginit();       // \n  picinit();       // disable pic // 8259A\n  ioapicinit();    // another interrupt controller\n  // ...\n  pinit();         // process table // ptable\n  tvinit();        // trap vectors\n  // ...\n  startothers();   // start other processors\n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // \n  userinit();      // first user process // initROP\n  mpmain();        // finish this processor's setup // mpmain\n}\n\n// Other AP CPUs jump here from entryother.S.\nstatic void\nmpenter(void)\n{\n  switchkvm();  // APkpgdir\n  seginit();    // \n  lapicinit();  // mainBSPlapicinit\n  mpmain();     // mpmain\n}\n\n// BSPAPS\n// \n//    1\n//    2\n//    3 \n// Common CPU setup code.\nstatic void\nmpmain(void)\n{\n  cprintf(\"cpu%d: starting %d\\n\", cpuid(), cpuid());\n  idtinit();       // load idt register // lidt\n  xchg(&(mycpu()->started), 1); // tell startothers() we're up\n  scheduler();     // start running processes\n}\n```\n\nBSPmaiin\n\n### mpinitcpu\n\n[](https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf)\n\nCPUCPUBSPCPUAPCPUBSP **BSPAPAPBSPMP floating pointer structureMP floating pointer structureMP configuration tableioapicMP floating pointer structureCPUBSPCPUBSPAPBSPAP** BSP CPUlapicIDIDCPUCPUBSPAPAP CPUAPOS**INIT or STARTUP interprocessor interrupts (IPIs)APBSPINIT or STARTUP** APBSP****\n\nBSPMP floating pointer structure**1MMP floating pointer structureBIOSBISO1M**\n\n1. In the first kilobyte of Extended BIOS Data Area (EBDA), or\n2. Within the last kilobyte of system base memory, or\n3. In the BIOS ROM address space between 0F0000h and 0FFFFFh.\n\n1Mhttps://wiki.osdev.org/BDA#BIOS_Data_Area_.28BDA.29\n\nMP Configuration Data StructuresMP floating pointer structureMP Configuration Table HeaderTable Entries\n\n![](./Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png)\n\nMP floating pointer structure\n\n![](./Scheduler/photo/scheduler/MP_floating_pointer_structure.png)\n\nPHYSICAL ADDRESS POINTERMP config table\n\nMP Configuration Table Header\n\n![](./Scheduler/photo/scheduler/MP_configuration_table_header.png)\n\n\n- MEMORY-MAPPED ADDRESS OF LOCAL APIC cpu**CPUlapic**lapic\"cpu\"cpulapic\n\n- BASE TABLE LENGTHtable\n\nMP Configuration Table HeaderBase MP Configuration Table EntriesEntryEntryEntry5Entry\n\n![](./Scheduler/photo/scheduler/entry_types.png)\n\nXV6Processor EntriesI/O APICEntry\n\nProcessor Entries\n\n![](./Scheduler/photo/scheduler/processor_entry.png)\n\nLOCAL APIC IDCPUlapicIDCPU\n\nI/O APIC Entries\n\n![](./Scheduler/photo/scheduler/ioapic_entry.png)\n\nI/O APIC IDI/O APICID\n\n\n\n```cpp\nvoid\nmpinit(void)\n{\n  uchar *p, *e;\n  int ismp;\n  struct mp *mp;              // MP floating pointer structure\n  struct mpconf *conf;        // MP Configuration Table Header\n  struct mpproc *proc;        // Processor Entries\n  struct mpioapic *ioapic;    // I/O APIC Entries\n\n  if((conf = mpconfig(&mp)) == 0)     // MP floating pointer structurePHYSICAL ADDRESS POINTERMP Configuration Table Header\n    panic(\"Expect to run on an SMP\");\n  ismp = 1;\n  lapic = (uint*)conf->lapicaddr;     // lapiclapic\n  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){  // MP Configuration Table HeaderTable Entry\n    switch(*p){\n    case MPPROC:                      // Processor Entries\n      proc = (struct mpproc*)p;\n      if(ncpu < NCPU) {\n        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu // cpulapicid\n        ncpu++;                       // CPU\n      }\n      p += sizeof(struct mpproc);\n      continue;\n    case MPIOAPIC:                    // I/O APIC Entries\n      ioapic = (struct mpioapic*)p;\n      ioapicid = ioapic->apicno;      // ioapicid\n      p += sizeof(struct mpioapic);\n      continue;\n    case MPBUS:                       // Table Entry\n    case MPIOINTR:\n    case MPLINTR:\n      p += 8;\n      continue;\n    default:\n      ismp = 0;\n      break;\n    }\n  }\n  if(!ismp)\n    panic(\"Didn't find a suitable machine\");\n\n  if(mp->imcrp){\n    // PIC ModeAPIC \n    // interrupt mode configuration register --> IMCR\n    // Bochs doesn't support IMCR, so this doesn't run on Bochs.\n    // But it would on real hardware.\n    outb(0x22, 0x70);   // Select IMCR\n    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.  // APIC\n  }\n}\n```\n\nmp->imcrp\n\n![](./Scheduler/photo/scheduler/imcrp.png)\n\n[](https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf)\n\n### lapicinitBSPcpulapic\n\nintel 64 and IA-32 3 \n\n```cpp\nvoid\nlapicinit(void)\n{\n  if(!lapic)    // lapicmpinitMP Configuration Table Headerlapic\n    return;\n\n  // Enable local APIC; set spurious interrupt vector.\n  lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));      // cpuAPIC\n\n  // lapic\n  // The timer repeatedly counts down at bus frequency\n  // from lapic[TICR] and then issues an interrupt.\n  // If xv6 cared more about precise timekeeping,\n  // TICR would be calibrated using an external time source.\n  lapicw(TDCR, X1);                               // X1\n  lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER)); // PERIODIC0x20\n  lapicw(TICR, 10000000);                         // \n\n  // Disable logical interrupt lines.\n  lapicw(LINT0, MASKED);                          // LINT0lapic\n  lapicw(LINT1, MASKED);                          // LINT1lapic\n\n  // Disable performance counter overflow interrupts\n  // on machines that provide that interrupt entry.\n  if(((lapic[VER]>>16) & 0xFF) >= 4)\n    lapicw(PCINT, MASKED);                        // PCINT\n\n  // Map error interrupt to IRQ_ERROR.\n  lapicw(ERROR, T_IRQ0 + IRQ_ERROR);            // 0x20 + 0x13ERROR\n\n  // Clear error status register (requires back-to-back writes).\n  lapicw(ESR, 0);\n  lapicw(ESR, 0);\n\n  // Ack any outstanding interrupts.\n  lapicw(EOI, 0);                               // ioapicEOI\n\n  // Send an Init Level De-Assert to synchronise arbitration ID's.\n  lapicw(ICRHI, 0);                             // // apic\n  lapicw(ICRLO, BCAST | INIT | LEVEL);          //  & INIT & \n  while(lapic[ICRLO] & DELIVS)                  // \n    ;\n\n  // Enable interrupts on the APIC (but not on the processor).\n  lapicw(TPR, 0);\n}\n```\n\n**BSPlapicAP**\n\n### ioapicinitioapic\n\nioapicmaster picioapicioapic RTE(Redirection Table Entry)RTET_IRQ0T_IRQ0 == 0x20EntryconsoleinitioapicenableEntry RTE(Redirection Table Entry)https://blog.csdn.net/weixin_46645613/article/details/119207945\n\n```cpp\nvoid\nioapicinit(void)\n{\n  int i, id, maxintr;\n\n  ioapic = (volatile struct ioapic*)IOAPIC;           // 0xFEC00000   // Default physical address of IO APIC\n  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;       // ioapic\n  id = ioapicread(REG_ID) >> 24;                      // ioapicID\n  if(id != ioapicid)                                  // \n    cprintf(\"ioapicinit: id isn't equal to ioapicid; not a MP\\n\");\n\n  // Mark all interrupts edge-triggered, active high, disabled,\n  // and not routed to any CPUs.\n  for(i = 0; i <= maxintr; i++){    //  RTE(Redirection Table Entry)PIC\n    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));\n    ioapicwrite(REG_TABLE+2*i+1, 0);\n  }\n}\n```\n\n### tvinit\n\nXV6\n\n\n\n```cpp\n// Interrupt descriptor table (shared by all CPUs).\nstruct gatedesc idt[256];   // \nextern uint vectors[];  // vectorsvectors.pl\n```\n\ntvinitSETGATE\n\nSETGATE(gate, istrap, sel, off, d) \n\n- 1idt[i]entry\n\n- 2\n\n- 3\n\n- 4\n\n- 5\n\n\n\n```cpp\nvoid\ntvinit(void)\n{\n  int i;\n  // \n  for(i = 0; i < 256; i++)\n    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);\n\n  // DPL_USER\n  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);\n\n  initlock(&tickslock, \"time\");\n}\n```\n\nvectors.plpl\n\n```pl\n#!/usr/bin/perl -w\n\n# Generate vectors.S, the trap/interrupt entry points.\n# There has to be one entry point per interrupt number\n# since otherwise there's no way for trap() to discover\n# the interrupt number.\n\nprint \"# generated by vectors.pl - do not edit\\n\";\nprint \"# handlers\\n\";\nprint \".globl alltraps\\n\";\nfor(my $i = 0; $i < 256; $i++){\n    print \".globl vector$i\\n\";\n    print \"vector$i:\\n\";\n    if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){\n        # cpuerrcode\n        # \n        # 0\n        # trapret\n        print \"  pushl \\$0\\n\";\n    }\n    print \"  pushl \\$$i\\n\";\n    print \"  jmp alltraps\\n\";\n}\n\nprint \"\\n# vector table\\n\";\nprint \".data\\n\";\nprint \".globl vectors\\n\";\nprint \"vectors:\\n\";\nfor(my $i = 0; $i < 256; $i++){\n    print \"  .long vector$i\\n\";\n}\n```\n\nplforvectorsvectorsforforifcpu****trapretforjmpplplalltrapsalltrapsplvectors256vectorii=12...\n\ntrapasm.Salltraps\n\n```asm\n#include \"mmu.h\"\n\n  # vectors.S sends all traps here.\n.globl alltraps\nalltraps:          # \n  # Build trap frame.\n  pushl %ds\n  pushl %es\n  pushl %fs\n  pushl %gs\n  pushal\n  \n  # Set up data segments.\n  movw $(SEG_KDATA<<3), %ax\n  movw %ax, %ds\n  movw %ax, %es\n\n  # Call trap(tf), where tf=%esp\n  pushl %esp\n  call trap       # trap\n  addl $4, %esp\n\n  # Return falls through to trapret...\n.globl trapret\ntrapret:          # \n  popal\n  popl %gs\n  popl %fs\n  popl %es\n  popl %ds\n  addl $0x8, %esp  # trapno and errcode\n  iret\n```\n\ntvinitplalltraps\n\n![](./Scheduler/photo/scheduler/trap__structure.png)\n\n\n\n\n\n\n0. TSSss0esp0\n\n1. **cpussesp**\n\n2. cpueflagscseip****\n\n3. **alltraps******\n\n4. trap\n\n5. **trapret******\n\n6. iretcpueflagscseip\n\n7. cpussesp\n\n****\n\n1. cpueflagscseip****\n\n2. **alltraps******\n\n3. trap\n\n4. **trapret******\n\n5. iretcpueflagscseip\n\nXV6\n\n```cpp\n//PAGEBREAK: 36\n// Layout of the trap frame built on the stack by the\n// hardware and by trapasm.S, and passed to trap().\nstruct trapframe {\n  // registers as pushed by pusha\n  uint edi;\n  uint esi;\n  uint ebp;\n  uint oesp;      // useless & ignored\n  uint ebx;\n  uint edx;\n  uint ecx;\n  uint eax;\n\n  // rest of trap frame\n  ushort gs;\n  ushort padding1;\n  ushort fs;\n  ushort padding2;\n  ushort es;\n  ushort padding3;\n  ushort ds;\n  ushort padding4;\n  uint trapno;\n\n  // below here defined by x86 hardware\n  uint err;\n  uint eip;\n  ushort cs;\n  ushort padding5;\n  uint eflags;\n\n  // below here only when crossing rings, such as from user to kernel\n  uint esp;\n  ushort ss;\n  ushort padding6;\n};\n```\n\n\n\n![](./Scheduler/photo/scheduler/trap_frame.png)\n\nhttps://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\n\n### startothersAP\n\nAPAP[](https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf)universal algorithmXV6lapicstartap\n\n\n\n![](./Scheduler/photo/scheduler/universal_algorithm.png)\n\nXV6AP\n\n```cpp\n// Start the non-boot (AP) processors.\nstatic void\nstartothers(void)\n{\n  extern uchar _binary_entryother_start[], _binary_entryother_size[];\n  uchar *code;\n  struct cpu *c;\n  char *stack;\n\n  // Write entry code to unused memory at 0x7000.\n  // The linker has placed the image of entryother.S in\n  // _binary_entryother_start.\n  // APentryotherentryother  boot + entry\n  code = P2V(0x7000);\n\n  // entryother0x7000\n  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);\n\n  // BSP forAP\n  for(c = cpus; c < cpus+ncpu; c++){\n    if(c == mycpu())  // We've started already.\n      continue;\n\n    // Tell entryother.S what stack to use, where to enter, and what\n    // pgdir to use. We cannot use kpgdir yet, because the AP processor\n    // is running in low  memory, so we use entrypgdir for the APs too.\n    stack = kalloc();   // APscheduler\n    *(void**)(code-4) = stack + KSTACKSIZE;\n    *(void(**)(void))(code-8) = mpenter;  // APmainmpenter\n    // BSP4M big page\n    *(int**)(code-12) = (void *) V2P(entrypgdir);\n\n    // lapicstartapuniversal algorithm\n    lapicstartap(c->apicid, V2P(code));   \n\n    // AP\n    // wait for cpu to finish mpmain()\n    while(c->started == 0)  \n      ;\n  }\n}\n```\n\nAP bootBSPbootBSP0x7c00AP0x70000x7000bootasm.S + entry.S\n\n1. \n\n2. entrypgdir\n\n3. scheduler\n\n4. mpenter\n\nentryother.S\n\nmpenter\n\n```cpp\n// Other CPUs jump here from entryother.S.\nstatic void\nmpenter(void)\n{\n  switchkvm();    // 4kkpgdir\n  seginit();       //BSPmainBSPentryother.S\n  lapicinit();    // BSP\n  mpmain();       // mpmain\n}\n```\n\nAPBSPCPUmpmainBSPmainmpmainBSPAP\n\nmpmainschedulerCPU\n\nmpmain\n\n```cpp\n// Common CPU setup code.\nstatic void\nmpmain(void)\n{\n  cprintf(\"cpu%d: starting %d\\n\", cpuid(), cpuid());\n  idtinit();       // load idt register\n  xchg(&(mycpu()->started), 1); // tell startothers() we're up\n  scheduler();     // start running processes\n}\n```\n\n## \n\nXV6CPU\n\n```cpp\n// Per-CPU state\nstruct cpu {\n  // lapciid\n  uchar apicid;                // Local APIC ID\n  // \n  struct context *scheduler;   // swtch() here to enter scheduler\n  // \n  struct taskstate ts;         // Used by x86 to find stack for interrupt\n  // \n  struct segdesc gdt[NSEGS];   // x86 global descriptor table\n  // cpu\n  volatile uint started;       // Has the CPU started?\n  // \n  int ncli;                    // Depth of pushcli nesting.\n  // cpu\n  int intena;                  // Were interrupts enabled before pushcli?\n  // cpuPCB\n  struct proc *proc;           // The process running on this cpu or null\n};\n\nextern struct cpu cpus[NCPU]; // cpu\nextern int ncpu;              // cpu\n```\n\nCPU\n\n|                                       |       |   |\n| :-:                                       |  :-:      |  :-:    |\n|                                |         |         |\n| lapic           |           |        |\n|ioapic                                     |         |          |\n|cpueipespeflag     |          |         |\n|               |           |        |\n|kpgdir               |         |          |\n|                                   |         |          |\n|ptable                          |        |          |\n|                              |         |         |\n|                                       |         |         |\n\nXV6PCBOSXV6PCBXV6PCBPCBOnixPCBPDBespesp4Kesp4K\n\nXV6PCB\n\n```cpp\n// proc.h\nenum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };\n\n// Per-process state\nstruct proc {\n  // \n  uint sz;                     // Size of process memory (bytes)\n  // \n  pde_t* pgdir;                // Page table\n  // \n  char *kstack;                // Bottom of kernel stack for this process\n  // \n  enum procstate state;        // Process state\n  // pid\n  int pid;                     // Process ID\n  // \n  struct proc *parent;         // Parent process\n  // \n  struct trapframe *tf;        // Trap frame for current syscall\n  // \n  struct context *context;     // swtch() here to run process\n  // \n  void *chan;                  // If non-zero, sleeping on chan\n  // \n  int killed;                  // If non-zero, have been killed\n  // \n  struct file *ofile[NOFILE];  // Open files\n  // inode\n  struct inode *cwd;           // Current directory\n  // \n  char name[16];               // Process name (debugging)\n};\n\n// proc.c\nstruct {\n  struct spinlock lock;       // \n  struct proc proc[NPROC];\n} ptable;                     // cpu\n\nstatic struct proc *initproc; // initPCB\nint nextpid = 1;              // pid\n```\n\nXV66UNUSEDPCB, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE/ PCBchanXV6sleepwaitreadsleeplockXV6SLEEPINGptableptablechanchanXV6chanXV6sleepchanticksjefrrisXV6\n\nAPBSPAPschedulerscheduler\n\n```cpp\n//PAGEBREAK: 42\n// Per-CPU process scheduler.\n// Each CPU calls scheduler() after setting itself up.\n// Scheduler never returns.  It loops, doing:\n//  - choose a process to run\n//  - swtch to start running that process\n//  - eventually that process transfers control\n//      via swtch back to the scheduler.\nvoid\nscheduler(void)\n{\n  struct proc *p;\n  struct cpu *c = mycpu();  // schedulercpu\n  c->proc = 0;              // cpu\n  \n  for(;;){\n    // Enable interrupts on this processor.\n    sti();                  // \n\n    // pushclimycpu()->intenasched\n    // Loop over process table looking for process to run.\n    acquire(&ptable.lock); // ptable\n    // ptable\n    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){\n      if(p->state != RUNNABLE)  // \n        continue;\n      // else \n      // Switch to chosen process.  It is the process's job\n      // to release ptable.lock and then reacquire it\n      // before jumping back to us.\n      c->proc = p;  // pcpu\n      //  \n      // 1tss\n      // 2tss\n      // 3cpup\n      switchuvm(p);\n      p->state = RUNNING; // p\n\n      swtch(&(c->scheduler), p->context); // pcpu\n      switchkvm();        // kpgdir\n\n      // Process is done running for now.\n      // It should have changed its p->state before coming back.\n      c->proc = 0;        // \n    }\n    release(&ptable.lock);  // \n\n  }\n}\n```\n\nXV6round robin\n\nswitchuvmtsscpup**tss**TSSTSSespssswitchuvm\n\n```cpp\n// Switch TSS and h/w page table to correspond to process p.\nvoid\nswitchuvm(struct proc *p)\n{\n  if(p == 0)\n    panic(\"switchuvm: no process\");\n  if(p->kstack == 0)\n    panic(\"switchuvm: no kstack\");\n  if(p->pgdir == 0)\n    panic(\"switchuvm: no pgdir\");\n\n  pushcli();\n  // tsscputss\n  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,\n                                sizeof(mycpu()->ts)-1, 0);\n  mycpu()->gdt[SEG_TSS].s = 0;\n  mycpu()->ts.ss0 = SEG_KDATA << 3;                 // \n  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;  // \n  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit\n  // forbids I/O instructions (e.g., inb and outb) from user space\n  mycpu()->ts.iomb = (ushort) 0xFFFF;\n  ltr(SEG_TSS << 3);                                // tss\n  // p\n  lcr3(V2P(p->pgdir));  // switch to process's address space\n  popcli();\n}\n```\n\nhttps://github.com/StevenBaby/onix/blob/dev/docs/07%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/062%20%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E7%AE%80%E4%BB%8B.md\n\nswtch\n\n```asm\n# Context switch\n#\n#   void swtch(struct context **old, struct context *new);\n# \n# Save the current registers on the stack, creating\n# a struct context, and save its address in *old.\n# Switch stacks to new and pop previously-saved registers.\n\n.globl swtch\nswtch:                # pushl eipcpu\n  movl 4(%esp), %eax  # struct context**\n  movl 8(%esp), %edx  #   struct context*\n\n  # Save old callee-saved registers\n  pushl %ebp\n  pushl %ebx\n  pushl %esi\n  pushl %edi\n\n  # Switch stacks\n  movl %esp, (%eax) # *\n  movl %edx, %esp   # esp\n\n  # Load new callee-saved registers\n  popl %edi\n  popl %esi\n  popl %ebx\n  popl %ebp\n  ret\n```\n\nstruct context\n\n```cpp\nstruct context {\n  uint edi;\n  uint esi;\n  uint ebx;\n  uint ebp;\n  uint eip;\n};\n```\n\ncpuschedulerschedcpu****traptrapyieldyieldschedtrap\n\n```cpp\nstruct spinlock tickslock;\nuint ticks;\n\n//PAGEBREAK: 41\nvoid\ntrap(struct trapframe *tf)\n{\n  if(tf->trapno == T_SYSCALL){  // \n    // ...\n    return;\n  }\n\n  switch(tf->trapno){\n  case T_IRQ0 + IRQ_TIMER:\n    if(cpuid() == 0){\n      acquire(&tickslock);\n      ticks++;            // 1\n      wakeup(&ticks);     // sleeping\n      release(&tickslock);\n    }\n    lapiceoi();           // lapic\n    break;\n  // ...\n  }\n\n  // ...\n\n  // Force process to give up CPU on clock tick.\n  // If interrupts were on while locks held, would need to check nlock.\n  if(myproc() && myproc()->state == RUNNING &&\n     tf->trapno == T_IRQ0+IRQ_TIMER)\n    yield();    // cpu\n\n  // ...\n}\n```\n\nyieldschedschedRUNNABLE\n\n```cpp\n// Enter scheduler.  Must hold only ptable.lock\n// and have changed proc->state. Saves and restores\n// intena because intena is a property of this\n// kernel thread, not this CPU. It should\n// be proc->intena and proc->ncli, but that would\n// break in the few places where a lock is held but\n// there's no process.\nvoid\nsched(void)\n{\n  int intena;\n  struct proc *p = myproc();\n\n  if(!holding(&ptable.lock))\n    panic(\"sched ptable.lock\");\n  if(mycpu()->ncli != 1)        // \n    panic(\"sched locks\");\n  if(p->state == RUNNING)       // sched\n    panic(\"sched running\");\n  if(readeflags()&FL_IF)        // \n    panic(\"sched interruptible\");\n  intena = mycpu()->intena;     // intena\n  swtch(&p->context, mycpu()->scheduler); // scheduler\n  mycpu()->intena = intena;     // intena\n}\n\n// Give up the CPU for one scheduling round.\nvoid\nyield(void)\n{\n  acquire(&ptable.lock);  //DOC: yieldlock\n  myproc()->state = RUNNABLE;\n  sched();\n  release(&ptable.lock);\n}\n```\n\nschedintenaintenaPCBXV6shcedintenaPCB**schedulerptable.lockpushcliintenaschedintenaschedulerschedulerptable.lockpopcliintenaintenafor**\n\n\n\n![](./Scheduler/photo/scheduler/task_stack.drawio.png)\n\nyieldscheduleryieldptableintenaschedulerschedulerschedulerschedulerptableptableschedulerptable\n\n![](./Scheduler/photo/scheduler/yield_scheduler.png)\n\nXV6**cpushedulerschedulerptableswapIncpuswapOut**\n\n**XV6XV6**\n\n**OnixOnixOnix**\n\n**sylarXV6**\n\n![](./Scheduler/photo/scheduler/scheduler.drawio.png)\n\n**CPU PoolXV6CPUptableCPU**\n\nsylar **sylarXV6** sylarC++sylarhttps://blog.csdn.net/m0_52566365/article/details/135991331\n\n## \n\nXV6\n\n|                             |XV6                        |Onix                 |\n|:-:                          |:-:|:-:|\n||kallockalloc|get_page2564G/page + alloc_kpagealloc_kpage/page + kmalloc/byte|\n|       |               |ebpediesiedxecxebx|\n|                     |               | |\n|                       |                 |loader     |\n|idle                     |idle                   |idle           |\n|...                          |...                             |...                     |\n\nOnixOnixOnixXV6Onix****OSXV6OSCPUCPUeipespeflagcpucpu\n\nXV6**XV6**XV6MuduoOne loop per thread MuduoOne loop per threadLinuxCPUXV6cpuptablecpuptablecpucpucpuxcpucpuxcpux**One loop per CPU**\n\n![](./Scheduler/photo/scheduler/scheduler_pluse.drawio.png)\n\n4\n\n****\n\nhttps://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\n\nXV6https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\n\nOnixhttps://github.com/StevenBaby/onix/\n\nAPIChttps://blog.csdn.net/weixin_46645613/article/details/119207945\n\n1https://zhuanlan.zhihu.com/p/394247844\n\n---\n\n****\n\n","source":"_posts/xv6/Scheduler.md","raw":"---\ntitle:  Onix & XV6 3Unix-like\ndate: 2024-06-08 12:00:00\ntags:\n  - Unix\n---\n\n## \n\nXV6CPU\n\nXV6cpu &  & && & BSP4K & kmap4K\n\nOnix\n\n- [github](https://github.com/StevenBaby/onix)\n\n- [B](https://www.bilibili.com/video/BV1qM4y127om/)\n\nXV6-x86github\n\n- [](https://github.com/mit-pdos/xv6-public)\n\n<!-- more -->\n\n## \n\nOS\n\n\n\n\n\n-  CPU UARTUART\n\n-  CPU \n\n- IO\n\n  CPU  \n\n### Onix\n\nPC 8259a PICprogrammable interrupt controllerPICINTCPUonix\n\n![](./Scheduler/photo/scheduler/8259a.drawio.png)\n\n8259a8259aPICINTCPU8259aINTPICIR2PIC PICPICCPU\n\nPICcpu\n\n-  (Initialization Command Words, ICW), ICW  4  ICW1 ~ ICW4\n\n-  (Operation Command Word, OCW), OCW  3  OCW1 ~ OCW3\n\nICW  ICW **** ICW1ICW2ICW3ICW4\n\nOCW  8259A 8259A  OCW OCW 3 \n\n**Onix**https://github.com/StevenBaby/onix/blob/dev/docs/04%20%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F/033%20%E5%A4%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.md\n\n8259aOnix\n\n```cpp\n#define PIC_M_CTRL 0x20 // \n#define PIC_M_DATA 0x21 // \n#define PIC_S_CTRL 0xa0 // \n#define PIC_S_DATA 0xa1 // \n#define PIC_EOI 0x20    // \n\n// \nvoid pic_init()\n{\n    // PIC\n    outb(PIC_M_CTRL, 0b00010001); // ICW1: ,  8259, ICW4.\n    outb(PIC_M_DATA, 0x20);       // ICW2:  0x20\n    outb(PIC_M_DATA, 0b00000100); // ICW3: IR2.\n    outb(PIC_M_DATA, 0b00000001); // ICW4: 8086, EOI\n\n    // PIC\n    outb(PIC_S_CTRL, 0b00010001); // ICW1: ,  8259, ICW4.\n    outb(PIC_S_DATA, 0x28);       // ICW2:  0x28\n    outb(PIC_S_DATA, 2);          // ICW3:  IR2 \n    outb(PIC_S_DATA, 0b00000001); // ICW4: 8086, EOI\n\n    outb(PIC_M_DATA, 0b11111111); // OCW1PIC\n    outb(PIC_S_DATA, 0b11111111); // OCW1PIC\n}\n```\n\nCPUPICPICOCW2 \n\n```cpp\n// \nvoid send_eoi(int vector)\n{\n    if (vector >= 0x20 && vector < 0x28)\n    {\n        outb(PIC_M_CTRL, PIC_EOI);\n    }\n    if (vector >= 0x28 && vector < 0x30)\n    {\n        outb(PIC_M_CTRL, PIC_EOI);\n        outb(PIC_S_CTRL, PIC_EOI);\n    }\n}\n```\n\nOS\n\n### XV6\n\nAPIC\n\n\n\n![](./Scheduler/photo/scheduler/APICStructure.png)\n\nhttps://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\n\n\n\nBSPbootstrap processor\n\nAPxapplication processors \n\nBSPAPxAP\n\nCPULocal APICAdvanced Programmable Interrupt Controller**lapiccpu**cpucpuAPICcpucpucpuespeipeflag\n\nlapicICCinterrupt controller communications BusIO APIC**ioapiccpu**cpu**ioapicIRQlapicIDlapic**lapicioapicioapic168259aioapic**ioapic8259a PIC**cpu\n\niopic RTE(Redirection Table Entry)RTE64entryentryioapicentrylapic\n\nlapicIDcpudevice spacelapicIDlapicIDcpulapicIDICC Buscpucpulapiclapiccpuioapiccpumaster picPIC_EOI\n\nlapicioapiclapicICR(Interrupt Command Register)ICRioapicRTEentrylapicIDlapiclapicBSPAPsINIT or STARTUP IPIinterprocessor interrupts\n\nXV6cpulapiciopicmpinitmpinitlapiciopic\"AP\"\n\nLocal APICIO APIIChttps://blog.csdn.net/weixin_46645613/article/details/119207945\n\n### \n\ncpu\n\nEntryEntry8\n\n![](./Scheduler/photo/scheduler/IDT_Entry.png)\n\n- Offset\n\n- Selector\n\n- Type **eflagFL_IFeflagFL_IF** i\n\n- S0\n\n- DPL0x00x3DPL_USER\n\n- P1.\n\nXV6XV6\n\n```cpp\n// Gate descriptors for interrupts and traps\nstruct gatedesc {\n  uint off_15_0 : 16;   // low 16 bits of offset in segment\n  uint cs : 16;         // code segment selector\n  uint args : 5;        // # args, 0 for interrupt/trap gates\n  uint rsv1 : 3;        // reserved(should be zero I guess)\n  uint type : 4;        // type(STS_{IG32,TG32})\n  uint s : 1;           // must be 0 (system)\n  uint dpl : 2;         // descriptor(meaning new) privilege level\n  uint p : 1;           // Present\n  uint off_31_16 : 16;  // high bits of offset in segment\n};\n\n// Set up a normal interrupt/trap gate descriptor.\n// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.\n//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone\n// - sel: Code segment selector for interrupt/trap handler\n// - off: Offset in code segment for interrupt/trap handler\n// - dpl: Descriptor Privilege Level -\n//        the privilege level required for software to invoke\n//        this interrupt/trap gate explicitly using an int instruction.\n#define SETGATE(gate, istrap, sel, off, d)                \\\n{                                                         \\\n  (gate).off_15_0 = (uint)(off) & 0xffff;                \\\n  (gate).cs = (sel);                                      \\\n  (gate).args = 0;                                        \\\n  (gate).rsv1 = 0;                                        \\\n  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \\\n  (gate).s = 0;                                           \\\n  (gate).dpl = (d);                                       \\\n  (gate).p = 1;                                           \\\n  (gate).off_31_16 = (uint)(off) >> 16;                  \\\n}\n```\n\n\n\n3216\n\n![](./Scheduler/photo/scheduler/IDTR.png)\n\n## AP\n\nmain\n\n```cpp\n// Bootstrap processor starts running C code here.\n// Allocate a real stack and switch to it, first\n// doing some setup required for memory allocator to work.\nint\nmain(void)\n{\n  kinit1(end, P2V(4*1024*1024)); // \n  kvmalloc();      // \n  mpinit();        // detect other processors\n  lapicinit();     // interrupt controller\n  seginit();       // \n  picinit();       // disable pic // 8259A\n  ioapicinit();    // another interrupt controller\n  // ...\n  pinit();         // process table // ptable\n  tvinit();        // trap vectors\n  // ...\n  startothers();   // start other processors\n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // \n  userinit();      // first user process // initROP\n  mpmain();        // finish this processor's setup // mpmain\n}\n\n// Other AP CPUs jump here from entryother.S.\nstatic void\nmpenter(void)\n{\n  switchkvm();  // APkpgdir\n  seginit();    // \n  lapicinit();  // mainBSPlapicinit\n  mpmain();     // mpmain\n}\n\n// BSPAPS\n// \n//    1\n//    2\n//    3 \n// Common CPU setup code.\nstatic void\nmpmain(void)\n{\n  cprintf(\"cpu%d: starting %d\\n\", cpuid(), cpuid());\n  idtinit();       // load idt register // lidt\n  xchg(&(mycpu()->started), 1); // tell startothers() we're up\n  scheduler();     // start running processes\n}\n```\n\nBSPmaiin\n\n### mpinitcpu\n\n[](https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf)\n\nCPUCPUBSPCPUAPCPUBSP **BSPAPAPBSPMP floating pointer structureMP floating pointer structureMP configuration tableioapicMP floating pointer structureCPUBSPCPUBSPAPBSPAP** BSP CPUlapicIDIDCPUCPUBSPAPAP CPUAPOS**INIT or STARTUP interprocessor interrupts (IPIs)APBSPINIT or STARTUP** APBSP****\n\nBSPMP floating pointer structure**1MMP floating pointer structureBIOSBISO1M**\n\n1. In the first kilobyte of Extended BIOS Data Area (EBDA), or\n2. Within the last kilobyte of system base memory, or\n3. In the BIOS ROM address space between 0F0000h and 0FFFFFh.\n\n1Mhttps://wiki.osdev.org/BDA#BIOS_Data_Area_.28BDA.29\n\nMP Configuration Data StructuresMP floating pointer structureMP Configuration Table HeaderTable Entries\n\n![](./Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png)\n\nMP floating pointer structure\n\n![](./Scheduler/photo/scheduler/MP_floating_pointer_structure.png)\n\nPHYSICAL ADDRESS POINTERMP config table\n\nMP Configuration Table Header\n\n![](./Scheduler/photo/scheduler/MP_configuration_table_header.png)\n\n\n- MEMORY-MAPPED ADDRESS OF LOCAL APIC cpu**CPUlapic**lapic\"cpu\"cpulapic\n\n- BASE TABLE LENGTHtable\n\nMP Configuration Table HeaderBase MP Configuration Table EntriesEntryEntryEntry5Entry\n\n![](./Scheduler/photo/scheduler/entry_types.png)\n\nXV6Processor EntriesI/O APICEntry\n\nProcessor Entries\n\n![](./Scheduler/photo/scheduler/processor_entry.png)\n\nLOCAL APIC IDCPUlapicIDCPU\n\nI/O APIC Entries\n\n![](./Scheduler/photo/scheduler/ioapic_entry.png)\n\nI/O APIC IDI/O APICID\n\n\n\n```cpp\nvoid\nmpinit(void)\n{\n  uchar *p, *e;\n  int ismp;\n  struct mp *mp;              // MP floating pointer structure\n  struct mpconf *conf;        // MP Configuration Table Header\n  struct mpproc *proc;        // Processor Entries\n  struct mpioapic *ioapic;    // I/O APIC Entries\n\n  if((conf = mpconfig(&mp)) == 0)     // MP floating pointer structurePHYSICAL ADDRESS POINTERMP Configuration Table Header\n    panic(\"Expect to run on an SMP\");\n  ismp = 1;\n  lapic = (uint*)conf->lapicaddr;     // lapiclapic\n  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){  // MP Configuration Table HeaderTable Entry\n    switch(*p){\n    case MPPROC:                      // Processor Entries\n      proc = (struct mpproc*)p;\n      if(ncpu < NCPU) {\n        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu // cpulapicid\n        ncpu++;                       // CPU\n      }\n      p += sizeof(struct mpproc);\n      continue;\n    case MPIOAPIC:                    // I/O APIC Entries\n      ioapic = (struct mpioapic*)p;\n      ioapicid = ioapic->apicno;      // ioapicid\n      p += sizeof(struct mpioapic);\n      continue;\n    case MPBUS:                       // Table Entry\n    case MPIOINTR:\n    case MPLINTR:\n      p += 8;\n      continue;\n    default:\n      ismp = 0;\n      break;\n    }\n  }\n  if(!ismp)\n    panic(\"Didn't find a suitable machine\");\n\n  if(mp->imcrp){\n    // PIC ModeAPIC \n    // interrupt mode configuration register --> IMCR\n    // Bochs doesn't support IMCR, so this doesn't run on Bochs.\n    // But it would on real hardware.\n    outb(0x22, 0x70);   // Select IMCR\n    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.  // APIC\n  }\n}\n```\n\nmp->imcrp\n\n![](./Scheduler/photo/scheduler/imcrp.png)\n\n[](https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf)\n\n### lapicinitBSPcpulapic\n\nintel 64 and IA-32 3 \n\n```cpp\nvoid\nlapicinit(void)\n{\n  if(!lapic)    // lapicmpinitMP Configuration Table Headerlapic\n    return;\n\n  // Enable local APIC; set spurious interrupt vector.\n  lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));      // cpuAPIC\n\n  // lapic\n  // The timer repeatedly counts down at bus frequency\n  // from lapic[TICR] and then issues an interrupt.\n  // If xv6 cared more about precise timekeeping,\n  // TICR would be calibrated using an external time source.\n  lapicw(TDCR, X1);                               // X1\n  lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER)); // PERIODIC0x20\n  lapicw(TICR, 10000000);                         // \n\n  // Disable logical interrupt lines.\n  lapicw(LINT0, MASKED);                          // LINT0lapic\n  lapicw(LINT1, MASKED);                          // LINT1lapic\n\n  // Disable performance counter overflow interrupts\n  // on machines that provide that interrupt entry.\n  if(((lapic[VER]>>16) & 0xFF) >= 4)\n    lapicw(PCINT, MASKED);                        // PCINT\n\n  // Map error interrupt to IRQ_ERROR.\n  lapicw(ERROR, T_IRQ0 + IRQ_ERROR);            // 0x20 + 0x13ERROR\n\n  // Clear error status register (requires back-to-back writes).\n  lapicw(ESR, 0);\n  lapicw(ESR, 0);\n\n  // Ack any outstanding interrupts.\n  lapicw(EOI, 0);                               // ioapicEOI\n\n  // Send an Init Level De-Assert to synchronise arbitration ID's.\n  lapicw(ICRHI, 0);                             // // apic\n  lapicw(ICRLO, BCAST | INIT | LEVEL);          //  & INIT & \n  while(lapic[ICRLO] & DELIVS)                  // \n    ;\n\n  // Enable interrupts on the APIC (but not on the processor).\n  lapicw(TPR, 0);\n}\n```\n\n**BSPlapicAP**\n\n### ioapicinitioapic\n\nioapicmaster picioapicioapic RTE(Redirection Table Entry)RTET_IRQ0T_IRQ0 == 0x20EntryconsoleinitioapicenableEntry RTE(Redirection Table Entry)https://blog.csdn.net/weixin_46645613/article/details/119207945\n\n```cpp\nvoid\nioapicinit(void)\n{\n  int i, id, maxintr;\n\n  ioapic = (volatile struct ioapic*)IOAPIC;           // 0xFEC00000   // Default physical address of IO APIC\n  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;       // ioapic\n  id = ioapicread(REG_ID) >> 24;                      // ioapicID\n  if(id != ioapicid)                                  // \n    cprintf(\"ioapicinit: id isn't equal to ioapicid; not a MP\\n\");\n\n  // Mark all interrupts edge-triggered, active high, disabled,\n  // and not routed to any CPUs.\n  for(i = 0; i <= maxintr; i++){    //  RTE(Redirection Table Entry)PIC\n    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));\n    ioapicwrite(REG_TABLE+2*i+1, 0);\n  }\n}\n```\n\n### tvinit\n\nXV6\n\n\n\n```cpp\n// Interrupt descriptor table (shared by all CPUs).\nstruct gatedesc idt[256];   // \nextern uint vectors[];  // vectorsvectors.pl\n```\n\ntvinitSETGATE\n\nSETGATE(gate, istrap, sel, off, d) \n\n- 1idt[i]entry\n\n- 2\n\n- 3\n\n- 4\n\n- 5\n\n\n\n```cpp\nvoid\ntvinit(void)\n{\n  int i;\n  // \n  for(i = 0; i < 256; i++)\n    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);\n\n  // DPL_USER\n  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);\n\n  initlock(&tickslock, \"time\");\n}\n```\n\nvectors.plpl\n\n```pl\n#!/usr/bin/perl -w\n\n# Generate vectors.S, the trap/interrupt entry points.\n# There has to be one entry point per interrupt number\n# since otherwise there's no way for trap() to discover\n# the interrupt number.\n\nprint \"# generated by vectors.pl - do not edit\\n\";\nprint \"# handlers\\n\";\nprint \".globl alltraps\\n\";\nfor(my $i = 0; $i < 256; $i++){\n    print \".globl vector$i\\n\";\n    print \"vector$i:\\n\";\n    if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){\n        # cpuerrcode\n        # \n        # 0\n        # trapret\n        print \"  pushl \\$0\\n\";\n    }\n    print \"  pushl \\$$i\\n\";\n    print \"  jmp alltraps\\n\";\n}\n\nprint \"\\n# vector table\\n\";\nprint \".data\\n\";\nprint \".globl vectors\\n\";\nprint \"vectors:\\n\";\nfor(my $i = 0; $i < 256; $i++){\n    print \"  .long vector$i\\n\";\n}\n```\n\nplforvectorsvectorsforforifcpu****trapretforjmpplplalltrapsalltrapsplvectors256vectorii=12...\n\ntrapasm.Salltraps\n\n```asm\n#include \"mmu.h\"\n\n  # vectors.S sends all traps here.\n.globl alltraps\nalltraps:          # \n  # Build trap frame.\n  pushl %ds\n  pushl %es\n  pushl %fs\n  pushl %gs\n  pushal\n  \n  # Set up data segments.\n  movw $(SEG_KDATA<<3), %ax\n  movw %ax, %ds\n  movw %ax, %es\n\n  # Call trap(tf), where tf=%esp\n  pushl %esp\n  call trap       # trap\n  addl $4, %esp\n\n  # Return falls through to trapret...\n.globl trapret\ntrapret:          # \n  popal\n  popl %gs\n  popl %fs\n  popl %es\n  popl %ds\n  addl $0x8, %esp  # trapno and errcode\n  iret\n```\n\ntvinitplalltraps\n\n![](./Scheduler/photo/scheduler/trap__structure.png)\n\n\n\n\n\n\n0. TSSss0esp0\n\n1. **cpussesp**\n\n2. cpueflagscseip****\n\n3. **alltraps******\n\n4. trap\n\n5. **trapret******\n\n6. iretcpueflagscseip\n\n7. cpussesp\n\n****\n\n1. cpueflagscseip****\n\n2. **alltraps******\n\n3. trap\n\n4. **trapret******\n\n5. iretcpueflagscseip\n\nXV6\n\n```cpp\n//PAGEBREAK: 36\n// Layout of the trap frame built on the stack by the\n// hardware and by trapasm.S, and passed to trap().\nstruct trapframe {\n  // registers as pushed by pusha\n  uint edi;\n  uint esi;\n  uint ebp;\n  uint oesp;      // useless & ignored\n  uint ebx;\n  uint edx;\n  uint ecx;\n  uint eax;\n\n  // rest of trap frame\n  ushort gs;\n  ushort padding1;\n  ushort fs;\n  ushort padding2;\n  ushort es;\n  ushort padding3;\n  ushort ds;\n  ushort padding4;\n  uint trapno;\n\n  // below here defined by x86 hardware\n  uint err;\n  uint eip;\n  ushort cs;\n  ushort padding5;\n  uint eflags;\n\n  // below here only when crossing rings, such as from user to kernel\n  uint esp;\n  ushort ss;\n  ushort padding6;\n};\n```\n\n\n\n![](./Scheduler/photo/scheduler/trap_frame.png)\n\nhttps://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\n\n### startothersAP\n\nAPAP[](https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf)universal algorithmXV6lapicstartap\n\n\n\n![](./Scheduler/photo/scheduler/universal_algorithm.png)\n\nXV6AP\n\n```cpp\n// Start the non-boot (AP) processors.\nstatic void\nstartothers(void)\n{\n  extern uchar _binary_entryother_start[], _binary_entryother_size[];\n  uchar *code;\n  struct cpu *c;\n  char *stack;\n\n  // Write entry code to unused memory at 0x7000.\n  // The linker has placed the image of entryother.S in\n  // _binary_entryother_start.\n  // APentryotherentryother  boot + entry\n  code = P2V(0x7000);\n\n  // entryother0x7000\n  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);\n\n  // BSP forAP\n  for(c = cpus; c < cpus+ncpu; c++){\n    if(c == mycpu())  // We've started already.\n      continue;\n\n    // Tell entryother.S what stack to use, where to enter, and what\n    // pgdir to use. We cannot use kpgdir yet, because the AP processor\n    // is running in low  memory, so we use entrypgdir for the APs too.\n    stack = kalloc();   // APscheduler\n    *(void**)(code-4) = stack + KSTACKSIZE;\n    *(void(**)(void))(code-8) = mpenter;  // APmainmpenter\n    // BSP4M big page\n    *(int**)(code-12) = (void *) V2P(entrypgdir);\n\n    // lapicstartapuniversal algorithm\n    lapicstartap(c->apicid, V2P(code));   \n\n    // AP\n    // wait for cpu to finish mpmain()\n    while(c->started == 0)  \n      ;\n  }\n}\n```\n\nAP bootBSPbootBSP0x7c00AP0x70000x7000bootasm.S + entry.S\n\n1. \n\n2. entrypgdir\n\n3. scheduler\n\n4. mpenter\n\nentryother.S\n\nmpenter\n\n```cpp\n// Other CPUs jump here from entryother.S.\nstatic void\nmpenter(void)\n{\n  switchkvm();    // 4kkpgdir\n  seginit();       //BSPmainBSPentryother.S\n  lapicinit();    // BSP\n  mpmain();       // mpmain\n}\n```\n\nAPBSPCPUmpmainBSPmainmpmainBSPAP\n\nmpmainschedulerCPU\n\nmpmain\n\n```cpp\n// Common CPU setup code.\nstatic void\nmpmain(void)\n{\n  cprintf(\"cpu%d: starting %d\\n\", cpuid(), cpuid());\n  idtinit();       // load idt register\n  xchg(&(mycpu()->started), 1); // tell startothers() we're up\n  scheduler();     // start running processes\n}\n```\n\n## \n\nXV6CPU\n\n```cpp\n// Per-CPU state\nstruct cpu {\n  // lapciid\n  uchar apicid;                // Local APIC ID\n  // \n  struct context *scheduler;   // swtch() here to enter scheduler\n  // \n  struct taskstate ts;         // Used by x86 to find stack for interrupt\n  // \n  struct segdesc gdt[NSEGS];   // x86 global descriptor table\n  // cpu\n  volatile uint started;       // Has the CPU started?\n  // \n  int ncli;                    // Depth of pushcli nesting.\n  // cpu\n  int intena;                  // Were interrupts enabled before pushcli?\n  // cpuPCB\n  struct proc *proc;           // The process running on this cpu or null\n};\n\nextern struct cpu cpus[NCPU]; // cpu\nextern int ncpu;              // cpu\n```\n\nCPU\n\n|                                       |       |   |\n| :-:                                       |  :-:      |  :-:    |\n|                                |         |         |\n| lapic           |           |        |\n|ioapic                                     |         |          |\n|cpueipespeflag     |          |         |\n|               |           |        |\n|kpgdir               |         |          |\n|                                   |         |          |\n|ptable                          |        |          |\n|                              |         |         |\n|                                       |         |         |\n\nXV6PCBOSXV6PCBXV6PCBPCBOnixPCBPDBespesp4Kesp4K\n\nXV6PCB\n\n```cpp\n// proc.h\nenum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };\n\n// Per-process state\nstruct proc {\n  // \n  uint sz;                     // Size of process memory (bytes)\n  // \n  pde_t* pgdir;                // Page table\n  // \n  char *kstack;                // Bottom of kernel stack for this process\n  // \n  enum procstate state;        // Process state\n  // pid\n  int pid;                     // Process ID\n  // \n  struct proc *parent;         // Parent process\n  // \n  struct trapframe *tf;        // Trap frame for current syscall\n  // \n  struct context *context;     // swtch() here to run process\n  // \n  void *chan;                  // If non-zero, sleeping on chan\n  // \n  int killed;                  // If non-zero, have been killed\n  // \n  struct file *ofile[NOFILE];  // Open files\n  // inode\n  struct inode *cwd;           // Current directory\n  // \n  char name[16];               // Process name (debugging)\n};\n\n// proc.c\nstruct {\n  struct spinlock lock;       // \n  struct proc proc[NPROC];\n} ptable;                     // cpu\n\nstatic struct proc *initproc; // initPCB\nint nextpid = 1;              // pid\n```\n\nXV66UNUSEDPCB, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE/ PCBchanXV6sleepwaitreadsleeplockXV6SLEEPINGptableptablechanchanXV6chanXV6sleepchanticksjefrrisXV6\n\nAPBSPAPschedulerscheduler\n\n```cpp\n//PAGEBREAK: 42\n// Per-CPU process scheduler.\n// Each CPU calls scheduler() after setting itself up.\n// Scheduler never returns.  It loops, doing:\n//  - choose a process to run\n//  - swtch to start running that process\n//  - eventually that process transfers control\n//      via swtch back to the scheduler.\nvoid\nscheduler(void)\n{\n  struct proc *p;\n  struct cpu *c = mycpu();  // schedulercpu\n  c->proc = 0;              // cpu\n  \n  for(;;){\n    // Enable interrupts on this processor.\n    sti();                  // \n\n    // pushclimycpu()->intenasched\n    // Loop over process table looking for process to run.\n    acquire(&ptable.lock); // ptable\n    // ptable\n    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){\n      if(p->state != RUNNABLE)  // \n        continue;\n      // else \n      // Switch to chosen process.  It is the process's job\n      // to release ptable.lock and then reacquire it\n      // before jumping back to us.\n      c->proc = p;  // pcpu\n      //  \n      // 1tss\n      // 2tss\n      // 3cpup\n      switchuvm(p);\n      p->state = RUNNING; // p\n\n      swtch(&(c->scheduler), p->context); // pcpu\n      switchkvm();        // kpgdir\n\n      // Process is done running for now.\n      // It should have changed its p->state before coming back.\n      c->proc = 0;        // \n    }\n    release(&ptable.lock);  // \n\n  }\n}\n```\n\nXV6round robin\n\nswitchuvmtsscpup**tss**TSSTSSespssswitchuvm\n\n```cpp\n// Switch TSS and h/w page table to correspond to process p.\nvoid\nswitchuvm(struct proc *p)\n{\n  if(p == 0)\n    panic(\"switchuvm: no process\");\n  if(p->kstack == 0)\n    panic(\"switchuvm: no kstack\");\n  if(p->pgdir == 0)\n    panic(\"switchuvm: no pgdir\");\n\n  pushcli();\n  // tsscputss\n  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,\n                                sizeof(mycpu()->ts)-1, 0);\n  mycpu()->gdt[SEG_TSS].s = 0;\n  mycpu()->ts.ss0 = SEG_KDATA << 3;                 // \n  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;  // \n  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit\n  // forbids I/O instructions (e.g., inb and outb) from user space\n  mycpu()->ts.iomb = (ushort) 0xFFFF;\n  ltr(SEG_TSS << 3);                                // tss\n  // p\n  lcr3(V2P(p->pgdir));  // switch to process's address space\n  popcli();\n}\n```\n\nhttps://github.com/StevenBaby/onix/blob/dev/docs/07%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/062%20%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E7%AE%80%E4%BB%8B.md\n\nswtch\n\n```asm\n# Context switch\n#\n#   void swtch(struct context **old, struct context *new);\n# \n# Save the current registers on the stack, creating\n# a struct context, and save its address in *old.\n# Switch stacks to new and pop previously-saved registers.\n\n.globl swtch\nswtch:                # pushl eipcpu\n  movl 4(%esp), %eax  # struct context**\n  movl 8(%esp), %edx  #   struct context*\n\n  # Save old callee-saved registers\n  pushl %ebp\n  pushl %ebx\n  pushl %esi\n  pushl %edi\n\n  # Switch stacks\n  movl %esp, (%eax) # *\n  movl %edx, %esp   # esp\n\n  # Load new callee-saved registers\n  popl %edi\n  popl %esi\n  popl %ebx\n  popl %ebp\n  ret\n```\n\nstruct context\n\n```cpp\nstruct context {\n  uint edi;\n  uint esi;\n  uint ebx;\n  uint ebp;\n  uint eip;\n};\n```\n\ncpuschedulerschedcpu****traptrapyieldyieldschedtrap\n\n```cpp\nstruct spinlock tickslock;\nuint ticks;\n\n//PAGEBREAK: 41\nvoid\ntrap(struct trapframe *tf)\n{\n  if(tf->trapno == T_SYSCALL){  // \n    // ...\n    return;\n  }\n\n  switch(tf->trapno){\n  case T_IRQ0 + IRQ_TIMER:\n    if(cpuid() == 0){\n      acquire(&tickslock);\n      ticks++;            // 1\n      wakeup(&ticks);     // sleeping\n      release(&tickslock);\n    }\n    lapiceoi();           // lapic\n    break;\n  // ...\n  }\n\n  // ...\n\n  // Force process to give up CPU on clock tick.\n  // If interrupts were on while locks held, would need to check nlock.\n  if(myproc() && myproc()->state == RUNNING &&\n     tf->trapno == T_IRQ0+IRQ_TIMER)\n    yield();    // cpu\n\n  // ...\n}\n```\n\nyieldschedschedRUNNABLE\n\n```cpp\n// Enter scheduler.  Must hold only ptable.lock\n// and have changed proc->state. Saves and restores\n// intena because intena is a property of this\n// kernel thread, not this CPU. It should\n// be proc->intena and proc->ncli, but that would\n// break in the few places where a lock is held but\n// there's no process.\nvoid\nsched(void)\n{\n  int intena;\n  struct proc *p = myproc();\n\n  if(!holding(&ptable.lock))\n    panic(\"sched ptable.lock\");\n  if(mycpu()->ncli != 1)        // \n    panic(\"sched locks\");\n  if(p->state == RUNNING)       // sched\n    panic(\"sched running\");\n  if(readeflags()&FL_IF)        // \n    panic(\"sched interruptible\");\n  intena = mycpu()->intena;     // intena\n  swtch(&p->context, mycpu()->scheduler); // scheduler\n  mycpu()->intena = intena;     // intena\n}\n\n// Give up the CPU for one scheduling round.\nvoid\nyield(void)\n{\n  acquire(&ptable.lock);  //DOC: yieldlock\n  myproc()->state = RUNNABLE;\n  sched();\n  release(&ptable.lock);\n}\n```\n\nschedintenaintenaPCBXV6shcedintenaPCB**schedulerptable.lockpushcliintenaschedintenaschedulerschedulerptable.lockpopcliintenaintenafor**\n\n\n\n![](./Scheduler/photo/scheduler/task_stack.drawio.png)\n\nyieldscheduleryieldptableintenaschedulerschedulerschedulerschedulerptableptableschedulerptable\n\n![](./Scheduler/photo/scheduler/yield_scheduler.png)\n\nXV6**cpushedulerschedulerptableswapIncpuswapOut**\n\n**XV6XV6**\n\n**OnixOnixOnix**\n\n**sylarXV6**\n\n![](./Scheduler/photo/scheduler/scheduler.drawio.png)\n\n**CPU PoolXV6CPUptableCPU**\n\nsylar **sylarXV6** sylarC++sylarhttps://blog.csdn.net/m0_52566365/article/details/135991331\n\n## \n\nXV6\n\n|                             |XV6                        |Onix                 |\n|:-:                          |:-:|:-:|\n||kallockalloc|get_page2564G/page + alloc_kpagealloc_kpage/page + kmalloc/byte|\n|       |               |ebpediesiedxecxebx|\n|                     |               | |\n|                       |                 |loader     |\n|idle                     |idle                   |idle           |\n|...                          |...                             |...                     |\n\nOnixOnixOnixXV6Onix****OSXV6OSCPUCPUeipespeflagcpucpu\n\nXV6**XV6**XV6MuduoOne loop per thread MuduoOne loop per threadLinuxCPUXV6cpuptablecpuptablecpucpucpuxcpucpuxcpux**One loop per CPU**\n\n![](./Scheduler/photo/scheduler/scheduler_pluse.drawio.png)\n\n4\n\n****\n\nhttps://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\n\nXV6https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\n\nOnixhttps://github.com/StevenBaby/onix/\n\nAPIChttps://blog.csdn.net/weixin_46645613/article/details/119207945\n\n1https://zhuanlan.zhihu.com/p/394247844\n\n---\n\n****\n\n","slug":"xv6/Scheduler","published":1,"updated":"2025-09-28T09:41:08.734Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9u0016q8ws8p1n16tx","content":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>XV6CPU</p>\n<p>XV6cpu &amp;  &amp; &amp;&amp; &amp; BSP4K &amp; kmap4K</p>\n<p>Onix</p>\n<ul>\n<li><p><a href=\"https://github.com/StevenBaby/onix\">github</a></p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/BV1qM4y127om/\">B</a></p>\n</li>\n</ul>\n<p>XV6-x86github</p>\n<ul>\n<li><a href=\"https://github.com/mit-pdos/xv6-public\"></a></li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>OS</p>\n<p></p>\n<p></p>\n<ul>\n<li><p> CPU UARTUART</p>\n</li>\n<li><p> CPU </p>\n</li>\n<li><p>IO</p>\n</li>\n</ul>\n<p>  CPU  </p>\n<h3 id=\"Onix\"><a href=\"#Onix\" class=\"headerlink\" title=\"Onix\"></a>Onix</h3><p>PC 8259a PICprogrammable interrupt controllerPICINTCPUonix</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/8259a.drawio.png\"></p>\n<p>8259a8259aPICINTCPU8259aINTPICIR2PIC PICPICCPU</p>\n<p>PICcpu</p>\n<ul>\n<li><p> (Initialization Command Words, ICW), ICW  4  ICW1 ~ ICW4</p>\n</li>\n<li><p> (Operation Command Word, OCW), OCW  3  OCW1 ~ OCW3</p>\n</li>\n</ul>\n<p>ICW  ICW <strong></strong> ICW1ICW2ICW3ICW4</p>\n<p>OCW  8259A 8259A  OCW OCW 3 </p>\n<p><strong>Onix</strong><a href=\"https://github.com/StevenBaby/onix/blob/dev/docs/04%20%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F/033%20%E5%A4%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.md\">https://github.com/StevenBaby/onix/blob/dev/docs/04%20%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F/033%20%E5%A4%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.md</a></p>\n<p>8259aOnix</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_M_CTRL 0x20 <span class=\"comment\">// </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_M_DATA 0x21 <span class=\"comment\">// </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_S_CTRL 0xa0 <span class=\"comment\">// </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_S_DATA 0xa1 <span class=\"comment\">// </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_EOI 0x20    <span class=\"comment\">// </span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pic_init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// PIC</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_CTRL, <span class=\"number\">0b00010001</span>); <span class=\"comment\">// ICW1: ,  8259, ICW4.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0x20</span>);       <span class=\"comment\">// ICW2:  0x20</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0b00000100</span>); <span class=\"comment\">// ICW3: IR2.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0b00000001</span>); <span class=\"comment\">// ICW4: 8086, EOI</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// PIC</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_CTRL, <span class=\"number\">0b00010001</span>); <span class=\"comment\">// ICW1: ,  8259, ICW4.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">0x28</span>);       <span class=\"comment\">// ICW2:  0x28</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">2</span>);          <span class=\"comment\">// ICW3:  IR2 </span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">0b00000001</span>); <span class=\"comment\">// ICW4: 8086, EOI</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0b11111111</span>); <span class=\"comment\">// OCW1PIC</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">0b11111111</span>); <span class=\"comment\">// OCW1PIC</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CPUPICPICOCW2 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">send_eoi</span><span class=\"params\">(<span class=\"type\">int</span> vector)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vector &gt;= <span class=\"number\">0x20</span> &amp;&amp; vector &lt; <span class=\"number\">0x28</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">outb</span>(PIC_M_CTRL, PIC_EOI);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vector &gt;= <span class=\"number\">0x28</span> &amp;&amp; vector &lt; <span class=\"number\">0x30</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">outb</span>(PIC_M_CTRL, PIC_EOI);</span><br><span class=\"line\">        <span class=\"built_in\">outb</span>(PIC_S_CTRL, PIC_EOI);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OS</p>\n<h3 id=\"XV6\"><a href=\"#XV6\" class=\"headerlink\" title=\"XV6\"></a>XV6</h3><p>APIC</p>\n<p></p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/APICStructure.png\"></p>\n<p><a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\">https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf</a></p>\n<p></p>\n<p>BSPbootstrap processor</p>\n<p>APxapplication processors </p>\n<p>BSPAPxAP</p>\n<p>CPULocal APICAdvanced Programmable Interrupt Controller<strong>lapiccpu</strong>cpucpuAPICcpucpucpuespeipeflag</p>\n<p>lapicICCinterrupt controller communications BusIO APIC<strong>ioapiccpu</strong>cpu<strong>ioapicIRQlapicIDlapic</strong>lapicioapicioapic168259aioapic<strong>ioapic8259a PIC</strong>cpu</p>\n<p>iopic RTE(Redirection Table Entry)RTE64entryentryioapicentrylapic</p>\n<p>lapicIDcpudevice spacelapicIDlapicIDcpulapicIDICC Buscpucpulapiclapiccpuioapiccpumaster picPIC_EOI</p>\n<p>lapicioapiclapicICR(Interrupt Command Register)ICRioapicRTEentrylapicIDlapiclapicBSPAPsINIT or STARTUP IPIinterprocessor interrupts</p>\n<p>XV6cpulapiciopicmpinitmpinitlapiciopicAP</p>\n<p>Local APICIO APIIC<a href=\"https://blog.csdn.net/weixin_46645613/article/details/119207945\">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>cpu</p>\n<p>EntryEntry8</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/IDT_Entry.png\"></p>\n<ul>\n<li><p>Offset</p>\n</li>\n<li><p>Selector</p>\n</li>\n<li><p>Type <strong>eflagFL_IFeflagFL_IF</strong> i</p>\n</li>\n<li><p>S0</p>\n</li>\n<li><p>DPL0x00x3DPL_USER</p>\n</li>\n<li><p>P1.</p>\n</li>\n</ul>\n<p>XV6XV6</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Gate descriptors for interrupts and traps</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">gatedesc</span> &#123;</span><br><span class=\"line\">  uint off_15_0 : <span class=\"number\">16</span>;   <span class=\"comment\">// low 16 bits of offset in segment</span></span><br><span class=\"line\">  uint cs : <span class=\"number\">16</span>;         <span class=\"comment\">// code segment selector</span></span><br><span class=\"line\">  uint args : <span class=\"number\">5</span>;        <span class=\"comment\">// # args, 0 for interrupt/trap gates</span></span><br><span class=\"line\">  uint rsv1 : <span class=\"number\">3</span>;        <span class=\"comment\">// reserved(should be zero I guess)</span></span><br><span class=\"line\">  uint type : <span class=\"number\">4</span>;        <span class=\"comment\">// type(STS_&#123;IG32,TG32&#125;)</span></span><br><span class=\"line\">  uint s : <span class=\"number\">1</span>;           <span class=\"comment\">// must be 0 (system)</span></span><br><span class=\"line\">  uint dpl : <span class=\"number\">2</span>;         <span class=\"comment\">// descriptor(meaning new) privilege level</span></span><br><span class=\"line\">  uint p : <span class=\"number\">1</span>;           <span class=\"comment\">// Present</span></span><br><span class=\"line\">  uint off_31_16 : <span class=\"number\">16</span>;  <span class=\"comment\">// high bits of offset in segment</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set up a normal interrupt/trap gate descriptor.</span></span><br><span class=\"line\"><span class=\"comment\">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span></span><br><span class=\"line\"><span class=\"comment\">//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone</span></span><br><span class=\"line\"><span class=\"comment\">// - sel: Code segment selector for interrupt/trap handler</span></span><br><span class=\"line\"><span class=\"comment\">// - off: Offset in code segment for interrupt/trap handler</span></span><br><span class=\"line\"><span class=\"comment\">// - dpl: Descriptor Privilege Level -</span></span><br><span class=\"line\"><span class=\"comment\">//        the privilege level required for software to invoke</span></span><br><span class=\"line\"><span class=\"comment\">//        this interrupt/trap gate explicitly using an int instruction.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SETGATE(gate, istrap, sel, off, d)                \\</span></span><br><span class=\"line\"><span class=\"meta\">&#123;                                                         \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).off_15_0 = (uint)(off) &amp; 0xffff;                \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).cs = (sel);                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).args = 0;                                        \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).rsv1 = 0;                                        \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).s = 0;                                           \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).dpl = (d);                                       \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).p = 1;                                           \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).off_31_16 = (uint)(off) &gt;&gt; 16;                  \\</span></span><br><span class=\"line\"><span class=\"meta\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p>3216</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/IDTR.png\"></p>\n<h2 id=\"AP\"><a href=\"#AP\" class=\"headerlink\" title=\"AP\"></a>AP</h2><p>main</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Bootstrap processor starts running C code here.</span></span><br><span class=\"line\"><span class=\"comment\">// Allocate a real stack and switch to it, first</span></span><br><span class=\"line\"><span class=\"comment\">// doing some setup required for memory allocator to work.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">kinit1</span>(end, <span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>)); <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"built_in\">kvmalloc</span>();      <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"built_in\">mpinit</span>();        <span class=\"comment\">// detect other processors</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicinit</span>();     <span class=\"comment\">// interrupt controller</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();       <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"built_in\">picinit</span>();       <span class=\"comment\">// disable pic // 8259A</span></span><br><span class=\"line\">  <span class=\"built_in\">ioapicinit</span>();    <span class=\"comment\">// another interrupt controller</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">pinit</span>();         <span class=\"comment\">// process table // ptable</span></span><br><span class=\"line\">  <span class=\"built_in\">tvinit</span>();        <span class=\"comment\">// trap vectors</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">startothers</span>();   <span class=\"comment\">// start other processors</span></span><br><span class=\"line\">  <span class=\"built_in\">kinit2</span>(<span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>), <span class=\"built_in\">P2V</span>(PHYSTOP)); <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"built_in\">userinit</span>();      <span class=\"comment\">// first user process // initROP</span></span><br><span class=\"line\">  <span class=\"built_in\">mpmain</span>();        <span class=\"comment\">// finish this processor&#x27;s setup // mpmain</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Other AP CPUs jump here from entryother.S.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpenter</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  switchkvm();  <span class=\"comment\">// APkpgdir</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();    <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"built_in\">lapicinit</span>();  <span class=\"comment\">// mainBSPlapicinit</span></span><br><span class=\"line\">  <span class=\"built_in\">mpmain</span>();     <span class=\"comment\">// mpmain</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BSPAPS</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">//    1</span></span><br><span class=\"line\"><span class=\"comment\">//    2</span></span><br><span class=\"line\"><span class=\"comment\">//    3 </span></span><br><span class=\"line\"><span class=\"comment\">// Common CPU setup code.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpmain</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cprintf</span>(<span class=\"string\">&quot;cpu%d: starting %d\\n&quot;</span>, <span class=\"built_in\">cpuid</span>(), <span class=\"built_in\">cpuid</span>());</span><br><span class=\"line\">  <span class=\"built_in\">idtinit</span>();       <span class=\"comment\">// load idt register // lidt</span></span><br><span class=\"line\">  <span class=\"built_in\">xchg</span>(&amp;(<span class=\"built_in\">mycpu</span>()-&gt;started), <span class=\"number\">1</span>); <span class=\"comment\">// tell startothers() we&#x27;re up</span></span><br><span class=\"line\">  <span class=\"built_in\">scheduler</span>();     <span class=\"comment\">// start running processes</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>BSPmaiin</p>\n<h3 id=\"mpinitcpu\"><a href=\"#mpinitcpu\" class=\"headerlink\" title=\"mpinitcpu\"></a>mpinitcpu</h3><p><a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\"></a></p>\n<p>CPUCPUBSPCPUAPCPUBSP <strong>BSPAPAPBSPMP floating pointer structureMP floating pointer structureMP configuration tableioapicMP floating pointer structureCPUBSPCPUBSPAPBSPAP</strong> BSP CPUlapicIDIDCPUCPUBSPAPAP CPUAPOS<strong>INIT or STARTUP interprocessor interrupts (IPIs)APBSPINIT or STARTUP</strong> APBSP<strong></strong></p>\n<p>BSPMP floating pointer structure<strong>1MMP floating pointer structureBIOSBISO1M</strong></p>\n<ol>\n<li>In the first kilobyte of Extended BIOS Data Area (EBDA), or</li>\n<li>Within the last kilobyte of system base memory, or</li>\n<li>In the BIOS ROM address space between 0F0000h and 0FFFFFh.</li>\n</ol>\n<p>1M<a href=\"https://wiki.osdev.org/BDA#BIOS_Data_Area_.28BDA.29\">https://wiki.osdev.org/BDA#BIOS_Data_Area_.28BDA.29</a></p>\n<p>MP Configuration Data StructuresMP floating pointer structureMP Configuration Table HeaderTable Entries</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png\"></p>\n<p>MP floating pointer structure</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/MP_floating_pointer_structure.png\"></p>\n<p>PHYSICAL ADDRESS POINTERMP config table</p>\n<p>MP Configuration Table Header</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/MP_configuration_table_header.png\"></p>\n<p></p>\n<ul>\n<li><p>MEMORY-MAPPED ADDRESS OF LOCAL APIC cpu<strong>CPUlapic</strong>lapiccpucpulapic</p>\n</li>\n<li><p>BASE TABLE LENGTHtable</p>\n</li>\n</ul>\n<p>MP Configuration Table HeaderBase MP Configuration Table EntriesEntryEntryEntry5Entry</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/entry_types.png\"></p>\n<p>XV6Processor EntriesI&#x2F;O APICEntry</p>\n<p>Processor Entries</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/processor_entry.png\"></p>\n<p>LOCAL APIC IDCPUlapicIDCPU</p>\n<p>I&#x2F;O APIC Entries</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/ioapic_entry.png\"></p>\n<p>I&#x2F;O APIC IDI&#x2F;O APICID</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  uchar *p, *e;</span><br><span class=\"line\">  <span class=\"type\">int</span> ismp;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mp</span> *mp;              <span class=\"comment\">// MP floating pointer structure</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mpconf</span> *conf;        <span class=\"comment\">// MP Configuration Table Header</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mpproc</span> *proc;        <span class=\"comment\">// Processor Entries</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mpioapic</span> *ioapic;    <span class=\"comment\">// I/O APIC Entries</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((conf = <span class=\"built_in\">mpconfig</span>(&amp;mp)) == <span class=\"number\">0</span>)     <span class=\"comment\">// MP floating pointer structurePHYSICAL ADDRESS POINTERMP Configuration Table Header</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;Expect to run on an SMP&quot;</span>);</span><br><span class=\"line\">  ismp = <span class=\"number\">1</span>;</span><br><span class=\"line\">  lapic = (uint*)conf-&gt;lapicaddr;     <span class=\"comment\">// lapiclapic</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(p=(uchar*)(conf<span class=\"number\">+1</span>), e=(uchar*)conf+conf-&gt;length; p&lt;e; )&#123;  <span class=\"comment\">// MP Configuration Table HeaderTable Entry</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(*p)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPPROC:                      <span class=\"comment\">// Processor Entries</span></span><br><span class=\"line\">      proc = (<span class=\"keyword\">struct</span> mpproc*)p;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(ncpu &lt; NCPU) &#123;</span><br><span class=\"line\">        cpus[ncpu].apicid = proc-&gt;apicid;  <span class=\"comment\">// apicid may differ from ncpu // cpulapicid</span></span><br><span class=\"line\">        ncpu++;                       <span class=\"comment\">// CPU</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      p += <span class=\"built_in\">sizeof</span>(<span class=\"keyword\">struct</span> mpproc);</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPIOAPIC:                    <span class=\"comment\">// I/O APIC Entries</span></span><br><span class=\"line\">      ioapic = (<span class=\"keyword\">struct</span> mpioapic*)p;</span><br><span class=\"line\">      ioapicid = ioapic-&gt;apicno;      <span class=\"comment\">// ioapicid</span></span><br><span class=\"line\">      p += <span class=\"built_in\">sizeof</span>(<span class=\"keyword\">struct</span> mpioapic);</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPBUS:                       <span class=\"comment\">// Table Entry</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPIOINTR:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPLINTR:</span><br><span class=\"line\">      p += <span class=\"number\">8</span>;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      ismp = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!ismp)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;Didn&#x27;t find a suitable machine&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(mp-&gt;imcrp)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// PIC ModeAPIC </span></span><br><span class=\"line\">    <span class=\"comment\">// interrupt mode configuration register --&gt; IMCR</span></span><br><span class=\"line\">    <span class=\"comment\">// Bochs doesn&#x27;t support IMCR, so this doesn&#x27;t run on Bochs.</span></span><br><span class=\"line\">    <span class=\"comment\">// But it would on real hardware.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(<span class=\"number\">0x22</span>, <span class=\"number\">0x70</span>);   <span class=\"comment\">// Select IMCR</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(<span class=\"number\">0x23</span>, <span class=\"built_in\">inb</span>(<span class=\"number\">0x23</span>) | <span class=\"number\">1</span>);  <span class=\"comment\">// Mask external interrupts.  // APIC</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mp-&gt;imcrp</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/imcrp.png\"></p>\n<p><a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\"></a></p>\n<h3 id=\"lapicinitBSPcpulapic\"><a href=\"#lapicinitBSPcpulapic\" class=\"headerlink\" title=\"lapicinitBSPcpulapic\"></a>lapicinitBSPcpulapic</h3><p>intel 64 and IA-32 3 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">lapicinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!lapic)    <span class=\"comment\">// lapicmpinitMP Configuration Table Headerlapic</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Enable local APIC; set spurious interrupt vector.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));      <span class=\"comment\">// cpuAPIC</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// lapic</span></span><br><span class=\"line\">  <span class=\"comment\">// The timer repeatedly counts down at bus frequency</span></span><br><span class=\"line\">  <span class=\"comment\">// from lapic[TICR] and then issues an interrupt.</span></span><br><span class=\"line\">  <span class=\"comment\">// If xv6 cared more about precise timekeeping,</span></span><br><span class=\"line\">  <span class=\"comment\">// TICR would be calibrated using an external time source.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TDCR, X1);                               <span class=\"comment\">// X1</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER)); <span class=\"comment\">// PERIODIC0x20</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TICR, <span class=\"number\">10000000</span>);                         <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Disable logical interrupt lines.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(LINT0, MASKED);                          <span class=\"comment\">// LINT0lapic</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(LINT1, MASKED);                          <span class=\"comment\">// LINT1lapic</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Disable performance counter overflow interrupts</span></span><br><span class=\"line\">  <span class=\"comment\">// on machines that provide that interrupt entry.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(((lapic[VER]&gt;&gt;<span class=\"number\">16</span>) &amp; <span class=\"number\">0xFF</span>) &gt;= <span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"built_in\">lapicw</span>(PCINT, MASKED);                        <span class=\"comment\">// PCINT</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Map error interrupt to IRQ_ERROR.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ERROR, T_IRQ0 + IRQ_ERROR);            <span class=\"comment\">// 0x20 + 0x13ERROR</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Clear error status register (requires back-to-back writes).</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ESR, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ESR, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Ack any outstanding interrupts.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(EOI, <span class=\"number\">0</span>);                               <span class=\"comment\">// ioapicEOI</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Send an Init Level De-Assert to synchronise arbitration ID&#x27;s.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ICRHI, <span class=\"number\">0</span>);                             <span class=\"comment\">// // apic</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ICRLO, BCAST | INIT | LEVEL);          <span class=\"comment\">//  &amp; INIT &amp; </span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(lapic[ICRLO] &amp; DELIVS)                  <span class=\"comment\">// </span></span><br><span class=\"line\">    ;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Enable interrupts on the APIC (but not on the processor).</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TPR, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>BSPlapicAP</strong></p>\n<h3 id=\"ioapicinitioapic\"><a href=\"#ioapicinitioapic\" class=\"headerlink\" title=\"ioapicinitioapic\"></a>ioapicinitioapic</h3><p>ioapicmaster picioapicioapic RTE(Redirection Table Entry)RTET_IRQ0T_IRQ0 &#x3D;&#x3D; 0x20EntryconsoleinitioapicenableEntry RTE(Redirection Table Entry)<a href=\"https://blog.csdn.net/weixin_46645613/article/details/119207945\">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">ioapicinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i, id, maxintr;</span><br><span class=\"line\"></span><br><span class=\"line\">  ioapic = (<span class=\"keyword\">volatile</span> <span class=\"keyword\">struct</span> ioapic*)IOAPIC;           <span class=\"comment\">// 0xFEC00000   // Default physical address of IO APIC</span></span><br><span class=\"line\">  maxintr = (<span class=\"built_in\">ioapicread</span>(REG_VER) &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xFF</span>;       <span class=\"comment\">// ioapic</span></span><br><span class=\"line\">  id = <span class=\"built_in\">ioapicread</span>(REG_ID) &gt;&gt; <span class=\"number\">24</span>;                      <span class=\"comment\">// ioapicID</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(id != ioapicid)                                  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"built_in\">cprintf</span>(<span class=\"string\">&quot;ioapicinit: id isn&#x27;t equal to ioapicid; not a MP\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Mark all interrupts edge-triggered, active high, disabled,</span></span><br><span class=\"line\">  <span class=\"comment\">// and not routed to any CPUs.</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt;= maxintr; i++)&#123;    <span class=\"comment\">//  RTE(Redirection Table Entry)PIC</span></span><br><span class=\"line\">    <span class=\"built_in\">ioapicwrite</span>(REG_TABLE<span class=\"number\">+2</span>*i, INT_DISABLED | (T_IRQ0 + i));</span><br><span class=\"line\">    <span class=\"built_in\">ioapicwrite</span>(REG_TABLE<span class=\"number\">+2</span>*i<span class=\"number\">+1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"tvinit\"><a href=\"#tvinit\" class=\"headerlink\" title=\"tvinit\"></a>tvinit</h3><p>XV6</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Interrupt descriptor table (shared by all CPUs).</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">gatedesc</span> idt[<span class=\"number\">256</span>];   <span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> uint vectors[];  <span class=\"comment\">// vectorsvectors.pl</span></span><br></pre></td></tr></table></figure>\n\n<p>tvinitSETGATE</p>\n<p>SETGATE(gate, istrap, sel, off, d) </p>\n<ul>\n<li><p>1idt[i]entry</p>\n</li>\n<li><p>2</p>\n</li>\n<li><p>3</p>\n</li>\n<li><p>4</p>\n</li>\n<li><p>5</p>\n</li>\n</ul>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">tvinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i;</span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">256</span>; i++)</span><br><span class=\"line\">    <span class=\"built_in\">SETGATE</span>(idt[i], <span class=\"number\">0</span>, SEG_KCODE&lt;&lt;<span class=\"number\">3</span>, vectors[i], <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// DPL_USER</span></span><br><span class=\"line\">  <span class=\"built_in\">SETGATE</span>(idt[T_SYSCALL], <span class=\"number\">1</span>, SEG_KCODE&lt;&lt;<span class=\"number\">3</span>, vectors[T_SYSCALL], DPL_USER);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">initlock</span>(&amp;tickslock, <span class=\"string\">&quot;time&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>vectors.plpl</p>\n<figure class=\"highlight pl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/perl -w</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Generate vectors.S, the trap/interrupt entry points.</span></span><br><span class=\"line\"><span class=\"comment\"># There has to be one entry point per interrupt number</span></span><br><span class=\"line\"><span class=\"comment\"># since otherwise there&#x27;s no way for trap() to discover</span></span><br><span class=\"line\"><span class=\"comment\"># the interrupt number.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;# generated by vectors.pl - do not edit\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;# handlers\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;.globl alltraps\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">my</span> <span class=\"variable\">$i</span> = <span class=\"number\">0</span>; <span class=\"variable\">$i</span> &lt; <span class=\"number\">256</span>; <span class=\"variable\">$i</span>++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;.globl vector<span class=\"variable\">$i</span>\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;vector<span class=\"variable\">$i</span>:\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(<span class=\"variable\">$i</span> == <span class=\"number\">8</span> || (<span class=\"variable\">$i</span> &gt;= <span class=\"number\">10</span> &amp;&amp; <span class=\"variable\">$i</span> &lt;= <span class=\"number\">14</span>) || <span class=\"variable\">$i</span> == <span class=\"number\">17</span>))&#123;</span><br><span class=\"line\">        <span class=\"comment\"># cpuerrcode</span></span><br><span class=\"line\">        <span class=\"comment\"># </span></span><br><span class=\"line\">        <span class=\"comment\"># 0</span></span><br><span class=\"line\">        <span class=\"comment\"># trapret</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">&quot;  pushl \\$0\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;  pushl \\$<span class=\"variable\">$i</span>\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;  jmp alltraps\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;\\n# vector table\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;.data\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;.globl vectors\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;vectors:\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">my</span> <span class=\"variable\">$i</span> = <span class=\"number\">0</span>; <span class=\"variable\">$i</span> &lt; <span class=\"number\">256</span>; <span class=\"variable\">$i</span>++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;  .long vector<span class=\"variable\">$i</span>\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>plforvectorsvectorsforforifcpu<strong></strong>trapretforjmpplplalltrapsalltrapsplvectors256vectorii&#x3D;12</p>\n<p>trapasm.Salltraps</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;mmu.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">  # vectors.S sends all traps here.</span><br><span class=\"line\">.globl alltraps</span><br><span class=\"line\">alltraps:          # </span><br><span class=\"line\">  # Build trap frame.</span><br><span class=\"line\">  pushl %ds</span><br><span class=\"line\">  pushl %es</span><br><span class=\"line\">  pushl %fs</span><br><span class=\"line\">  pushl %gs</span><br><span class=\"line\">  pushal</span><br><span class=\"line\">  </span><br><span class=\"line\">  # Set up data segments.</span><br><span class=\"line\">  movw $(SEG_KDATA&lt;&lt;3), %ax</span><br><span class=\"line\">  movw %ax, %ds</span><br><span class=\"line\">  movw %ax, %es</span><br><span class=\"line\"></span><br><span class=\"line\">  # Call trap(tf), where tf=%esp</span><br><span class=\"line\">  pushl %esp</span><br><span class=\"line\">  call trap       # trap</span><br><span class=\"line\">  addl $4, %esp</span><br><span class=\"line\"></span><br><span class=\"line\">  # Return falls through to trapret...</span><br><span class=\"line\">.globl trapret</span><br><span class=\"line\">trapret:          # </span><br><span class=\"line\">  popal</span><br><span class=\"line\">  popl %gs</span><br><span class=\"line\">  popl %fs</span><br><span class=\"line\">  popl %es</span><br><span class=\"line\">  popl %ds</span><br><span class=\"line\">  addl $0x8, %esp  # trapno and errcode</span><br><span class=\"line\">  iret</span><br></pre></td></tr></table></figure>\n\n<p>tvinitplalltraps</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/trap__structure.png\"></p>\n<p></p>\n<p></p>\n<ol start=\"0\">\n<li><p>TSSss0esp0</p>\n</li>\n<li><p><strong>cpussesp</strong></p>\n</li>\n<li><p>cpueflagscseip<strong></strong></p>\n</li>\n<li><p><strong>alltraps</strong><strong></strong></p>\n</li>\n<li><p>trap</p>\n</li>\n<li><p><strong>trapret</strong><strong></strong></p>\n</li>\n<li><p>iretcpueflagscseip</p>\n</li>\n<li><p>cpussesp</p>\n</li>\n</ol>\n<p><strong></strong></p>\n<ol>\n<li><p>cpueflagscseip<strong></strong></p>\n</li>\n<li><p><strong>alltraps</strong><strong></strong></p>\n</li>\n<li><p>trap</p>\n</li>\n<li><p><strong>trapret</strong><strong></strong></p>\n</li>\n<li><p>iretcpueflagscseip</p>\n</li>\n</ol>\n<p>XV6</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PAGEBREAK: 36</span></span><br><span class=\"line\"><span class=\"comment\">// Layout of the trap frame built on the stack by the</span></span><br><span class=\"line\"><span class=\"comment\">// hardware and by trapasm.S, and passed to trap().</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">trapframe</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// registers as pushed by pusha</span></span><br><span class=\"line\">  uint edi;</span><br><span class=\"line\">  uint esi;</span><br><span class=\"line\">  uint ebp;</span><br><span class=\"line\">  uint oesp;      <span class=\"comment\">// useless &amp; ignored</span></span><br><span class=\"line\">  uint ebx;</span><br><span class=\"line\">  uint edx;</span><br><span class=\"line\">  uint ecx;</span><br><span class=\"line\">  uint eax;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// rest of trap frame</span></span><br><span class=\"line\">  ushort gs;</span><br><span class=\"line\">  ushort padding1;</span><br><span class=\"line\">  ushort fs;</span><br><span class=\"line\">  ushort padding2;</span><br><span class=\"line\">  ushort es;</span><br><span class=\"line\">  ushort padding3;</span><br><span class=\"line\">  ushort ds;</span><br><span class=\"line\">  ushort padding4;</span><br><span class=\"line\">  uint trapno;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// below here defined by x86 hardware</span></span><br><span class=\"line\">  uint err;</span><br><span class=\"line\">  uint eip;</span><br><span class=\"line\">  ushort cs;</span><br><span class=\"line\">  ushort padding5;</span><br><span class=\"line\">  uint eflags;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// below here only when crossing rings, such as from user to kernel</span></span><br><span class=\"line\">  uint esp;</span><br><span class=\"line\">  ushort ss;</span><br><span class=\"line\">  ushort padding6;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/trap_frame.png\"></p>\n<p><a href=\"https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\">https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf</a></p>\n<h3 id=\"startothersAP\"><a href=\"#startothersAP\" class=\"headerlink\" title=\"startothersAP\"></a>startothersAP</h3><p>APAP<a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\"></a>universal algorithmXV6lapicstartap</p>\n<p></p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/universal_algorithm.png\"></p>\n<p>XV6AP</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Start the non-boot (AP) processors.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">startothers</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">extern</span> uchar _binary_entryother_start[], _binary_entryother_size[];</span><br><span class=\"line\">  uchar *code;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> *c;</span><br><span class=\"line\">  <span class=\"type\">char</span> *stack;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Write entry code to unused memory at 0x7000.</span></span><br><span class=\"line\">  <span class=\"comment\">// The linker has placed the image of entryother.S in</span></span><br><span class=\"line\">  <span class=\"comment\">// _binary_entryother_start.</span></span><br><span class=\"line\">  <span class=\"comment\">// APentryotherentryother  boot + entry</span></span><br><span class=\"line\">  code = <span class=\"built_in\">P2V</span>(<span class=\"number\">0x7000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// entryother0x7000</span></span><br><span class=\"line\">  <span class=\"built_in\">memmove</span>(code, _binary_entryother_start, (uint)_binary_entryother_size);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// BSP forAP</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(c = cpus; c &lt; cpus+ncpu; c++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c == <span class=\"built_in\">mycpu</span>())  <span class=\"comment\">// We&#x27;ve started already.</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Tell entryother.S what stack to use, where to enter, and what</span></span><br><span class=\"line\">    <span class=\"comment\">// pgdir to use. We cannot use kpgdir yet, because the AP processor</span></span><br><span class=\"line\">    <span class=\"comment\">// is running in low  memory, so we use entrypgdir for the APs too.</span></span><br><span class=\"line\">    stack = <span class=\"built_in\">kalloc</span>();   <span class=\"comment\">// APscheduler</span></span><br><span class=\"line\">    *(<span class=\"type\">void</span>**)(code<span class=\"number\">-4</span>) = stack + KSTACKSIZE;</span><br><span class=\"line\">    *(<span class=\"built_in\">void</span>(**)(<span class=\"type\">void</span>))(code<span class=\"number\">-8</span>) = mpenter;  <span class=\"comment\">// APmainmpenter</span></span><br><span class=\"line\">    <span class=\"comment\">// BSP4M big page</span></span><br><span class=\"line\">    *(<span class=\"type\">int</span>**)(code<span class=\"number\">-12</span>) = (<span class=\"type\">void</span> *) <span class=\"built_in\">V2P</span>(entrypgdir);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// lapicstartapuniversal algorithm</span></span><br><span class=\"line\">    <span class=\"built_in\">lapicstartap</span>(c-&gt;apicid, <span class=\"built_in\">V2P</span>(code));   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// AP</span></span><br><span class=\"line\">    <span class=\"comment\">// wait for cpu to finish mpmain()</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c-&gt;started == <span class=\"number\">0</span>)  </span><br><span class=\"line\">      ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AP bootBSPbootBSP0x7c00AP0x70000x7000bootasm.S + entry.S</p>\n<ol>\n<li><p></p>\n</li>\n<li><p>entrypgdir</p>\n</li>\n<li><p>scheduler</p>\n</li>\n<li><p>mpenter</p>\n</li>\n</ol>\n<p>entryother.S</p>\n<p>mpenter</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Other CPUs jump here from entryother.S.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpenter</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  switchkvm();    <span class=\"comment\">// 4kkpgdir</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();       <span class=\"comment\">//BSPmainBSPentryother.S</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicinit</span>();    <span class=\"comment\">// BSP</span></span><br><span class=\"line\">  <span class=\"built_in\">mpmain</span>();       <span class=\"comment\">// mpmain</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>APBSPCPUmpmainBSPmainmpmainBSPAP</p>\n<p>mpmainschedulerCPU</p>\n<p>mpmain</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Common CPU setup code.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpmain</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cprintf</span>(<span class=\"string\">&quot;cpu%d: starting %d\\n&quot;</span>, <span class=\"built_in\">cpuid</span>(), <span class=\"built_in\">cpuid</span>());</span><br><span class=\"line\">  <span class=\"built_in\">idtinit</span>();       <span class=\"comment\">// load idt register</span></span><br><span class=\"line\">  <span class=\"built_in\">xchg</span>(&amp;(<span class=\"built_in\">mycpu</span>()-&gt;started), <span class=\"number\">1</span>); <span class=\"comment\">// tell startothers() we&#x27;re up</span></span><br><span class=\"line\">  <span class=\"built_in\">scheduler</span>();     <span class=\"comment\">// start running processes</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>XV6CPU</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Per-CPU state</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// lapciid</span></span><br><span class=\"line\">  uchar apicid;                <span class=\"comment\">// Local APIC ID</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">context</span> *scheduler;   <span class=\"comment\">// swtch() here to enter scheduler</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">taskstate</span> ts;         <span class=\"comment\">// Used by x86 to find stack for interrupt</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">segdesc</span> gdt[NSEGS];   <span class=\"comment\">// x86 global descriptor table</span></span><br><span class=\"line\">  <span class=\"comment\">// cpu</span></span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> uint started;       <span class=\"comment\">// Has the CPU started?</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">int</span> ncli;                    <span class=\"comment\">// Depth of pushcli nesting.</span></span><br><span class=\"line\">  <span class=\"comment\">// cpu</span></span><br><span class=\"line\">  <span class=\"type\">int</span> intena;                  <span class=\"comment\">// Were interrupts enabled before pushcli?</span></span><br><span class=\"line\">  <span class=\"comment\">// cpuPCB</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *proc;           <span class=\"comment\">// The process running on this cpu or null</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> cpus[NCPU]; <span class=\"comment\">// cpu</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> ncpu;              <span class=\"comment\">// cpu</span></span><br></pre></td></tr></table></figure>\n\n<p>CPU</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">lapic</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">ioapic</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">cpueipespeflag</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">kpgdir</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">ptable</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>XV6PCBOSXV6PCBXV6PCBPCBOnixPCBPDBespesp4Kesp4K</p>\n<p>XV6PCB</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// proc.h</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">procstate</span> &#123; UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Per-process state</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  uint sz;                     <span class=\"comment\">// Size of process memory (bytes)</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">pde_t</span>* pgdir;                <span class=\"comment\">// Page table</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">char</span> *kstack;                <span class=\"comment\">// Bottom of kernel stack for this process</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">enum</span> <span class=\"title class_\">procstate</span> state;        <span class=\"comment\">// Process state</span></span><br><span class=\"line\">  <span class=\"comment\">// pid</span></span><br><span class=\"line\">  <span class=\"type\">int</span> pid;                     <span class=\"comment\">// Process ID</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *parent;         <span class=\"comment\">// Parent process</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">trapframe</span> *tf;        <span class=\"comment\">// Trap frame for current syscall</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">context</span> *context;     <span class=\"comment\">// swtch() here to run process</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">void</span> *chan;                  <span class=\"comment\">// If non-zero, sleeping on chan</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">int</span> killed;                  <span class=\"comment\">// If non-zero, have been killed</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">file</span> *ofile[NOFILE];  <span class=\"comment\">// Open files</span></span><br><span class=\"line\">  <span class=\"comment\">// inode</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">inode</span> *cwd;           <span class=\"comment\">// Current directory</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">char</span> name[<span class=\"number\">16</span>];               <span class=\"comment\">// Process name (debugging)</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// proc.c</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">spinlock</span> lock;       <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> proc[NPROC];</span><br><span class=\"line\">&#125; ptable;                     <span class=\"comment\">// cpu</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *initproc; <span class=\"comment\">// initPCB</span></span><br><span class=\"line\"><span class=\"type\">int</span> nextpid = <span class=\"number\">1</span>;              <span class=\"comment\">// pid</span></span><br></pre></td></tr></table></figure>\n\n<p>XV66UNUSEDPCB, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE&#x2F; PCBchanXV6sleepwaitreadsleeplockXV6SLEEPINGptableptablechanchanXV6chanXV6sleepchanticksjefrrisXV6</p>\n<p>APBSPAPschedulerscheduler</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PAGEBREAK: 42</span></span><br><span class=\"line\"><span class=\"comment\">// Per-CPU process scheduler.</span></span><br><span class=\"line\"><span class=\"comment\">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class=\"line\"><span class=\"comment\">// Scheduler never returns.  It loops, doing:</span></span><br><span class=\"line\"><span class=\"comment\">//  - choose a process to run</span></span><br><span class=\"line\"><span class=\"comment\">//  - swtch to start running that process</span></span><br><span class=\"line\"><span class=\"comment\">//  - eventually that process transfers control</span></span><br><span class=\"line\"><span class=\"comment\">//      via swtch back to the scheduler.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">scheduler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *p;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> *c = <span class=\"built_in\">mycpu</span>();  <span class=\"comment\">// schedulercpu</span></span><br><span class=\"line\">  c-&gt;proc = <span class=\"number\">0</span>;              <span class=\"comment\">// cpu</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Enable interrupts on this processor.</span></span><br><span class=\"line\">    <span class=\"built_in\">sti</span>();                  <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// pushclimycpu()-&gt;intenasched</span></span><br><span class=\"line\">    <span class=\"comment\">// Loop over process table looking for process to run.</span></span><br><span class=\"line\">    <span class=\"built_in\">acquire</span>(&amp;ptable.lock); <span class=\"comment\">// ptable</span></span><br><span class=\"line\">    <span class=\"comment\">// ptable</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(p-&gt;state != RUNNABLE)  <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      <span class=\"comment\">// else </span></span><br><span class=\"line\">      <span class=\"comment\">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class=\"line\">      <span class=\"comment\">// to release ptable.lock and then reacquire it</span></span><br><span class=\"line\">      <span class=\"comment\">// before jumping back to us.</span></span><br><span class=\"line\">      c-&gt;proc = p;  <span class=\"comment\">// pcpu</span></span><br><span class=\"line\">      <span class=\"comment\">//  </span></span><br><span class=\"line\">      <span class=\"comment\">// 1tss</span></span><br><span class=\"line\">      <span class=\"comment\">// 2tss</span></span><br><span class=\"line\">      <span class=\"comment\">// 3cpup</span></span><br><span class=\"line\">      switchuvm(p);</span><br><span class=\"line\">      p-&gt;state = RUNNING; <span class=\"comment\">// p</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">swtch</span>(&amp;(c-&gt;scheduler), p-&gt;context); <span class=\"comment\">// pcpu</span></span><br><span class=\"line\">      switchkvm();        <span class=\"comment\">// kpgdir</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Process is done running for now.</span></span><br><span class=\"line\">      <span class=\"comment\">// It should have changed its p-&gt;state before coming back.</span></span><br><span class=\"line\">      c-&gt;proc = <span class=\"number\">0</span>;        <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">release</span>(&amp;ptable.lock);  <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>XV6round robin</p>\n<p>switchuvmtsscpup<strong>tss</strong>TSSTSSespssswitchuvm</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Switch TSS and h/w page table to correspond to process p.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">switchuvm</span><span class=\"params\">(<span class=\"keyword\">struct</span> proc *p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;switchuvm: no process&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;kstack == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;switchuvm: no kstack&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;pgdir == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;switchuvm: no pgdir&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">pushcli</span>();</span><br><span class=\"line\">  <span class=\"comment\">// tsscputss</span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;gdt[SEG_TSS] = <span class=\"built_in\">SEG16</span>(STS_T32A, &amp;<span class=\"built_in\">mycpu</span>()-&gt;ts,</span><br><span class=\"line\">                                <span class=\"built_in\">sizeof</span>(<span class=\"built_in\">mycpu</span>()-&gt;ts)<span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;gdt[SEG_TSS].s = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;ts.ss0 = SEG_KDATA &lt;&lt; <span class=\"number\">3</span>;                 <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;ts.esp0 = (uint)p-&gt;kstack + KSTACKSIZE;  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"comment\">// setting IOPL=0 in eflags *and* iomb beyond the tss segment limit</span></span><br><span class=\"line\">  <span class=\"comment\">// forbids I/O instructions (e.g., inb and outb) from user space</span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;ts.iomb = (ushort) <span class=\"number\">0xFFFF</span>;</span><br><span class=\"line\">  <span class=\"built_in\">ltr</span>(SEG_TSS &lt;&lt; <span class=\"number\">3</span>);                                <span class=\"comment\">// tss</span></span><br><span class=\"line\">  <span class=\"comment\">// p</span></span><br><span class=\"line\">  <span class=\"built_in\">lcr3</span>(<span class=\"built_in\">V2P</span>(p-&gt;pgdir));  <span class=\"comment\">// switch to process&#x27;s address space</span></span><br><span class=\"line\">  <span class=\"built_in\">popcli</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/StevenBaby/onix/blob/dev/docs/07%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/062%20%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E7%AE%80%E4%BB%8B.md\">https://github.com/StevenBaby/onix/blob/dev/docs/07%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/062%20%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E7%AE%80%E4%BB%8B.md</a></p>\n<p>swtch</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Context switch</span><br><span class=\"line\">#</span><br><span class=\"line\">#   void swtch(struct context **old, struct context *new);</span><br><span class=\"line\"># </span><br><span class=\"line\"># Save the current registers on the stack, creating</span><br><span class=\"line\"># a struct context, and save its address in *old.</span><br><span class=\"line\"># Switch stacks to new and pop previously-saved registers.</span><br><span class=\"line\"></span><br><span class=\"line\">.globl swtch</span><br><span class=\"line\">swtch:                # pushl eipcpu</span><br><span class=\"line\">  movl 4(%esp), %eax  # struct context**</span><br><span class=\"line\">  movl 8(%esp), %edx  #   struct context*</span><br><span class=\"line\"></span><br><span class=\"line\">  # Save old callee-saved registers</span><br><span class=\"line\">  pushl %ebp</span><br><span class=\"line\">  pushl %ebx</span><br><span class=\"line\">  pushl %esi</span><br><span class=\"line\">  pushl %edi</span><br><span class=\"line\"></span><br><span class=\"line\">  # Switch stacks</span><br><span class=\"line\">  movl %esp, (%eax) # *</span><br><span class=\"line\">  movl %edx, %esp   # esp</span><br><span class=\"line\"></span><br><span class=\"line\">  # Load new callee-saved registers</span><br><span class=\"line\">  popl %edi</span><br><span class=\"line\">  popl %esi</span><br><span class=\"line\">  popl %ebx</span><br><span class=\"line\">  popl %ebp</span><br><span class=\"line\">  ret</span><br></pre></td></tr></table></figure>\n\n<p>struct context</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">context</span> &#123;</span><br><span class=\"line\">  uint edi;</span><br><span class=\"line\">  uint esi;</span><br><span class=\"line\">  uint ebx;</span><br><span class=\"line\">  uint ebp;</span><br><span class=\"line\">  uint eip;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>cpuschedulerschedcpu<strong></strong>traptrapyieldyieldschedtrap</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">spinlock</span> tickslock;</span><br><span class=\"line\">uint ticks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//PAGEBREAK: 41</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">trap</span><span class=\"params\">(<span class=\"keyword\">struct</span> trapframe *tf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(tf-&gt;trapno == T_SYSCALL)&#123;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(tf-&gt;trapno)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">cpuid</span>() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">acquire</span>(&amp;tickslock);</span><br><span class=\"line\">      ticks++;            <span class=\"comment\">// 1</span></span><br><span class=\"line\">      <span class=\"built_in\">wakeup</span>(&amp;ticks);     <span class=\"comment\">// sleeping</span></span><br><span class=\"line\">      <span class=\"built_in\">release</span>(&amp;tickslock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">lapiceoi</span>();           <span class=\"comment\">// lapic</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Force process to give up CPU on clock tick.</span></span><br><span class=\"line\">  <span class=\"comment\">// If interrupts were on while locks held, would need to check nlock.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">myproc</span>() &amp;&amp; <span class=\"built_in\">myproc</span>()-&gt;state == RUNNING &amp;&amp;</span><br><span class=\"line\">     tf-&gt;trapno == T_IRQ0+IRQ_TIMER)</span><br><span class=\"line\">    <span class=\"built_in\">yield</span>();    <span class=\"comment\">// cpu</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>yieldschedschedRUNNABLE</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Enter scheduler.  Must hold only ptable.lock</span></span><br><span class=\"line\"><span class=\"comment\">// and have changed proc-&gt;state. Saves and restores</span></span><br><span class=\"line\"><span class=\"comment\">// intena because intena is a property of this</span></span><br><span class=\"line\"><span class=\"comment\">// kernel thread, not this CPU. It should</span></span><br><span class=\"line\"><span class=\"comment\">// be proc-&gt;intena and proc-&gt;ncli, but that would</span></span><br><span class=\"line\"><span class=\"comment\">// break in the few places where a lock is held but</span></span><br><span class=\"line\"><span class=\"comment\">// there&#x27;s no process.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sched</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> intena;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *p = <span class=\"built_in\">myproc</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"built_in\">holding</span>(&amp;ptable.lock))</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched ptable.lock&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">mycpu</span>()-&gt;ncli != <span class=\"number\">1</span>)        <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched locks&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;state == RUNNING)       <span class=\"comment\">// sched</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched running&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">readeflags</span>()&amp;FL_IF)        <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched interruptible&quot;</span>);</span><br><span class=\"line\">  intena = <span class=\"built_in\">mycpu</span>()-&gt;intena;     <span class=\"comment\">// intena</span></span><br><span class=\"line\">  <span class=\"built_in\">swtch</span>(&amp;p-&gt;context, <span class=\"built_in\">mycpu</span>()-&gt;scheduler); <span class=\"comment\">// scheduler</span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;intena = intena;     <span class=\"comment\">// intena</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Give up the CPU for one scheduling round.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">yield</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">acquire</span>(&amp;ptable.lock);  <span class=\"comment\">//DOC: yieldlock</span></span><br><span class=\"line\">  <span class=\"built_in\">myproc</span>()-&gt;state = RUNNABLE;</span><br><span class=\"line\">  <span class=\"built_in\">sched</span>();</span><br><span class=\"line\">  <span class=\"built_in\">release</span>(&amp;ptable.lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>schedintenaintenaPCBXV6shcedintenaPCB<strong>schedulerptable.lockpushcliintenaschedintenaschedulerschedulerptable.lockpopcliintenaintenafor</strong></p>\n<p></p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/task_stack.drawio.png\"></p>\n<p>yieldscheduleryieldptableintenaschedulerschedulerschedulerschedulerptableptableschedulerptable</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/yield_scheduler.png\"></p>\n<p>XV6<strong>cpushedulerschedulerptableswapIncpuswapOut</strong></p>\n<p><strong>XV6XV6</strong></p>\n<p><strong>OnixOnixOnix</strong></p>\n<p><strong>sylarXV6</strong></p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler.drawio.png\"></p>\n<p><strong>CPU PoolXV6CPUptableCPU</strong></p>\n<p>sylar <strong>sylarXV6</strong> sylarC++sylar<a href=\"https://blog.csdn.net/m0_52566365/article/details/135991331%E3%80%82\">https://blog.csdn.net/m0_52566365/article/details/135991331</a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>XV6</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">XV6</th>\n<th align=\"center\">Onix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\">kallockalloc</td>\n<td align=\"center\">get_page2564G&#x2F;page + alloc_kpagealloc_kpage&#x2F;page + kmalloc&#x2F;byte</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">ebpediesiedxecxebx</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">loader</td>\n</tr>\n<tr>\n<td align=\"center\">idle</td>\n<td align=\"center\">idle</td>\n<td align=\"center\">idle</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>OnixOnixOnixXV6Onix<strong></strong>OSXV6OSCPUCPUeipespeflagcpucpu</p>\n<p>XV6<strong>XV6</strong>XV6MuduoOne loop per thread MuduoOne loop per threadLinuxCPUXV6cpuptablecpuptablecpucpucpuxcpucpuxcpux<strong>One loop per CPU</strong></p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler_pluse.drawio.png\"></p>\n<p>4</p>\n<p><strong></strong></p>\n<p><a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\">https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf</a></p>\n<p>XV6<a href=\"https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\">https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf</a></p>\n<p>Onix<a href=\"https://github.com/StevenBaby/onix/\">https://github.com/StevenBaby/onix/</a></p>\n<p>APIC<a href=\"https://blog.csdn.net/weixin_46645613/article/details/119207945\">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>\n<p>1<a href=\"https://zhuanlan.zhihu.com/p/394247844\">https://zhuanlan.zhihu.com/p/394247844</a></p>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>XV6CPU</p>\n<p>XV6cpu &amp;  &amp; &amp;&amp; &amp; BSP4K &amp; kmap4K</p>\n<p>Onix</p>\n<ul>\n<li><p><a href=\"https://github.com/StevenBaby/onix\">github</a></p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/BV1qM4y127om/\">B</a></p>\n</li>\n</ul>\n<p>XV6-x86github</p>\n<ul>\n<li><a href=\"https://github.com/mit-pdos/xv6-public\"></a></li>\n</ul>","more":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>OS</p>\n<p></p>\n<p></p>\n<ul>\n<li><p> CPU UARTUART</p>\n</li>\n<li><p> CPU </p>\n</li>\n<li><p>IO</p>\n</li>\n</ul>\n<p>  CPU  </p>\n<h3 id=\"Onix\"><a href=\"#Onix\" class=\"headerlink\" title=\"Onix\"></a>Onix</h3><p>PC 8259a PICprogrammable interrupt controllerPICINTCPUonix</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/8259a.drawio.png\"></p>\n<p>8259a8259aPICINTCPU8259aINTPICIR2PIC PICPICCPU</p>\n<p>PICcpu</p>\n<ul>\n<li><p> (Initialization Command Words, ICW), ICW  4  ICW1 ~ ICW4</p>\n</li>\n<li><p> (Operation Command Word, OCW), OCW  3  OCW1 ~ OCW3</p>\n</li>\n</ul>\n<p>ICW  ICW <strong></strong> ICW1ICW2ICW3ICW4</p>\n<p>OCW  8259A 8259A  OCW OCW 3 </p>\n<p><strong>Onix</strong><a href=\"https://github.com/StevenBaby/onix/blob/dev/docs/04%20%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F/033%20%E5%A4%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.md\">https://github.com/StevenBaby/onix/blob/dev/docs/04%20%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F/033%20%E5%A4%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.md</a></p>\n<p>8259aOnix</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_M_CTRL 0x20 <span class=\"comment\">// </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_M_DATA 0x21 <span class=\"comment\">// </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_S_CTRL 0xa0 <span class=\"comment\">// </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_S_DATA 0xa1 <span class=\"comment\">// </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIC_EOI 0x20    <span class=\"comment\">// </span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pic_init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// PIC</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_CTRL, <span class=\"number\">0b00010001</span>); <span class=\"comment\">// ICW1: ,  8259, ICW4.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0x20</span>);       <span class=\"comment\">// ICW2:  0x20</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0b00000100</span>); <span class=\"comment\">// ICW3: IR2.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0b00000001</span>); <span class=\"comment\">// ICW4: 8086, EOI</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// PIC</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_CTRL, <span class=\"number\">0b00010001</span>); <span class=\"comment\">// ICW1: ,  8259, ICW4.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">0x28</span>);       <span class=\"comment\">// ICW2:  0x28</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">2</span>);          <span class=\"comment\">// ICW3:  IR2 </span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">0b00000001</span>); <span class=\"comment\">// ICW4: 8086, EOI</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_M_DATA, <span class=\"number\">0b11111111</span>); <span class=\"comment\">// OCW1PIC</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(PIC_S_DATA, <span class=\"number\">0b11111111</span>); <span class=\"comment\">// OCW1PIC</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CPUPICPICOCW2 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">send_eoi</span><span class=\"params\">(<span class=\"type\">int</span> vector)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vector &gt;= <span class=\"number\">0x20</span> &amp;&amp; vector &lt; <span class=\"number\">0x28</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">outb</span>(PIC_M_CTRL, PIC_EOI);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vector &gt;= <span class=\"number\">0x28</span> &amp;&amp; vector &lt; <span class=\"number\">0x30</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">outb</span>(PIC_M_CTRL, PIC_EOI);</span><br><span class=\"line\">        <span class=\"built_in\">outb</span>(PIC_S_CTRL, PIC_EOI);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OS</p>\n<h3 id=\"XV6\"><a href=\"#XV6\" class=\"headerlink\" title=\"XV6\"></a>XV6</h3><p>APIC</p>\n<p></p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/APICStructure.png\"></p>\n<p><a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\">https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf</a></p>\n<p></p>\n<p>BSPbootstrap processor</p>\n<p>APxapplication processors </p>\n<p>BSPAPxAP</p>\n<p>CPULocal APICAdvanced Programmable Interrupt Controller<strong>lapiccpu</strong>cpucpuAPICcpucpucpuespeipeflag</p>\n<p>lapicICCinterrupt controller communications BusIO APIC<strong>ioapiccpu</strong>cpu<strong>ioapicIRQlapicIDlapic</strong>lapicioapicioapic168259aioapic<strong>ioapic8259a PIC</strong>cpu</p>\n<p>iopic RTE(Redirection Table Entry)RTE64entryentryioapicentrylapic</p>\n<p>lapicIDcpudevice spacelapicIDlapicIDcpulapicIDICC Buscpucpulapiclapiccpuioapiccpumaster picPIC_EOI</p>\n<p>lapicioapiclapicICR(Interrupt Command Register)ICRioapicRTEentrylapicIDlapiclapicBSPAPsINIT or STARTUP IPIinterprocessor interrupts</p>\n<p>XV6cpulapiciopicmpinitmpinitlapiciopicAP</p>\n<p>Local APICIO APIIC<a href=\"https://blog.csdn.net/weixin_46645613/article/details/119207945\">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>cpu</p>\n<p>EntryEntry8</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/IDT_Entry.png\"></p>\n<ul>\n<li><p>Offset</p>\n</li>\n<li><p>Selector</p>\n</li>\n<li><p>Type <strong>eflagFL_IFeflagFL_IF</strong> i</p>\n</li>\n<li><p>S0</p>\n</li>\n<li><p>DPL0x00x3DPL_USER</p>\n</li>\n<li><p>P1.</p>\n</li>\n</ul>\n<p>XV6XV6</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Gate descriptors for interrupts and traps</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">gatedesc</span> &#123;</span><br><span class=\"line\">  uint off_15_0 : <span class=\"number\">16</span>;   <span class=\"comment\">// low 16 bits of offset in segment</span></span><br><span class=\"line\">  uint cs : <span class=\"number\">16</span>;         <span class=\"comment\">// code segment selector</span></span><br><span class=\"line\">  uint args : <span class=\"number\">5</span>;        <span class=\"comment\">// # args, 0 for interrupt/trap gates</span></span><br><span class=\"line\">  uint rsv1 : <span class=\"number\">3</span>;        <span class=\"comment\">// reserved(should be zero I guess)</span></span><br><span class=\"line\">  uint type : <span class=\"number\">4</span>;        <span class=\"comment\">// type(STS_&#123;IG32,TG32&#125;)</span></span><br><span class=\"line\">  uint s : <span class=\"number\">1</span>;           <span class=\"comment\">// must be 0 (system)</span></span><br><span class=\"line\">  uint dpl : <span class=\"number\">2</span>;         <span class=\"comment\">// descriptor(meaning new) privilege level</span></span><br><span class=\"line\">  uint p : <span class=\"number\">1</span>;           <span class=\"comment\">// Present</span></span><br><span class=\"line\">  uint off_31_16 : <span class=\"number\">16</span>;  <span class=\"comment\">// high bits of offset in segment</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set up a normal interrupt/trap gate descriptor.</span></span><br><span class=\"line\"><span class=\"comment\">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span></span><br><span class=\"line\"><span class=\"comment\">//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone</span></span><br><span class=\"line\"><span class=\"comment\">// - sel: Code segment selector for interrupt/trap handler</span></span><br><span class=\"line\"><span class=\"comment\">// - off: Offset in code segment for interrupt/trap handler</span></span><br><span class=\"line\"><span class=\"comment\">// - dpl: Descriptor Privilege Level -</span></span><br><span class=\"line\"><span class=\"comment\">//        the privilege level required for software to invoke</span></span><br><span class=\"line\"><span class=\"comment\">//        this interrupt/trap gate explicitly using an int instruction.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SETGATE(gate, istrap, sel, off, d)                \\</span></span><br><span class=\"line\"><span class=\"meta\">&#123;                                                         \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).off_15_0 = (uint)(off) &amp; 0xffff;                \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).cs = (sel);                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).args = 0;                                        \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).rsv1 = 0;                                        \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).s = 0;                                           \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).dpl = (d);                                       \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).p = 1;                                           \\</span></span><br><span class=\"line\"><span class=\"meta\">  (gate).off_31_16 = (uint)(off) &gt;&gt; 16;                  \\</span></span><br><span class=\"line\"><span class=\"meta\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p>3216</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/IDTR.png\"></p>\n<h2 id=\"AP\"><a href=\"#AP\" class=\"headerlink\" title=\"AP\"></a>AP</h2><p>main</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Bootstrap processor starts running C code here.</span></span><br><span class=\"line\"><span class=\"comment\">// Allocate a real stack and switch to it, first</span></span><br><span class=\"line\"><span class=\"comment\">// doing some setup required for memory allocator to work.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">kinit1</span>(end, <span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>)); <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"built_in\">kvmalloc</span>();      <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"built_in\">mpinit</span>();        <span class=\"comment\">// detect other processors</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicinit</span>();     <span class=\"comment\">// interrupt controller</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();       <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"built_in\">picinit</span>();       <span class=\"comment\">// disable pic // 8259A</span></span><br><span class=\"line\">  <span class=\"built_in\">ioapicinit</span>();    <span class=\"comment\">// another interrupt controller</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">pinit</span>();         <span class=\"comment\">// process table // ptable</span></span><br><span class=\"line\">  <span class=\"built_in\">tvinit</span>();        <span class=\"comment\">// trap vectors</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">startothers</span>();   <span class=\"comment\">// start other processors</span></span><br><span class=\"line\">  <span class=\"built_in\">kinit2</span>(<span class=\"built_in\">P2V</span>(<span class=\"number\">4</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>), <span class=\"built_in\">P2V</span>(PHYSTOP)); <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"built_in\">userinit</span>();      <span class=\"comment\">// first user process // initROP</span></span><br><span class=\"line\">  <span class=\"built_in\">mpmain</span>();        <span class=\"comment\">// finish this processor&#x27;s setup // mpmain</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Other AP CPUs jump here from entryother.S.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpenter</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  switchkvm();  <span class=\"comment\">// APkpgdir</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();    <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"built_in\">lapicinit</span>();  <span class=\"comment\">// mainBSPlapicinit</span></span><br><span class=\"line\">  <span class=\"built_in\">mpmain</span>();     <span class=\"comment\">// mpmain</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BSPAPS</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">//    1</span></span><br><span class=\"line\"><span class=\"comment\">//    2</span></span><br><span class=\"line\"><span class=\"comment\">//    3 </span></span><br><span class=\"line\"><span class=\"comment\">// Common CPU setup code.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpmain</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cprintf</span>(<span class=\"string\">&quot;cpu%d: starting %d\\n&quot;</span>, <span class=\"built_in\">cpuid</span>(), <span class=\"built_in\">cpuid</span>());</span><br><span class=\"line\">  <span class=\"built_in\">idtinit</span>();       <span class=\"comment\">// load idt register // lidt</span></span><br><span class=\"line\">  <span class=\"built_in\">xchg</span>(&amp;(<span class=\"built_in\">mycpu</span>()-&gt;started), <span class=\"number\">1</span>); <span class=\"comment\">// tell startothers() we&#x27;re up</span></span><br><span class=\"line\">  <span class=\"built_in\">scheduler</span>();     <span class=\"comment\">// start running processes</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>BSPmaiin</p>\n<h3 id=\"mpinitcpu\"><a href=\"#mpinitcpu\" class=\"headerlink\" title=\"mpinitcpu\"></a>mpinitcpu</h3><p><a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\"></a></p>\n<p>CPUCPUBSPCPUAPCPUBSP <strong>BSPAPAPBSPMP floating pointer structureMP floating pointer structureMP configuration tableioapicMP floating pointer structureCPUBSPCPUBSPAPBSPAP</strong> BSP CPUlapicIDIDCPUCPUBSPAPAP CPUAPOS<strong>INIT or STARTUP interprocessor interrupts (IPIs)APBSPINIT or STARTUP</strong> APBSP<strong></strong></p>\n<p>BSPMP floating pointer structure<strong>1MMP floating pointer structureBIOSBISO1M</strong></p>\n<ol>\n<li>In the first kilobyte of Extended BIOS Data Area (EBDA), or</li>\n<li>Within the last kilobyte of system base memory, or</li>\n<li>In the BIOS ROM address space between 0F0000h and 0FFFFFh.</li>\n</ol>\n<p>1M<a href=\"https://wiki.osdev.org/BDA#BIOS_Data_Area_.28BDA.29\">https://wiki.osdev.org/BDA#BIOS_Data_Area_.28BDA.29</a></p>\n<p>MP Configuration Data StructuresMP floating pointer structureMP Configuration Table HeaderTable Entries</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png\"></p>\n<p>MP floating pointer structure</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/MP_floating_pointer_structure.png\"></p>\n<p>PHYSICAL ADDRESS POINTERMP config table</p>\n<p>MP Configuration Table Header</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/MP_configuration_table_header.png\"></p>\n<p></p>\n<ul>\n<li><p>MEMORY-MAPPED ADDRESS OF LOCAL APIC cpu<strong>CPUlapic</strong>lapiccpucpulapic</p>\n</li>\n<li><p>BASE TABLE LENGTHtable</p>\n</li>\n</ul>\n<p>MP Configuration Table HeaderBase MP Configuration Table EntriesEntryEntryEntry5Entry</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/entry_types.png\"></p>\n<p>XV6Processor EntriesI&#x2F;O APICEntry</p>\n<p>Processor Entries</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/processor_entry.png\"></p>\n<p>LOCAL APIC IDCPUlapicIDCPU</p>\n<p>I&#x2F;O APIC Entries</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/ioapic_entry.png\"></p>\n<p>I&#x2F;O APIC IDI&#x2F;O APICID</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  uchar *p, *e;</span><br><span class=\"line\">  <span class=\"type\">int</span> ismp;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mp</span> *mp;              <span class=\"comment\">// MP floating pointer structure</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mpconf</span> *conf;        <span class=\"comment\">// MP Configuration Table Header</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mpproc</span> *proc;        <span class=\"comment\">// Processor Entries</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">mpioapic</span> *ioapic;    <span class=\"comment\">// I/O APIC Entries</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((conf = <span class=\"built_in\">mpconfig</span>(&amp;mp)) == <span class=\"number\">0</span>)     <span class=\"comment\">// MP floating pointer structurePHYSICAL ADDRESS POINTERMP Configuration Table Header</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;Expect to run on an SMP&quot;</span>);</span><br><span class=\"line\">  ismp = <span class=\"number\">1</span>;</span><br><span class=\"line\">  lapic = (uint*)conf-&gt;lapicaddr;     <span class=\"comment\">// lapiclapic</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(p=(uchar*)(conf<span class=\"number\">+1</span>), e=(uchar*)conf+conf-&gt;length; p&lt;e; )&#123;  <span class=\"comment\">// MP Configuration Table HeaderTable Entry</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(*p)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPPROC:                      <span class=\"comment\">// Processor Entries</span></span><br><span class=\"line\">      proc = (<span class=\"keyword\">struct</span> mpproc*)p;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(ncpu &lt; NCPU) &#123;</span><br><span class=\"line\">        cpus[ncpu].apicid = proc-&gt;apicid;  <span class=\"comment\">// apicid may differ from ncpu // cpulapicid</span></span><br><span class=\"line\">        ncpu++;                       <span class=\"comment\">// CPU</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      p += <span class=\"built_in\">sizeof</span>(<span class=\"keyword\">struct</span> mpproc);</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPIOAPIC:                    <span class=\"comment\">// I/O APIC Entries</span></span><br><span class=\"line\">      ioapic = (<span class=\"keyword\">struct</span> mpioapic*)p;</span><br><span class=\"line\">      ioapicid = ioapic-&gt;apicno;      <span class=\"comment\">// ioapicid</span></span><br><span class=\"line\">      p += <span class=\"built_in\">sizeof</span>(<span class=\"keyword\">struct</span> mpioapic);</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPBUS:                       <span class=\"comment\">// Table Entry</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPIOINTR:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MPLINTR:</span><br><span class=\"line\">      p += <span class=\"number\">8</span>;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      ismp = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!ismp)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;Didn&#x27;t find a suitable machine&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(mp-&gt;imcrp)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// PIC ModeAPIC </span></span><br><span class=\"line\">    <span class=\"comment\">// interrupt mode configuration register --&gt; IMCR</span></span><br><span class=\"line\">    <span class=\"comment\">// Bochs doesn&#x27;t support IMCR, so this doesn&#x27;t run on Bochs.</span></span><br><span class=\"line\">    <span class=\"comment\">// But it would on real hardware.</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(<span class=\"number\">0x22</span>, <span class=\"number\">0x70</span>);   <span class=\"comment\">// Select IMCR</span></span><br><span class=\"line\">    <span class=\"built_in\">outb</span>(<span class=\"number\">0x23</span>, <span class=\"built_in\">inb</span>(<span class=\"number\">0x23</span>) | <span class=\"number\">1</span>);  <span class=\"comment\">// Mask external interrupts.  // APIC</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mp-&gt;imcrp</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/imcrp.png\"></p>\n<p><a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\"></a></p>\n<h3 id=\"lapicinitBSPcpulapic\"><a href=\"#lapicinitBSPcpulapic\" class=\"headerlink\" title=\"lapicinitBSPcpulapic\"></a>lapicinitBSPcpulapic</h3><p>intel 64 and IA-32 3 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">lapicinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!lapic)    <span class=\"comment\">// lapicmpinitMP Configuration Table Headerlapic</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Enable local APIC; set spurious interrupt vector.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));      <span class=\"comment\">// cpuAPIC</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// lapic</span></span><br><span class=\"line\">  <span class=\"comment\">// The timer repeatedly counts down at bus frequency</span></span><br><span class=\"line\">  <span class=\"comment\">// from lapic[TICR] and then issues an interrupt.</span></span><br><span class=\"line\">  <span class=\"comment\">// If xv6 cared more about precise timekeeping,</span></span><br><span class=\"line\">  <span class=\"comment\">// TICR would be calibrated using an external time source.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TDCR, X1);                               <span class=\"comment\">// X1</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER)); <span class=\"comment\">// PERIODIC0x20</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TICR, <span class=\"number\">10000000</span>);                         <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Disable logical interrupt lines.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(LINT0, MASKED);                          <span class=\"comment\">// LINT0lapic</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(LINT1, MASKED);                          <span class=\"comment\">// LINT1lapic</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Disable performance counter overflow interrupts</span></span><br><span class=\"line\">  <span class=\"comment\">// on machines that provide that interrupt entry.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(((lapic[VER]&gt;&gt;<span class=\"number\">16</span>) &amp; <span class=\"number\">0xFF</span>) &gt;= <span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"built_in\">lapicw</span>(PCINT, MASKED);                        <span class=\"comment\">// PCINT</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Map error interrupt to IRQ_ERROR.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ERROR, T_IRQ0 + IRQ_ERROR);            <span class=\"comment\">// 0x20 + 0x13ERROR</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Clear error status register (requires back-to-back writes).</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ESR, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ESR, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Ack any outstanding interrupts.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(EOI, <span class=\"number\">0</span>);                               <span class=\"comment\">// ioapicEOI</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Send an Init Level De-Assert to synchronise arbitration ID&#x27;s.</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ICRHI, <span class=\"number\">0</span>);                             <span class=\"comment\">// // apic</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(ICRLO, BCAST | INIT | LEVEL);          <span class=\"comment\">//  &amp; INIT &amp; </span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(lapic[ICRLO] &amp; DELIVS)                  <span class=\"comment\">// </span></span><br><span class=\"line\">    ;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Enable interrupts on the APIC (but not on the processor).</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicw</span>(TPR, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>BSPlapicAP</strong></p>\n<h3 id=\"ioapicinitioapic\"><a href=\"#ioapicinitioapic\" class=\"headerlink\" title=\"ioapicinitioapic\"></a>ioapicinitioapic</h3><p>ioapicmaster picioapicioapic RTE(Redirection Table Entry)RTET_IRQ0T_IRQ0 &#x3D;&#x3D; 0x20EntryconsoleinitioapicenableEntry RTE(Redirection Table Entry)<a href=\"https://blog.csdn.net/weixin_46645613/article/details/119207945\">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">ioapicinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i, id, maxintr;</span><br><span class=\"line\"></span><br><span class=\"line\">  ioapic = (<span class=\"keyword\">volatile</span> <span class=\"keyword\">struct</span> ioapic*)IOAPIC;           <span class=\"comment\">// 0xFEC00000   // Default physical address of IO APIC</span></span><br><span class=\"line\">  maxintr = (<span class=\"built_in\">ioapicread</span>(REG_VER) &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xFF</span>;       <span class=\"comment\">// ioapic</span></span><br><span class=\"line\">  id = <span class=\"built_in\">ioapicread</span>(REG_ID) &gt;&gt; <span class=\"number\">24</span>;                      <span class=\"comment\">// ioapicID</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(id != ioapicid)                                  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"built_in\">cprintf</span>(<span class=\"string\">&quot;ioapicinit: id isn&#x27;t equal to ioapicid; not a MP\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Mark all interrupts edge-triggered, active high, disabled,</span></span><br><span class=\"line\">  <span class=\"comment\">// and not routed to any CPUs.</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt;= maxintr; i++)&#123;    <span class=\"comment\">//  RTE(Redirection Table Entry)PIC</span></span><br><span class=\"line\">    <span class=\"built_in\">ioapicwrite</span>(REG_TABLE<span class=\"number\">+2</span>*i, INT_DISABLED | (T_IRQ0 + i));</span><br><span class=\"line\">    <span class=\"built_in\">ioapicwrite</span>(REG_TABLE<span class=\"number\">+2</span>*i<span class=\"number\">+1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"tvinit\"><a href=\"#tvinit\" class=\"headerlink\" title=\"tvinit\"></a>tvinit</h3><p>XV6</p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Interrupt descriptor table (shared by all CPUs).</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">gatedesc</span> idt[<span class=\"number\">256</span>];   <span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> uint vectors[];  <span class=\"comment\">// vectorsvectors.pl</span></span><br></pre></td></tr></table></figure>\n\n<p>tvinitSETGATE</p>\n<p>SETGATE(gate, istrap, sel, off, d) </p>\n<ul>\n<li><p>1idt[i]entry</p>\n</li>\n<li><p>2</p>\n</li>\n<li><p>3</p>\n</li>\n<li><p>4</p>\n</li>\n<li><p>5</p>\n</li>\n</ul>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">tvinit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i;</span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">256</span>; i++)</span><br><span class=\"line\">    <span class=\"built_in\">SETGATE</span>(idt[i], <span class=\"number\">0</span>, SEG_KCODE&lt;&lt;<span class=\"number\">3</span>, vectors[i], <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// DPL_USER</span></span><br><span class=\"line\">  <span class=\"built_in\">SETGATE</span>(idt[T_SYSCALL], <span class=\"number\">1</span>, SEG_KCODE&lt;&lt;<span class=\"number\">3</span>, vectors[T_SYSCALL], DPL_USER);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">initlock</span>(&amp;tickslock, <span class=\"string\">&quot;time&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>vectors.plpl</p>\n<figure class=\"highlight pl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/perl -w</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Generate vectors.S, the trap/interrupt entry points.</span></span><br><span class=\"line\"><span class=\"comment\"># There has to be one entry point per interrupt number</span></span><br><span class=\"line\"><span class=\"comment\"># since otherwise there&#x27;s no way for trap() to discover</span></span><br><span class=\"line\"><span class=\"comment\"># the interrupt number.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;# generated by vectors.pl - do not edit\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;# handlers\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;.globl alltraps\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">my</span> <span class=\"variable\">$i</span> = <span class=\"number\">0</span>; <span class=\"variable\">$i</span> &lt; <span class=\"number\">256</span>; <span class=\"variable\">$i</span>++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;.globl vector<span class=\"variable\">$i</span>\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;vector<span class=\"variable\">$i</span>:\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(<span class=\"variable\">$i</span> == <span class=\"number\">8</span> || (<span class=\"variable\">$i</span> &gt;= <span class=\"number\">10</span> &amp;&amp; <span class=\"variable\">$i</span> &lt;= <span class=\"number\">14</span>) || <span class=\"variable\">$i</span> == <span class=\"number\">17</span>))&#123;</span><br><span class=\"line\">        <span class=\"comment\"># cpuerrcode</span></span><br><span class=\"line\">        <span class=\"comment\"># </span></span><br><span class=\"line\">        <span class=\"comment\"># 0</span></span><br><span class=\"line\">        <span class=\"comment\"># trapret</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">&quot;  pushl \\$0\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;  pushl \\$<span class=\"variable\">$i</span>\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;  jmp alltraps\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;\\n# vector table\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;.data\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;.globl vectors\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;vectors:\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">my</span> <span class=\"variable\">$i</span> = <span class=\"number\">0</span>; <span class=\"variable\">$i</span> &lt; <span class=\"number\">256</span>; <span class=\"variable\">$i</span>++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;  .long vector<span class=\"variable\">$i</span>\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>plforvectorsvectorsforforifcpu<strong></strong>trapretforjmpplplalltrapsalltrapsplvectors256vectorii&#x3D;12</p>\n<p>trapasm.Salltraps</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;mmu.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">  # vectors.S sends all traps here.</span><br><span class=\"line\">.globl alltraps</span><br><span class=\"line\">alltraps:          # </span><br><span class=\"line\">  # Build trap frame.</span><br><span class=\"line\">  pushl %ds</span><br><span class=\"line\">  pushl %es</span><br><span class=\"line\">  pushl %fs</span><br><span class=\"line\">  pushl %gs</span><br><span class=\"line\">  pushal</span><br><span class=\"line\">  </span><br><span class=\"line\">  # Set up data segments.</span><br><span class=\"line\">  movw $(SEG_KDATA&lt;&lt;3), %ax</span><br><span class=\"line\">  movw %ax, %ds</span><br><span class=\"line\">  movw %ax, %es</span><br><span class=\"line\"></span><br><span class=\"line\">  # Call trap(tf), where tf=%esp</span><br><span class=\"line\">  pushl %esp</span><br><span class=\"line\">  call trap       # trap</span><br><span class=\"line\">  addl $4, %esp</span><br><span class=\"line\"></span><br><span class=\"line\">  # Return falls through to trapret...</span><br><span class=\"line\">.globl trapret</span><br><span class=\"line\">trapret:          # </span><br><span class=\"line\">  popal</span><br><span class=\"line\">  popl %gs</span><br><span class=\"line\">  popl %fs</span><br><span class=\"line\">  popl %es</span><br><span class=\"line\">  popl %ds</span><br><span class=\"line\">  addl $0x8, %esp  # trapno and errcode</span><br><span class=\"line\">  iret</span><br></pre></td></tr></table></figure>\n\n<p>tvinitplalltraps</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/trap__structure.png\"></p>\n<p></p>\n<p></p>\n<ol start=\"0\">\n<li><p>TSSss0esp0</p>\n</li>\n<li><p><strong>cpussesp</strong></p>\n</li>\n<li><p>cpueflagscseip<strong></strong></p>\n</li>\n<li><p><strong>alltraps</strong><strong></strong></p>\n</li>\n<li><p>trap</p>\n</li>\n<li><p><strong>trapret</strong><strong></strong></p>\n</li>\n<li><p>iretcpueflagscseip</p>\n</li>\n<li><p>cpussesp</p>\n</li>\n</ol>\n<p><strong></strong></p>\n<ol>\n<li><p>cpueflagscseip<strong></strong></p>\n</li>\n<li><p><strong>alltraps</strong><strong></strong></p>\n</li>\n<li><p>trap</p>\n</li>\n<li><p><strong>trapret</strong><strong></strong></p>\n</li>\n<li><p>iretcpueflagscseip</p>\n</li>\n</ol>\n<p>XV6</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PAGEBREAK: 36</span></span><br><span class=\"line\"><span class=\"comment\">// Layout of the trap frame built on the stack by the</span></span><br><span class=\"line\"><span class=\"comment\">// hardware and by trapasm.S, and passed to trap().</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">trapframe</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// registers as pushed by pusha</span></span><br><span class=\"line\">  uint edi;</span><br><span class=\"line\">  uint esi;</span><br><span class=\"line\">  uint ebp;</span><br><span class=\"line\">  uint oesp;      <span class=\"comment\">// useless &amp; ignored</span></span><br><span class=\"line\">  uint ebx;</span><br><span class=\"line\">  uint edx;</span><br><span class=\"line\">  uint ecx;</span><br><span class=\"line\">  uint eax;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// rest of trap frame</span></span><br><span class=\"line\">  ushort gs;</span><br><span class=\"line\">  ushort padding1;</span><br><span class=\"line\">  ushort fs;</span><br><span class=\"line\">  ushort padding2;</span><br><span class=\"line\">  ushort es;</span><br><span class=\"line\">  ushort padding3;</span><br><span class=\"line\">  ushort ds;</span><br><span class=\"line\">  ushort padding4;</span><br><span class=\"line\">  uint trapno;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// below here defined by x86 hardware</span></span><br><span class=\"line\">  uint err;</span><br><span class=\"line\">  uint eip;</span><br><span class=\"line\">  ushort cs;</span><br><span class=\"line\">  ushort padding5;</span><br><span class=\"line\">  uint eflags;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// below here only when crossing rings, such as from user to kernel</span></span><br><span class=\"line\">  uint esp;</span><br><span class=\"line\">  ushort ss;</span><br><span class=\"line\">  ushort padding6;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/trap_frame.png\"></p>\n<p><a href=\"https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\">https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf</a></p>\n<h3 id=\"startothersAP\"><a href=\"#startothersAP\" class=\"headerlink\" title=\"startothersAP\"></a>startothersAP</h3><p>APAP<a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\"></a>universal algorithmXV6lapicstartap</p>\n<p></p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/universal_algorithm.png\"></p>\n<p>XV6AP</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Start the non-boot (AP) processors.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">startothers</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">extern</span> uchar _binary_entryother_start[], _binary_entryother_size[];</span><br><span class=\"line\">  uchar *code;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> *c;</span><br><span class=\"line\">  <span class=\"type\">char</span> *stack;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Write entry code to unused memory at 0x7000.</span></span><br><span class=\"line\">  <span class=\"comment\">// The linker has placed the image of entryother.S in</span></span><br><span class=\"line\">  <span class=\"comment\">// _binary_entryother_start.</span></span><br><span class=\"line\">  <span class=\"comment\">// APentryotherentryother  boot + entry</span></span><br><span class=\"line\">  code = <span class=\"built_in\">P2V</span>(<span class=\"number\">0x7000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// entryother0x7000</span></span><br><span class=\"line\">  <span class=\"built_in\">memmove</span>(code, _binary_entryother_start, (uint)_binary_entryother_size);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// BSP forAP</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(c = cpus; c &lt; cpus+ncpu; c++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c == <span class=\"built_in\">mycpu</span>())  <span class=\"comment\">// We&#x27;ve started already.</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Tell entryother.S what stack to use, where to enter, and what</span></span><br><span class=\"line\">    <span class=\"comment\">// pgdir to use. We cannot use kpgdir yet, because the AP processor</span></span><br><span class=\"line\">    <span class=\"comment\">// is running in low  memory, so we use entrypgdir for the APs too.</span></span><br><span class=\"line\">    stack = <span class=\"built_in\">kalloc</span>();   <span class=\"comment\">// APscheduler</span></span><br><span class=\"line\">    *(<span class=\"type\">void</span>**)(code<span class=\"number\">-4</span>) = stack + KSTACKSIZE;</span><br><span class=\"line\">    *(<span class=\"built_in\">void</span>(**)(<span class=\"type\">void</span>))(code<span class=\"number\">-8</span>) = mpenter;  <span class=\"comment\">// APmainmpenter</span></span><br><span class=\"line\">    <span class=\"comment\">// BSP4M big page</span></span><br><span class=\"line\">    *(<span class=\"type\">int</span>**)(code<span class=\"number\">-12</span>) = (<span class=\"type\">void</span> *) <span class=\"built_in\">V2P</span>(entrypgdir);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// lapicstartapuniversal algorithm</span></span><br><span class=\"line\">    <span class=\"built_in\">lapicstartap</span>(c-&gt;apicid, <span class=\"built_in\">V2P</span>(code));   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// AP</span></span><br><span class=\"line\">    <span class=\"comment\">// wait for cpu to finish mpmain()</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c-&gt;started == <span class=\"number\">0</span>)  </span><br><span class=\"line\">      ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AP bootBSPbootBSP0x7c00AP0x70000x7000bootasm.S + entry.S</p>\n<ol>\n<li><p></p>\n</li>\n<li><p>entrypgdir</p>\n</li>\n<li><p>scheduler</p>\n</li>\n<li><p>mpenter</p>\n</li>\n</ol>\n<p>entryother.S</p>\n<p>mpenter</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Other CPUs jump here from entryother.S.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpenter</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  switchkvm();    <span class=\"comment\">// 4kkpgdir</span></span><br><span class=\"line\">  <span class=\"built_in\">seginit</span>();       <span class=\"comment\">//BSPmainBSPentryother.S</span></span><br><span class=\"line\">  <span class=\"built_in\">lapicinit</span>();    <span class=\"comment\">// BSP</span></span><br><span class=\"line\">  <span class=\"built_in\">mpmain</span>();       <span class=\"comment\">// mpmain</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>APBSPCPUmpmainBSPmainmpmainBSPAP</p>\n<p>mpmainschedulerCPU</p>\n<p>mpmain</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Common CPU setup code.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mpmain</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cprintf</span>(<span class=\"string\">&quot;cpu%d: starting %d\\n&quot;</span>, <span class=\"built_in\">cpuid</span>(), <span class=\"built_in\">cpuid</span>());</span><br><span class=\"line\">  <span class=\"built_in\">idtinit</span>();       <span class=\"comment\">// load idt register</span></span><br><span class=\"line\">  <span class=\"built_in\">xchg</span>(&amp;(<span class=\"built_in\">mycpu</span>()-&gt;started), <span class=\"number\">1</span>); <span class=\"comment\">// tell startothers() we&#x27;re up</span></span><br><span class=\"line\">  <span class=\"built_in\">scheduler</span>();     <span class=\"comment\">// start running processes</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>XV6CPU</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Per-CPU state</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// lapciid</span></span><br><span class=\"line\">  uchar apicid;                <span class=\"comment\">// Local APIC ID</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">context</span> *scheduler;   <span class=\"comment\">// swtch() here to enter scheduler</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">taskstate</span> ts;         <span class=\"comment\">// Used by x86 to find stack for interrupt</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">segdesc</span> gdt[NSEGS];   <span class=\"comment\">// x86 global descriptor table</span></span><br><span class=\"line\">  <span class=\"comment\">// cpu</span></span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> uint started;       <span class=\"comment\">// Has the CPU started?</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">int</span> ncli;                    <span class=\"comment\">// Depth of pushcli nesting.</span></span><br><span class=\"line\">  <span class=\"comment\">// cpu</span></span><br><span class=\"line\">  <span class=\"type\">int</span> intena;                  <span class=\"comment\">// Were interrupts enabled before pushcli?</span></span><br><span class=\"line\">  <span class=\"comment\">// cpuPCB</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *proc;           <span class=\"comment\">// The process running on this cpu or null</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> cpus[NCPU]; <span class=\"comment\">// cpu</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> ncpu;              <span class=\"comment\">// cpu</span></span><br></pre></td></tr></table></figure>\n\n<p>CPU</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">lapic</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">ioapic</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">cpueipespeflag</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">kpgdir</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">ptable</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>XV6PCBOSXV6PCBXV6PCBPCBOnixPCBPDBespesp4Kesp4K</p>\n<p>XV6PCB</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// proc.h</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">procstate</span> &#123; UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Per-process state</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  uint sz;                     <span class=\"comment\">// Size of process memory (bytes)</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">pde_t</span>* pgdir;                <span class=\"comment\">// Page table</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">char</span> *kstack;                <span class=\"comment\">// Bottom of kernel stack for this process</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">enum</span> <span class=\"title class_\">procstate</span> state;        <span class=\"comment\">// Process state</span></span><br><span class=\"line\">  <span class=\"comment\">// pid</span></span><br><span class=\"line\">  <span class=\"type\">int</span> pid;                     <span class=\"comment\">// Process ID</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *parent;         <span class=\"comment\">// Parent process</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">trapframe</span> *tf;        <span class=\"comment\">// Trap frame for current syscall</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">context</span> *context;     <span class=\"comment\">// swtch() here to run process</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">void</span> *chan;                  <span class=\"comment\">// If non-zero, sleeping on chan</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">int</span> killed;                  <span class=\"comment\">// If non-zero, have been killed</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">file</span> *ofile[NOFILE];  <span class=\"comment\">// Open files</span></span><br><span class=\"line\">  <span class=\"comment\">// inode</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">inode</span> *cwd;           <span class=\"comment\">// Current directory</span></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"type\">char</span> name[<span class=\"number\">16</span>];               <span class=\"comment\">// Process name (debugging)</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// proc.c</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">spinlock</span> lock;       <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> proc[NPROC];</span><br><span class=\"line\">&#125; ptable;                     <span class=\"comment\">// cpu</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *initproc; <span class=\"comment\">// initPCB</span></span><br><span class=\"line\"><span class=\"type\">int</span> nextpid = <span class=\"number\">1</span>;              <span class=\"comment\">// pid</span></span><br></pre></td></tr></table></figure>\n\n<p>XV66UNUSEDPCB, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE&#x2F; PCBchanXV6sleepwaitreadsleeplockXV6SLEEPINGptableptablechanchanXV6chanXV6sleepchanticksjefrrisXV6</p>\n<p>APBSPAPschedulerscheduler</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PAGEBREAK: 42</span></span><br><span class=\"line\"><span class=\"comment\">// Per-CPU process scheduler.</span></span><br><span class=\"line\"><span class=\"comment\">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class=\"line\"><span class=\"comment\">// Scheduler never returns.  It loops, doing:</span></span><br><span class=\"line\"><span class=\"comment\">//  - choose a process to run</span></span><br><span class=\"line\"><span class=\"comment\">//  - swtch to start running that process</span></span><br><span class=\"line\"><span class=\"comment\">//  - eventually that process transfers control</span></span><br><span class=\"line\"><span class=\"comment\">//      via swtch back to the scheduler.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">scheduler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *p;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">cpu</span> *c = <span class=\"built_in\">mycpu</span>();  <span class=\"comment\">// schedulercpu</span></span><br><span class=\"line\">  c-&gt;proc = <span class=\"number\">0</span>;              <span class=\"comment\">// cpu</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Enable interrupts on this processor.</span></span><br><span class=\"line\">    <span class=\"built_in\">sti</span>();                  <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// pushclimycpu()-&gt;intenasched</span></span><br><span class=\"line\">    <span class=\"comment\">// Loop over process table looking for process to run.</span></span><br><span class=\"line\">    <span class=\"built_in\">acquire</span>(&amp;ptable.lock); <span class=\"comment\">// ptable</span></span><br><span class=\"line\">    <span class=\"comment\">// ptable</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(p-&gt;state != RUNNABLE)  <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      <span class=\"comment\">// else </span></span><br><span class=\"line\">      <span class=\"comment\">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class=\"line\">      <span class=\"comment\">// to release ptable.lock and then reacquire it</span></span><br><span class=\"line\">      <span class=\"comment\">// before jumping back to us.</span></span><br><span class=\"line\">      c-&gt;proc = p;  <span class=\"comment\">// pcpu</span></span><br><span class=\"line\">      <span class=\"comment\">//  </span></span><br><span class=\"line\">      <span class=\"comment\">// 1tss</span></span><br><span class=\"line\">      <span class=\"comment\">// 2tss</span></span><br><span class=\"line\">      <span class=\"comment\">// 3cpup</span></span><br><span class=\"line\">      switchuvm(p);</span><br><span class=\"line\">      p-&gt;state = RUNNING; <span class=\"comment\">// p</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">swtch</span>(&amp;(c-&gt;scheduler), p-&gt;context); <span class=\"comment\">// pcpu</span></span><br><span class=\"line\">      switchkvm();        <span class=\"comment\">// kpgdir</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Process is done running for now.</span></span><br><span class=\"line\">      <span class=\"comment\">// It should have changed its p-&gt;state before coming back.</span></span><br><span class=\"line\">      c-&gt;proc = <span class=\"number\">0</span>;        <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">release</span>(&amp;ptable.lock);  <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>XV6round robin</p>\n<p>switchuvmtsscpup<strong>tss</strong>TSSTSSespssswitchuvm</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Switch TSS and h/w page table to correspond to process p.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">switchuvm</span><span class=\"params\">(<span class=\"keyword\">struct</span> proc *p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;switchuvm: no process&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;kstack == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;switchuvm: no kstack&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;pgdir == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;switchuvm: no pgdir&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">pushcli</span>();</span><br><span class=\"line\">  <span class=\"comment\">// tsscputss</span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;gdt[SEG_TSS] = <span class=\"built_in\">SEG16</span>(STS_T32A, &amp;<span class=\"built_in\">mycpu</span>()-&gt;ts,</span><br><span class=\"line\">                                <span class=\"built_in\">sizeof</span>(<span class=\"built_in\">mycpu</span>()-&gt;ts)<span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;gdt[SEG_TSS].s = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;ts.ss0 = SEG_KDATA &lt;&lt; <span class=\"number\">3</span>;                 <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;ts.esp0 = (uint)p-&gt;kstack + KSTACKSIZE;  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"comment\">// setting IOPL=0 in eflags *and* iomb beyond the tss segment limit</span></span><br><span class=\"line\">  <span class=\"comment\">// forbids I/O instructions (e.g., inb and outb) from user space</span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;ts.iomb = (ushort) <span class=\"number\">0xFFFF</span>;</span><br><span class=\"line\">  <span class=\"built_in\">ltr</span>(SEG_TSS &lt;&lt; <span class=\"number\">3</span>);                                <span class=\"comment\">// tss</span></span><br><span class=\"line\">  <span class=\"comment\">// p</span></span><br><span class=\"line\">  <span class=\"built_in\">lcr3</span>(<span class=\"built_in\">V2P</span>(p-&gt;pgdir));  <span class=\"comment\">// switch to process&#x27;s address space</span></span><br><span class=\"line\">  <span class=\"built_in\">popcli</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/StevenBaby/onix/blob/dev/docs/07%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/062%20%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E7%AE%80%E4%BB%8B.md\">https://github.com/StevenBaby/onix/blob/dev/docs/07%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/062%20%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E7%AE%80%E4%BB%8B.md</a></p>\n<p>swtch</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Context switch</span><br><span class=\"line\">#</span><br><span class=\"line\">#   void swtch(struct context **old, struct context *new);</span><br><span class=\"line\"># </span><br><span class=\"line\"># Save the current registers on the stack, creating</span><br><span class=\"line\"># a struct context, and save its address in *old.</span><br><span class=\"line\"># Switch stacks to new and pop previously-saved registers.</span><br><span class=\"line\"></span><br><span class=\"line\">.globl swtch</span><br><span class=\"line\">swtch:                # pushl eipcpu</span><br><span class=\"line\">  movl 4(%esp), %eax  # struct context**</span><br><span class=\"line\">  movl 8(%esp), %edx  #   struct context*</span><br><span class=\"line\"></span><br><span class=\"line\">  # Save old callee-saved registers</span><br><span class=\"line\">  pushl %ebp</span><br><span class=\"line\">  pushl %ebx</span><br><span class=\"line\">  pushl %esi</span><br><span class=\"line\">  pushl %edi</span><br><span class=\"line\"></span><br><span class=\"line\">  # Switch stacks</span><br><span class=\"line\">  movl %esp, (%eax) # *</span><br><span class=\"line\">  movl %edx, %esp   # esp</span><br><span class=\"line\"></span><br><span class=\"line\">  # Load new callee-saved registers</span><br><span class=\"line\">  popl %edi</span><br><span class=\"line\">  popl %esi</span><br><span class=\"line\">  popl %ebx</span><br><span class=\"line\">  popl %ebp</span><br><span class=\"line\">  ret</span><br></pre></td></tr></table></figure>\n\n<p>struct context</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">context</span> &#123;</span><br><span class=\"line\">  uint edi;</span><br><span class=\"line\">  uint esi;</span><br><span class=\"line\">  uint ebx;</span><br><span class=\"line\">  uint ebp;</span><br><span class=\"line\">  uint eip;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>cpuschedulerschedcpu<strong></strong>traptrapyieldyieldschedtrap</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">spinlock</span> tickslock;</span><br><span class=\"line\">uint ticks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//PAGEBREAK: 41</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">trap</span><span class=\"params\">(<span class=\"keyword\">struct</span> trapframe *tf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(tf-&gt;trapno == T_SYSCALL)&#123;  <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(tf-&gt;trapno)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">cpuid</span>() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">acquire</span>(&amp;tickslock);</span><br><span class=\"line\">      ticks++;            <span class=\"comment\">// 1</span></span><br><span class=\"line\">      <span class=\"built_in\">wakeup</span>(&amp;ticks);     <span class=\"comment\">// sleeping</span></span><br><span class=\"line\">      <span class=\"built_in\">release</span>(&amp;tickslock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">lapiceoi</span>();           <span class=\"comment\">// lapic</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Force process to give up CPU on clock tick.</span></span><br><span class=\"line\">  <span class=\"comment\">// If interrupts were on while locks held, would need to check nlock.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">myproc</span>() &amp;&amp; <span class=\"built_in\">myproc</span>()-&gt;state == RUNNING &amp;&amp;</span><br><span class=\"line\">     tf-&gt;trapno == T_IRQ0+IRQ_TIMER)</span><br><span class=\"line\">    <span class=\"built_in\">yield</span>();    <span class=\"comment\">// cpu</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>yieldschedschedRUNNABLE</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Enter scheduler.  Must hold only ptable.lock</span></span><br><span class=\"line\"><span class=\"comment\">// and have changed proc-&gt;state. Saves and restores</span></span><br><span class=\"line\"><span class=\"comment\">// intena because intena is a property of this</span></span><br><span class=\"line\"><span class=\"comment\">// kernel thread, not this CPU. It should</span></span><br><span class=\"line\"><span class=\"comment\">// be proc-&gt;intena and proc-&gt;ncli, but that would</span></span><br><span class=\"line\"><span class=\"comment\">// break in the few places where a lock is held but</span></span><br><span class=\"line\"><span class=\"comment\">// there&#x27;s no process.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sched</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> intena;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proc</span> *p = <span class=\"built_in\">myproc</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"built_in\">holding</span>(&amp;ptable.lock))</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched ptable.lock&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">mycpu</span>()-&gt;ncli != <span class=\"number\">1</span>)        <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched locks&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;state == RUNNING)       <span class=\"comment\">// sched</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched running&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">readeflags</span>()&amp;FL_IF)        <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;sched interruptible&quot;</span>);</span><br><span class=\"line\">  intena = <span class=\"built_in\">mycpu</span>()-&gt;intena;     <span class=\"comment\">// intena</span></span><br><span class=\"line\">  <span class=\"built_in\">swtch</span>(&amp;p-&gt;context, <span class=\"built_in\">mycpu</span>()-&gt;scheduler); <span class=\"comment\">// scheduler</span></span><br><span class=\"line\">  <span class=\"built_in\">mycpu</span>()-&gt;intena = intena;     <span class=\"comment\">// intena</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Give up the CPU for one scheduling round.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">yield</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">acquire</span>(&amp;ptable.lock);  <span class=\"comment\">//DOC: yieldlock</span></span><br><span class=\"line\">  <span class=\"built_in\">myproc</span>()-&gt;state = RUNNABLE;</span><br><span class=\"line\">  <span class=\"built_in\">sched</span>();</span><br><span class=\"line\">  <span class=\"built_in\">release</span>(&amp;ptable.lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>schedintenaintenaPCBXV6shcedintenaPCB<strong>schedulerptable.lockpushcliintenaschedintenaschedulerschedulerptable.lockpopcliintenaintenafor</strong></p>\n<p></p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/task_stack.drawio.png\"></p>\n<p>yieldscheduleryieldptableintenaschedulerschedulerschedulerschedulerptableptableschedulerptable</p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/yield_scheduler.png\"></p>\n<p>XV6<strong>cpushedulerschedulerptableswapIncpuswapOut</strong></p>\n<p><strong>XV6XV6</strong></p>\n<p><strong>OnixOnixOnix</strong></p>\n<p><strong>sylarXV6</strong></p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler.drawio.png\"></p>\n<p><strong>CPU PoolXV6CPUptableCPU</strong></p>\n<p>sylar <strong>sylarXV6</strong> sylarC++sylar<a href=\"https://blog.csdn.net/m0_52566365/article/details/135991331%E3%80%82\">https://blog.csdn.net/m0_52566365/article/details/135991331</a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>XV6</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">XV6</th>\n<th align=\"center\">Onix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\">kallockalloc</td>\n<td align=\"center\">get_page2564G&#x2F;page + alloc_kpagealloc_kpage&#x2F;page + kmalloc&#x2F;byte</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">ebpediesiedxecxebx</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">loader</td>\n</tr>\n<tr>\n<td align=\"center\">idle</td>\n<td align=\"center\">idle</td>\n<td align=\"center\">idle</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>OnixOnixOnixXV6Onix<strong></strong>OSXV6OSCPUCPUeipespeflagcpucpu</p>\n<p>XV6<strong>XV6</strong>XV6MuduoOne loop per thread MuduoOne loop per threadLinuxCPUXV6cpuptablecpuptablecpucpucpuxcpucpuxcpux<strong>One loop per CPU</strong></p>\n<p><img src=\"/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler_pluse.drawio.png\"></p>\n<p>4</p>\n<p><strong></strong></p>\n<p><a href=\"https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf\">https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf</a></p>\n<p>XV6<a href=\"https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf\">https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf</a></p>\n<p>Onix<a href=\"https://github.com/StevenBaby/onix/\">https://github.com/StevenBaby/onix/</a></p>\n<p>APIC<a href=\"https://blog.csdn.net/weixin_46645613/article/details/119207945\">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>\n<p>1<a href=\"https://zhuanlan.zhihu.com/p/394247844\">https://zhuanlan.zhihu.com/p/394247844</a></p>\n<hr>\n<p><strong></strong></p>"},{"title":" Onix & XV6 1XV6-x86","date":"2024-06-07T04:00:00.000Z","_content":"\n## \n\nOnixXV6OSOnix\n\nXV6OnixOnixXV6XV6\n\nOnixbootloaderOSOnixOnixbootloaderXV6CXV6XV6\n\nOnix\n\n- [github](https://github.com/StevenBaby/onix)\n\n- [B](https://www.bilibili.com/video/BV1qM4y127om/)\n\nXV6-x86github\n\n- [](https://github.com/mit-pdos/xv6-public)\n\n<!-- more -->\n\n## Makefile & kernel.ld\n\n  \n\n** BIOS  512  GRUB**\n\nBISO\n\n1. 0x7c00\n2. 512\n3. 0x55aa\n\nosMakefilebootmainososelfoslinkos\n\n### Makefile\n\nmakefile\n\n```makefile\n# ddOSbootblockkernel\n# 10000\n# bootblock0\n# 1OS\nxv6.img: bootblock kernel\n\tdd if=/dev/zero of=xv6.img count=10000\n\tdd if=bootblock of=xv6.img conv=notrunc\n\tdd if=kernel of=xv6.img seek=1 conv=notrunc\n\n# osbootloader$(OBJCOPY)\n# elf$(LD)\n# start0x7C00bootblock\n# pl5120x55aa\nbootblock: bootasm.S bootmain.c\n\t$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c\n\t$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S\n\t$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o\n\t$(OBJDUMP) -S bootblock.o > bootblock.asm\n\t$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock\n\t./sign.pl bootblock\n\n# AP cpuboot\n# 0x7000\n# bootblockelf\n# entryotherkernel\nentryother: entryother.S\n\t$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S\n\t$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o\n\t$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother\n\t$(OBJDUMP) -S bootblockother.o > entryother.asm\n\n# initboot\n# $(OBJCOPY)elfinitcode\n# 0\ninitcode: initcode.S\n\t$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S\n\t$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o\n\t$(OBJCOPY) -S -O binary initcode.out initcode\n\t$(OBJDUMP) -S initcode.o > initcode.asm\n\n# elf\nkernel: $(OBJS) entry.o entryother initcode kernel.ld\n\t$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother\n\t$(OBJDUMP) -S kernel > kernel.asm\n\t$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym\n\n```\n\n\n\nddxv6.imgbootblock0kernel1bootblockcpukernel0x7C00bootblock\\$(LD)bootblock0x7C00**BIOS05125120x7C00BIOSeip0x7C00bootasm.S**\n\n\\$(LD)bootblock.obootasm.obootmain.obootasm.oeip0x7C00start\n\nbootblock\\$(OBJCOPY)\\$(OBJCOPY)elfBIOS0bootblockelf\\$(OBJCOPY)\n\nbootblock\n\n### kernel.ld\n\nkernel.ld\n\n```link\nOUTPUT_FORMAT(\"elf32-i386\", \"elf32-i386\", \"elf32-i386\")\nOUTPUT_ARCH(i386)\nENTRY(_start)\n\nSECTIONS\n{\n\t/* Link the kernel at this address: \".\" means the current address */\n        /* Must be equal to KERNLINK */\n\t. = 0x80100000; // \n\n\t.text : AT(0x100000) {  // \n\t\t*(.text .stub .text.* .gnu.linkonce.t.*)\n\t}\n\n  /*\n    ...\n  */\n}\n```\n\nkernelkernel0x8010 0000x100000AT  /  \n\n## \n\nxv6bootasm.Sxv6AT&T\n\n```arm\n#include \"asm.h\"\n#include \"memlayout.h\"\n#include \"mmu.h\"\n\n# Start the first CPU: switch to 32-bit protected mode, jump into C.\n# The BIOS loads this code from the first sector of the hard disk into\n# memory at physical address 0x7c00 and starts executing in real mode\n# with %cs=0 %ip=7c00.\n\n.code16                       # Assemble for 16-bit mode\n.globl start\nstart:\n  cli                         # BIOS enabled interrupts; disable\n\n  # Zero data segment registers DS, ES, and SS.\n  xorw    %ax,%ax             # Set %ax to zero\n  movw    %ax,%ds             # -> Data Segment\n  movw    %ax,%es             # -> Extra Segment\n  movw    %ax,%ss             # -> Stack Segment\n\n  # OS\n  # Physical address line A20 is tied to zero so that the first PCs \n  # with 2 MB would run software that assumed 1 MB.  Undo that.\nseta20.1:\n  inb     $0x64,%al               # Wait for not busy\n  testb   $0x2,%al\n  jnz     seta20.1\n\n  movb    $0xd1,%al               # 0xd1 -> port 0x64\n  outb    %al,$0x64\n\nseta20.2:\n  inb     $0x64,%al               # Wait for not busy\n  testb   $0x2,%al\n  jnz     seta20.2\n\n  movb    $0xdf,%al               # 0xdf -> port 0x60\n  outb    %al,$0x60\n\n  # Switch from real to protected mode.  Use a bootstrap GDT that makes\n  # virtual addresses map directly to physical addresses so that the\n  # effective memory map doesn't change during the transition.\n  lgdt    gdtdesc\n  movl    %cr0, %eax\n  orl     $CR0_PE, %eax\n  movl    %eax, %cr0\n ########################### 32\n//PAGEBREAK!\n  # Complete the transition to 32-bit protected mode by using a long jmp\n  # to reload %cs and %eip.  The segment descriptors are set up with no\n  # translation, so that the mapping is still the identity mapping.\n  ljmp    $(SEG_KCODE<<3), $start32\n\n.code32  # Tell assembler to generate 32-bit code now.\nstart32:\n  # Set up the protected-mode data segment registers\n  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector\n  movw    %ax, %ds                # -> DS: Data Segment\n  movw    %ax, %es                # -> ES: Extra Segment\n  movw    %ax, %ss                # -> SS: Stack Segment\n  movw    $0, %ax                 # Zero segments not ready for use\n  movw    %ax, %fs                # -> FS\n  movw    %ax, %gs                # -> GS\n\n  # Set up the stack pointer and call into C.\n  movl    $start, %esp            # espstartbootasm\n  call    bootmain\n\n  # If bootmain returns (it shouldn't), trigger a Bochs\n  # breakpoint if running under Bochs, then loop.\n  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00\n  movw    %ax, %dx\n  outw    %ax, %dx\n  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00\n  outw    %ax, %dx\nspin:\n  jmp     spin\n\n# Bootstrap GDT\n.p2align 2                                # force 4 byte alignment\ngdt:\n  SEG_NULLASM                             # null seg\n  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg\n  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg\n\ngdtdesc:\n  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1\n  .long   gdt                             # address gdt\n\n```\n\n\n\n- PC1616 + 1620\n\n- CPU163264 + 324G+\n\nbootasm.SBIOS1M**boot0x7C00 < 1M 1M**cpu4G\n\n -> xv6bootasm\n\n0. CPUBSPbootstrap processorBSPAPBSP\n\n1. dsesss\n\n2. A20.\n\n3. lgdtGDTRgdt\n\n4. CR001PE\n\n5. ljmpstart32\n\n    ```\n    # xv6ljmp\n    # Complete the transition to 32-bit protected mode by using a long jmp\n    # to reload %cs and %eip. \n    ```\n\n6. esp0x7C00bootmainXV6 OS\n\n\n\nDescriptor4K/\n\n![](./Boot/photo/start/SegmentDescriptor.png)\n\n8\n\n![](./Boot/photo/start/GDT.png)\n\n********\n\n![](./Boot/photo/start/GDTR.png)\n\n820~1\n\n![](./Boot/photo/start/SegmentSelector.png)\n\n  cpucputss\n\nGDT\n\n[](https://blog.csdn.net/abc123lzf/article/details/109289567)\n\n[](https://blog.csdn.net/me1171115772/article/details/51750442)\n\n## XV6\n\nelfelfELF headerProgram header table\n\n[https://zhuanlan.zhihu.com/p/165336511](https://zhuanlan.zhihu.com/p/165336511)\n\n```cpp\n#define ELF_MAGIC 0x464C457FU  // \"\\x7FELF\" in little endian\n\n// ELF \nstruct elfhdr {\n  uint magic;       // 4  0x464C457FU 0x7felf\n                      //  ELF \n\n  uchar elf[12];    // 12 \n                    //     0 : 1 = 32 2 = 64 \n                    //     1 : 0 = 1 = 2 = \n                    //     2 :  0x1\n                    //     3 : \n                    //     4 : \n                    //     5 ~ 11 :  0\n\n  ushort type;      // 2 \n                    //     0x0 : \n                    //     0x1 : \n                    //     0x2 : \n                    //     0x3 : \n                    //     0x4 : \n                    //     0xff00 : \n                    //     0xffff : \n\n  ushort machine;   // 2 \n                    //  0x0 0x3  x86 \n\n  uint version;     // 4 \n\n  uint entry;       // 4  0\n\n  uint phoff;       // 4 \n\n  uint shoff;       // 4 \n\n  uint flags;       // 4 \n\n  ushort ehsize;    // 2 ELF\n\n  ushort phentsize; // 2 \n\n  ushort phnum;     // 2 \n                    // phnum * phentsize = \n\n  ushort shentsize; // 2 \n\n  ushort shnum;     // 2 \n                    // shnum * shentsize = \n\n  ushort shstrndx;  // 2 \n};\n\n// \nstruct proghdr {\n  uint type;        // 4  \n                    //         1 PT_LOAD : \n                    //         2 PT_DYNAMIC : \n                    //         3 PT_INTERP : \n                    //         4 PT_NOTE : \n                    //         5 PT_SHLIB : \n                    //         6 PT_PHDR : \n                    //         7 PT_TLS : \n  uint off;         // 4  \n  uint vaddr;       // 4  \n  uint paddr;       // 4  ()\n  uint filesz;      // 4  \n  uint memsz;       // 4  \n  uint flags;       // 4  \n                    //         1 : \n                    //         2 : \n                    //         4 : \n  uint align;       // 4  \n};\n```\n\n[ELF](https://blog.csdn.net/pingxiaozhao/article/details/109239221)elfELF headerProgram header tableXV6\n\nkernel elf\n\n```cpp\nvoid\nbootmain(void)\n{\n  struct elfhdr *elf;\n  struct proghdr *ph, *eph;\n  void (*entry)(void);\n  uchar* pa;\n  // \n  // 46K\n  elf = (struct elfhdr*)0x10000;  // scratch space\n\n  // 04096elf\n  // Read 1st page off disk\n  readseg((uchar*)elf, 4096, 0);\n\n  // elf\n  // Is this an ELF executable?\n  if(elf->magic != ELF_MAGIC)\n    return;  // let bootasm.S handle error\n\n  // Program header table\n  // Load each program segment (ignores ph flags).\n  ph = (struct proghdr*)((uchar*)elf + elf->phoff);\n  // \n  eph = ph + elf->phnum;\n\n  // \n  for(; ph < eph; ph++){  // struct proghdr\n    // xv60x100000\n    pa = (uchar*)ph->paddr;\n    // pa\n    readseg(pa, ph->filesz, ph->off);\n    if(ph->memsz > ph->filesz)\n      // memfile\n      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);\n  }\n\n  // Call the entry point from the ELF header.\n  // Does not return!\n  entry = (void(*)(void))(elf->entry);  // xv6kernel.ld_start\n  entry();\n}\n```\n\nkernelelfelfentry_startkernel.ld_startcpu &  & ****kernelelf0x8010 0000entry.S_startXV6_startxv6\n\n**bootasmespesp1Mbootasmesp0x7c00**\n\nbootmain\n\n![](./Boot/photo/start/boot.drawio.png)\n\n\n\n```cpp\nvoid\nwaitdisk(void)\n{\n  // Wait for disk ready.\n  while((inb(0x1F7) & 0xC0) != 0x40)\n    ;\n}\n\n// readsecthttps://zhuanlan.zhihu.com/p/165336511\n// Read a single sector at offset into dst.\nvoid\nreadsect(void *dst, uint offset)\n{\n  // Issue command.\n  waitdisk();\n  outb(0x1F2, 1);   // count = 1          //  count = 1\n  outb(0x1F3, offset);                    //  LBA  0-7 \n  outb(0x1F4, offset >> 8);               //  LBA  8-15 \n  outb(0x1F5, offset >> 16);              //  LBA  16-23 \n  outb(0x1F6, (offset >> 24) | 0xE0);     // offset | 11100000  1\n                                          //         7     1\n                                          //         6     LBA1LBA\n                                          //         5     1\n                                          //         4     01\n                                          //         3~0    LBA  24-27 \n  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors  // 20h30h\n\n  // Read data.\n  waitdisk();\n  insl(0x1F0, dst, SECTSIZE/4); // 44\n}\n\n// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.\n// Might copy more than asked.\nvoid\nreadseg(uchar* pa, uint count, uint offset)\n{\n  uchar* epa; // end phy addr\n\n  epa = pa + count; // \n\n  // offsetSECTSIZE512Byte\n  // 512offset512\n  // offsetSECTSIZEoffset\n  // offsetofsofsoffset % SECTSIZE\n  // paoffset % SECTSIZEoffset\n  // Round down to sector boundary.\n  pa -= offset % SECTSIZE;    \n\n  // offset\n  // Translate from bytes to sectors; kernel starts at sector 1.\n  offset = (offset / SECTSIZE) + 1; \n\n  // \n  for(; pa < epa; pa += SECTSIZE, offset++)\n    readsect(pa, offset);\n}\n```\n\nreadsegpaxv6\n\n## _start\n\nentry.S\n\n```arm\n#include \"asm.h\"\n#include \"memlayout.h\"\n#include \"mmu.h\"\n#include \"param.h\"\n\n# Multiboot header.  Data to direct multiboot loader.\n.p2align 2\n.text\n.globl multiboot_header\nmultiboot_header:\n  #define magic 0x1badb002\n  #define flags 0\n  .long magic\n  .long flags\n  .long (-magic-flags)\n  \n# elf\n# entry\n# V2P_WOentrybootmainentry.\n# V2P_WO 0x8000 0000 \n.globl _start\n_start = V2P_WO(entry)\n\n# Entering xv6 on boot processor, with paging off.\n.globl entry\nentry:\n  # 4M big page\n  # Turn on page size extension for 4Mbyte pages\n  movl    %cr4, %eax\n  orl     $(CR4_PSE), %eax\n  movl    %eax, %cr4\n\n  # entrypgdir\n  # entrypgdirentrypgdir\n  # \n  # Set page directory\n  movl    $(V2P_WO(entrypgdir)), %eax\n  movl    %eax, %cr3\n\n  # \n  # Turn on paging.\n  movl    %cr0, %eax\n  orl     $(CR0_PG|CR0_WP), %eax\n  movl    %eax, %cr0\n\n  ########################### \n  # espesp\n  # Set up the stack pointer.\n  movl $(stack + KSTACKSIZE), %esp\n\n  # main\n  mov $main, %eax\n  jmp *%eax\n\n.comm stack, KSTACKSIZE\n```\n\nmain\n\n1. 4M big pagecpu4Mentrypgdir4Mentrypgdirmainkpgdir4Kxv6\n\n2. entrypgdirBSPbooststrap processor\n\n3. \n\n4. esp4K\n\n5. main\n\nentry.Scpu\n\n![](./Boot/photo/start/entry.drawio.png)\n\ncpuunix\n\n---\n\n****\n\n","source":"_posts/xv6/Boot.md","raw":"---\ntitle:  Onix & XV6 1XV6-x86\ndate: 2024-06-07 12:00:00\ntags:\n  - Unix\n---\n\n## \n\nOnixXV6OSOnix\n\nXV6OnixOnixXV6XV6\n\nOnixbootloaderOSOnixOnixbootloaderXV6CXV6XV6\n\nOnix\n\n- [github](https://github.com/StevenBaby/onix)\n\n- [B](https://www.bilibili.com/video/BV1qM4y127om/)\n\nXV6-x86github\n\n- [](https://github.com/mit-pdos/xv6-public)\n\n<!-- more -->\n\n## Makefile & kernel.ld\n\n  \n\n** BIOS  512  GRUB**\n\nBISO\n\n1. 0x7c00\n2. 512\n3. 0x55aa\n\nosMakefilebootmainososelfoslinkos\n\n### Makefile\n\nmakefile\n\n```makefile\n# ddOSbootblockkernel\n# 10000\n# bootblock0\n# 1OS\nxv6.img: bootblock kernel\n\tdd if=/dev/zero of=xv6.img count=10000\n\tdd if=bootblock of=xv6.img conv=notrunc\n\tdd if=kernel of=xv6.img seek=1 conv=notrunc\n\n# osbootloader$(OBJCOPY)\n# elf$(LD)\n# start0x7C00bootblock\n# pl5120x55aa\nbootblock: bootasm.S bootmain.c\n\t$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c\n\t$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S\n\t$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o\n\t$(OBJDUMP) -S bootblock.o > bootblock.asm\n\t$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock\n\t./sign.pl bootblock\n\n# AP cpuboot\n# 0x7000\n# bootblockelf\n# entryotherkernel\nentryother: entryother.S\n\t$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S\n\t$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o\n\t$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother\n\t$(OBJDUMP) -S bootblockother.o > entryother.asm\n\n# initboot\n# $(OBJCOPY)elfinitcode\n# 0\ninitcode: initcode.S\n\t$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S\n\t$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o\n\t$(OBJCOPY) -S -O binary initcode.out initcode\n\t$(OBJDUMP) -S initcode.o > initcode.asm\n\n# elf\nkernel: $(OBJS) entry.o entryother initcode kernel.ld\n\t$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother\n\t$(OBJDUMP) -S kernel > kernel.asm\n\t$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym\n\n```\n\n\n\nddxv6.imgbootblock0kernel1bootblockcpukernel0x7C00bootblock\\$(LD)bootblock0x7C00**BIOS05125120x7C00BIOSeip0x7C00bootasm.S**\n\n\\$(LD)bootblock.obootasm.obootmain.obootasm.oeip0x7C00start\n\nbootblock\\$(OBJCOPY)\\$(OBJCOPY)elfBIOS0bootblockelf\\$(OBJCOPY)\n\nbootblock\n\n### kernel.ld\n\nkernel.ld\n\n```link\nOUTPUT_FORMAT(\"elf32-i386\", \"elf32-i386\", \"elf32-i386\")\nOUTPUT_ARCH(i386)\nENTRY(_start)\n\nSECTIONS\n{\n\t/* Link the kernel at this address: \".\" means the current address */\n        /* Must be equal to KERNLINK */\n\t. = 0x80100000; // \n\n\t.text : AT(0x100000) {  // \n\t\t*(.text .stub .text.* .gnu.linkonce.t.*)\n\t}\n\n  /*\n    ...\n  */\n}\n```\n\nkernelkernel0x8010 0000x100000AT  /  \n\n## \n\nxv6bootasm.Sxv6AT&T\n\n```arm\n#include \"asm.h\"\n#include \"memlayout.h\"\n#include \"mmu.h\"\n\n# Start the first CPU: switch to 32-bit protected mode, jump into C.\n# The BIOS loads this code from the first sector of the hard disk into\n# memory at physical address 0x7c00 and starts executing in real mode\n# with %cs=0 %ip=7c00.\n\n.code16                       # Assemble for 16-bit mode\n.globl start\nstart:\n  cli                         # BIOS enabled interrupts; disable\n\n  # Zero data segment registers DS, ES, and SS.\n  xorw    %ax,%ax             # Set %ax to zero\n  movw    %ax,%ds             # -> Data Segment\n  movw    %ax,%es             # -> Extra Segment\n  movw    %ax,%ss             # -> Stack Segment\n\n  # OS\n  # Physical address line A20 is tied to zero so that the first PCs \n  # with 2 MB would run software that assumed 1 MB.  Undo that.\nseta20.1:\n  inb     $0x64,%al               # Wait for not busy\n  testb   $0x2,%al\n  jnz     seta20.1\n\n  movb    $0xd1,%al               # 0xd1 -> port 0x64\n  outb    %al,$0x64\n\nseta20.2:\n  inb     $0x64,%al               # Wait for not busy\n  testb   $0x2,%al\n  jnz     seta20.2\n\n  movb    $0xdf,%al               # 0xdf -> port 0x60\n  outb    %al,$0x60\n\n  # Switch from real to protected mode.  Use a bootstrap GDT that makes\n  # virtual addresses map directly to physical addresses so that the\n  # effective memory map doesn't change during the transition.\n  lgdt    gdtdesc\n  movl    %cr0, %eax\n  orl     $CR0_PE, %eax\n  movl    %eax, %cr0\n ########################### 32\n//PAGEBREAK!\n  # Complete the transition to 32-bit protected mode by using a long jmp\n  # to reload %cs and %eip.  The segment descriptors are set up with no\n  # translation, so that the mapping is still the identity mapping.\n  ljmp    $(SEG_KCODE<<3), $start32\n\n.code32  # Tell assembler to generate 32-bit code now.\nstart32:\n  # Set up the protected-mode data segment registers\n  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector\n  movw    %ax, %ds                # -> DS: Data Segment\n  movw    %ax, %es                # -> ES: Extra Segment\n  movw    %ax, %ss                # -> SS: Stack Segment\n  movw    $0, %ax                 # Zero segments not ready for use\n  movw    %ax, %fs                # -> FS\n  movw    %ax, %gs                # -> GS\n\n  # Set up the stack pointer and call into C.\n  movl    $start, %esp            # espstartbootasm\n  call    bootmain\n\n  # If bootmain returns (it shouldn't), trigger a Bochs\n  # breakpoint if running under Bochs, then loop.\n  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00\n  movw    %ax, %dx\n  outw    %ax, %dx\n  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00\n  outw    %ax, %dx\nspin:\n  jmp     spin\n\n# Bootstrap GDT\n.p2align 2                                # force 4 byte alignment\ngdt:\n  SEG_NULLASM                             # null seg\n  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg\n  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg\n\ngdtdesc:\n  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1\n  .long   gdt                             # address gdt\n\n```\n\n\n\n- PC1616 + 1620\n\n- CPU163264 + 324G+\n\nbootasm.SBIOS1M**boot0x7C00 < 1M 1M**cpu4G\n\n -> xv6bootasm\n\n0. CPUBSPbootstrap processorBSPAPBSP\n\n1. dsesss\n\n2. A20.\n\n3. lgdtGDTRgdt\n\n4. CR001PE\n\n5. ljmpstart32\n\n    ```\n    # xv6ljmp\n    # Complete the transition to 32-bit protected mode by using a long jmp\n    # to reload %cs and %eip. \n    ```\n\n6. esp0x7C00bootmainXV6 OS\n\n\n\nDescriptor4K/\n\n![](./Boot/photo/start/SegmentDescriptor.png)\n\n8\n\n![](./Boot/photo/start/GDT.png)\n\n********\n\n![](./Boot/photo/start/GDTR.png)\n\n820~1\n\n![](./Boot/photo/start/SegmentSelector.png)\n\n  cpucputss\n\nGDT\n\n[](https://blog.csdn.net/abc123lzf/article/details/109289567)\n\n[](https://blog.csdn.net/me1171115772/article/details/51750442)\n\n## XV6\n\nelfelfELF headerProgram header table\n\n[https://zhuanlan.zhihu.com/p/165336511](https://zhuanlan.zhihu.com/p/165336511)\n\n```cpp\n#define ELF_MAGIC 0x464C457FU  // \"\\x7FELF\" in little endian\n\n// ELF \nstruct elfhdr {\n  uint magic;       // 4  0x464C457FU 0x7felf\n                      //  ELF \n\n  uchar elf[12];    // 12 \n                    //     0 : 1 = 32 2 = 64 \n                    //     1 : 0 = 1 = 2 = \n                    //     2 :  0x1\n                    //     3 : \n                    //     4 : \n                    //     5 ~ 11 :  0\n\n  ushort type;      // 2 \n                    //     0x0 : \n                    //     0x1 : \n                    //     0x2 : \n                    //     0x3 : \n                    //     0x4 : \n                    //     0xff00 : \n                    //     0xffff : \n\n  ushort machine;   // 2 \n                    //  0x0 0x3  x86 \n\n  uint version;     // 4 \n\n  uint entry;       // 4  0\n\n  uint phoff;       // 4 \n\n  uint shoff;       // 4 \n\n  uint flags;       // 4 \n\n  ushort ehsize;    // 2 ELF\n\n  ushort phentsize; // 2 \n\n  ushort phnum;     // 2 \n                    // phnum * phentsize = \n\n  ushort shentsize; // 2 \n\n  ushort shnum;     // 2 \n                    // shnum * shentsize = \n\n  ushort shstrndx;  // 2 \n};\n\n// \nstruct proghdr {\n  uint type;        // 4  \n                    //         1 PT_LOAD : \n                    //         2 PT_DYNAMIC : \n                    //         3 PT_INTERP : \n                    //         4 PT_NOTE : \n                    //         5 PT_SHLIB : \n                    //         6 PT_PHDR : \n                    //         7 PT_TLS : \n  uint off;         // 4  \n  uint vaddr;       // 4  \n  uint paddr;       // 4  ()\n  uint filesz;      // 4  \n  uint memsz;       // 4  \n  uint flags;       // 4  \n                    //         1 : \n                    //         2 : \n                    //         4 : \n  uint align;       // 4  \n};\n```\n\n[ELF](https://blog.csdn.net/pingxiaozhao/article/details/109239221)elfELF headerProgram header tableXV6\n\nkernel elf\n\n```cpp\nvoid\nbootmain(void)\n{\n  struct elfhdr *elf;\n  struct proghdr *ph, *eph;\n  void (*entry)(void);\n  uchar* pa;\n  // \n  // 46K\n  elf = (struct elfhdr*)0x10000;  // scratch space\n\n  // 04096elf\n  // Read 1st page off disk\n  readseg((uchar*)elf, 4096, 0);\n\n  // elf\n  // Is this an ELF executable?\n  if(elf->magic != ELF_MAGIC)\n    return;  // let bootasm.S handle error\n\n  // Program header table\n  // Load each program segment (ignores ph flags).\n  ph = (struct proghdr*)((uchar*)elf + elf->phoff);\n  // \n  eph = ph + elf->phnum;\n\n  // \n  for(; ph < eph; ph++){  // struct proghdr\n    // xv60x100000\n    pa = (uchar*)ph->paddr;\n    // pa\n    readseg(pa, ph->filesz, ph->off);\n    if(ph->memsz > ph->filesz)\n      // memfile\n      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);\n  }\n\n  // Call the entry point from the ELF header.\n  // Does not return!\n  entry = (void(*)(void))(elf->entry);  // xv6kernel.ld_start\n  entry();\n}\n```\n\nkernelelfelfentry_startkernel.ld_startcpu &  & ****kernelelf0x8010 0000entry.S_startXV6_startxv6\n\n**bootasmespesp1Mbootasmesp0x7c00**\n\nbootmain\n\n![](./Boot/photo/start/boot.drawio.png)\n\n\n\n```cpp\nvoid\nwaitdisk(void)\n{\n  // Wait for disk ready.\n  while((inb(0x1F7) & 0xC0) != 0x40)\n    ;\n}\n\n// readsecthttps://zhuanlan.zhihu.com/p/165336511\n// Read a single sector at offset into dst.\nvoid\nreadsect(void *dst, uint offset)\n{\n  // Issue command.\n  waitdisk();\n  outb(0x1F2, 1);   // count = 1          //  count = 1\n  outb(0x1F3, offset);                    //  LBA  0-7 \n  outb(0x1F4, offset >> 8);               //  LBA  8-15 \n  outb(0x1F5, offset >> 16);              //  LBA  16-23 \n  outb(0x1F6, (offset >> 24) | 0xE0);     // offset | 11100000  1\n                                          //         7     1\n                                          //         6     LBA1LBA\n                                          //         5     1\n                                          //         4     01\n                                          //         3~0    LBA  24-27 \n  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors  // 20h30h\n\n  // Read data.\n  waitdisk();\n  insl(0x1F0, dst, SECTSIZE/4); // 44\n}\n\n// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.\n// Might copy more than asked.\nvoid\nreadseg(uchar* pa, uint count, uint offset)\n{\n  uchar* epa; // end phy addr\n\n  epa = pa + count; // \n\n  // offsetSECTSIZE512Byte\n  // 512offset512\n  // offsetSECTSIZEoffset\n  // offsetofsofsoffset % SECTSIZE\n  // paoffset % SECTSIZEoffset\n  // Round down to sector boundary.\n  pa -= offset % SECTSIZE;    \n\n  // offset\n  // Translate from bytes to sectors; kernel starts at sector 1.\n  offset = (offset / SECTSIZE) + 1; \n\n  // \n  for(; pa < epa; pa += SECTSIZE, offset++)\n    readsect(pa, offset);\n}\n```\n\nreadsegpaxv6\n\n## _start\n\nentry.S\n\n```arm\n#include \"asm.h\"\n#include \"memlayout.h\"\n#include \"mmu.h\"\n#include \"param.h\"\n\n# Multiboot header.  Data to direct multiboot loader.\n.p2align 2\n.text\n.globl multiboot_header\nmultiboot_header:\n  #define magic 0x1badb002\n  #define flags 0\n  .long magic\n  .long flags\n  .long (-magic-flags)\n  \n# elf\n# entry\n# V2P_WOentrybootmainentry.\n# V2P_WO 0x8000 0000 \n.globl _start\n_start = V2P_WO(entry)\n\n# Entering xv6 on boot processor, with paging off.\n.globl entry\nentry:\n  # 4M big page\n  # Turn on page size extension for 4Mbyte pages\n  movl    %cr4, %eax\n  orl     $(CR4_PSE), %eax\n  movl    %eax, %cr4\n\n  # entrypgdir\n  # entrypgdirentrypgdir\n  # \n  # Set page directory\n  movl    $(V2P_WO(entrypgdir)), %eax\n  movl    %eax, %cr3\n\n  # \n  # Turn on paging.\n  movl    %cr0, %eax\n  orl     $(CR0_PG|CR0_WP), %eax\n  movl    %eax, %cr0\n\n  ########################### \n  # espesp\n  # Set up the stack pointer.\n  movl $(stack + KSTACKSIZE), %esp\n\n  # main\n  mov $main, %eax\n  jmp *%eax\n\n.comm stack, KSTACKSIZE\n```\n\nmain\n\n1. 4M big pagecpu4Mentrypgdir4Mentrypgdirmainkpgdir4Kxv6\n\n2. entrypgdirBSPbooststrap processor\n\n3. \n\n4. esp4K\n\n5. main\n\nentry.Scpu\n\n![](./Boot/photo/start/entry.drawio.png)\n\ncpuunix\n\n---\n\n****\n\n","slug":"xv6/Boot","published":1,"updated":"2025-09-28T09:40:45.876Z","comments":1,"layout":"post","photos":[],"_id":"cmg3w8w9v0017q8wseafudr8p","content":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>OnixXV6OSOnix</p>\n<p>XV6OnixOnixXV6XV6</p>\n<p>OnixbootloaderOSOnixOnixbootloaderXV6CXV6XV6</p>\n<p>Onix</p>\n<ul>\n<li><p><a href=\"https://github.com/StevenBaby/onix\">github</a></p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/BV1qM4y127om/\">B</a></p>\n</li>\n</ul>\n<p>XV6-x86github</p>\n<ul>\n<li><a href=\"https://github.com/mit-pdos/xv6-public\"></a></li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"Makefile-kernel-ld\"><a href=\"#Makefile-kernel-ld\" class=\"headerlink\" title=\"Makefile &amp; kernel.ld\"></a>Makefile &amp; kernel.ld</h2><p>  </p>\n<p><strong> BIOS  512  GRUB</strong></p>\n<p>BISO</p>\n<ol>\n<li>0x7c00</li>\n<li>512</li>\n<li>0x55aa</li>\n</ol>\n<p>osMakefilebootmainososelfoslinkos</p>\n<h3 id=\"Makefile\"><a href=\"#Makefile\" class=\"headerlink\" title=\"Makefile\"></a>Makefile</h3><p>makefile</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ddOSbootblockkernel</span></span><br><span class=\"line\"><span class=\"comment\"># 10000</span></span><br><span class=\"line\"><span class=\"comment\"># bootblock0</span></span><br><span class=\"line\"><span class=\"comment\"># 1OS</span></span><br><span class=\"line\"><span class=\"section\">xv6.img: bootblock kernel</span></span><br><span class=\"line\">\tdd if=/dev/zero of=xv6.img count=10000</span><br><span class=\"line\">\tdd if=bootblock of=xv6.img conv=notrunc</span><br><span class=\"line\">\tdd if=kernel of=xv6.img seek=1 conv=notrunc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># osbootloader$(OBJCOPY)</span></span><br><span class=\"line\"><span class=\"comment\"># elf$(LD)</span></span><br><span class=\"line\"><span class=\"comment\"># start0x7C00bootblock</span></span><br><span class=\"line\"><span class=\"comment\"># pl5120x55aa</span></span><br><span class=\"line\"><span class=\"section\">bootblock: bootasm.S bootmain.c</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -fno-pic -O -nostdinc -I. -c bootmain.c</span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -fno-pic -nostdinc -I. -c bootasm.S</span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S bootblock.o &gt; bootblock.asm</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJCOPY)</span> -S -O binary -j .text bootblock.o bootblock</span><br><span class=\"line\">\t./sign.pl bootblock</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># AP cpuboot</span></span><br><span class=\"line\"><span class=\"comment\"># 0x7000</span></span><br><span class=\"line\"><span class=\"comment\"># bootblockelf</span></span><br><span class=\"line\"><span class=\"comment\"># entryotherkernel</span></span><br><span class=\"line\"><span class=\"section\">entryother: entryother.S</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -fno-pic -nostdinc -I. -c entryother.S</span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJCOPY)</span> -S -O binary -j .text bootblockother.o entryother</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S bootblockother.o &gt; entryother.asm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># initboot</span></span><br><span class=\"line\"><span class=\"comment\"># $(OBJCOPY)elfinitcode</span></span><br><span class=\"line\"><span class=\"comment\"># 0</span></span><br><span class=\"line\"><span class=\"section\">initcode: initcode.S</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -nostdinc -I. -c initcode.S</span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -N -e start -Ttext 0 -o initcode.out initcode.o</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJCOPY)</span> -S -O binary initcode.out initcode</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S initcode.o &gt; initcode.asm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># elf</span></span><br><span class=\"line\"><span class=\"section\">kernel: <span class=\"variable\">$(OBJS)</span> entry.o entryother initcode kernel.ld</span></span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -T kernel.ld -o kernel entry.o <span class=\"variable\">$(OBJS)</span> -b binary initcode entryother</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S kernel &gt; kernel.asm</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -t kernel | sed &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; kernel.sym</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p>ddxv6.imgbootblock0kernel1bootblockcpukernel0x7C00bootblock$(LD)bootblock0x7C00<strong>BIOS05125120x7C00BIOSeip0x7C00bootasm.S</strong></p>\n<p>$(LD)bootblock.obootasm.obootmain.obootasm.oeip0x7C00start</p>\n<p>bootblock$(OBJCOPY)$(OBJCOPY)elfBIOS0bootblockelf$(OBJCOPY)</p>\n<p>bootblock</p>\n<h3 id=\"kernel-ld\"><a href=\"#kernel-ld\" class=\"headerlink\" title=\"kernel.ld\"></a>kernel.ld</h3><p>kernel.ld</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OUTPUT_FORMAT(&quot;elf32-i386&quot;, &quot;elf32-i386&quot;, &quot;elf32-i386&quot;)</span><br><span class=\"line\">OUTPUT_ARCH(i386)</span><br><span class=\"line\">ENTRY(_start)</span><br><span class=\"line\"></span><br><span class=\"line\">SECTIONS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t/* Link the kernel at this address: &quot;.&quot; means the current address */</span><br><span class=\"line\">        /* Must be equal to KERNLINK */</span><br><span class=\"line\">\t. = 0x80100000; // </span><br><span class=\"line\"></span><br><span class=\"line\">\t.text : AT(0x100000) &#123;  // </span><br><span class=\"line\">\t\t*(.text .stub .text.* .gnu.linkonce.t.*)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>kernelkernel0x8010 0000x100000AT  &#x2F;  </p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>xv6bootasm.Sxv6AT&amp;T</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &quot;asm.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;memlayout.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;mmu.h&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Start the first CPU: switch to 32-bit protected mode, jump into C.</span></span><br><span class=\"line\"><span class=\"comment\"># The BIOS loads this code from the first sector of the hard disk into</span></span><br><span class=\"line\"><span class=\"comment\"># memory at physical address 0x7c00 and starts executing in real mode</span></span><br><span class=\"line\"><span class=\"comment\"># with %cs=0 %ip=7c00.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.code16</span>                       # Assemble for <span class=\"number\">16</span>-bit mode</span><br><span class=\"line\"><span class=\"symbol\">.globl</span> start</span><br><span class=\"line\"><span class=\"symbol\">start:</span></span><br><span class=\"line\">  cli                         # BIOS enabled interrupts<span class=\"comment\">; disable</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Zero data segment registers DS, ES, and SS.</span></span><br><span class=\"line\">  xorw    %ax,%ax             # Set %ax to zero</span><br><span class=\"line\">  movw    %ax,%ds             # -&gt; <span class=\"meta\">Data</span> Segment</span><br><span class=\"line\">  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class=\"line\">  movw    %ax,%ss             # -&gt; Stack Segment</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># OS</span></span><br><span class=\"line\">  <span class=\"comment\"># Physical address line A20 is tied to zero so that the first PCs </span></span><br><span class=\"line\">  <span class=\"comment\"># with 2 MB would run software that assumed 1 MB.  Undo that.</span></span><br><span class=\"line\"><span class=\"symbol\">seta20.1:</span></span><br><span class=\"line\">  inb     <span class=\"number\">$0x64</span>,%al               # Wait for not busy</span><br><span class=\"line\">  testb   <span class=\"number\">$0x2</span>,%al</span><br><span class=\"line\">  jnz     seta20.<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  movb    <span class=\"number\">$0xd1</span>,%al               # <span class=\"number\">0xd1</span> -&gt; port <span class=\"number\">0x64</span></span><br><span class=\"line\">  outb    %al,<span class=\"number\">$0x64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">seta20.2:</span></span><br><span class=\"line\">  inb     <span class=\"number\">$0x64</span>,%al               # Wait for not busy</span><br><span class=\"line\">  testb   <span class=\"number\">$0x2</span>,%al</span><br><span class=\"line\">  jnz     seta20.<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">  movb    <span class=\"number\">$0xdf</span>,%al               # <span class=\"number\">0xdf</span> -&gt; port <span class=\"number\">0x60</span></span><br><span class=\"line\">  outb    %al,<span class=\"number\">$0x60</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Switch from real to protected mode.  Use a bootstrap GDT that makes</span></span><br><span class=\"line\">  <span class=\"comment\"># virtual addresses map directly to physical addresses so that the</span></span><br><span class=\"line\">  <span class=\"comment\"># effective memory map doesn&#x27;t change during the transition.</span></span><br><span class=\"line\">  lgdt    gdtdesc</span><br><span class=\"line\">  movl    %cr0, %eax</span><br><span class=\"line\">  orl     $CR0_PE, %eax</span><br><span class=\"line\">  movl    %eax, %cr0</span><br><span class=\"line\"> <span class=\"comment\">########################### 32</span></span><br><span class=\"line\"><span class=\"comment\">//PAGEBREAK!</span></span><br><span class=\"line\">  <span class=\"comment\"># Complete the transition to 32-bit protected mode by using a long jmp</span></span><br><span class=\"line\">  <span class=\"comment\"># to reload %cs and %eip.  The segment descriptors are set up with no</span></span><br><span class=\"line\">  <span class=\"comment\"># translation, so that the mapping is still the identity mapping.</span></span><br><span class=\"line\">  ljmp    $(SEG_KCODE&lt;&lt;<span class=\"number\">3</span>), $start32</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.code32</span>  # Tell assembler to generate <span class=\"number\">32</span>-bit <span class=\"meta\">code</span> now.</span><br><span class=\"line\"><span class=\"symbol\">start32:</span></span><br><span class=\"line\">  <span class=\"comment\"># Set up the protected-mode data segment registers</span></span><br><span class=\"line\">  movw    $(SEG_KDATA&lt;&lt;<span class=\"number\">3</span>), %ax    # Our <span class=\"meta\">data</span> segment selector</span><br><span class=\"line\">  movw    %ax, %ds                # -&gt; DS: <span class=\"meta\">Data</span> Segment</span><br><span class=\"line\">  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class=\"line\">  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br><span class=\"line\">  movw    <span class=\"number\">$0</span>, %ax                 # Zero segments not ready for use</span><br><span class=\"line\">  movw    %ax, %fs                # -&gt; FS</span><br><span class=\"line\">  movw    %ax, %gs                # -&gt; GS</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Set up the stack pointer and call into C.</span></span><br><span class=\"line\">  movl    $start, %esp            # espstartbootasm</span><br><span class=\"line\">  call    bootmain</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># If bootmain returns (it shouldn&#x27;t), trigger a Bochs</span></span><br><span class=\"line\">  <span class=\"comment\"># breakpoint if running under Bochs, then loop.</span></span><br><span class=\"line\">  movw    <span class=\"number\">$0x8a00</span>, %ax            # <span class=\"number\">0x8a00</span> -&gt; port <span class=\"number\">0x8a00</span></span><br><span class=\"line\">  movw    %ax, %dx</span><br><span class=\"line\">  outw    %ax, %dx</span><br><span class=\"line\">  movw    <span class=\"number\">$0x8ae0</span>, %ax            # <span class=\"number\">0x8ae0</span> -&gt; port <span class=\"number\">0x8a00</span></span><br><span class=\"line\">  outw    %ax, %dx</span><br><span class=\"line\"><span class=\"symbol\">spin:</span></span><br><span class=\"line\">  jmp     spin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Bootstrap GDT</span></span><br><span class=\"line\"><span class=\"symbol\">.p2align</span> <span class=\"number\">2</span>                                # force <span class=\"number\">4</span> byte alignment</span><br><span class=\"line\"><span class=\"symbol\">gdt:</span></span><br><span class=\"line\">  SEG_NULLASM                             # null seg</span><br><span class=\"line\">  SEG_ASM(STA_X<span class=\"title\">|STA_R, 0x0, 0xffffffff)   # code seg</span></span><br><span class=\"line\"><span class=\"title\">  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">gdtdesc:</span></span><br><span class=\"line\"><span class=\"title\">  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1</span></span><br><span class=\"line\"><span class=\"title\">  .long   gdt                             # address gdt</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br></pre></td></tr></table></figure>\n\n<p></p>\n<ul>\n<li><p>PC1616 + 1620</p>\n</li>\n<li><p>CPU163264 + 324G+</p>\n</li>\n</ul>\n<p>bootasm.SBIOS1M<strong>boot0x7C00 &lt; 1M 1M</strong>cpu4G</p>\n<p> -&gt; xv6bootasm</p>\n<ol start=\"0\">\n<li><p>CPUBSPbootstrap processorBSPAPBSP</p>\n</li>\n<li><p>dsesss</p>\n</li>\n<li><p>A20.</p>\n</li>\n<li><p>lgdtGDTRgdt</p>\n</li>\n<li><p>CR001PE</p>\n</li>\n<li><p>ljmpstart32</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># xv6ljmp</span><br><span class=\"line\"># Complete the transition to 32-bit protected mode by using a long jmp</span><br><span class=\"line\"># to reload %cs and %eip. </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>esp0x7C00bootmainXV6 OS</p>\n</li>\n</ol>\n<p></p>\n<p>Descriptor4K&#x2F;</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/SegmentDescriptor.png\"></p>\n<p>8</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/GDT.png\"></p>\n<p><strong></strong><strong></strong></p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/GDTR.png\"></p>\n<p>820~1</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/SegmentSelector.png\"></p>\n<p>  cpucputss</p>\n<p>GDT</p>\n<p><a href=\"https://blog.csdn.net/abc123lzf/article/details/109289567\"></a></p>\n<p><a href=\"https://blog.csdn.net/me1171115772/article/details/51750442\"></a></p>\n<h2 id=\"XV6\"><a href=\"#XV6\" class=\"headerlink\" title=\"XV6\"></a>XV6</h2><p>elfelfELF headerProgram header table</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/165336511\">https://zhuanlan.zhihu.com/p/165336511</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ELF_MAGIC 0x464C457FU  <span class=\"comment\">// &quot;\\x7FELF&quot; in little endian</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ELF </span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">elfhdr</span> &#123;</span><br><span class=\"line\">  uint magic;       <span class=\"comment\">// 4  0x464C457FU 0x7felf</span></span><br><span class=\"line\">                      <span class=\"comment\">//  ELF </span></span><br><span class=\"line\"></span><br><span class=\"line\">  uchar elf[<span class=\"number\">12</span>];    <span class=\"comment\">// 12 </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0 : 1 = 32 2 = 64 </span></span><br><span class=\"line\">                    <span class=\"comment\">//     1 : 0 = 1 = 2 = </span></span><br><span class=\"line\">                    <span class=\"comment\">//     2 :  0x1</span></span><br><span class=\"line\">                    <span class=\"comment\">//     3 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     4 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     5 ~ 11 :  0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort type;      <span class=\"comment\">// 2 </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x0 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x1 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x2 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x3 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x4 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0xff00 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0xffff : </span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort machine;   <span class=\"comment\">// 2 </span></span><br><span class=\"line\">                    <span class=\"comment\">//  0x0 0x3  x86 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint version;     <span class=\"comment\">// 4 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint entry;       <span class=\"comment\">// 4  0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint phoff;       <span class=\"comment\">// 4 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint shoff;       <span class=\"comment\">// 4 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint flags;       <span class=\"comment\">// 4 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort ehsize;    <span class=\"comment\">// 2 ELF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort phentsize; <span class=\"comment\">// 2 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort phnum;     <span class=\"comment\">// 2 </span></span><br><span class=\"line\">                    <span class=\"comment\">// phnum * phentsize = </span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort shentsize; <span class=\"comment\">// 2 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort shnum;     <span class=\"comment\">// 2 </span></span><br><span class=\"line\">                    <span class=\"comment\">// shnum * shentsize = </span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort shstrndx;  <span class=\"comment\">// 2 </span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">proghdr</span> &#123;</span><br><span class=\"line\">  uint type;        <span class=\"comment\">// 4  </span></span><br><span class=\"line\">                    <span class=\"comment\">//         1 PT_LOAD : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         2 PT_DYNAMIC : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         3 PT_INTERP : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         4 PT_NOTE : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         5 PT_SHLIB : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         6 PT_PHDR : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         7 PT_TLS : </span></span><br><span class=\"line\">  uint off;         <span class=\"comment\">// 4  </span></span><br><span class=\"line\">  uint vaddr;       <span class=\"comment\">// 4  </span></span><br><span class=\"line\">  uint paddr;       <span class=\"comment\">// 4  ()</span></span><br><span class=\"line\">  uint filesz;      <span class=\"comment\">// 4  </span></span><br><span class=\"line\">  uint memsz;       <span class=\"comment\">// 4  </span></span><br><span class=\"line\">  uint flags;       <span class=\"comment\">// 4  </span></span><br><span class=\"line\">                    <span class=\"comment\">//         1 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         2 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         4 : </span></span><br><span class=\"line\">  uint align;       <span class=\"comment\">// 4  </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://blog.csdn.net/pingxiaozhao/article/details/109239221\">ELF</a>elfELF headerProgram header tableXV6</p>\n<p>kernel elf</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">bootmain</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">elfhdr</span> *elf;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proghdr</span> *ph, *eph;</span><br><span class=\"line\">  <span class=\"built_in\">void</span> (*entry)(<span class=\"type\">void</span>);</span><br><span class=\"line\">  uchar* pa;</span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"comment\">// 46K</span></span><br><span class=\"line\">  elf = (<span class=\"keyword\">struct</span> elfhdr*)<span class=\"number\">0x10000</span>;  <span class=\"comment\">// scratch space</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 04096elf</span></span><br><span class=\"line\">  <span class=\"comment\">// Read 1st page off disk</span></span><br><span class=\"line\">  <span class=\"built_in\">readseg</span>((uchar*)elf, <span class=\"number\">4096</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// elf</span></span><br><span class=\"line\">  <span class=\"comment\">// Is this an ELF executable?</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(elf-&gt;magic != ELF_MAGIC)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;  <span class=\"comment\">// let bootasm.S handle error</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Program header table</span></span><br><span class=\"line\">  <span class=\"comment\">// Load each program segment (ignores ph flags).</span></span><br><span class=\"line\">  ph = (<span class=\"keyword\">struct</span> proghdr*)((uchar*)elf + elf-&gt;phoff);</span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  eph = ph + elf-&gt;phnum;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; ph &lt; eph; ph++)&#123;  <span class=\"comment\">// struct proghdr</span></span><br><span class=\"line\">    <span class=\"comment\">// xv60x100000</span></span><br><span class=\"line\">    pa = (uchar*)ph-&gt;paddr;</span><br><span class=\"line\">    <span class=\"comment\">// pa</span></span><br><span class=\"line\">    <span class=\"built_in\">readseg</span>(pa, ph-&gt;filesz, ph-&gt;off);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ph-&gt;memsz &gt; ph-&gt;filesz)</span><br><span class=\"line\">      <span class=\"comment\">// memfile</span></span><br><span class=\"line\">      <span class=\"built_in\">stosb</span>(pa + ph-&gt;filesz, <span class=\"number\">0</span>, ph-&gt;memsz - ph-&gt;filesz);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Call the entry point from the ELF header.</span></span><br><span class=\"line\">  <span class=\"comment\">// Does not return!</span></span><br><span class=\"line\">  entry = (<span class=\"built_in\">void</span>(*)(<span class=\"type\">void</span>))(elf-&gt;entry);  <span class=\"comment\">// xv6kernel.ld_start</span></span><br><span class=\"line\">  <span class=\"built_in\">entry</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>kernelelfelfentry_startkernel.ld_startcpu &amp;  &amp; <strong></strong>kernelelf0x8010 0000entry.S_startXV6_startxv6</p>\n<p><strong>bootasmespesp1Mbootasmesp0x7c00</strong></p>\n<p>bootmain</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/boot.drawio.png\"></p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">waitdisk</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Wait for disk ready.</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>((<span class=\"built_in\">inb</span>(<span class=\"number\">0x1F7</span>) &amp; <span class=\"number\">0xC0</span>) != <span class=\"number\">0x40</span>)</span><br><span class=\"line\">    ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// readsecthttps://zhuanlan.zhihu.com/p/165336511</span></span><br><span class=\"line\"><span class=\"comment\">// Read a single sector at offset into dst.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">readsect</span><span class=\"params\">(<span class=\"type\">void</span> *dst, uint offset)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Issue command.</span></span><br><span class=\"line\">  <span class=\"built_in\">waitdisk</span>();</span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F2</span>, <span class=\"number\">1</span>);   <span class=\"comment\">// count = 1          //  count = 1</span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F3</span>, offset);                    <span class=\"comment\">//  LBA  0-7 </span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F4</span>, offset &gt;&gt; <span class=\"number\">8</span>);               <span class=\"comment\">//  LBA  8-15 </span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F5</span>, offset &gt;&gt; <span class=\"number\">16</span>);              <span class=\"comment\">//  LBA  16-23 </span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F6</span>, (offset &gt;&gt; <span class=\"number\">24</span>) | <span class=\"number\">0xE0</span>);     <span class=\"comment\">// offset | 11100000  1</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         7     1</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         6     LBA1LBA</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         5     1</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         4     01</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         3~0    LBA  24-27 </span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F7</span>, <span class=\"number\">0x20</span>);  <span class=\"comment\">// cmd 0x20 - read sectors  // 20h30h</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Read data.</span></span><br><span class=\"line\">  <span class=\"built_in\">waitdisk</span>();</span><br><span class=\"line\">  <span class=\"built_in\">insl</span>(<span class=\"number\">0x1F0</span>, dst, SECTSIZE/<span class=\"number\">4</span>); <span class=\"comment\">// 44</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Read &#x27;count&#x27; bytes at &#x27;offset&#x27; from kernel into physical address &#x27;pa&#x27;.</span></span><br><span class=\"line\"><span class=\"comment\">// Might copy more than asked.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">readseg</span><span class=\"params\">(uchar* pa, uint count, uint offset)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  uchar* epa; <span class=\"comment\">// end phy addr</span></span><br><span class=\"line\"></span><br><span class=\"line\">  epa = pa + count; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// offsetSECTSIZE512Byte</span></span><br><span class=\"line\">  <span class=\"comment\">// 512offset512</span></span><br><span class=\"line\">  <span class=\"comment\">// offsetSECTSIZEoffset</span></span><br><span class=\"line\">  <span class=\"comment\">// offsetofsofsoffset % SECTSIZE</span></span><br><span class=\"line\">  <span class=\"comment\">// paoffset % SECTSIZEoffset</span></span><br><span class=\"line\">  <span class=\"comment\">// Round down to sector boundary.</span></span><br><span class=\"line\">  pa -= offset % SECTSIZE;    </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// offset</span></span><br><span class=\"line\">  <span class=\"comment\">// Translate from bytes to sectors; kernel starts at sector 1.</span></span><br><span class=\"line\">  offset = (offset / SECTSIZE) + <span class=\"number\">1</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; pa &lt; epa; pa += SECTSIZE, offset++)</span><br><span class=\"line\">    <span class=\"built_in\">readsect</span>(pa, offset);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>readsegpaxv6</p>\n<h2 id=\"-start\"><a href=\"#-start\" class=\"headerlink\" title=\"_start\"></a>_start</h2><p>entry.S</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &quot;asm.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;memlayout.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;mmu.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;param.h&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Multiboot header.  Data to direct multiboot loader.</span></span><br><span class=\"line\"><span class=\"symbol\">.p2align</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"symbol\">.text</span></span><br><span class=\"line\"><span class=\"symbol\">.globl</span> multiboot_header</span><br><span class=\"line\"><span class=\"symbol\">multiboot_header:</span></span><br><span class=\"line\">  <span class=\"comment\">#define magic 0x1badb002</span></span><br><span class=\"line\">  <span class=\"comment\">#define flags 0</span></span><br><span class=\"line\">  <span class=\"meta\">.long</span> magic</span><br><span class=\"line\">  <span class=\"meta\">.long</span> flags</span><br><span class=\"line\">  <span class=\"meta\">.long</span> (-magic-flags)</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># elf</span></span><br><span class=\"line\"><span class=\"comment\"># entry</span></span><br><span class=\"line\"><span class=\"comment\"># V2P_WOentrybootmainentry.</span></span><br><span class=\"line\"><span class=\"comment\"># V2P_WO 0x8000 0000 </span></span><br><span class=\"line\"><span class=\"symbol\">.globl</span> _start</span><br><span class=\"line\"><span class=\"symbol\">_start</span> = V2P_WO(<span class=\"meta\">entry</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Entering xv6 on boot processor, with paging off.</span></span><br><span class=\"line\"><span class=\"symbol\">.globl</span> <span class=\"meta\">entry</span></span><br><span class=\"line\"><span class=\"symbol\">entry:</span></span><br><span class=\"line\">  <span class=\"comment\"># 4M big page</span></span><br><span class=\"line\">  <span class=\"comment\"># Turn on page size extension for 4Mbyte pages</span></span><br><span class=\"line\">  movl    %cr4, %eax</span><br><span class=\"line\">  orl     $(CR4_PSE), %eax</span><br><span class=\"line\">  movl    %eax, %cr4</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># entrypgdir</span></span><br><span class=\"line\">  <span class=\"comment\"># entrypgdirentrypgdir</span></span><br><span class=\"line\">  <span class=\"comment\"># </span></span><br><span class=\"line\">  <span class=\"comment\"># Set page directory</span></span><br><span class=\"line\">  movl    $(V2P_WO(entrypgdir)), %eax</span><br><span class=\"line\">  movl    %eax, %cr3</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># </span></span><br><span class=\"line\">  <span class=\"comment\"># Turn on paging.</span></span><br><span class=\"line\">  movl    %cr0, %eax</span><br><span class=\"line\">  orl     $(CR0_PG<span class=\"title\">|CR0_WP), %eax</span></span><br><span class=\"line\"><span class=\"title\">  movl    %eax, %cr0</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">  ########################### </span></span><br><span class=\"line\"><span class=\"title\">  # espesp</span></span><br><span class=\"line\"><span class=\"title\">  # Set up the stack pointer.</span></span><br><span class=\"line\"><span class=\"title\">  movl $(stack + KSTACKSIZE), %esp</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">  # main</span></span><br><span class=\"line\"><span class=\"title\">  mov $main, %eax</span></span><br><span class=\"line\"><span class=\"title\">  jmp *%eax</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">.comm stack, KSTACKSIZE</span></span><br></pre></td></tr></table></figure>\n\n<p>main</p>\n<ol>\n<li><p>4M big pagecpu4Mentrypgdir4Mentrypgdirmainkpgdir4Kxv6</p>\n</li>\n<li><p>entrypgdirBSPbooststrap processor</p>\n</li>\n<li><p></p>\n</li>\n<li><p>esp4K</p>\n</li>\n<li><p>main</p>\n</li>\n</ol>\n<p>entry.Scpu</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/entry.drawio.png\"></p>\n<p>cpuunix</p>\n<hr>\n<p><strong></strong></p>\n","excerpt":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>OnixXV6OSOnix</p>\n<p>XV6OnixOnixXV6XV6</p>\n<p>OnixbootloaderOSOnixOnixbootloaderXV6CXV6XV6</p>\n<p>Onix</p>\n<ul>\n<li><p><a href=\"https://github.com/StevenBaby/onix\">github</a></p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/BV1qM4y127om/\">B</a></p>\n</li>\n</ul>\n<p>XV6-x86github</p>\n<ul>\n<li><a href=\"https://github.com/mit-pdos/xv6-public\"></a></li>\n</ul>","more":"<h2 id=\"Makefile-kernel-ld\"><a href=\"#Makefile-kernel-ld\" class=\"headerlink\" title=\"Makefile &amp; kernel.ld\"></a>Makefile &amp; kernel.ld</h2><p>  </p>\n<p><strong> BIOS  512  GRUB</strong></p>\n<p>BISO</p>\n<ol>\n<li>0x7c00</li>\n<li>512</li>\n<li>0x55aa</li>\n</ol>\n<p>osMakefilebootmainososelfoslinkos</p>\n<h3 id=\"Makefile\"><a href=\"#Makefile\" class=\"headerlink\" title=\"Makefile\"></a>Makefile</h3><p>makefile</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ddOSbootblockkernel</span></span><br><span class=\"line\"><span class=\"comment\"># 10000</span></span><br><span class=\"line\"><span class=\"comment\"># bootblock0</span></span><br><span class=\"line\"><span class=\"comment\"># 1OS</span></span><br><span class=\"line\"><span class=\"section\">xv6.img: bootblock kernel</span></span><br><span class=\"line\">\tdd if=/dev/zero of=xv6.img count=10000</span><br><span class=\"line\">\tdd if=bootblock of=xv6.img conv=notrunc</span><br><span class=\"line\">\tdd if=kernel of=xv6.img seek=1 conv=notrunc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># osbootloader$(OBJCOPY)</span></span><br><span class=\"line\"><span class=\"comment\"># elf$(LD)</span></span><br><span class=\"line\"><span class=\"comment\"># start0x7C00bootblock</span></span><br><span class=\"line\"><span class=\"comment\"># pl5120x55aa</span></span><br><span class=\"line\"><span class=\"section\">bootblock: bootasm.S bootmain.c</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -fno-pic -O -nostdinc -I. -c bootmain.c</span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -fno-pic -nostdinc -I. -c bootasm.S</span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S bootblock.o &gt; bootblock.asm</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJCOPY)</span> -S -O binary -j .text bootblock.o bootblock</span><br><span class=\"line\">\t./sign.pl bootblock</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># AP cpuboot</span></span><br><span class=\"line\"><span class=\"comment\"># 0x7000</span></span><br><span class=\"line\"><span class=\"comment\"># bootblockelf</span></span><br><span class=\"line\"><span class=\"comment\"># entryotherkernel</span></span><br><span class=\"line\"><span class=\"section\">entryother: entryother.S</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -fno-pic -nostdinc -I. -c entryother.S</span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJCOPY)</span> -S -O binary -j .text bootblockother.o entryother</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S bootblockother.o &gt; entryother.asm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># initboot</span></span><br><span class=\"line\"><span class=\"comment\"># $(OBJCOPY)elfinitcode</span></span><br><span class=\"line\"><span class=\"comment\"># 0</span></span><br><span class=\"line\"><span class=\"section\">initcode: initcode.S</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -nostdinc -I. -c initcode.S</span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -N -e start -Ttext 0 -o initcode.out initcode.o</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJCOPY)</span> -S -O binary initcode.out initcode</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S initcode.o &gt; initcode.asm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># elf</span></span><br><span class=\"line\"><span class=\"section\">kernel: <span class=\"variable\">$(OBJS)</span> entry.o entryother initcode kernel.ld</span></span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -T kernel.ld -o kernel entry.o <span class=\"variable\">$(OBJS)</span> -b binary initcode entryother</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S kernel &gt; kernel.asm</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -t kernel | sed &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; kernel.sym</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p></p>\n<p>ddxv6.imgbootblock0kernel1bootblockcpukernel0x7C00bootblock$(LD)bootblock0x7C00<strong>BIOS05125120x7C00BIOSeip0x7C00bootasm.S</strong></p>\n<p>$(LD)bootblock.obootasm.obootmain.obootasm.oeip0x7C00start</p>\n<p>bootblock$(OBJCOPY)$(OBJCOPY)elfBIOS0bootblockelf$(OBJCOPY)</p>\n<p>bootblock</p>\n<h3 id=\"kernel-ld\"><a href=\"#kernel-ld\" class=\"headerlink\" title=\"kernel.ld\"></a>kernel.ld</h3><p>kernel.ld</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OUTPUT_FORMAT(&quot;elf32-i386&quot;, &quot;elf32-i386&quot;, &quot;elf32-i386&quot;)</span><br><span class=\"line\">OUTPUT_ARCH(i386)</span><br><span class=\"line\">ENTRY(_start)</span><br><span class=\"line\"></span><br><span class=\"line\">SECTIONS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t/* Link the kernel at this address: &quot;.&quot; means the current address */</span><br><span class=\"line\">        /* Must be equal to KERNLINK */</span><br><span class=\"line\">\t. = 0x80100000; // </span><br><span class=\"line\"></span><br><span class=\"line\">\t.text : AT(0x100000) &#123;  // </span><br><span class=\"line\">\t\t*(.text .stub .text.* .gnu.linkonce.t.*)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>kernelkernel0x8010 0000x100000AT  &#x2F;  </p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>xv6bootasm.Sxv6AT&amp;T</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &quot;asm.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;memlayout.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;mmu.h&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Start the first CPU: switch to 32-bit protected mode, jump into C.</span></span><br><span class=\"line\"><span class=\"comment\"># The BIOS loads this code from the first sector of the hard disk into</span></span><br><span class=\"line\"><span class=\"comment\"># memory at physical address 0x7c00 and starts executing in real mode</span></span><br><span class=\"line\"><span class=\"comment\"># with %cs=0 %ip=7c00.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.code16</span>                       # Assemble for <span class=\"number\">16</span>-bit mode</span><br><span class=\"line\"><span class=\"symbol\">.globl</span> start</span><br><span class=\"line\"><span class=\"symbol\">start:</span></span><br><span class=\"line\">  cli                         # BIOS enabled interrupts<span class=\"comment\">; disable</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Zero data segment registers DS, ES, and SS.</span></span><br><span class=\"line\">  xorw    %ax,%ax             # Set %ax to zero</span><br><span class=\"line\">  movw    %ax,%ds             # -&gt; <span class=\"meta\">Data</span> Segment</span><br><span class=\"line\">  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class=\"line\">  movw    %ax,%ss             # -&gt; Stack Segment</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># OS</span></span><br><span class=\"line\">  <span class=\"comment\"># Physical address line A20 is tied to zero so that the first PCs </span></span><br><span class=\"line\">  <span class=\"comment\"># with 2 MB would run software that assumed 1 MB.  Undo that.</span></span><br><span class=\"line\"><span class=\"symbol\">seta20.1:</span></span><br><span class=\"line\">  inb     <span class=\"number\">$0x64</span>,%al               # Wait for not busy</span><br><span class=\"line\">  testb   <span class=\"number\">$0x2</span>,%al</span><br><span class=\"line\">  jnz     seta20.<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  movb    <span class=\"number\">$0xd1</span>,%al               # <span class=\"number\">0xd1</span> -&gt; port <span class=\"number\">0x64</span></span><br><span class=\"line\">  outb    %al,<span class=\"number\">$0x64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">seta20.2:</span></span><br><span class=\"line\">  inb     <span class=\"number\">$0x64</span>,%al               # Wait for not busy</span><br><span class=\"line\">  testb   <span class=\"number\">$0x2</span>,%al</span><br><span class=\"line\">  jnz     seta20.<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">  movb    <span class=\"number\">$0xdf</span>,%al               # <span class=\"number\">0xdf</span> -&gt; port <span class=\"number\">0x60</span></span><br><span class=\"line\">  outb    %al,<span class=\"number\">$0x60</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Switch from real to protected mode.  Use a bootstrap GDT that makes</span></span><br><span class=\"line\">  <span class=\"comment\"># virtual addresses map directly to physical addresses so that the</span></span><br><span class=\"line\">  <span class=\"comment\"># effective memory map doesn&#x27;t change during the transition.</span></span><br><span class=\"line\">  lgdt    gdtdesc</span><br><span class=\"line\">  movl    %cr0, %eax</span><br><span class=\"line\">  orl     $CR0_PE, %eax</span><br><span class=\"line\">  movl    %eax, %cr0</span><br><span class=\"line\"> <span class=\"comment\">########################### 32</span></span><br><span class=\"line\"><span class=\"comment\">//PAGEBREAK!</span></span><br><span class=\"line\">  <span class=\"comment\"># Complete the transition to 32-bit protected mode by using a long jmp</span></span><br><span class=\"line\">  <span class=\"comment\"># to reload %cs and %eip.  The segment descriptors are set up with no</span></span><br><span class=\"line\">  <span class=\"comment\"># translation, so that the mapping is still the identity mapping.</span></span><br><span class=\"line\">  ljmp    $(SEG_KCODE&lt;&lt;<span class=\"number\">3</span>), $start32</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.code32</span>  # Tell assembler to generate <span class=\"number\">32</span>-bit <span class=\"meta\">code</span> now.</span><br><span class=\"line\"><span class=\"symbol\">start32:</span></span><br><span class=\"line\">  <span class=\"comment\"># Set up the protected-mode data segment registers</span></span><br><span class=\"line\">  movw    $(SEG_KDATA&lt;&lt;<span class=\"number\">3</span>), %ax    # Our <span class=\"meta\">data</span> segment selector</span><br><span class=\"line\">  movw    %ax, %ds                # -&gt; DS: <span class=\"meta\">Data</span> Segment</span><br><span class=\"line\">  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class=\"line\">  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br><span class=\"line\">  movw    <span class=\"number\">$0</span>, %ax                 # Zero segments not ready for use</span><br><span class=\"line\">  movw    %ax, %fs                # -&gt; FS</span><br><span class=\"line\">  movw    %ax, %gs                # -&gt; GS</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Set up the stack pointer and call into C.</span></span><br><span class=\"line\">  movl    $start, %esp            # espstartbootasm</span><br><span class=\"line\">  call    bootmain</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># If bootmain returns (it shouldn&#x27;t), trigger a Bochs</span></span><br><span class=\"line\">  <span class=\"comment\"># breakpoint if running under Bochs, then loop.</span></span><br><span class=\"line\">  movw    <span class=\"number\">$0x8a00</span>, %ax            # <span class=\"number\">0x8a00</span> -&gt; port <span class=\"number\">0x8a00</span></span><br><span class=\"line\">  movw    %ax, %dx</span><br><span class=\"line\">  outw    %ax, %dx</span><br><span class=\"line\">  movw    <span class=\"number\">$0x8ae0</span>, %ax            # <span class=\"number\">0x8ae0</span> -&gt; port <span class=\"number\">0x8a00</span></span><br><span class=\"line\">  outw    %ax, %dx</span><br><span class=\"line\"><span class=\"symbol\">spin:</span></span><br><span class=\"line\">  jmp     spin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Bootstrap GDT</span></span><br><span class=\"line\"><span class=\"symbol\">.p2align</span> <span class=\"number\">2</span>                                # force <span class=\"number\">4</span> byte alignment</span><br><span class=\"line\"><span class=\"symbol\">gdt:</span></span><br><span class=\"line\">  SEG_NULLASM                             # null seg</span><br><span class=\"line\">  SEG_ASM(STA_X<span class=\"title\">|STA_R, 0x0, 0xffffffff)   # code seg</span></span><br><span class=\"line\"><span class=\"title\">  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">gdtdesc:</span></span><br><span class=\"line\"><span class=\"title\">  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1</span></span><br><span class=\"line\"><span class=\"title\">  .long   gdt                             # address gdt</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br></pre></td></tr></table></figure>\n\n<p></p>\n<ul>\n<li><p>PC1616 + 1620</p>\n</li>\n<li><p>CPU163264 + 324G+</p>\n</li>\n</ul>\n<p>bootasm.SBIOS1M<strong>boot0x7C00 &lt; 1M 1M</strong>cpu4G</p>\n<p> -&gt; xv6bootasm</p>\n<ol start=\"0\">\n<li><p>CPUBSPbootstrap processorBSPAPBSP</p>\n</li>\n<li><p>dsesss</p>\n</li>\n<li><p>A20.</p>\n</li>\n<li><p>lgdtGDTRgdt</p>\n</li>\n<li><p>CR001PE</p>\n</li>\n<li><p>ljmpstart32</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># xv6ljmp</span><br><span class=\"line\"># Complete the transition to 32-bit protected mode by using a long jmp</span><br><span class=\"line\"># to reload %cs and %eip. </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>esp0x7C00bootmainXV6 OS</p>\n</li>\n</ol>\n<p></p>\n<p>Descriptor4K&#x2F;</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/SegmentDescriptor.png\"></p>\n<p>8</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/GDT.png\"></p>\n<p><strong></strong><strong></strong></p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/GDTR.png\"></p>\n<p>820~1</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/SegmentSelector.png\"></p>\n<p>  cpucputss</p>\n<p>GDT</p>\n<p><a href=\"https://blog.csdn.net/abc123lzf/article/details/109289567\"></a></p>\n<p><a href=\"https://blog.csdn.net/me1171115772/article/details/51750442\"></a></p>\n<h2 id=\"XV6\"><a href=\"#XV6\" class=\"headerlink\" title=\"XV6\"></a>XV6</h2><p>elfelfELF headerProgram header table</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/165336511\">https://zhuanlan.zhihu.com/p/165336511</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ELF_MAGIC 0x464C457FU  <span class=\"comment\">// &quot;\\x7FELF&quot; in little endian</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ELF </span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">elfhdr</span> &#123;</span><br><span class=\"line\">  uint magic;       <span class=\"comment\">// 4  0x464C457FU 0x7felf</span></span><br><span class=\"line\">                      <span class=\"comment\">//  ELF </span></span><br><span class=\"line\"></span><br><span class=\"line\">  uchar elf[<span class=\"number\">12</span>];    <span class=\"comment\">// 12 </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0 : 1 = 32 2 = 64 </span></span><br><span class=\"line\">                    <span class=\"comment\">//     1 : 0 = 1 = 2 = </span></span><br><span class=\"line\">                    <span class=\"comment\">//     2 :  0x1</span></span><br><span class=\"line\">                    <span class=\"comment\">//     3 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     4 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     5 ~ 11 :  0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort type;      <span class=\"comment\">// 2 </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x0 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x1 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x2 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x3 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0x4 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0xff00 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//     0xffff : </span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort machine;   <span class=\"comment\">// 2 </span></span><br><span class=\"line\">                    <span class=\"comment\">//  0x0 0x3  x86 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint version;     <span class=\"comment\">// 4 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint entry;       <span class=\"comment\">// 4  0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint phoff;       <span class=\"comment\">// 4 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint shoff;       <span class=\"comment\">// 4 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint flags;       <span class=\"comment\">// 4 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort ehsize;    <span class=\"comment\">// 2 ELF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort phentsize; <span class=\"comment\">// 2 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort phnum;     <span class=\"comment\">// 2 </span></span><br><span class=\"line\">                    <span class=\"comment\">// phnum * phentsize = </span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort shentsize; <span class=\"comment\">// 2 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort shnum;     <span class=\"comment\">// 2 </span></span><br><span class=\"line\">                    <span class=\"comment\">// shnum * shentsize = </span></span><br><span class=\"line\"></span><br><span class=\"line\">  ushort shstrndx;  <span class=\"comment\">// 2 </span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">proghdr</span> &#123;</span><br><span class=\"line\">  uint type;        <span class=\"comment\">// 4  </span></span><br><span class=\"line\">                    <span class=\"comment\">//         1 PT_LOAD : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         2 PT_DYNAMIC : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         3 PT_INTERP : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         4 PT_NOTE : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         5 PT_SHLIB : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         6 PT_PHDR : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         7 PT_TLS : </span></span><br><span class=\"line\">  uint off;         <span class=\"comment\">// 4  </span></span><br><span class=\"line\">  uint vaddr;       <span class=\"comment\">// 4  </span></span><br><span class=\"line\">  uint paddr;       <span class=\"comment\">// 4  ()</span></span><br><span class=\"line\">  uint filesz;      <span class=\"comment\">// 4  </span></span><br><span class=\"line\">  uint memsz;       <span class=\"comment\">// 4  </span></span><br><span class=\"line\">  uint flags;       <span class=\"comment\">// 4  </span></span><br><span class=\"line\">                    <span class=\"comment\">//         1 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         2 : </span></span><br><span class=\"line\">                    <span class=\"comment\">//         4 : </span></span><br><span class=\"line\">  uint align;       <span class=\"comment\">// 4  </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://blog.csdn.net/pingxiaozhao/article/details/109239221\">ELF</a>elfELF headerProgram header tableXV6</p>\n<p>kernel elf</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">bootmain</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">elfhdr</span> *elf;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">proghdr</span> *ph, *eph;</span><br><span class=\"line\">  <span class=\"built_in\">void</span> (*entry)(<span class=\"type\">void</span>);</span><br><span class=\"line\">  uchar* pa;</span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"comment\">// 46K</span></span><br><span class=\"line\">  elf = (<span class=\"keyword\">struct</span> elfhdr*)<span class=\"number\">0x10000</span>;  <span class=\"comment\">// scratch space</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 04096elf</span></span><br><span class=\"line\">  <span class=\"comment\">// Read 1st page off disk</span></span><br><span class=\"line\">  <span class=\"built_in\">readseg</span>((uchar*)elf, <span class=\"number\">4096</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// elf</span></span><br><span class=\"line\">  <span class=\"comment\">// Is this an ELF executable?</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(elf-&gt;magic != ELF_MAGIC)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;  <span class=\"comment\">// let bootasm.S handle error</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Program header table</span></span><br><span class=\"line\">  <span class=\"comment\">// Load each program segment (ignores ph flags).</span></span><br><span class=\"line\">  ph = (<span class=\"keyword\">struct</span> proghdr*)((uchar*)elf + elf-&gt;phoff);</span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  eph = ph + elf-&gt;phnum;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; ph &lt; eph; ph++)&#123;  <span class=\"comment\">// struct proghdr</span></span><br><span class=\"line\">    <span class=\"comment\">// xv60x100000</span></span><br><span class=\"line\">    pa = (uchar*)ph-&gt;paddr;</span><br><span class=\"line\">    <span class=\"comment\">// pa</span></span><br><span class=\"line\">    <span class=\"built_in\">readseg</span>(pa, ph-&gt;filesz, ph-&gt;off);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ph-&gt;memsz &gt; ph-&gt;filesz)</span><br><span class=\"line\">      <span class=\"comment\">// memfile</span></span><br><span class=\"line\">      <span class=\"built_in\">stosb</span>(pa + ph-&gt;filesz, <span class=\"number\">0</span>, ph-&gt;memsz - ph-&gt;filesz);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Call the entry point from the ELF header.</span></span><br><span class=\"line\">  <span class=\"comment\">// Does not return!</span></span><br><span class=\"line\">  entry = (<span class=\"built_in\">void</span>(*)(<span class=\"type\">void</span>))(elf-&gt;entry);  <span class=\"comment\">// xv6kernel.ld_start</span></span><br><span class=\"line\">  <span class=\"built_in\">entry</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>kernelelfelfentry_startkernel.ld_startcpu &amp;  &amp; <strong></strong>kernelelf0x8010 0000entry.S_startXV6_startxv6</p>\n<p><strong>bootasmespesp1Mbootasmesp0x7c00</strong></p>\n<p>bootmain</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/boot.drawio.png\"></p>\n<p></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">waitdisk</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Wait for disk ready.</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>((<span class=\"built_in\">inb</span>(<span class=\"number\">0x1F7</span>) &amp; <span class=\"number\">0xC0</span>) != <span class=\"number\">0x40</span>)</span><br><span class=\"line\">    ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// readsecthttps://zhuanlan.zhihu.com/p/165336511</span></span><br><span class=\"line\"><span class=\"comment\">// Read a single sector at offset into dst.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">readsect</span><span class=\"params\">(<span class=\"type\">void</span> *dst, uint offset)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Issue command.</span></span><br><span class=\"line\">  <span class=\"built_in\">waitdisk</span>();</span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F2</span>, <span class=\"number\">1</span>);   <span class=\"comment\">// count = 1          //  count = 1</span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F3</span>, offset);                    <span class=\"comment\">//  LBA  0-7 </span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F4</span>, offset &gt;&gt; <span class=\"number\">8</span>);               <span class=\"comment\">//  LBA  8-15 </span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F5</span>, offset &gt;&gt; <span class=\"number\">16</span>);              <span class=\"comment\">//  LBA  16-23 </span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F6</span>, (offset &gt;&gt; <span class=\"number\">24</span>) | <span class=\"number\">0xE0</span>);     <span class=\"comment\">// offset | 11100000  1</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         7     1</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         6     LBA1LBA</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         5     1</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         4     01</span></span><br><span class=\"line\">                                          <span class=\"comment\">//         3~0    LBA  24-27 </span></span><br><span class=\"line\">  <span class=\"built_in\">outb</span>(<span class=\"number\">0x1F7</span>, <span class=\"number\">0x20</span>);  <span class=\"comment\">// cmd 0x20 - read sectors  // 20h30h</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Read data.</span></span><br><span class=\"line\">  <span class=\"built_in\">waitdisk</span>();</span><br><span class=\"line\">  <span class=\"built_in\">insl</span>(<span class=\"number\">0x1F0</span>, dst, SECTSIZE/<span class=\"number\">4</span>); <span class=\"comment\">// 44</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Read &#x27;count&#x27; bytes at &#x27;offset&#x27; from kernel into physical address &#x27;pa&#x27;.</span></span><br><span class=\"line\"><span class=\"comment\">// Might copy more than asked.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">readseg</span><span class=\"params\">(uchar* pa, uint count, uint offset)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  uchar* epa; <span class=\"comment\">// end phy addr</span></span><br><span class=\"line\"></span><br><span class=\"line\">  epa = pa + count; <span class=\"comment\">// </span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// offsetSECTSIZE512Byte</span></span><br><span class=\"line\">  <span class=\"comment\">// 512offset512</span></span><br><span class=\"line\">  <span class=\"comment\">// offsetSECTSIZEoffset</span></span><br><span class=\"line\">  <span class=\"comment\">// offsetofsofsoffset % SECTSIZE</span></span><br><span class=\"line\">  <span class=\"comment\">// paoffset % SECTSIZEoffset</span></span><br><span class=\"line\">  <span class=\"comment\">// Round down to sector boundary.</span></span><br><span class=\"line\">  pa -= offset % SECTSIZE;    </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// offset</span></span><br><span class=\"line\">  <span class=\"comment\">// Translate from bytes to sectors; kernel starts at sector 1.</span></span><br><span class=\"line\">  offset = (offset / SECTSIZE) + <span class=\"number\">1</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// </span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; pa &lt; epa; pa += SECTSIZE, offset++)</span><br><span class=\"line\">    <span class=\"built_in\">readsect</span>(pa, offset);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>readsegpaxv6</p>\n<h2 id=\"-start\"><a href=\"#-start\" class=\"headerlink\" title=\"_start\"></a>_start</h2><p>entry.S</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &quot;asm.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;memlayout.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;mmu.h&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#include &quot;param.h&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Multiboot header.  Data to direct multiboot loader.</span></span><br><span class=\"line\"><span class=\"symbol\">.p2align</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"symbol\">.text</span></span><br><span class=\"line\"><span class=\"symbol\">.globl</span> multiboot_header</span><br><span class=\"line\"><span class=\"symbol\">multiboot_header:</span></span><br><span class=\"line\">  <span class=\"comment\">#define magic 0x1badb002</span></span><br><span class=\"line\">  <span class=\"comment\">#define flags 0</span></span><br><span class=\"line\">  <span class=\"meta\">.long</span> magic</span><br><span class=\"line\">  <span class=\"meta\">.long</span> flags</span><br><span class=\"line\">  <span class=\"meta\">.long</span> (-magic-flags)</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># elf</span></span><br><span class=\"line\"><span class=\"comment\"># entry</span></span><br><span class=\"line\"><span class=\"comment\"># V2P_WOentrybootmainentry.</span></span><br><span class=\"line\"><span class=\"comment\"># V2P_WO 0x8000 0000 </span></span><br><span class=\"line\"><span class=\"symbol\">.globl</span> _start</span><br><span class=\"line\"><span class=\"symbol\">_start</span> = V2P_WO(<span class=\"meta\">entry</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Entering xv6 on boot processor, with paging off.</span></span><br><span class=\"line\"><span class=\"symbol\">.globl</span> <span class=\"meta\">entry</span></span><br><span class=\"line\"><span class=\"symbol\">entry:</span></span><br><span class=\"line\">  <span class=\"comment\"># 4M big page</span></span><br><span class=\"line\">  <span class=\"comment\"># Turn on page size extension for 4Mbyte pages</span></span><br><span class=\"line\">  movl    %cr4, %eax</span><br><span class=\"line\">  orl     $(CR4_PSE), %eax</span><br><span class=\"line\">  movl    %eax, %cr4</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># entrypgdir</span></span><br><span class=\"line\">  <span class=\"comment\"># entrypgdirentrypgdir</span></span><br><span class=\"line\">  <span class=\"comment\"># </span></span><br><span class=\"line\">  <span class=\"comment\"># Set page directory</span></span><br><span class=\"line\">  movl    $(V2P_WO(entrypgdir)), %eax</span><br><span class=\"line\">  movl    %eax, %cr3</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># </span></span><br><span class=\"line\">  <span class=\"comment\"># Turn on paging.</span></span><br><span class=\"line\">  movl    %cr0, %eax</span><br><span class=\"line\">  orl     $(CR0_PG<span class=\"title\">|CR0_WP), %eax</span></span><br><span class=\"line\"><span class=\"title\">  movl    %eax, %cr0</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">  ########################### </span></span><br><span class=\"line\"><span class=\"title\">  # espesp</span></span><br><span class=\"line\"><span class=\"title\">  # Set up the stack pointer.</span></span><br><span class=\"line\"><span class=\"title\">  movl $(stack + KSTACKSIZE), %esp</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">  # main</span></span><br><span class=\"line\"><span class=\"title\">  mov $main, %eax</span></span><br><span class=\"line\"><span class=\"title\">  jmp *%eax</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">.comm stack, KSTACKSIZE</span></span><br></pre></td></tr></table></figure>\n\n<p>main</p>\n<ol>\n<li><p>4M big pagecpu4Mentrypgdir4Mentrypgdirmainkpgdir4Kxv6</p>\n</li>\n<li><p>entrypgdirBSPbooststrap processor</p>\n</li>\n<li><p></p>\n</li>\n<li><p>esp4K</p>\n</li>\n<li><p>main</p>\n</li>\n</ol>\n<p>entry.Scpu</p>\n<p><img src=\"/2024/06/07/xv6/Boot/photo/start/entry.drawio.png\"></p>\n<p>cpuunix</p>\n<hr>\n<p><strong></strong></p>"}],"PostAsset":[{"_id":"source/_posts/muduo/AsyncLogging/photo/AsynLogging.drawio.png","slug":"photo\\AsynLogging.drawio.png","post":"cmg3w8w9k0003q8wsb3i18lsz","modified":0,"renderable":0},{"_id":"source/_posts/buildroot/stage_install/photo/stage_install0.png","slug":"photo\\stage_install0.png","post":"cmg3w8w9i0001q8ws0sso6gl1","modified":0,"renderable":0},{"_id":"source/_posts/buildroot/stage_install/photo/stage_install1.png","slug":"photo\\stage_install1.png","post":"cmg3w8w9i0001q8ws0sso6gl1","modified":0,"renderable":0},{"_id":"source/_posts/buildroot/stage_install/photo/stage_install2.png","slug":"photo\\stage_install2.png","post":"cmg3w8w9i0001q8ws0sso6gl1","modified":0,"renderable":0},{"_id":"source/_posts/muduo/EventLoopThreadPool/photo/EventLoopThreadPool.drawio.png","slug":"photo\\EventLoopThreadPool.drawio.png","post":"cmg3w8w9p000cq8wsbylt7ba0","modified":0,"renderable":0},{"_id":"source/_posts/muduo/EvevntLoopAndThread/photo/EventLoop.drawio.png","slug":"photo\\EventLoop.drawio.png","post":"cmg3w8w9p000eq8ws2a4bco90","modified":0,"renderable":0},{"_id":"source/_posts/muduo/ThreadAndThreadPool/photo/ThreadPool.drawio.png","slug":"photo\\ThreadPool.drawio.png","post":"cmg3w8w9r000oq8ws4u2pb7o9","modified":0,"renderable":0},{"_id":"source/_posts/muduo/TcpServer/photo/TcpServer.drawio.png","slug":"photo\\TcpServer.drawio.png","post":"cmg3w8w9r000mq8wsbnlaectd","modified":0,"renderable":0},{"_id":"source/_posts/workflow/TCPServer_1/photo/EventLoopFlowChart.drawio.png","slug":"photo\\EventLoopFlowChart.drawio.png","post":"cmg3w8w9s000uq8ws80lh02fu","modified":0,"renderable":0},{"_id":"source/_posts/workflow/TCPServer_1/photo/EventLoopThreadPool.drawio.png","slug":"photo\\EventLoopThreadPool.drawio.png","post":"cmg3w8w9s000uq8ws80lh02fu","modified":0,"renderable":0},{"_id":"source/_posts/workflow/TCPServer_2/photo/ReadStatusTranslate.drawio.png","slug":"photo\\ReadStatusTranslate.drawio.png","post":"cmg3w8w9t0010q8ws2bl6bydm","modified":0,"renderable":0},{"_id":"source/_posts/workflow/TCPServer_2/photo/StateTranslateThreadPool.drawio.png","slug":"photo\\StateTranslateThreadPool.drawio.png","post":"cmg3w8w9t0010q8ws2bl6bydm","modified":0,"renderable":0},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/entry.png","slug":"photo\\memmanager\\entry.png","post":"cmg3w8w9u0012q8wsfwecb723","modified":0,"renderable":0},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/kalloc.drawio.png","slug":"photo\\memmanager\\kalloc.drawio.png","post":"cmg3w8w9u0012q8wsfwecb723","modified":0,"renderable":0},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/main_page_table.drawio.png","slug":"photo\\memmanager\\main_page_table.drawio.png","post":"cmg3w8w9u0012q8wsfwecb723","modified":0,"renderable":0},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/memory_paging_02.drawio.png","slug":"photo\\memmanager\\memory_paging_02.drawio.png","post":"cmg3w8w9u0012q8wsfwecb723","modified":0,"renderable":0},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/onix_memory_map.drawio.png","slug":"photo\\memmanager\\onix_memory_map.drawio.png","post":"cmg3w8w9u0012q8wsfwecb723","modified":0,"renderable":0},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/vaddr.png","slug":"photo\\memmanager\\vaddr.png","post":"cmg3w8w9u0012q8wsfwecb723","modified":0,"renderable":0},{"_id":"source/_posts/xv6/MemoryManager/photo/memmanager/vaddr2paddr.png","slug":"photo\\memmanager\\vaddr2paddr.png","post":"cmg3w8w9u0012q8wsfwecb723","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/8259a.drawio.png","slug":"photo\\scheduler\\8259a.drawio.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/APICStructure.png","slug":"photo\\scheduler\\APICStructure.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/entry_types.png","slug":"photo\\scheduler\\entry_types.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/IDTR.png","slug":"photo\\scheduler\\IDTR.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/IDT_Entry.png","slug":"photo\\scheduler\\IDT_Entry.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/imcrp.png","slug":"photo\\scheduler\\imcrp.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/ioapic_entry.png","slug":"photo\\scheduler\\ioapic_entry.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png","slug":"photo\\scheduler\\MP_Configuration_Data_Structures.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/MP_configuration_table_header.png","slug":"photo\\scheduler\\MP_configuration_table_header.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/MP_floating_pointer_structure.png","slug":"photo\\scheduler\\MP_floating_pointer_structure.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/processor_entry.png","slug":"photo\\scheduler\\processor_entry.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/scheduler.drawio.png","slug":"photo\\scheduler\\scheduler.drawio.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/scheduler_pluse.drawio.png","slug":"photo\\scheduler\\scheduler_pluse.drawio.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/task_stack.drawio.png","slug":"photo\\scheduler\\task_stack.drawio.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/trap_frame.png","slug":"photo\\scheduler\\trap_frame.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/trap__structure.png","slug":"photo\\scheduler\\trap__structure.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/universal_algorithm.png","slug":"photo\\scheduler\\universal_algorithm.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Scheduler/photo/scheduler/yield_scheduler.png","slug":"photo\\scheduler\\yield_scheduler.png","post":"cmg3w8w9u0016q8ws8p1n16tx","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio","slug":"photo\\filesystem\\onix_caceh1.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_caceh1.drawio.png","slug":"photo\\filesystem\\onix_caceh1.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache.drawio","slug":"photo\\filesystem\\onix_cache.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache.drawio.png","slug":"photo\\filesystem\\onix_cache.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache2.drawio","slug":"photo\\filesystem\\onix_cache2.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache2.drawio.png","slug":"photo\\filesystem\\onix_cache2.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache3.drawio","slug":"photo\\filesystem\\onix_cache3.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_cache3.drawio.png","slug":"photo\\filesystem\\onix_cache3.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_dentry.drawio","slug":"photo\\filesystem\\onix_dentry.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_dentry.drawio.png","slug":"photo\\filesystem\\onix_dentry.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio","slug":"photo\\filesystem\\onix_fsstructureondisk.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fsstructureondisk.drawio.png","slug":"photo\\filesystem\\onix_fsstructureondisk.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio","slug":"photo\\filesystem\\onix_fs_structure.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_fs_structure.drawio.png","slug":"photo\\filesystem\\onix_fs_structure.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_ide.drawio","slug":"photo\\filesystem\\onix_ide.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_ide.drawio.png","slug":"photo\\filesystem\\onix_ide.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio","slug":"photo\\filesystem\\onix_minix_inode.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_minix_inode.drawio.png","slug":"photo\\filesystem\\onix_minix_inode.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_mount.drawio","slug":"photo\\filesystem\\onix_mount.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_mount.drawio.png","slug":"photo\\filesystem\\onix_mount.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio","slug":"photo\\filesystem\\onix_vfs_structure.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/onix_vfs_structure.drawio.png","slug":"photo\\filesystem\\onix_vfs_structure.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_fsstructureondisk.png","slug":"photo\\filesystem\\xv6_fsstructureondisk.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio","slug":"photo\\filesystem\\xv6_fs_structure.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_fs_structure.drawio.png","slug":"photo\\filesystem\\xv6_fs_structure.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_ide.drawio","slug":"photo\\filesystem\\xv6_ide.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_ide.drawio.png","slug":"photo\\filesystem\\xv6_ide.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio","slug":"photo\\filesystem\\xv6_log_structure.drawio","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/FileSystem/photo/filesystem/xv6_log_structure.drawio.png","slug":"photo\\filesystem\\xv6_log_structure.drawio.png","post":"cmg3w8w9u0014q8ws9y7072z2","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/Logo.jpg","slug":"photo\\Logo.jpg","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/8259a.drawio.png","slug":"photo\\scheduler\\8259a.drawio.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/APICStructure.png","slug":"photo\\scheduler\\APICStructure.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/entry_types.png","slug":"photo\\scheduler\\entry_types.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/IDTR.png","slug":"photo\\scheduler\\IDTR.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/IDT_Entry.png","slug":"photo\\scheduler\\IDT_Entry.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/imcrp.png","slug":"photo\\scheduler\\imcrp.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/ioapic_entry.png","slug":"photo\\scheduler\\ioapic_entry.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/MP_Configuration_Data_Structures.png","slug":"photo\\scheduler\\MP_Configuration_Data_Structures.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/MP_configuration_table_header.png","slug":"photo\\scheduler\\MP_configuration_table_header.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/MP_floating_pointer_structure.png","slug":"photo\\scheduler\\MP_floating_pointer_structure.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/processor_entry.png","slug":"photo\\scheduler\\processor_entry.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/scheduler.drawio.png","slug":"photo\\scheduler\\scheduler.drawio.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/scheduler_pluse.drawio.png","slug":"photo\\scheduler\\scheduler_pluse.drawio.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/task_stack.drawio.png","slug":"photo\\scheduler\\task_stack.drawio.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/trap_frame.png","slug":"photo\\scheduler\\trap_frame.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/trap__structure.png","slug":"photo\\scheduler\\trap__structure.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/universal_algorithm.png","slug":"photo\\scheduler\\universal_algorithm.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/scheduler/yield_scheduler.png","slug":"photo\\scheduler\\yield_scheduler.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/start/boot.drawio.png","slug":"photo\\start\\boot.drawio.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/start/entry.drawio.png","slug":"photo\\start\\entry.drawio.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/start/GDT.png","slug":"photo\\start\\GDT.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/start/GDTR.png","slug":"photo\\start\\GDTR.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/start/SegmentDescriptor.png","slug":"photo\\start\\SegmentDescriptor.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0},{"_id":"source/_posts/xv6/Boot/photo/start/SegmentSelector.png","slug":"photo\\start\\SegmentSelector.png","post":"cmg3w8w9v0017q8wseafudr8p","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cmg3w8w9i0001q8ws0sso6gl1","tag_id":"cmg3w8w9l0004q8ws6v7de8g9","_id":"cmg3w8w9m0007q8ws3itw2kea"},{"post_id":"cmg3w8w9k0003q8wsb3i18lsz","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9m0008q8ws8eg17a15"},{"post_id":"cmg3w8w9o0009q8ws2nst23jm","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9p000bq8ws9nle43uc"},{"post_id":"cmg3w8w9o000aq8ws7nc90xlj","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9p000dq8wscfxhe60r"},{"post_id":"cmg3w8w9p000cq8wsbylt7ba0","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9q000fq8wsaj7ice34"},{"post_id":"cmg3w8w9p000eq8ws2a4bco90","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9q000hq8wsb2isaytg"},{"post_id":"cmg3w8w9q000gq8wscd9u3po5","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9q000jq8ws0srg3i7i"},{"post_id":"cmg3w8w9q000iq8ws6f7reaee","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9r000lq8wsbu9lat7a"},{"post_id":"cmg3w8w9q000kq8ws5wshe41s","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9r000nq8wsemsyh7yu"},{"post_id":"cmg3w8w9r000mq8wsbnlaectd","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9s000pq8ws2vrqbt3u"},{"post_id":"cmg3w8w9r000oq8ws4u2pb7o9","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9s000rq8ws9xpi98cp"},{"post_id":"cmg3w8w9s000qq8wsfjymfkx3","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9s000tq8wsg3x8fkq2"},{"post_id":"cmg3w8w9s000sq8ws8wi65amy","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9t000vq8wsb6hv28ct"},{"post_id":"cmg3w8w9s000uq8ws80lh02fu","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9t000xq8wsf61bem9w"},{"post_id":"cmg3w8w9t000wq8ws64du4jnn","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9t000zq8wsdqptg4ii"},{"post_id":"cmg3w8w9t000yq8ws5v75f0jg","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9t0011q8ws4e7ue97x"},{"post_id":"cmg3w8w9t0010q8ws2bl6bydm","tag_id":"cmg3w8w9m0006q8wsdrlwcbve","_id":"cmg3w8w9u0013q8ws822j3ykw"},{"post_id":"cmg3w8w9v0017q8wseafudr8p","tag_id":"cmg3w8w9u0015q8ws02uy0nc3","_id":"cmg3w8w9v0019q8ws7diehjgb"},{"post_id":"cmg3w8w9u0012q8wsfwecb723","tag_id":"cmg3w8w9u0015q8ws02uy0nc3","_id":"cmg3w8w9v001aq8wsd4lk4bbq"},{"post_id":"cmg3w8w9u0014q8ws9y7072z2","tag_id":"cmg3w8w9u0015q8ws02uy0nc3","_id":"cmg3w8w9w001cq8wshuljfnkm"},{"post_id":"cmg3w8w9u0016q8ws8p1n16tx","tag_id":"cmg3w8w9u0015q8ws02uy0nc3","_id":"cmg3w8w9w001dq8ws0qwg2qa1"}],"Tag":[{"name":"Linux","_id":"cmg3w8w9l0004q8ws6v7de8g9"},{"name":"","_id":"cmg3w8w9m0006q8wsdrlwcbve"},{"name":"Unix","_id":"cmg3w8w9u0015q8ws02uy0nc3"}]}}